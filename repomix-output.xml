This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.repomixignore
src/com/company/assembleegameclient/account/ui/CheckBoxField.as
src/com/company/assembleegameclient/account/ui/CreateGuildFrame.as
src/com/company/assembleegameclient/account/ui/Frame.as
src/com/company/assembleegameclient/account/ui/MarketInput.as
src/com/company/assembleegameclient/account/ui/TextInputField.as
src/com/company/assembleegameclient/account/ui/unboxing/EmbedMysteryInv.as
src/com/company/assembleegameclient/account/ui/unboxing/EmbedUnboxSquare.as
src/com/company/assembleegameclient/account/ui/unboxing/Frame2.as
src/com/company/assembleegameclient/account/ui/unboxing/FrameuBox.as
src/com/company/assembleegameclient/account/ui/unboxing/ItemResultBox.as
src/com/company/assembleegameclient/account/ui/unboxing/MysteryInv.png
src/com/company/assembleegameclient/account/ui/unboxing/UnboxResultBox.as
src/com/company/assembleegameclient/account/ui/unboxing/UnboxResultBoxMediator.as
src/com/company/assembleegameclient/account/ui/unboxing/UnboxScroll.as
src/com/company/assembleegameclient/account/ui/unboxing/UnboxSquare.as
src/com/company/assembleegameclient/account/ui/unboxing/UnboxSquare.png
src/com/company/assembleegameclient/appengine/CharacterStats.as
src/com/company/assembleegameclient/appengine/SavedCharacter.as
src/com/company/assembleegameclient/appengine/SavedCharactersList.as
src/com/company/assembleegameclient/appengine/SavedNewsItem.as
src/com/company/assembleegameclient/background/Background.as
src/com/company/assembleegameclient/background/NexusBackground.as
src/com/company/assembleegameclient/background/StarBackground.as
src/com/company/assembleegameclient/constants/InventoryOwnerTypes.as
src/com/company/assembleegameclient/constants/ScreenTypes.as
src/com/company/assembleegameclient/editor/Command.as
src/com/company/assembleegameclient/editor/CommandEvent.as
src/com/company/assembleegameclient/editor/CommandList.as
src/com/company/assembleegameclient/editor/CommandMenu.as
src/com/company/assembleegameclient/editor/CommandMenuItem.as
src/com/company/assembleegameclient/editor/CommandQueue.as
src/com/company/assembleegameclient/game/events/DeathEvent.as
src/com/company/assembleegameclient/game/events/GuildResultEvent.as
src/com/company/assembleegameclient/game/events/NameResultEvent.as
src/com/company/assembleegameclient/game/events/ReconnectEvent.as
src/com/company/assembleegameclient/game/GameSprite.as
src/com/company/assembleegameclient/game/MapUserInput.as
src/com/company/assembleegameclient/objects/animation/AnimationData.as
src/com/company/assembleegameclient/objects/animation/Animations.as
src/com/company/assembleegameclient/objects/animation/AnimationsData.as
src/com/company/assembleegameclient/objects/animation/FrameData.as
src/com/company/assembleegameclient/objects/BasicObject.as
src/com/company/assembleegameclient/objects/CaveWall.as
src/com/company/assembleegameclient/objects/Character.as
src/com/company/assembleegameclient/objects/CharacterChanger.as
src/com/company/assembleegameclient/objects/ClosedGiftChest.as
src/com/company/assembleegameclient/objects/ClosedVaultChest.as
src/com/company/assembleegameclient/objects/ConnectedObject.as
src/com/company/assembleegameclient/objects/ConnectedWall.as
src/com/company/assembleegameclient/objects/Container.as
src/com/company/assembleegameclient/objects/FlashDescription.as
src/com/company/assembleegameclient/objects/GiftChest.as
src/com/company/assembleegameclient/objects/GuildBoard.as
src/com/company/assembleegameclient/objects/GuildChronicle.as
src/com/company/assembleegameclient/objects/GuildHallPortal.as
src/com/company/assembleegameclient/objects/GuildMerchant.as
src/com/company/assembleegameclient/objects/GuildRegister.as
src/com/company/assembleegameclient/objects/IInteractiveObject.as
src/com/company/assembleegameclient/objects/MarketObject.as
src/com/company/assembleegameclient/objects/Merchant.as
src/com/company/assembleegameclient/objects/ObjectLibrary.as
src/com/company/assembleegameclient/objects/ObjectProperties.as
src/com/company/assembleegameclient/objects/OneWayContainer.as
src/com/company/assembleegameclient/objects/particles/AOEEffect.as
src/com/company/assembleegameclient/objects/particles/BaseParticle.as
src/com/company/assembleegameclient/objects/particles/BubbleEffect.as
src/com/company/assembleegameclient/objects/particles/BubbleParticle.as
src/com/company/assembleegameclient/objects/particles/BurstEffect.as
src/com/company/assembleegameclient/objects/particles/CollapseEffect.as
src/com/company/assembleegameclient/objects/particles/ConeBlastEffect.as
src/com/company/assembleegameclient/objects/particles/EffectProperties.as
src/com/company/assembleegameclient/objects/particles/ExplosionEffect.as
src/com/company/assembleegameclient/objects/particles/FlowEffect.as
src/com/company/assembleegameclient/objects/particles/FountainEffect.as
src/com/company/assembleegameclient/objects/particles/GasEffect.as
src/com/company/assembleegameclient/objects/particles/GasParticle.as
src/com/company/assembleegameclient/objects/particles/HealEffect.as
src/com/company/assembleegameclient/objects/particles/HealingEffect.as
src/com/company/assembleegameclient/objects/particles/HealParticle.as
src/com/company/assembleegameclient/objects/particles/HitEffect.as
src/com/company/assembleegameclient/objects/particles/LevelUpEffect.as
src/com/company/assembleegameclient/objects/particles/LightningEffect.as
src/com/company/assembleegameclient/objects/particles/LineEffect.as
src/com/company/assembleegameclient/objects/particles/NovaEffect.as
src/com/company/assembleegameclient/objects/particles/Particle.as
src/com/company/assembleegameclient/objects/particles/ParticleEffect.as
src/com/company/assembleegameclient/objects/particles/ParticleGenerator.as
src/com/company/assembleegameclient/objects/particles/ParticleLibrary.as
src/com/company/assembleegameclient/objects/particles/ParticleProperties.as
src/com/company/assembleegameclient/objects/particles/PoisonEffect.as
src/com/company/assembleegameclient/objects/particles/RingEffect.as
src/com/company/assembleegameclient/objects/particles/SparkerParticle.as
src/com/company/assembleegameclient/objects/particles/SparkParticle.as
src/com/company/assembleegameclient/objects/particles/StreamEffect.as
src/com/company/assembleegameclient/objects/particles/TeleportEffect.as
src/com/company/assembleegameclient/objects/particles/ThrowEffect.as
src/com/company/assembleegameclient/objects/particles/VentEffect.as
src/com/company/assembleegameclient/objects/particles/XMLEffect.as
src/com/company/assembleegameclient/objects/particles/XMLParticle.as
src/com/company/assembleegameclient/objects/Party.as
src/com/company/assembleegameclient/objects/Portal.as
src/com/company/assembleegameclient/objects/Projectile.as
src/com/company/assembleegameclient/objects/ProjectileProperties.as
src/com/company/assembleegameclient/objects/ReskinVendor.as
src/com/company/assembleegameclient/objects/SellableObject.as
src/com/company/assembleegameclient/objects/Sign.as
src/com/company/assembleegameclient/objects/SpiderWeb.as
src/com/company/assembleegameclient/objects/Stalagmite.as
src/com/company/assembleegameclient/objects/TextureData.as
src/com/company/assembleegameclient/objects/thrown/ThrownObject.as
src/com/company/assembleegameclient/objects/thrown/ThrownProjectile.as
src/com/company/assembleegameclient/objects/thrown/ThrowProjectileEffect.as
src/com/company/assembleegameclient/objects/Traits.as
src/com/company/assembleegameclient/objects/VaultChest.as
src/com/company/assembleegameclient/objects/Wall.as
src/com/company/assembleegameclient/parameters/Parameters.as
src/com/company/assembleegameclient/screens/AccountLoadingScreen.as
src/com/company/assembleegameclient/screens/AccountScreen.as
src/com/company/assembleegameclient/screens/BrickLeft.png
src/com/company/assembleegameclient/screens/BrickRight.png
src/com/company/assembleegameclient/screens/CharacterBox.as
src/com/company/assembleegameclient/screens/CharacterList.as
src/com/company/assembleegameclient/screens/CharacterSelectionAndNewsScreen.as
src/com/company/assembleegameclient/screens/charrects/BuyCharacterRect.as
src/com/company/assembleegameclient/screens/charrects/CharacterRect.as
src/com/company/assembleegameclient/screens/charrects/CharacterRectBg.png
src/com/company/assembleegameclient/screens/charrects/CharacterRectList.as
src/com/company/assembleegameclient/screens/charrects/CreateNewCharacterRect.as
src/com/company/assembleegameclient/screens/charrects/CurrentCharacterRect.as
src/com/company/assembleegameclient/screens/events/DeleteCharacterEvent.as
src/com/company/assembleegameclient/screens/LoadingScreen.as
src/com/company/assembleegameclient/screens/NameTextSign.png
src/com/company/assembleegameclient/screens/NewCharacterScreen.as
src/com/company/assembleegameclient/screens/NewsLine.as
src/com/company/assembleegameclient/screens/NewsList.as
src/com/company/assembleegameclient/screens/ScoreTextLine.as
src/com/company/assembleegameclient/screens/ScoringBox.as
src/com/company/assembleegameclient/screens/TitleMenuOption.as
src/com/company/assembleegameclient/screens/UnpackEmbed.as
src/com/company/assembleegameclient/sound/Music.as
src/com/company/assembleegameclient/sound/SFX.as
src/com/company/assembleegameclient/sound/Song.as
src/com/company/assembleegameclient/sound/SoundEffectLibrary.as
src/com/company/assembleegameclient/ui/board/EditBoard.as
src/com/company/assembleegameclient/ui/board/GuildBoardWindow.as
src/com/company/assembleegameclient/ui/board/ViewBoard.as
src/com/company/assembleegameclient/ui/ClickableText.as
src/com/company/assembleegameclient/ui/components/TimerDisplay.as
src/com/company/assembleegameclient/ui/dialogs/DebugDialog.as
src/com/company/assembleegameclient/ui/dialogs/Dialog.as
src/com/company/assembleegameclient/ui/dialogs/ErrorDialog.as
src/com/company/assembleegameclient/ui/dialogs/NotEnoughFameDialog.as
src/com/company/assembleegameclient/ui/dropdown/DropDown.as
src/com/company/assembleegameclient/ui/dropdown/DropDownItem.as
src/com/company/assembleegameclient/ui/ElementFormats.as
src/com/company/assembleegameclient/ui/FrameOverlay.as
src/com/company/assembleegameclient/ui/GameObjectListItem.as
src/com/company/assembleegameclient/ui/guild/GuildChronicleScreen.as
src/com/company/assembleegameclient/ui/guild/GuildPlayerList.as
src/com/company/assembleegameclient/ui/guild/GuildPlayerListEvent.as
src/com/company/assembleegameclient/ui/guild/MemberListLine.as
src/com/company/assembleegameclient/ui/GuildText.as
src/com/company/assembleegameclient/ui/IconButton.as
src/com/company/assembleegameclient/ui/LineBreakDesign.as
src/com/company/assembleegameclient/ui/menu/Menu.as
src/com/company/assembleegameclient/ui/menu/MenuOption.as
src/com/company/assembleegameclient/ui/menu/PlayerGroupMenu.as
src/com/company/assembleegameclient/ui/menu/PlayerMenu.as
src/com/company/assembleegameclient/ui/menu/TeleportMenuOption.as
src/com/company/assembleegameclient/ui/options/ChoiceBox.as
src/com/company/assembleegameclient/ui/options/ChoiceOption.as
src/com/company/assembleegameclient/ui/options/KeyCodeBox.as
src/com/company/assembleegameclient/ui/options/KeyMapper.as
src/com/company/assembleegameclient/ui/options/Option.as
src/com/company/assembleegameclient/ui/options/Options.as
src/com/company/assembleegameclient/ui/options/OptionsTabTitle.as
src/com/company/assembleegameclient/ui/panels/ButtonPanel.as
src/com/company/assembleegameclient/ui/panels/CharacterChangerPanel.as
src/com/company/assembleegameclient/ui/panels/GiftChestPanel.as
src/com/company/assembleegameclient/ui/panels/GuildBoardPanel.as
src/com/company/assembleegameclient/ui/panels/GuildChroniclePanel.as
src/com/company/assembleegameclient/ui/panels/GuildHallPortalPanel.as
src/com/company/assembleegameclient/ui/panels/GuildInvitePanel.as
src/com/company/assembleegameclient/ui/panels/GuildRegisterPanel.as
src/com/company/assembleegameclient/ui/panels/InteractPanel.as
src/com/company/assembleegameclient/ui/panels/itemgrids/BindGrid.as
src/com/company/assembleegameclient/ui/panels/itemgrids/ContainerGrid.as
src/com/company/assembleegameclient/ui/panels/itemgrids/EquippedGrid.as
src/com/company/assembleegameclient/ui/panels/itemgrids/InventoryGrid.as
src/com/company/assembleegameclient/ui/panels/itemgrids/ItemGrid.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/BindTile.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/EquipmentTile.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/InteractiveItemTile.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/InventoryTile.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/ItemTile.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/ItemTileEvent.as
src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/ItemTileSprite.as
src/com/company/assembleegameclient/ui/panels/mediators/InteractPanelMediator.as
src/com/company/assembleegameclient/ui/panels/mediators/InventoryGridMediator.as
src/com/company/assembleegameclient/ui/panels/mediators/ItemGridMediator.as
src/com/company/assembleegameclient/ui/panels/Panel.as
src/com/company/assembleegameclient/ui/panels/PartyPanel.as
src/com/company/assembleegameclient/ui/panels/PortalPanel.as
src/com/company/assembleegameclient/ui/panels/TradeRequestPanel.as
src/com/company/assembleegameclient/ui/panels/TraitsPanel.as
src/com/company/assembleegameclient/ui/panels/VaultChestPanel.as
src/com/company/assembleegameclient/ui/RankText.as
src/com/company/assembleegameclient/ui/Scrollbar.as
src/com/company/assembleegameclient/ui/Slot.as
src/com/company/assembleegameclient/ui/SoundIcon.as
src/com/company/assembleegameclient/ui/StatusBar.as
src/com/company/assembleegameclient/ui/TextBox.as
src/com/company/assembleegameclient/ui/TextBoxLine.as
src/com/company/assembleegameclient/ui/TextButton.as
src/com/company/assembleegameclient/ui/tooltip/ClassToolTip.as
src/com/company/assembleegameclient/ui/tooltip/EquipmentToolTip.as
src/com/company/assembleegameclient/ui/tooltip/MyPlayerToolTip.as
src/com/company/assembleegameclient/ui/tooltip/PlayerGroupToolTip.as
src/com/company/assembleegameclient/ui/tooltip/PlayerToolTip.as
src/com/company/assembleegameclient/ui/tooltip/PortraitToolTip.as
src/com/company/assembleegameclient/ui/tooltip/QuestToolTip.as
src/com/company/assembleegameclient/ui/tooltip/RankToolTip.as
src/com/company/assembleegameclient/ui/tooltip/TextToolTip.as
src/com/company/assembleegameclient/ui/tooltip/ToolTip.as
src/com/company/assembleegameclient/ui/tooltip/TooltipHelper.as
src/com/company/assembleegameclient/ui/TradeButton.as
src/com/company/assembleegameclient/ui/TradeInventory.as
src/com/company/assembleegameclient/ui/TradePanel.as
src/com/company/assembleegameclient/ui/TradeSlot.as
src/com/company/assembleegameclient/util/AnimatedChar.as
src/com/company/assembleegameclient/util/AnimatedChars.as
src/com/company/assembleegameclient/util/AssetLoader.as
src/com/company/assembleegameclient/util/BloodComposition.as
src/com/company/assembleegameclient/util/ConditionEffect.as
src/com/company/assembleegameclient/util/Currency.as
src/com/company/assembleegameclient/util/DisplayHierarchy.as
src/com/company/assembleegameclient/util/FreeList.as
src/com/company/assembleegameclient/util/GuildUtil.as
src/com/company/assembleegameclient/util/HonorUtil.as
src/com/company/assembleegameclient/util/MaskedImage.as
src/com/company/assembleegameclient/util/MaskedImageSet.as
src/com/company/assembleegameclient/util/RandomUtil.as
src/com/company/assembleegameclient/util/redrawers/GlowRedrawer.as
src/com/company/assembleegameclient/util/Stage3DProxy.as
src/com/company/assembleegameclient/util/StageProxy.as
src/com/company/assembleegameclient/util/TextureRedrawer_textureShaderEmbed_.as
src/com/company/assembleegameclient/util/TextureRedrawer.as
src/com/company/assembleegameclient/util/TileRedrawer.as
src/com/company/assembleegameclient/util/TimeUtil.as
src/com/company/ui/fonts/MyriadPro.as
src/com/company/ui/fonts/MyriadProBold.as
src/com/company/ui/fonts/MyriadProBoldCFF.as
src/com/company/ui/fonts/MyriadProCFF.as
src/com/company/ui/SimpleText.as
src/com/company/untiered/graphics/DeleteXGraphic.as
src/com/company/untiered/graphics/DeleteXGraphic.swf
src/com/company/untiered/graphics/HonorIconBackgroundDesign.as
src/com/company/untiered/graphics/HonorIconBackgroundDesign.swf
src/com/company/untiered/graphics/LockedCharBoxGraphic.as
src/com/company/untiered/graphics/LockedCharBoxGraphic.swf
src/com/company/untiered/graphics/ScreenGraphic.as
src/com/company/untiered/graphics/ScreenGraphic.swf
src/com/company/untiered/graphics/StarGraphic.as
src/com/company/untiered/graphics/StarGraphic.swf
src/com/company/util/ArrayIterator.as
src/com/company/util/AssetLibrary.as
src/com/company/util/Base64Decoder.as
src/com/company/util/BitmapUtil.as
src/com/company/util/CachingColorTransformer.as
src/com/company/util/CapabilitiesUtil.as
src/com/company/util/ConversionUtil.as
src/com/company/util/DateFormatterReplacement.as
src/com/company/util/Extents2D.as
src/com/company/util/GraphicsUtil.as
src/com/company/util/Guid.as
src/com/company/util/HTMLUtil.as
src/com/company/util/IIterator.as
src/com/company/util/ImageSet.as
src/com/company/util/IntPoint.as
src/com/company/util/KeyCodes.as
src/com/company/util/LineSegmentUtil.as
src/com/company/util/MoreColorUtil.as
src/com/company/util/MoreDateUtil.as
src/com/company/util/MoreObjectUtil.as
src/com/company/util/MoreStringUtil.as
src/com/company/util/PointUtil.as
src/com/company/util/Random.as
src/com/company/util/RectangleUtil.as
src/com/company/util/SpriteUtil.as
src/com/company/util/Triangle.as
src/com/company/util/Trig.as
src/GameClient.as
src/svera/display/Loader/LoaderProxy.as
src/svera/display/Loader/LoaderProxyConcrete.as
src/svera/display/LoaderInfo/LoaderInfoProxy.as
src/svera/display/LoaderInfo/LoaderInfoProxyConcrete.as
src/svera/lib/framework/AppContext.as
src/svera/lib/framework/CommandBus.as
src/svera/lib/framework/CommandMapping.as
src/svera/lib/framework/ICommand.as
src/svera/lib/framework/IGuard.as
src/svera/lib/framework/IMediator.as
src/svera/lib/framework/IModule.as
src/svera/lib/framework/Mediator.as
src/svera/lib/framework/MediatorFactory.as
src/svera/lib/json/JsonParser.as
src/svera/lib/json/SoftwareJsonParser.as
src/svera/lib/loopedprocs/LoopedCallback.as
src/svera/lib/loopedprocs/LoopedProcess.as
src/svera/lib/net/api/MessageHandlerProxy.as
src/svera/lib/net/api/MessageMap.as
src/svera/lib/net/api/MessageMapping.as
src/svera/lib/net/api/MessageProvider.as
src/svera/lib/net/impl/ClassHandlerProxy.as
src/svera/lib/net/impl/Message.as
src/svera/lib/net/impl/MessageCenter.as
src/svera/lib/net/impl/MessageCenterMapping.as
src/svera/lib/net/impl/MessagePool.as
src/svera/lib/net/impl/MethodHandlerProxy.as
src/svera/lib/net/impl/SocketServer.as
src/svera/lib/net/NetModule.as
src/svera/lib/resizing/ResizeModule.as
src/svera/lib/resizing/signals/Resize.as
src/svera/lib/resizing/view/Resizable.as
src/svera/lib/resizing/view/ResizableMediator.as
src/svera/lib/signals/DeferredQueueSignal.as
src/svera/lib/tasks/BaseTask.as
src/svera/lib/tasks/BranchingTask.as
src/svera/lib/tasks/DispatchSignalTask.as
src/svera/lib/tasks/Task.as
src/svera/lib/tasks/TaskGroup.as
src/svera/lib/tasks/TaskMonitor.as
src/svera/lib/tasks/TaskResultSignal.as
src/svera/lib/tasks/TaskSequence.as
src/svera/lib/tasks/TaskStartedSignal.as
src/svera/lib/ui/api/Layout.as
src/svera/lib/ui/api/List.as
src/svera/lib/ui/api/Scrollbar.as
src/svera/lib/ui/api/Size.as
src/svera/lib/ui/GroupMappedSignal.as
src/svera/lib/ui/impl/HorizontalLayout.as
src/svera/lib/ui/impl/LayoutList.as
src/svera/lib/ui/impl/NullLayout.as
src/svera/lib/ui/impl/VerticalLayout.as
src/svera/lib/util/DateValidator.as
src/svera/lib/util/GIF.as
src/svera/lib/util/StageLifecycleUtil.as
src/svera/lib/util/TimeWriter.as
src/svera/lib/util/VectorAS3Util.as
src/svera/untiered/account/AccountModule.as
src/svera/untiered/account/core/Account.as
src/svera/untiered/account/core/BuyCharacterSlotCommand.as
src/svera/untiered/account/core/control/IsAccountRegisteredGuard.as
src/svera/untiered/account/core/model/JSInitializedModel.as
src/svera/untiered/account/core/services/BuyCharacterSlotTask.as
src/svera/untiered/account/core/services/ChangePasswordTask.as
src/svera/untiered/account/core/services/GetCharListTask.as
src/svera/untiered/account/core/services/LinkAccountsTask.as
src/svera/untiered/account/core/services/LoadAccountTask.as
src/svera/untiered/account/core/services/LoadApiTask.as
src/svera/untiered/account/core/services/LoginTask.as
src/svera/untiered/account/core/services/RegisterAccountTask.as
src/svera/untiered/account/core/services/RelayLoginTask.as
src/svera/untiered/account/core/services/SendPasswordReminderTask.as
src/svera/untiered/account/core/signals/CharListDataSignal.as
src/svera/untiered/account/core/signals/LinkWebAccountSignal.as
src/svera/untiered/account/core/signals/LoginSignal.as
src/svera/untiered/account/core/signals/LogoutSignal.as
src/svera/untiered/account/core/signals/OpenAccountInfoSignal.as
src/svera/untiered/account/core/signals/OpenQuitDialogSignal.as
src/svera/untiered/account/core/signals/RegisterSignal.as
src/svera/untiered/account/core/signals/SendPasswordReminderSignal.as
src/svera/untiered/account/core/signals/UpdateAccountInfoSignal.as
src/svera/untiered/account/core/view/AccountInfoMediator.as
src/svera/untiered/account/core/view/AccountInfoView.as
src/svera/untiered/account/core/view/BuyingDialog.as
src/svera/untiered/account/core/view/EmptyFrame.as
src/svera/untiered/account/core/view/RegisterPromptDialog.as
src/svera/untiered/account/core/view/RegisterPromptDialogMediator.as
src/svera/untiered/account/core/view/RegisterWebAccountDialog.as
src/svera/untiered/account/ui/components/DateField.as
src/svera/untiered/account/web/commands/WebChangePasswordCommand.as
src/svera/untiered/account/web/commands/WebLoginCommand.as
src/svera/untiered/account/web/commands/WebLogoutCommand.as
src/svera/untiered/account/web/commands/WebOpenAccountInfoCommand.as
src/svera/untiered/account/web/commands/WebOpenQuitDialogCommand.as
src/svera/untiered/account/web/commands/WebRegisterAccountCommand.as
src/svera/untiered/account/web/commands/WebSendPasswordReminderCommand.as
src/svera/untiered/account/web/model/AccountData.as
src/svera/untiered/account/web/model/ChangePasswordData.as
src/svera/untiered/account/web/services/WebChangePasswordTask.as
src/svera/untiered/account/web/services/WebLoadAccountTask.as
src/svera/untiered/account/web/services/WebLoginTask.as
src/svera/untiered/account/web/services/WebRegisterAccountTask.as
src/svera/untiered/account/web/services/WebSendPasswordReminderTask.as
src/svera/untiered/account/web/signals/WebChangePasswordSignal.as
src/svera/untiered/account/web/view/DateFieldValidator.as
src/svera/untiered/account/web/view/FormField.as
src/svera/untiered/account/web/view/LabeledField.as
src/svera/untiered/account/web/view/WebAccountDetailDialog.as
src/svera/untiered/account/web/view/WebAccountDetailMediator.as
src/svera/untiered/account/web/view/WebAccountInfoMediator.as
src/svera/untiered/account/web/view/WebAccountInfoView.as
src/svera/untiered/account/web/view/WebChangePasswordDialog.as
src/svera/untiered/account/web/view/WebChangePasswordMediator.as
src/svera/untiered/account/web/view/WebLoginDialog.as
src/svera/untiered/account/web/view/WebLoginMediator.as
src/svera/untiered/account/web/view/WebQuitDialog.as
src/svera/untiered/account/web/view/WebQuitMediator.as
src/svera/untiered/account/web/view/WebRegisterDialog.as
src/svera/untiered/account/web/view/WebRegisterMediator.as
src/svera/untiered/account/web/WebAccount.as
src/svera/untiered/account/web/WebAccountModule.as
src/svera/untiered/appengine/api/AppEngineClient.as
src/svera/untiered/appengine/api/RetryLoader.as
src/svera/untiered/appengine/AppEngineModule.as
src/svera/untiered/appengine/impl/AppEngineRetryLoader.as
src/svera/untiered/appengine/impl/SimpleAppEngineClient.as
src/svera/untiered/assets/AssetsModule.as
src/svera/untiered/assets/cursors.png
src/svera/untiered/assets/EmbeddedAssets.as
src/svera/untiered/assets/EmbeddedData.as
src/svera/untiered/assets/Entities/Containers/DroppedContainers8x8.png
src/svera/untiered/assets/Entities/Containers/Foundry_Containers16x16.png
src/svera/untiered/assets/Entities/Enemies/Asgard_Enemies_Retirlisk16x16.png
src/svera/untiered/assets/Entities/Enemies/Overworld_Enemies_DroughtsPath16x16.png
src/svera/untiered/assets/Entities/Enemies/Overworld_Enemies_FearedShallows16x16.png
src/svera/untiered/assets/Entities/Enemies/Overworld_Enemies_Feltare16x16.png
src/svera/untiered/assets/Entities/Enemies/Overworld_Enemies_Nidavellir16x16.png
src/svera/untiered/assets/Entities/Player/Gravestones16x16.png
src/svera/untiered/assets/Entities/Player/Gravestones8x8.png
src/svera/untiered/assets/Entities/Player/Pets16x16.png
src/svera/untiered/assets/Entities/Player/Player_Particles.png
src/svera/untiered/assets/Entities/Player/players-old.png
src/svera/untiered/assets/Entities/Player/Players.png
src/svera/untiered/assets/Entities/Player/PlayersMask-old.png
src/svera/untiered/assets/Entities/Player/PlayersMask.png
src/svera/untiered/assets/Entities/Player/playersSkins.png
src/svera/untiered/assets/Entities/Player/playersSkinsMask.png
src/svera/untiered/assets/Entities/Player/textile10x10.png
src/svera/untiered/assets/Entities/Player/textile4x4.png
src/svera/untiered/assets/Entities/Player/textile5x5.png
src/svera/untiered/assets/Entities/Player/textile9x9.png
src/svera/untiered/assets/Entities/Player/Textiles8x8.png
src/svera/untiered/assets/Entities/Stations/Foundry_Stations16x16.png
src/svera/untiered/assets/Entities/Stations/Foundry_Stations32x32.png
src/svera/untiered/assets/Entities/Stations/Marketplace_Stations16x16.png
src/svera/untiered/assets/Environment/customobjects16x16.png
src/svera/untiered/assets/Environment/Foundry/Foundry_Environment16x16.png
src/svera/untiered/assets/Environment/Foundry/Foundry_Environment32x32.png
src/svera/untiered/assets/Environment/Foundry/Foundry_Environment8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_AshenValley16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_AshenValley8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_DroughtsPath16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_DroughtsPath8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_FearedShallows16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_FearedShallows32x32.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_FearedShallows8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_Feltare16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_Feltare32x32.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_Feltare8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_GarnetWoods16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_GarnetWoods16x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_GarnetWoods32x32.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_GarnetWoods8x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_GarnetWoods8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_Nidavellir16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_Nidavellir16x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_Nidavellir8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_NotSpecific8x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_SandstoneValley16x16.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_SandstoneValley16x8.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_SandstoneValley32x32.png
src/svera/untiered/assets/Environment/Overworld/Overworld_Environment_SandstoneValley8x8.png
src/svera/untiered/assets/Environment/Tavern/Tavern_Environment8x8.png
src/svera/untiered/assets/Environment/Underworld/Overworld_Environment_Feltare16x16.png
src/svera/untiered/assets/Environment/Underworld/Overworld_Environment_Feltare8x8.png
src/svera/untiered/assets/Environment/Underworld/underworld_Environment_Shared16x16.png
src/svera/untiered/assets/Environment/Underworld/underworld_Environment_Shared8x8.png
src/svera/untiered/assets/Environment/Vault/Vault_Environment8x8.png
src/svera/untiered/assets/innerMask.png
src/svera/untiered/assets/innerP1Mask.png
src/svera/untiered/assets/innerP2Mask.png
src/svera/untiered/assets/Interface/Currency/Currency_Icons16x16.png
src/svera/untiered/assets/Interface/Currency/Currency_Icons8x8.png
src/svera/untiered/assets/Interface/StatusIcons/StatusIcons16x16.png
src/svera/untiered/assets/Interface/StatusIcons/StatusIcons18x18.png
src/svera/untiered/assets/Items/Artifact/ArtifactAbilities.png
src/svera/untiered/assets/Items/Artifact/ArtifactAbilityCharacters16x16.png
src/svera/untiered/assets/Items/Artifact/ArtifactAbilityCharacters8x8.png
src/svera/untiered/assets/Items/Artifact/ArtifactAbilityEntities.png
src/svera/untiered/assets/Items/Artifact/ArtifactAbilityEntities16x16.png
src/svera/untiered/assets/Items/Artifact/ArtifactAbilityProjectiles.png
src/svera/untiered/assets/Items/Artifact/ArtifactAccessories.png
src/svera/untiered/assets/Items/Artifact/ArtifactArmor.png
src/svera/untiered/assets/Items/Artifact/ArtifactWeapons.png
src/svera/untiered/assets/Items/Artifact/ArtifactWeaponsProjectiles.png
src/svera/untiered/assets/Items/Consumables/Consumables_Maxing8x8.png
src/svera/untiered/assets/Items/Consumables/Consumables_Tokens8x8.png
src/svera/untiered/assets/Items/Consumables/Consumables_Upgrades8x8.png
src/svera/untiered/assets/Items/Crafting/Crafting_Capsules8x8.png
src/svera/untiered/assets/Items/Crafting/Crafting_Ingredients8x8.png
src/svera/untiered/assets/Items/Crafting/Crafting_LuckyDips.png
src/svera/untiered/assets/Items/Godly/GodlyAbilities.png
src/svera/untiered/assets/Items/Godly/GodlyAccessories.png
src/svera/untiered/assets/Items/Godly/GodlyArmor.png
src/svera/untiered/assets/Items/Godly/GodlyMiscellaneous.png
src/svera/untiered/assets/Items/Godly/GodlyProjectiles.png
src/svera/untiered/assets/Items/Godly/GodlyWeapons.png
src/svera/untiered/assets/Items/GodSlayer/GodSlayerAbilities.png
src/svera/untiered/assets/Items/GodSlayer/GodSlayerAccessories.png
src/svera/untiered/assets/Items/GodSlayer/GodSlayerArmor.png
src/svera/untiered/assets/Items/GodSlayer/GodSlayerProjectiles.png
src/svera/untiered/assets/Items/GodSlayer/GodSlayerWeapons.png
src/svera/untiered/assets/Items/Legendary/LegendaryAbilities.png
src/svera/untiered/assets/Items/Legendary/LegendaryAccessories.png
src/svera/untiered/assets/Items/Legendary/LegendaryArmor.png
src/svera/untiered/assets/Items/Legendary/LegendaryProjectiles.png
src/svera/untiered/assets/Items/Legendary/LegendaryWeapons.png
src/svera/untiered/assets/Items/Sacred/Sacred.png
src/svera/untiered/assets/Items/Sacred/SacredAbilities.png
src/svera/untiered/assets/Items/Sacred/SacredAccessories.png
src/svera/untiered/assets/Items/Sacred/SacredArmor.png
src/svera/untiered/assets/Items/Sacred/SacredProjectiles.png
src/svera/untiered/assets/Items/Sacred/SacredProjs.png
src/svera/untiered/assets/Items/Sacred/SacredWeapons.png
src/svera/untiered/assets/Items/StarterGear.png
src/svera/untiered/assets/Items/Utilities/Utilities_Artifact8x8.png
src/svera/untiered/assets/Items/Utilities/Utilities_PetStones8x8.png
src/svera/untiered/assets/Items/Utilities/Utilities_Valiant8x8.png
src/svera/untiered/assets/Items/Valiant/ValiantAbilities.png
src/svera/untiered/assets/Items/Valiant/ValiantAbilityCharacters.png
src/svera/untiered/assets/Items/Valiant/ValiantAbilityEntities16x16.png
src/svera/untiered/assets/Items/Valiant/ValiantAbilityProjectiles.png
src/svera/untiered/assets/Items/Valiant/ValiantAccessories.png
src/svera/untiered/assets/Items/Valiant/ValiantArmor.png
src/svera/untiered/assets/Items/Valiant/ValiantWeapons.png
src/svera/untiered/assets/Items/Valiant/ValiantWeaponsProjectiles.png
src/svera/untiered/assets/lofiInterface.png
src/svera/untiered/assets/lofiInterface2.png
src/svera/untiered/assets/lofiInterfaceBig.png
src/svera/untiered/assets/lofiParts.png
src/svera/untiered/assets/model/Animation.as
src/svera/untiered/assets/model/CharacterTemplate.as
src/svera/untiered/assets/Models/bigcube.dat
src/svera/untiered/assets/Models/brokenPillar.dat
src/svera/untiered/assets/Models/crate.dat
src/svera/untiered/assets/Models/cube.dat
src/svera/untiered/assets/Models/dodecahedron.dat
src/svera/untiered/assets/Models/icosahedron.dat
src/svera/untiered/assets/Models/obelisk.dat
src/svera/untiered/assets/Models/octahedron.dat
src/svera/untiered/assets/Models/pillar.dat
src/svera/untiered/assets/Models/pyramid.dat
src/svera/untiered/assets/Models/sign.dat
src/svera/untiered/assets/Models/table.dat
src/svera/untiered/assets/Models/tableEdge.dat
src/svera/untiered/assets/Models/tetrahedron.dat
src/svera/untiered/assets/Models/tower.dat
src/svera/untiered/assets/Models/web.dat
src/svera/untiered/assets/outerMask.png
src/svera/untiered/assets/Portals/Foundry_Portals16x16.png
src/svera/untiered/assets/Portals/Foundry_Portals32x32.png
src/svera/untiered/assets/services/CharacterFactory.as
src/svera/untiered/assets/services/IconFactory.as
src/svera/untiered/assets/sidesMask.png
src/svera/untiered/assets/splash_logo.png
src/svera/untiered/assets/stars.png
src/svera/untiered/characters/CharactersModule.as
src/svera/untiered/characters/deletion/control/DeleteCharacterCommand.as
src/svera/untiered/characters/deletion/control/DeleteCharacterSignal.as
src/svera/untiered/characters/deletion/DeletionModule.as
src/svera/untiered/characters/deletion/service/DeleteCharacterTask.as
src/svera/untiered/characters/deletion/view/ConfirmDeleteCharacterDialog.as
src/svera/untiered/characters/deletion/view/ConfirmDeleteCharacterMediator.as
src/svera/untiered/characters/deletion/view/DeletingCharacterView.as
src/svera/untiered/characters/model/CharacterModel.as
src/svera/untiered/characters/model/LegacyCharacterModel.as
src/svera/untiered/characters/reskin/control/OpenReskinDialogCommand.as
src/svera/untiered/characters/reskin/control/OpenReskinDialogSignal.as
src/svera/untiered/characters/reskin/control/ReskinCharacterCommand.as
src/svera/untiered/characters/reskin/control/ReskinCharacterSignal.as
src/svera/untiered/characters/reskin/control/ReskinHandler.as
src/svera/untiered/characters/reskin/ReskinModule.as
src/svera/untiered/characters/reskin/view/ReskinCharacterMediator.as
src/svera/untiered/characters/reskin/view/ReskinCharacterView.as
src/svera/untiered/characters/reskin/view/ReskinPanel.as
src/svera/untiered/characters/reskin/view/ReskinPanelMediator.as
src/svera/untiered/classes/ClassesModule.as
src/svera/untiered/classes/control/BuyCharacterSkinCommand.as
src/svera/untiered/classes/control/BuyCharacterSkinSignal.as
src/svera/untiered/classes/control/FocusCharacterSkinSignal.as
src/svera/untiered/classes/control/ParseCharListXmlCommand.as
src/svera/untiered/classes/control/ParseClassesXmlCommand.as
src/svera/untiered/classes/control/ParseClassesXMLSignal.as
src/svera/untiered/classes/control/ParseSkinsXmlCommand.as
src/svera/untiered/classes/control/ResetClassDataCommand.as
src/svera/untiered/classes/model/CharacterClass.as
src/svera/untiered/classes/model/CharacterClassStat.as
src/svera/untiered/classes/model/CharacterClassUnlock.as
src/svera/untiered/classes/model/CharacterSkin.as
src/svera/untiered/classes/model/CharacterSkins.as
src/svera/untiered/classes/model/CharacterSkinState.as
src/svera/untiered/classes/model/ClassesModel.as
src/svera/untiered/classes/services/BuySkinTask.as
src/svera/untiered/classes/view/CharacterSkinListItem.as
src/svera/untiered/classes/view/CharacterSkinListItemFactory.as
src/svera/untiered/classes/view/CharacterSkinListItemMediator.as
src/svera/untiered/classes/view/CharacterSkinListMediator.as
src/svera/untiered/classes/view/CharacterSkinListView.as
src/svera/untiered/classes/view/CharacterSkinMediator.as
src/svera/untiered/classes/view/CharacterSkinView.as
src/svera/untiered/classes/view/ClassDetailMediator.as
src/svera/untiered/classes/view/ClassDetailView.as
src/svera/untiered/classes/view/Orbiter.as
src/svera/untiered/constants/ActivationType.as
src/svera/untiered/constants/GeneralConstants.as
src/svera/untiered/constants/ItemConstants.as
src/svera/untiered/core/commands/InvalidateDataCommand.as
src/svera/untiered/core/commands/SetScreenWithValidDataCommand.as
src/svera/untiered/core/commands/UpdatePlayerModelCommand.as
src/svera/untiered/core/CoreModule.as
src/svera/untiered/core/model/MapModel.as
src/svera/untiered/core/model/PlayerModel.as
src/svera/untiered/core/model/ScreenModel.as
src/svera/untiered/core/signals/GotoPreviousScreenSignal.as
src/svera/untiered/core/signals/HideTooltipsSignal.as
src/svera/untiered/core/signals/InvalidateDataSignal.as
src/svera/untiered/core/signals/LaunchGameSignal.as
src/svera/untiered/core/signals/SetLoadingMessageSignal.as
src/svera/untiered/core/signals/SetScreenSignal.as
src/svera/untiered/core/signals/SetScreenWithValidDataSignal.as
src/svera/untiered/core/signals/ShowTooltipSignal.as
src/svera/untiered/core/signals/TaskErrorSignal.as
src/svera/untiered/core/signals/UpdateNewCharacterScreenSignal.as
src/svera/untiered/core/StaticInjectorContext.as
src/svera/untiered/core/view/Layers.as
src/svera/untiered/core/view/ScreensMediator.as
src/svera/untiered/core/view/ScreensView.as
src/svera/untiered/death/control/HandleDeathCommand.as
src/svera/untiered/death/control/HandleDeathSignal.as
src/svera/untiered/death/control/HandleNormalDeathCommand.as
src/svera/untiered/death/control/HandleNormalDeathSignal.as
src/svera/untiered/death/DeathModule.as
src/svera/untiered/death/model/DeathModel.as
src/svera/untiered/dialogs/control/CloseDialogsSignal.as
src/svera/untiered/dialogs/control/OpenDialogSignal.as
src/svera/untiered/dialogs/control/ShowDialogBackgroundSignal.as
src/svera/untiered/dialogs/DialogsModule.as
src/svera/untiered/dialogs/view/DialogsMediator.as
src/svera/untiered/dialogs/view/DialogsView.as
src/svera/untiered/game/commands/PlayGameCommand.as
src/svera/untiered/game/commands/TransitionFromGameToMenuCommand.as
src/svera/untiered/game/commands/UsePotionCommand.as
src/svera/untiered/game/focus/control/SetGameFocusSignal.as
src/svera/untiered/game/focus/GameFocusModule.as
src/svera/untiered/game/focus/view/GameFocusMediator.as
src/svera/untiered/game/GameModule.as
src/svera/untiered/game/model/AddSpeechBalloonVO.as
src/svera/untiered/game/model/AddTextLineVO.as
src/svera/untiered/game/model/ChatFilter.as
src/svera/untiered/game/model/GameInitData.as
src/svera/untiered/game/model/GameModel.as
src/svera/untiered/game/model/PotionInventoryModel.as
src/svera/untiered/game/model/StatModel.as
src/svera/untiered/game/model/UsePotionVO.as
src/svera/untiered/game/signals/AddSpeechBalloonSignal.as
src/svera/untiered/game/signals/AddTextLineSignal.as
src/svera/untiered/game/signals/DisconnectGameSignal.as
src/svera/untiered/game/signals/ExitGameSignal.as
src/svera/untiered/game/signals/GameClosedSignal.as
src/svera/untiered/game/signals/PlayGameSignal.as
src/svera/untiered/game/signals/SetTextBoxVisibilitySignal.as
src/svera/untiered/game/signals/SetWorldInteractionSignal.as
src/svera/untiered/game/signals/ShowChatInputSignal.as
src/svera/untiered/game/signals/UpdateLootboxButtonSignal.as
src/svera/untiered/game/signals/UsePotionSignal.as
src/svera/untiered/game/view/components/StatMediator.as
src/svera/untiered/game/view/components/StatsMediator.as
src/svera/untiered/game/view/components/StatsView.as
src/svera/untiered/game/view/components/StatView.as
src/svera/untiered/game/view/CurrencyDisplay.as
src/svera/untiered/game/view/CurrencyDisplayMediator.as
src/svera/untiered/game/view/GameSpriteMediator.as
src/svera/untiered/game/view/LootboxesDisplay.as
src/svera/untiered/game/view/LootboxesDisplayMediator.as
src/svera/untiered/game/view/LootboxMediator.as
src/svera/untiered/game/view/LootboxModalButton.as
src/svera/untiered/game/view/MapOverlayMediator.as
src/svera/untiered/game/view/PortalPanelMediator.as
src/svera/untiered/game/view/RaidLauncherButton.as
src/svera/untiered/game/view/SellableObjectPanel.as
src/svera/untiered/game/view/SellableObjectPanelMediator.as
src/svera/untiered/game/view/TextBoxMediator.as
src/svera/untiered/honor/control/ShowHonorViewCommand.as
src/svera/untiered/honor/control/ShowHonorViewSignal.as
src/svera/untiered/honor/HonorModule.as
src/svera/untiered/honor/model/HonorModel.as
src/svera/untiered/honor/model/HonorVO.as
src/svera/untiered/honor/model/SimpleHonorVO.as
src/svera/untiered/honor/service/RequestCharacterHonorTask.as
src/svera/untiered/honor/view/HonorMediator.as
src/svera/untiered/honor/view/HonorView.as
src/svera/untiered/hud/HUD_Overlay.as
src/svera/untiered/hud/HUD_Overlay.png
src/svera/untiered/hud/HUDModule.as
src/svera/untiered/itemdata/ActivateEffectsData.as
src/svera/untiered/itemdata/DataKeys.as
src/svera/untiered/itemdata/Item.as
src/svera/untiered/itemdata/LinkUtils.as
src/svera/untiered/itemdata/NewItemData.as
src/svera/untiered/itemdata/ProjectileData.as
src/svera/untiered/itemdata/TierHelper.as
src/svera/untiered/legends/control/ExitLegendsCommand.as
src/svera/untiered/legends/control/ExitLegendsSignal.as
src/svera/untiered/legends/control/HonorListUpdateSignal.as
src/svera/untiered/legends/control/RequestHonorListCommand.as
src/svera/untiered/legends/control/RequestHonorListSignal.as
src/svera/untiered/legends/LegendsModule.as
src/svera/untiered/legends/model/Legend.as
src/svera/untiered/legends/model/LegendFactory.as
src/svera/untiered/legends/model/LegendsModel.as
src/svera/untiered/legends/model/Timespan.as
src/svera/untiered/legends/service/GetLegendsListTask.as
src/svera/untiered/legends/view/LegendListItem.as
src/svera/untiered/legends/view/LegendsMediator.as
src/svera/untiered/legends/view/LegendsTab.as
src/svera/untiered/legends/view/LegendsView.as
src/svera/untiered/lootBoxes/BronzeLootbox_ImageEmbed.png
src/svera/untiered/lootBoxes/EliteLootbox_ImageEmbed.png
src/svera/untiered/lootBoxes/EventLootbox_ImageEmbed.png
src/svera/untiered/lootBoxes/GoldLootbox_ImageEmbed.png
src/svera/untiered/lootBoxes/LockerLootbox_ImageEmbed.png
src/svera/untiered/lootBoxes/LootboxBackground_ImageEmbed.png
src/svera/untiered/lootBoxes/LootboxModal.as
src/svera/untiered/lootBoxes/LootboxModalMediator.as
src/svera/untiered/lootBoxes/lootBoxObtained.png
src/svera/untiered/lootBoxes/PopupWindowBackground.as
src/svera/untiered/lootBoxes/PremiumLootbox_ImageEmbed.png
src/svera/untiered/lootBoxes/SilverLootbox_ImageEmbed.png
src/svera/untiered/memMarket/content/MemMarketBuyItem.as
src/svera/untiered/memMarket/content/MemMarketInventoryItem.as
src/svera/untiered/memMarket/content/MemMarketItem.as
src/svera/untiered/memMarket/content/MemMarketSellItem.as
src/svera/untiered/memMarket/MemMarket.as
src/svera/untiered/memMarket/MemMarketPanel.as
src/svera/untiered/memMarket/signals/MemMarketAddSignal.as
src/svera/untiered/memMarket/signals/MemMarketBuySignal.as
src/svera/untiered/memMarket/signals/MemMarketMyOffersSignal.as
src/svera/untiered/memMarket/signals/MemMarketRemoveSignal.as
src/svera/untiered/memMarket/signals/MemMarketSearchSignal.as
src/svera/untiered/memMarket/tabs/MemMarketBuyTab.as
src/svera/untiered/memMarket/tabs/MemMarketSellTab.as
src/svera/untiered/memMarket/tabs/MemMarketTab.as
src/svera/untiered/memMarket/utils/DialogUtils.as
src/svera/untiered/memMarket/utils/IconUtils.as
src/svera/untiered/memMarket/utils/ItemUtils.as
src/svera/untiered/memMarket/utils/SortUtils.as
src/svera/untiered/memMarket/utils/TintUtils.as
src/svera/untiered/messaging/impl/data/GroundTileData.as
src/svera/untiered/messaging/impl/data/MarketData.as
src/svera/untiered/messaging/impl/data/MarketOffer.as
src/svera/untiered/messaging/impl/data/ObjectData.as
src/svera/untiered/messaging/impl/data/ObjectDropData.as
src/svera/untiered/messaging/impl/data/ObjectStatusData.as
src/svera/untiered/messaging/impl/data/PlayerShopItem.as
src/svera/untiered/messaging/impl/data/SlotObjectData.as
src/svera/untiered/messaging/impl/data/StatData.as
src/svera/untiered/messaging/impl/data/TradeItemData.as
src/svera/untiered/messaging/impl/data/WorldPosData.as
src/svera/untiered/messaging/impl/GameServerConnection.as
src/svera/untiered/messaging/impl/incoming/AccountList.as
src/svera/untiered/messaging/impl/incoming/AllyShoot.as
src/svera/untiered/messaging/impl/incoming/Aoe.as
src/svera/untiered/messaging/impl/incoming/BuyResult.as
src/svera/untiered/messaging/impl/incoming/CreateSuccess.as
src/svera/untiered/messaging/impl/incoming/Damage.as
src/svera/untiered/messaging/impl/incoming/Death.as
src/svera/untiered/messaging/impl/incoming/EnemyShoot.as
src/svera/untiered/messaging/impl/incoming/Failure.as
src/svera/untiered/messaging/impl/incoming/GlobalNotification.as
src/svera/untiered/messaging/impl/incoming/Goto.as
src/svera/untiered/messaging/impl/incoming/GuildResult.as
src/svera/untiered/messaging/impl/incoming/IncomingMessage.as
src/svera/untiered/messaging/impl/incoming/InvitedToGuild.as
src/svera/untiered/messaging/impl/incoming/InvResult.as
src/svera/untiered/messaging/impl/incoming/MapInfo.as
src/svera/untiered/messaging/impl/incoming/market/MarketAddResult.as
src/svera/untiered/messaging/impl/incoming/market/MarketBuyResult.as
src/svera/untiered/messaging/impl/incoming/market/MarketMyOffersResult.as
src/svera/untiered/messaging/impl/incoming/market/MarketRemoveResult.as
src/svera/untiered/messaging/impl/incoming/market/MarketSearchResult.as
src/svera/untiered/messaging/impl/incoming/MarketResult.as
src/svera/untiered/messaging/impl/incoming/NewTick.as
src/svera/untiered/messaging/impl/incoming/Notification.as
src/svera/untiered/messaging/impl/incoming/PlaySound.as
src/svera/untiered/messaging/impl/incoming/QuestObjId.as
src/svera/untiered/messaging/impl/incoming/Reconnect.as
src/svera/untiered/messaging/impl/incoming/ServerPlayerShoot.as
src/svera/untiered/messaging/impl/incoming/SetFocus.as
src/svera/untiered/messaging/impl/incoming/ShowEffect.as
src/svera/untiered/messaging/impl/incoming/StorageSlotUpdate.as
src/svera/untiered/messaging/impl/incoming/StorageUpdate.as
src/svera/untiered/messaging/impl/incoming/SwitchMusic.as
src/svera/untiered/messaging/impl/incoming/Text.as
src/svera/untiered/messaging/impl/incoming/TradeAccepted.as
src/svera/untiered/messaging/impl/incoming/TradeChanged.as
src/svera/untiered/messaging/impl/incoming/TradeDone.as
src/svera/untiered/messaging/impl/incoming/TradeRequested.as
src/svera/untiered/messaging/impl/incoming/TradeStart.as
src/svera/untiered/messaging/impl/incoming/UnboxResultPacket.as
src/svera/untiered/messaging/impl/incoming/Update.as
src/svera/untiered/messaging/impl/JitterWatcher.as
src/svera/untiered/messaging/impl/outgoing/AcceptTrade.as
src/svera/untiered/messaging/impl/outgoing/AoeAck.as
src/svera/untiered/messaging/impl/outgoing/Buy.as
src/svera/untiered/messaging/impl/outgoing/CancelTrade.as
src/svera/untiered/messaging/impl/outgoing/ChangeGuildRank.as
src/svera/untiered/messaging/impl/outgoing/ChangeTrade.as
src/svera/untiered/messaging/impl/outgoing/Create.as
src/svera/untiered/messaging/impl/outgoing/CreateGuild.as
src/svera/untiered/messaging/impl/outgoing/EditAccountList.as
src/svera/untiered/messaging/impl/outgoing/EnemyHit.as
src/svera/untiered/messaging/impl/outgoing/Escape.as
src/svera/untiered/messaging/impl/outgoing/GotoAck.as
src/svera/untiered/messaging/impl/outgoing/GuildInvite.as
src/svera/untiered/messaging/impl/outgoing/GuildRemove.as
src/svera/untiered/messaging/impl/outgoing/Hello.as
src/svera/untiered/messaging/impl/outgoing/InvDrop.as
src/svera/untiered/messaging/impl/outgoing/InvSwap.as
src/svera/untiered/messaging/impl/outgoing/JoinGuild.as
src/svera/untiered/messaging/impl/outgoing/LaunchRaid.as
src/svera/untiered/messaging/impl/outgoing/Load.as
src/svera/untiered/messaging/impl/outgoing/market/MarketAdd.as
src/svera/untiered/messaging/impl/outgoing/market/MarketAll.as
src/svera/untiered/messaging/impl/outgoing/market/MarketBuy.as
src/svera/untiered/messaging/impl/outgoing/market/MarketMyOffers.as
src/svera/untiered/messaging/impl/outgoing/market/MarketRemove.as
src/svera/untiered/messaging/impl/outgoing/market/MarketSearch.as
src/svera/untiered/messaging/impl/outgoing/Move.as
src/svera/untiered/messaging/impl/outgoing/OutgoingMessage.as
src/svera/untiered/messaging/impl/outgoing/PlayerHit.as
src/svera/untiered/messaging/impl/outgoing/PlayerShoot.as
src/svera/untiered/messaging/impl/outgoing/PlayerText.as
src/svera/untiered/messaging/impl/outgoing/Reskin.as
src/svera/untiered/messaging/impl/outgoing/ShootAck.as
src/svera/untiered/messaging/impl/outgoing/SquareHit.as
src/svera/untiered/messaging/impl/outgoing/StorageRequest.as
src/svera/untiered/messaging/impl/outgoing/StorageUpgrade.as
src/svera/untiered/messaging/impl/outgoing/Teleport.as
src/svera/untiered/messaging/impl/outgoing/TradeRequest.as
src/svera/untiered/messaging/impl/outgoing/UnboxRequest.as
src/svera/untiered/messaging/impl/outgoing/UseItem.as
src/svera/untiered/messaging/impl/outgoing/UsePortal.as
src/svera/untiered/messaging/impl/OutstandingBuy.as
src/svera/untiered/minimap/control/MiniMapZoomSignal.as
src/svera/untiered/minimap/control/SetMiniMapMapSignal.as
src/svera/untiered/minimap/control/UpdateGameObjectTileSignal.as
src/svera/untiered/minimap/control/UpdateGroundTileSignal.as
src/svera/untiered/minimap/MiniMapModule.as
src/svera/untiered/minimap/model/UpdateGroundTileVO.as
src/svera/untiered/minimap/view/MiniMap.as
src/svera/untiered/minimap/view/MiniMapMediator.as
src/svera/untiered/minimap/view/MiniMapZoomButtons.as
src/svera/untiered/Particles/Recallingbase_0.png
src/svera/untiered/Particles/Recallingbase_00.png
src/svera/untiered/Particles/Recallingbase_1.png
src/svera/untiered/Particles/Recallingbase_11.png
src/svera/untiered/Particles/Recallingbase_2.png
src/svera/untiered/Particles/Recallingbase_22.png
src/svera/untiered/Particles/Recallingbase_3.png
src/svera/untiered/Particles/Recallingbase_33.png
src/svera/untiered/Particles/Recallingbase.as
src/svera/untiered/raidLauncher/Raid1_launchFlag.png
src/svera/untiered/raidLauncher/Raid2_launchFlag.png
src/svera/untiered/raidLauncher/Raid3_launchFlag.png
src/svera/untiered/raidLauncher/RaidLauncher_backgroundImageEmbed.png
src/svera/untiered/raidLauncher/RaidLauncherMediator.as
src/svera/untiered/raidLauncher/RaidLauncherModal.as
src/svera/untiered/stage3D/graphic3D/Graphic3D.as
src/svera/untiered/stage3D/graphic3D/Graphic3DHelper.as
src/svera/untiered/stage3D/graphic3D/IndexBufferFactory.as
src/svera/untiered/stage3D/graphic3D/Program3DFactory.as
src/svera/untiered/stage3D/graphic3D/TextureFactory.as
src/svera/untiered/stage3D/graphic3D/VertexBufferFactory.as
src/svera/untiered/stage3D/GraphicsFillExtra.as
src/svera/untiered/stage3D/Object3D/Model3D_stage3d.as
src/svera/untiered/stage3D/Object3D/Object3DStage3D.as
src/svera/untiered/stage3D/Object3D/OBJGroup.as
src/svera/untiered/stage3D/Object3D/Util.as
src/svera/untiered/stage3D/proxies/Context3DProxy.as
src/svera/untiered/stage3D/proxies/IndexBuffer3DProxy.as
src/svera/untiered/stage3D/proxies/Program3DProxy.as
src/svera/untiered/stage3D/proxies/TextureProxy.as
src/svera/untiered/stage3D/proxies/VertexBuffer3DProxy.as
src/svera/untiered/stage3D/Render3D.as
src/svera/untiered/stage3D/Renderer.as
src/svera/untiered/stage3D/shaders/FragmentShader.as
src/svera/untiered/stage3D/shaders/FragmentShaderRepeat.as
src/svera/untiered/stage3D/shaders/VertextShader.as
src/svera/untiered/stage3D/Stage3DModule.as
src/svera/untiered/startup/control/StartupCommand.as
src/svera/untiered/startup/control/StartupSequence.as
src/svera/untiered/startup/control/StartupSignal.as
src/svera/untiered/startup/model/api/StartupDelegate.as
src/svera/untiered/startup/model/impl/SignalTaskDelegate.as
src/svera/untiered/startup/model/impl/TaskDelegate.as
src/svera/untiered/startup/StartupModule.as
src/svera/untiered/storage/components/StorageSortTab.as
src/svera/untiered/storage/components/VaultUpgradeButton.as
src/svera/untiered/storage/GiftContent.as
src/svera/untiered/storage/GiftWindow.as
src/svera/untiered/storage/mediator/GiftWindowMediator.as
src/svera/untiered/storage/mediator/VaultWindowMediator.as
src/svera/untiered/storage/signals/GiftSlotUpdateSignal.as
src/svera/untiered/storage/signals/GiftUpdateSignal.as
src/svera/untiered/storage/signals/VaultSlotUpdateSignal.as
src/svera/untiered/storage/signals/VaultUpdateSignal.as
src/svera/untiered/storage/StorageUtil.as
src/svera/untiered/storage/VaultContent.as
src/svera/untiered/storage/VaultWindow.as
src/svera/untiered/tooltips/TooltipsModule.as
src/svera/untiered/tooltips/view/TooltipsMediator.as
src/svera/untiered/tooltips/view/TooltipsView.as
src/svera/untiered/traits/background.as
src/svera/untiered/traits/background.png
src/svera/untiered/traits/Bricks.png
src/svera/untiered/traits/TraitsGUI.as
src/svera/untiered/ui/commands/EnterGameCommand.as
src/svera/untiered/ui/commands/HUDInitCommand.as
src/svera/untiered/ui/commands/ShowLoadingUICommand.as
src/svera/untiered/ui/commands/ShowSplashUICommand.as
src/svera/untiered/ui/commands/ShowTitleUICommand.as
src/svera/untiered/ui/model/HUDModel.as
src/svera/untiered/ui/model/PotionModel.as
src/svera/untiered/ui/model/UpdateGameObjectTileVO.as
src/svera/untiered/ui/PlayerGroupMenuMediator.as
src/svera/untiered/ui/signals/BuyCharacterSlotSignal.as
src/svera/untiered/ui/signals/EnterGameSignal.as
src/svera/untiered/ui/signals/HUDModelInitialized.as
src/svera/untiered/ui/signals/HUDSetupStarted.as
src/svera/untiered/ui/signals/NameChangedSignal.as
src/svera/untiered/ui/signals/ShowLoadingUISignal.as
src/svera/untiered/ui/signals/ShowSplashUISignal.as
src/svera/untiered/ui/signals/ShowTitleUISignal.as
src/svera/untiered/ui/signals/UpdateHUDSignal.as
src/svera/untiered/ui/signals/UpdatePotionInventorySignal.as
src/svera/untiered/ui/UIModule.as
src/svera/untiered/ui/UIUtils.as
src/svera/untiered/ui/view/AccountScreenMediator.as
src/svera/untiered/ui/view/CharacterDetailsMediator.as
src/svera/untiered/ui/view/CharacterDetailsView.as
src/svera/untiered/ui/view/CharacterRectListMediator.as
src/svera/untiered/ui/view/CharacterSlotNeedTsavoriteDialog.as
src/svera/untiered/ui/view/CharacterSlotNeedTsavoriteMediator.as
src/svera/untiered/ui/view/CharacterSlotRegisterDialog.as
src/svera/untiered/ui/view/CharacterSlotRegisterMediator.as
src/svera/untiered/ui/view/CharacterWindowBackground.as
src/svera/untiered/ui/view/ChooseNameRegisterDialog.as
src/svera/untiered/ui/view/ChooseNameRegisterMediator.as
src/svera/untiered/ui/view/components/CharSelectionBackground.as
src/svera/untiered/ui/view/components/CharSelectionBackground.png
src/svera/untiered/ui/view/components/DefaultBackground.as
src/svera/untiered/ui/view/components/DefaultBackground.png
src/svera/untiered/ui/view/components/HomescreenBackground.as
src/svera/untiered/ui/view/components/HomescreenBackground.png
src/svera/untiered/ui/view/components/PotionSlotMediator.as
src/svera/untiered/ui/view/components/PotionSlotView.as
src/svera/untiered/ui/view/components/ScreenBase.as
src/svera/untiered/ui/view/CurrentCharacterMediator.as
src/svera/untiered/ui/view/CurrentCharacterRectMediator.as
src/svera/untiered/ui/view/ErrorDialogMediator.as
src/svera/untiered/ui/view/HUDMediator.as
src/svera/untiered/ui/view/HUDView.as
src/svera/untiered/ui/view/LoadingMediator.as
src/svera/untiered/ui/view/MapEditorMediator.as
src/svera/untiered/ui/view/MessageCloseDialog.as
src/svera/untiered/ui/view/MessageCloseMediator.as
src/svera/untiered/ui/view/NewCharacterMediator.as
src/svera/untiered/ui/view/NewsLineMediator.as
src/svera/untiered/ui/view/NotEnoughTsavoriteDialog.as
src/svera/untiered/ui/view/NotEnoughTsavoriteMediator.as
src/svera/untiered/ui/view/SignalWaiter.as
src/svera/untiered/ui/view/SplashMediator.as
src/svera/untiered/ui/view/SplashView.as
src/svera/untiered/ui/view/StatMetersMediator.as
src/svera/untiered/ui/view/StatMetersView.as
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_1.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_10.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_11.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_12.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_13.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_14.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_15.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_16.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_17.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_18.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_19.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_2.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_20.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_21.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_22.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_23.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_24.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_25.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_26.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_27.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_28.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_29.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_3.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_30.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_31.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_32.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_4.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_5.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_6.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_7.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_8.png
src/svera/untiered/ui/view/tiernotifications/celestial/Celestial_Frame_9.png
src/svera/untiered/ui/view/tiernotifications/CelestialPopup.as
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_1.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_10.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_11.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_12.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_13.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_14.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_15.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_16.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_17.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_18.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_19.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_2.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_20.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_21.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_22.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_23.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_24.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_25.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_26.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_27.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_28.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_29.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_3.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_30.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_31.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_32.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_4.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_5.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_6.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_7.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_8.png
src/svera/untiered/ui/view/tiernotifications/exiled/Exiled_Frame_9.png
src/svera/untiered/ui/view/tiernotifications/ExiledPopup.as
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_1.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_10.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_11.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_12.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_13.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_14.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_15.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_16.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_2.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_3.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_4.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_5.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_6.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_7.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_8.png
src/svera/untiered/ui/view/tiernotifications/relic/Relic_Frame_9.png
src/svera/untiered/ui/view/tiernotifications/RelicPopup.as
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_1.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_10.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_11.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_12.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_13.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_14.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_15.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_16.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_17.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_18.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_19.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_2.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_20.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_21.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_22.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_23.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_24.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_3.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_4.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_5.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_6.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_7.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_8.png
src/svera/untiered/ui/view/tiernotifications/tarnished/Tarnished_Frame_9.png
src/svera/untiered/ui/view/tiernotifications/TarnishedPopup.as
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_1.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_10.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_11.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_12.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_13.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_14.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_15.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_16.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_2.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_3.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_4.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_5.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_6.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_7.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_8.png
src/svera/untiered/ui/view/tiernotifications/uncommon/Uncommon_Frame_9.png
src/svera/untiered/ui/view/tiernotifications/UncommonPopup.as
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_1.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_10.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_11.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_12.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_13.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_14.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_15.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_16.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_17.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_18.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_19.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_2.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_20.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_21.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_22.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_23.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_24.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_3.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_4.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_5.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_6.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_7.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_8.png
src/svera/untiered/ui/view/tiernotifications/valiant/Valiant_Frame_9.png
src/svera/untiered/ui/view/tiernotifications/ValiantPopup.as
src/svera/untiered/ui/view/TitleMediator.as
src/svera/untiered/ui/view/TitleView.as
src/svera/untiered/util/components/api/BuyButton.as
src/svera/untiered/util/components/DialogBackground.as
src/svera/untiered/util/components/HorizontalScrollbar.as
src/svera/untiered/util/components/HorizontalScrollbarBar.as
src/svera/untiered/util/components/HorizontalScrollbarGroove.as
src/svera/untiered/util/components/HorizontalScrollingList.as
src/svera/untiered/util/components/LegacyBuyButton.as
src/svera/untiered/util/components/RadioButton.as
src/svera/untiered/util/components/StarsView.as
src/svera/untiered/util/components/VerticalScrollbar.as
src/svera/untiered/util/components/VerticalScrollbarBar.as
src/svera/untiered/util/components/VerticalScrollbarGroove.as
src/svera/untiered/util/components/VerticalScrollingList.as
src/svera/untiered/util/graphics/BevelRect.as
src/svera/untiered/util/graphics/ButtonLayoutHelper.as
src/svera/untiered/util/graphics/GraphicsHelper.as
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
.gitattributes
.gitignore
.actionScriptProperties
.project
config.xml
GameClient-app.xml
untiered.iml
.git/
.idea/
bin-debug/
libs/as3-signals.swc
libs/as3core.swc
libs/as3crypto.swc
libs/GTween-v2.01.swc
libs/hamcrest-as3-flex-1.1.3.swc
libs/Hi-Res-Stats.swc
libs/ionel.swc
libs/robotlegs.swc
libs/starling.swc
libs/Swiftsuspenders-v2.0.0rc1.swc
src/com/company/assembleegameclient/util/TextureRedrawer_textureShaderEmbed_.dat
src/com/company/assembleegameclient/engine3d/
src/com/company/assembleegameclient/map/
src/com/company/assembleegameclient/mapeditor/
src/com/company/ui/fonts/MyriadPro.otf
src/com/company/ui/fonts/MyriadProBold.otf
src/svera/untiered/hud/Overlay.aseprite
src/svera/untiered/traits/background.aseprite
src/svera/untiered/assets/Xmls/
src/com/company/assembleegameclient/objects/GameObject.as
src/com/company/assembleegameclient/objects/Player.as
</file>

<file path="src/com/company/assembleegameclient/util/TextureRedrawer_textureShaderEmbed_.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.assembleegameclient.util {
import mx.core.ByteArrayAsset;

[Embed(source="TextureRedrawer_textureShaderEmbed_.dat", mimeType="application/octet-stream")]
public class TextureRedrawer_textureShaderEmbed_ extends ByteArrayAsset {


}
}//package com.company.assembleegameclient.util
</file>

<file path="src/com/company/untiered/graphics/DeleteXGraphic.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.untiered.graphics {
import flash.display.MovieClip;

[Embed(source="DeleteXGraphic.swf", symbol="com.company.rotmg.graphics.DeleteXGraphic")]
public dynamic class DeleteXGraphic extends MovieClip {
    public function DeleteXGraphic() {
        super();
    }
}
}//package com.company.rotmg.graphics
</file>

<file path="src/com/company/untiered/graphics/ScreenGraphic.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.untiered.graphics {
import flash.display.MovieClip;

[Embed(source="ScreenGraphic.swf", symbol="com.company.rotmg.graphics.ScreenGraphic")]
public dynamic class ScreenGraphic extends MovieClip {
    public function ScreenGraphic() {
        super();
    }
}
}//package com.company.rotmg.graphics
</file>

<file path="src/svera/lib/framework/AppContext.as">
package svera.lib.framework {
import org.swiftsuspenders.Injector;
import flash.display.DisplayObject;
import flash.utils.Dictionary;
import flash.utils.getQualifiedClassName;

/**
 * Lightweight Application Context
 * Replaces Robotlegs with minimal overhead while maintaining DI and modularity
 */
public class AppContext {
    private var _injector:Injector;
    private var _mediatorFactory:MediatorFactory;
    private var _commandBus:CommandBus;
    private var _modules:Vector.<IModule>;
    private var _initialized:Boolean = false;

    public function AppContext() {
        _injector = new Injector();
        _mediatorFactory = new MediatorFactory(_injector);
        _commandBus = new CommandBus(_injector);
        _modules = new Vector.<IModule>();

        // Map core services
        _injector.map(Injector).toValue(_injector);
        _injector.map(AppContext).toValue(this);
        _injector.map(MediatorFactory).toValue(_mediatorFactory);
        _injector.map(CommandBus).toValue(_commandBus);
    }

    public function get injector():Injector {
        return _injector;
    }

    public function get mediators():MediatorFactory {
        return _mediatorFactory;
    }

    public function get commands():CommandBus {
        return _commandBus;
    }

    /**
     * Register a module for configuration
     */
    public function install(module:IModule):AppContext {
        if (_initialized) {
            throw new Error("Cannot install modules after initialization");
        }
        _modules.push(module);
        return this;
    }

    /**
     * Initialize the application context
     */
    public function initialize():void {
        if (_initialized) return;

        // Configure all modules
        for each (var module:IModule in _modules) {
            module.configure(this);
        }

        _initialized = true;
    }

    /**
     * Clean shutdown
     */
    public function destroy():void {
        _mediatorFactory.destroyAll();
        _commandBus.destroy();
        _modules.length = 0;
        _initialized = false;
    }
}
}
</file>

<file path="src/svera/lib/framework/CommandBus.as">
package svera.lib.framework {
import org.swiftsuspenders.Injector;
import org.osflash.signals.Signal;
import flash.utils.Dictionary;

/**
 * Command Bus - Signal-to-Command mapping
 * Replaces Robotlegs SignalCommandMap with minimal overhead
 */
public class CommandBus {
    private var _injector:Injector;
    private var _mappings:Dictionary; // signal -> CommandMapping[]

    public function CommandBus(injector:Injector) {
        _injector = injector;
        _mappings = new Dictionary();
    }

    /**
     * Map a signal to a command
     */
    public function map(signalClass:Class):CommandMapping {
        var signal:Signal = _injector.getInstance(signalClass) as Signal;
        if (!signal) {
            throw new Error("Signal must be mapped in injector first");
        }

        if (!_mappings[signal]) {
            _mappings[signal] = new Vector.<CommandMapping>();
        }

        var mapping:CommandMapping = new CommandMapping(signal, _injector);
        _mappings[signal].push(mapping);

        signal.add(mapping.execute);

        return mapping;
    }

    /**
     * Unmap a signal
     */
    public function unmap(signalClass:Class):void {
        var signal:Signal = _injector.getInstance(signalClass) as Signal;
        if (!signal || !_mappings[signal]) return;

        var mappings:Vector.<CommandMapping> = _mappings[signal];
        for each (var mapping:CommandMapping in mappings) {
            signal.remove(mapping.execute);
        }

        delete _mappings[signal];
    }

    public function destroy():void {
        for (var signal:* in _mappings) {
            var mappings:Vector.<CommandMapping> = _mappings[signal];
            for each (var mapping:CommandMapping in mappings) {
                (signal as Signal).remove(mapping.execute);
            }
        }
        _mappings = new Dictionary();
    }
}
}
</file>

<file path="src/svera/lib/framework/CommandMapping.as">
package svera.lib.framework {
import org.swiftsuspenders.Injector;
import org.osflash.signals.Signal;

/**
 * Command Mapping - holds command execution configuration
 * Provides fluent API for configuring command behavior (guards, once execution, etc.)
 */
public class CommandMapping {
    private var _signal:Signal;
    private var _injector:Injector;
    private var _commandClass:Class;
    private var _guards:Vector.<Class>;
    private var _once:Boolean = false;

    public function CommandMapping(signal:Signal, injector:Injector) {
        _signal = signal;
        _injector = injector;
        _guards = new Vector.<Class>();
    }

    /**
     * Set the command class to execute when signal is dispatched
     * @param commandClass The command class (must implement ICommand)
     * @return This mapping for chaining
     */
    public function toCommand(commandClass:Class):CommandMapping {
        _commandClass = commandClass;
        return this;
    }

    /**
     * Add guards to check before command execution
     * Guards are checked in order, and all must approve for command to execute
     * @param guards One or more guard classes (must implement IGuard)
     * @return This mapping for chaining
     */
    public function withGuards(...guards):CommandMapping {
        for each (var guard:Class in guards) {
            _guards.push(guard);
        }
        return this;
    }

    /**
     * Execute command only once, then automatically unmap
     * @return This mapping for chaining
     */
    public function once():CommandMapping {
        _once = true;
        return this;
    }

    /**
     * Get the command class for this mapping
     * @return The command class
     */
    public function get commandClass():Class {
        return _commandClass;
    }

    /**
     * Execute the command (called by signal dispatch)
     * Checks guards, creates command instance, injects dependencies, and executes
     * @param args Signal parameters passed to command
     */
    public function execute(...args):void {
        trace("[CommandMapping] execute() called for command:", _commandClass);
        // Check guards
        for each (var guardClass:Class in _guards) {
            var guard:IGuard = _injector.getInstance(guardClass) as IGuard;
            if (guard && !guard.approve()) {
                trace("[CommandMapping] Guard rejected:", guardClass);
                return; // Guard rejected, don't execute command
            }
        }

        // Create and execute command
        if (_commandClass) {
            // Create new instance of command
            var command:ICommand = new _commandClass() as ICommand;
            if (command) {
                // Inject dependencies into the command
                _injector.injectInto(command);
                // Execute the command
                command.execute();
            } else {
                trace("[CommandMapping] ERROR: Could not cast to ICommand!");
            }
        }

        // Remove mapping if once is set
        if (_once) {
            _signal.remove(execute);
        }
    }
}
}
</file>

<file path="src/svera/lib/framework/ICommand.as">
package svera.lib.framework {

/**
 * Command interface
 */
public interface ICommand {
    function execute():void;
}
}
</file>

<file path="src/svera/lib/framework/IGuard.as">
package svera.lib.framework {

/**
 * Guard interface
 */
public interface IGuard {
    function approve():Boolean;
}
}
</file>

<file path="src/svera/lib/framework/IMediator.as">
package svera.lib.framework {
import flash.display.DisplayObject;

/**
 * Mediator interface - simplified from Robotlegs
 */
public interface IMediator {
    function setView(view:DisplayObject):void;
    function initialize():void;
    function destroy():void;
}
}
</file>

<file path="src/svera/lib/framework/IModule.as">
package svera.lib.framework {

/**
 * Module interface - replaces Robotlegs IConfig
 */
public interface IModule {
    function configure(context:AppContext):void;
}
}
</file>

<file path="src/svera/lib/framework/Mediator.as">
package svera.lib.framework {
import flash.display.DisplayObject;

/**
 * Base Mediator class
 * Much lighter than Robotlegs mediator with direct property access
 */
public class Mediator implements IMediator {
    private var _view:DisplayObject;
    private var _initialized:Boolean = false;

    public function setView(view:DisplayObject):void {
        _view = view;
    }

    protected function get view():DisplayObject {
        return _view;
    }

    public function initialize():void {
        if (_initialized) return;
        _initialized = true;
        onInitialize();
    }

    public function destroy():void {
        if (!_initialized) return;
        onDestroy();
        _initialized = false;
        _view = null;
    }

    // Override these in subclasses
    protected function onInitialize():void {}
    protected function onDestroy():void {}
}
}
</file>

<file path="src/svera/lib/framework/MediatorFactory.as">
package svera.lib.framework {
import org.swiftsuspenders.Injector;
import flash.display.DisplayObject;
import flash.events.Event;
import flash.utils.Dictionary;
import flash.utils.getQualifiedClassName;

/**
 * Lightweight Mediator Factory
 * Manages view-mediator lifecycle without reflection overhead
 * Automatically creates mediators when views are added to stage and destroys them when removed
 */
public class MediatorFactory {
    private var _injector:Injector;
    private var _mappings:Dictionary; // viewClass -> mediatorClass
    private var _mediators:Dictionary; // view -> mediator
    private var _autoDestroy:Boolean = true;

    public function MediatorFactory(injector:Injector) {
        _injector = injector;
        _mappings = new Dictionary();
        _mediators = new Dictionary(true); // weak keys for automatic GC
    }

    /**
     * Map a view class to a mediator class
     * @param viewClass The view class to map
     * @param mediatorClass The mediator class that will manage the view
     */
    public function map(viewClass:Class, mediatorClass:Class):void {
        var key:String = getQualifiedClassName(viewClass);
        _mappings[key] = mediatorClass;
    }

    /**
     * Unmap a view class
     * @param viewClass The view class to unmap
     */
    public function unmap(viewClass:Class):void {
        var key:String = getQualifiedClassName(viewClass);
        delete _mappings[key];
    }

    /**
     * Create and initialize a mediator for a view
     * @param view The view instance to mediate
     * @return The created mediator or null if no mapping exists
     */
    public function create(view:DisplayObject):IMediator {
        if (_mediators[view]) {
            return _mediators[view];
        }

        var viewKey:String = getQualifiedClassName(view);
        var mediatorClass:Class = _mappings[viewKey];

        if (!mediatorClass) {
            return null;
        }

        // Create new instance of mediator using 'new'
        var mediator:IMediator = new mediatorClass() as IMediator;
        if (!mediator) {
            throw new Error("Mediator must implement IMediator interface");
        }

        mediator.setView(view);
        _injector.injectInto(mediator);
        _mediators[view] = mediator;

        mediator.initialize();

        // Auto-destroy on removed from stage
        if (_autoDestroy) {
            view.addEventListener(Event.REMOVED_FROM_STAGE, onViewRemoved, false, 0, true);
        }

        return mediator;
    }

    /**
     * Destroy a mediator for a view
     * @param view The view whose mediator should be destroyed
     */
    public function destroy(view:DisplayObject):void {
        var mediator:IMediator = _mediators[view];
        if (mediator) {
            view.removeEventListener(Event.REMOVED_FROM_STAGE, onViewRemoved);
            mediator.destroy();
            delete _mediators[view];
        }
    }

    /**
     * Destroy all active mediators
     */
    public function destroyAll():void {
        for (var view:* in _mediators) {
            destroy(view as DisplayObject);
        }
    }

    /**
     * Get the mediator for a view if it exists
     * @param view The view to get the mediator for
     * @return The mediator or null if none exists
     */
    public function getMediator(view:DisplayObject):IMediator {
        return _mediators[view];
    }

    private function onViewRemoved(e:Event):void {
        destroy(e.currentTarget as DisplayObject);
    }

    /**
     * Enable or disable automatic destruction of mediators when views are removed from stage
     */
    public function set autoDestroy(value:Boolean):void {
        _autoDestroy = value;
    }

    public function get autoDestroy():Boolean {
        return _autoDestroy;
    }
}
}
</file>

<file path="src/svera/lib/net/NetModule.as">
package svera.lib.net {
import flash.net.Socket;

import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.lib.net.api.MessageMap;
import svera.lib.net.api.MessageProvider;
import svera.lib.net.impl.MessageCenter;
import svera.lib.net.impl.SocketServer;

public class NetModule implements IModule {

    private var messageCenter:MessageCenter;

    public function NetModule() {
        super();
    }

    public function configure(context:AppContext):void {
        this.messageCenter = new MessageCenter().setInjector(context.injector);
        context.injector.map(Socket);
        context.injector.map(MessageMap).toValue(this.messageCenter);
        context.injector.map(MessageProvider).toValue(this.messageCenter);
        context.injector.map(SocketServer).asSingleton();
    }
}
}
</file>

<file path="src/svera/lib/resizing/ResizeModule.as">
// FILE: src/svera/lib/resizing/ResizeModule.as
package svera.lib.resizing {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;
import svera.lib.framework.IModule;
import svera.lib.resizing.signals.Resize;
import svera.lib.resizing.view.Resizable;
import svera.lib.resizing.view.ResizableMediator;

public class ResizeModule implements IModule {

    public function configure(context:AppContext):void {
        var injector:Injector = context.injector;

        // Map signal
        injector.map(Resize).asSingleton();

        // Map mediator
        context.mediators.map(Resizable, ResizableMediator);
    }
}
}
</file>

<file path="src/svera/untiered/account/AccountModule.as">
package svera.untiered.account {
import flash.display.DisplayObjectContainer;
import flash.display.LoaderInfo;

import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;
import svera.lib.framework.IModule;
import svera.untiered.account.core.BuyCharacterSlotCommand;
import svera.untiered.account.core.control.IsAccountRegisteredGuard;
import svera.untiered.account.core.services.GetCharListTask;
import svera.untiered.account.core.signals.UpdateAccountInfoSignal;
import svera.untiered.account.web.WebAccountModule;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.ui.signals.BuyCharacterSlotSignal;

public class AccountModule implements IModule {

    public function configure(context:AppContext):void {
        this.configureCommonFunctionality(context);
        this.configureAccountSpecificFunctionality(context);
    }

    private function configureCommonFunctionality(context:AppContext):void {
        var injector:Injector = context.injector;

        // Map signals and services
        injector.map(TaskErrorSignal).asSingleton();
        injector.map(UpdateAccountInfoSignal).asSingleton();
        injector.map(GetCharListTask);

        // Map commands with guards
        context.commands.map(BuyCharacterSlotSignal)
                .toCommand(BuyCharacterSlotCommand)
                .withGuards(IsAccountRegisteredGuard);
    }

    private function configureAccountSpecificFunctionality(context:AppContext):void {
        // Install sub-module
        var webAccountModule:WebAccountModule = new WebAccountModule();
        webAccountModule.configure(context);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/WebAccountModule.as">
package svera.untiered.account.web {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.services.ChangePasswordTask;
import svera.untiered.account.core.services.LoadAccountTask;
import svera.untiered.account.core.services.LoginTask;
import svera.untiered.account.core.services.RegisterAccountTask;
import svera.untiered.account.core.services.SendPasswordReminderTask;
import svera.untiered.account.core.signals.LoginSignal;
import svera.untiered.account.core.signals.LogoutSignal;
import svera.untiered.account.core.signals.OpenAccountInfoSignal;
import svera.untiered.account.core.signals.OpenQuitDialogSignal;
import svera.untiered.account.core.signals.RegisterSignal;
import svera.untiered.account.core.signals.SendPasswordReminderSignal;
import svera.untiered.account.web.commands.WebChangePasswordCommand;
import svera.untiered.account.web.commands.WebLoginCommand;
import svera.untiered.account.web.commands.WebLogoutCommand;
import svera.untiered.account.web.commands.WebOpenAccountInfoCommand;
import svera.untiered.account.web.commands.WebOpenQuitDialogCommand;
import svera.untiered.account.web.commands.WebRegisterAccountCommand;
import svera.untiered.account.web.commands.WebSendPasswordReminderCommand;
import svera.untiered.account.web.services.WebChangePasswordTask;
import svera.untiered.account.web.services.WebLoadAccountTask;
import svera.untiered.account.web.services.WebLoginTask;
import svera.untiered.account.web.services.WebRegisterAccountTask;
import svera.untiered.account.web.services.WebSendPasswordReminderTask;
import svera.untiered.account.web.signals.WebChangePasswordSignal;
import svera.untiered.account.web.view.WebAccountDetailDialog;
import svera.untiered.account.web.view.WebAccountDetailMediator;
import svera.untiered.account.web.view.WebAccountInfoMediator;
import svera.untiered.account.web.view.WebAccountInfoView;
import svera.untiered.account.web.view.WebChangePasswordDialog;
import svera.untiered.account.web.view.WebChangePasswordMediator;
import svera.untiered.account.web.view.WebLoginDialog;
import svera.untiered.account.web.view.WebLoginMediator;
import svera.untiered.account.web.view.WebQuitDialog;
import svera.untiered.account.web.view.WebQuitMediator;
import svera.untiered.account.web.view.WebRegisterDialog;
import svera.untiered.account.web.view.WebRegisterMediator;

public class WebAccountModule implements IModule {


    public function WebAccountModule() {
        super();
    }

    public function configure(context:AppContext):void {
        this.mapModel(context);
        this.mapCommands(context);
        this.mapMediators(context);
        this.mapTasks(context);
    }

    protected function mapModel(context:AppContext):void {
        context.injector.map(Account).toSingleton(WebAccount);
    }

    protected function mapCommands(context:AppContext):void {
        context.commands.map(OpenQuitDialogSignal).toCommand(WebOpenQuitDialogCommand);
        context.commands.map(OpenAccountInfoSignal).toCommand(WebOpenAccountInfoCommand);
        context.commands.map(LoginSignal).toCommand(WebLoginCommand);
        context.commands.map(LogoutSignal).toCommand(WebLogoutCommand);
        context.commands.map(WebChangePasswordSignal).toCommand(WebChangePasswordCommand);
        context.commands.map(SendPasswordReminderSignal).toCommand(WebSendPasswordReminderCommand);
        context.commands.map(RegisterSignal).toCommand(WebRegisterAccountCommand);
        //context.commands.map(CharListDataSignal);
    }

    protected function mapMediators(context:AppContext):void {
        context.mediators.map(WebQuitDialog, WebQuitMediator);
        context.mediators.map(WebAccountInfoView, WebAccountInfoMediator);
        context.mediators.map(WebChangePasswordDialog, WebChangePasswordMediator);
        context.mediators.map(WebAccountDetailDialog, WebAccountDetailMediator);
        context.mediators.map(WebRegisterDialog, WebRegisterMediator);
        context.mediators.map(WebLoginDialog, WebLoginMediator);
    }

    protected function mapTasks(context:AppContext):void {
        context.injector.map(ChangePasswordTask).toType(WebChangePasswordTask);
        context.injector.map(LoadAccountTask).toType(WebLoadAccountTask);
        context.injector.map(LoginTask).toType(WebLoginTask);
        context.injector.map(RegisterAccountTask).toType(WebRegisterAccountTask);
        context.injector.map(SendPasswordReminderTask).toType(WebSendPasswordReminderTask);
    }
}
}
</file>

<file path="src/svera/untiered/appengine/AppEngineModule.as">
package svera.untiered.appengine {
import org.swiftsuspenders.Injector;

import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.appengine.api.RetryLoader;
import svera.untiered.appengine.impl.AppEngineRetryLoader;
import svera.untiered.appengine.impl.SimpleAppEngineClient;

public class AppEngineModule implements IModule {

    public function AppEngineModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(RetryLoader).toType(AppEngineRetryLoader);
        context.injector.map(AppEngineClient).toType(SimpleAppEngineClient);
    }
}
}
</file>

<file path="src/svera/untiered/assets/AssetsModule.as">
package svera.untiered.assets {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.assets.services.IconFactory;

public class AssetsModule implements IModule {

    public function AssetsModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(CharacterFactory).asSingleton();
        context.injector.map(IconFactory).asSingleton();
    }
}
}
</file>

<file path="src/svera/untiered/characters/CharactersModule.as">
package svera.untiered.characters {
import org.swiftsuspenders.Injector;

import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.untiered.characters.deletion.DeletionModule;
import svera.untiered.characters.model.CharacterModel;
import svera.untiered.characters.model.LegacyCharacterModel;
import svera.untiered.characters.reskin.ReskinModule;

public class CharactersModule implements IModule {

    public function CharactersModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(CharacterModel).toSingleton(LegacyCharacterModel);
        context.install(new DeletionModule());
        context.install(new ReskinModule());
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/DeletionModule.as">
package svera.untiered.characters.deletion {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.characters.deletion.control.DeleteCharacterCommand;
import svera.untiered.characters.deletion.control.DeleteCharacterSignal;
import svera.untiered.characters.deletion.service.DeleteCharacterTask;
import svera.untiered.characters.deletion.view.ConfirmDeleteCharacterDialog;
import svera.untiered.characters.deletion.view.ConfirmDeleteCharacterMediator;

public class DeletionModule implements IModule {

    public function DeletionModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(DeleteCharacterTask);
        context.mediators.map(ConfirmDeleteCharacterDialog, ConfirmDeleteCharacterMediator);
        context.commands.map(DeleteCharacterSignal).toCommand(DeleteCharacterCommand);
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/ReskinModule.as">
package svera.untiered.characters.reskin {
import org.swiftsuspenders.Injector;

import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.lib.net.api.MessageMap;
import svera.untiered.characters.reskin.control.OpenReskinDialogCommand;
import svera.untiered.characters.reskin.control.OpenReskinDialogSignal;
import svera.untiered.characters.reskin.control.ReskinCharacterCommand;
import svera.untiered.characters.reskin.control.ReskinCharacterSignal;
import svera.untiered.characters.reskin.control.ReskinHandler;
import svera.untiered.characters.reskin.view.ReskinCharacterMediator;
import svera.untiered.characters.reskin.view.ReskinCharacterView;
import svera.untiered.characters.reskin.view.ReskinPanel;
import svera.untiered.characters.reskin.view.ReskinPanelMediator;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.messaging.impl.outgoing.Reskin;

public class ReskinModule implements IModule {

    [Inject]
    public var messageMap:MessageMap;

    public function ReskinModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.mediators.map(ReskinCharacterView, ReskinCharacterMediator);
        context.mediators.map(ReskinPanel, ReskinPanelMediator);
        context.commands.map(OpenReskinDialogSignal).toCommand(OpenReskinDialogCommand);
        context.commands.map(ReskinCharacterSignal).toCommand(ReskinCharacterCommand);
    }
}
}
</file>

<file path="src/svera/untiered/classes/ClassesModule.as">
package svera.untiered.classes {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;
import svera.lib.framework.IModule;
import svera.untiered.account.core.control.IsAccountRegisteredGuard;
import svera.untiered.account.core.signals.CharListDataSignal;
import svera.untiered.account.core.signals.LogoutSignal;
import svera.untiered.assets.EmbeddedData;
import svera.untiered.classes.control.*;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.classes.services.BuySkinTask;
import svera.untiered.classes.view.*;

/**
 * Classes Module - Replaces ClassesConfig
 * Configures character classes, skins, and related functionality
 */
public class ClassesModule implements IModule {

    public function configure(context:AppContext):void {
        var injector:Injector = context.injector;

        // Model
        injector.map(ClassesModel).asSingleton();

        // Signals
        injector.map(ParseClassesXMLSignal).asSingleton();
        injector.map(BuyCharacterSkinSignal).asSingleton();
        injector.map(FocusCharacterSkinSignal).asSingleton();

        // Services
        injector.map(BuySkinTask);
        injector.map(CharacterSkinListItemFactory).asSingleton();

        // Command mappings with guards
        context.commands.map(ParseClassesXMLSignal)
                .toCommand(ParseClassesXmlCommand);

        context.commands.map(CharListDataSignal)
                .toCommand(ParseCharListXmlCommand);

        context.commands.map(BuyCharacterSkinSignal)
                .toCommand(BuyCharacterSkinCommand)
                .withGuards(IsAccountRegisteredGuard);

        context.commands.map(LogoutSignal)
                .toCommand(ResetClassDataCommand);

        // Mediator mappings
        context.mediators.map(ClassDetailView, ClassDetailMediator);
        context.mediators.map(CharacterSkinView, CharacterSkinMediator);
        context.mediators.map(CharacterSkinListView, CharacterSkinListMediator);
        context.mediators.map(CharacterSkinListItem, CharacterSkinListItemMediator);

        // Parse initial data
        // EmbeddedData.Players is a Class, need to instantiate and convert to XML
        var parseSignal:ParseClassesXMLSignal = injector.getInstance(ParseClassesXMLSignal);
        var playersXML:XML = XML(new EmbeddedData.Players());
        parseSignal.dispatch(playersXML);

        // Note: ParseSkinsXmlCommand reads directly from EmbeddedData.skinsXML
        // so we don't need to dispatch for skins - it ignores the data parameter
    }
}
}
</file>

<file path="src/svera/untiered/core/CoreModule.as">
package svera.untiered.core {
import org.swiftsuspenders.Injector;
import flash.display.DisplayObjectContainer;

import svera.lib.framework.AppContext;
import svera.lib.framework.IModule;
import svera.lib.json.JsonParser;
import svera.lib.json.SoftwareJsonParser;
import svera.lib.tasks.TaskMonitor;
import svera.untiered.account.core.signals.CharListDataSignal;
import svera.untiered.core.commands.InvalidateDataCommand;
import svera.untiered.core.commands.SetScreenWithValidDataCommand;
import svera.untiered.core.commands.UpdatePlayerModelCommand;
import svera.untiered.core.model.MapModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.model.ScreenModel;
import svera.untiered.core.signals.*;
import svera.untiered.core.view.Layers;
import svera.untiered.core.view.ScreensMediator;
import svera.untiered.core.view.ScreensView;
import svera.untiered.startup.control.StartupSequence;

/**
 * Core Module - Replaces CoreConfig
 * Configures the core application models, commands, and views
 */
public class CoreModule implements IModule {

    public function configure(context:AppContext):void {
        var injector:Injector = context.injector;

        // Models - singleton pattern
        injector.map(PlayerModel).asSingleton();
        injector.map(MapModel).asSingleton();
        injector.map(ScreenModel).asSingleton();

        // Services
        injector.map(JsonParser).toSingleton(SoftwareJsonParser);
        injector.map(TaskMonitor).asSingleton();

        // Signals
        injector.map(SetScreenSignal).asSingleton();
        injector.map(GotoPreviousScreenSignal).asSingleton();
        injector.map(LaunchGameSignal).asSingleton();
        injector.map(ShowTooltipSignal).asSingleton();
        injector.map(HideTooltipsSignal).asSingleton();
        injector.map(SetLoadingMessageSignal).asSingleton();
        injector.map(UpdateNewCharacterScreenSignal).asSingleton();

        // Command mappings
        context.commands.map(InvalidateDataSignal).toCommand(InvalidateDataCommand);
        context.commands.map(SetScreenWithValidDataSignal).toCommand(SetScreenWithValidDataCommand);
        context.commands.map(CharListDataSignal).toCommand(UpdatePlayerModelCommand);

        // Mediator mappings
        context.mediators.map(ScreensView, ScreensMediator);

        // Initialize view hierarchy
        // Get the mapped DisplayObjectContainer instead of trying to instantiate it
        var contextView:DisplayObjectContainer = injector.getInstance(DisplayObjectContainer);

        var layers:Layers = new Layers();
        injector.map(Layers).toValue(layers);
        contextView.addChild(layers);

        var screensView:ScreensView = new ScreensView();
        layers.addChild(screensView);

        // Create mediator for screens view
        context.mediators.create(screensView);
    }
}
}
</file>

<file path="src/svera/untiered/death/DeathModule.as">
package svera.untiered.death {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.death.control.HandleDeathCommand;
import svera.untiered.death.control.HandleDeathSignal;
import svera.untiered.death.control.HandleNormalDeathCommand;
import svera.untiered.death.control.HandleNormalDeathSignal;
import svera.untiered.death.model.DeathModel;

public class DeathModule implements IModule {

    public function DeathModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(DeathModel).asSingleton();
        context.commands.map(HandleDeathSignal).toCommand(HandleDeathCommand);
        context.commands.map(HandleNormalDeathSignal).toCommand(HandleNormalDeathCommand);
    }
}
}
</file>

<file path="src/svera/untiered/dialogs/DialogsModule.as">
package svera.untiered.dialogs {
import svera.lib.framework.AppContext;
import svera.lib.framework.IModule;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.dialogs.view.DialogsMediator;
import svera.untiered.dialogs.view.DialogsView;

public class DialogsModule implements IModule {

    public function configure(context:AppContext):void {

        // Map signals
        context.injector.map(OpenDialogSignal).asSingleton();

        // Map mediator (simplified!)
        context.mediators.map(DialogsView, DialogsMediator);
    }
}
}
</file>

<file path="src/svera/untiered/game/focus/GameFocusModule.as">
package svera.untiered.game.focus {
import com.company.assembleegameclient.game.GameSprite;

import org.swiftsuspenders.Injector;

import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.untiered.game.focus.control.SetGameFocusSignal;
import svera.untiered.game.focus.view.GameFocusMediator;

public class GameFocusModule implements IModule {

    [Inject]
    public var injector:Injector;

    public function GameFocusModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(SetGameFocusSignal).asSingleton();
        context.mediators.map(GameSprite, GameFocusMediator);
    }
}
}
</file>

<file path="src/svera/untiered/game/GameModule.as">
package svera.untiered.game {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.map.MapMediator;
import com.company.assembleegameclient.map.mapoverlay.MapOverlay;
import com.company.assembleegameclient.ui.TextBox;
import com.company.assembleegameclient.ui.panels.InteractPanel;
import com.company.assembleegameclient.ui.panels.PortalPanel;
import com.company.assembleegameclient.ui.panels.itemgrids.InventoryGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.assembleegameclient.ui.panels.mediators.InteractPanelMediator;
import com.company.assembleegameclient.ui.panels.mediators.InventoryGridMediator;
import com.company.assembleegameclient.ui.panels.mediators.ItemGridMediator;

import org.swiftsuspenders.Injector;

import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.untiered.game.commands.PlayGameCommand;
import svera.untiered.game.commands.TransitionFromGameToMenuCommand;
import svera.untiered.game.commands.UsePotionCommand;
import svera.untiered.game.focus.GameFocusModule;
import svera.untiered.game.model.ChatFilter;
import svera.untiered.game.model.GameModel;
import svera.untiered.game.signals.AddSpeechBalloonSignal;
import svera.untiered.game.signals.AddTextLineSignal;
import svera.untiered.game.signals.DisconnectGameSignal;
import svera.untiered.game.signals.ExitGameSignal;
import svera.untiered.game.signals.GameClosedSignal;
import svera.untiered.game.signals.PlayGameSignal;
import svera.untiered.game.signals.SetTextBoxVisibilitySignal;
import svera.untiered.game.signals.SetWorldInteractionSignal;
import svera.untiered.game.signals.ShowChatInputSignal;
import svera.untiered.game.signals.UsePotionSignal;
import svera.untiered.game.view.CurrencyDisplay;
import svera.untiered.game.view.CurrencyDisplayMediator;
import svera.untiered.game.view.GameSpriteMediator;
import svera.untiered.game.view.LootboxMediator;
import svera.untiered.game.view.LootboxModalButton;
import svera.untiered.game.view.MapOverlayMediator;
import svera.untiered.game.view.PortalPanelMediator;
import svera.untiered.game.view.SellableObjectPanel;
import svera.untiered.game.view.SellableObjectPanelMediator;
import svera.untiered.game.view.TextBoxMediator;
import svera.untiered.game.view.components.StatMediator;
import svera.untiered.game.view.components.StatView;
import svera.untiered.game.view.components.StatsMediator;
import svera.untiered.game.view.components.StatsView;
import svera.untiered.lootBoxes.LootboxModal;
import svera.untiered.lootBoxes.LootboxModalMediator;

public class GameModule implements IModule {

    public function GameModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.install(new GameFocusModule());
        context.injector.map(GameModel).asSingleton();
        context.injector.map(SetWorldInteractionSignal).asSingleton();
        context.injector.map(AddTextLineSignal).asSingleton();
        context.injector.map(SetTextBoxVisibilitySignal).asSingleton();
        context.injector.map(AddSpeechBalloonSignal).asSingleton();
        context.injector.map(ChatFilter).asSingleton();
        context.injector.map(DisconnectGameSignal).asSingleton();
        context.injector.map(ExitGameSignal).asSingleton();
        context.injector.map(ShowChatInputSignal).asSingleton();
        context.mediators.map(GameSprite, GameSpriteMediator);
        context.mediators.map(CurrencyDisplay, CurrencyDisplayMediator);
        context.mediators.map(SellableObjectPanel, SellableObjectPanelMediator);
        context.mediators.map(LootboxModalButton, LootboxMediator);
        context.mediators.map(PortalPanel, PortalPanelMediator);
        context.mediators.map(InteractPanel, InteractPanelMediator);
        context.mediators.map(ItemGrid, ItemGridMediator);
        context.mediators.map(InventoryGrid, InventoryGridMediator);
        context.mediators.map(TextBox, TextBoxMediator);
        context.mediators.map(MapOverlay, MapOverlayMediator);
        context.mediators.map(Map, MapMediator);
        context.mediators.map(LootboxModal, LootboxModalMediator);
        context.mediators.map(StatView, StatMediator);
        context.mediators.map(StatsView, StatsMediator);
        context.commands.map(UsePotionSignal).toCommand(UsePotionCommand);
        context.commands.map(GameClosedSignal).toCommand(TransitionFromGameToMenuCommand);
        context.commands.map(PlayGameSignal).toCommand(PlayGameCommand);
    }
}
}
</file>

<file path="src/svera/untiered/honor/HonorModule.as">
package svera.untiered.honor {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.honor.control.ShowHonorViewCommand;
import svera.untiered.honor.control.ShowHonorViewSignal;
import svera.untiered.honor.model.HonorModel;
import svera.untiered.honor.service.RequestCharacterHonorTask;
import svera.untiered.honor.view.HonorMediator;
import svera.untiered.honor.view.HonorView;

public class HonorModule implements IModule {

    public function HonorModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(HonorModel).asSingleton();
        context.injector.map(RequestCharacterHonorTask);
        context.commands.map(ShowHonorViewSignal).toCommand(ShowHonorViewCommand);
        context.mediators.map(HonorView, HonorMediator);
    }
}
}
</file>

<file path="src/svera/untiered/hud/HUDModule.as">
package svera.untiered.hud {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

public class HUDModule implements IModule {

    public function HUDModule() {
        super();
    }

    public function configure(context:AppContext):void {
    }
}
}
</file>

<file path="src/svera/untiered/legends/LegendsModule.as">
package svera.untiered.legends {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.legends.control.ExitLegendsCommand;
import svera.untiered.legends.control.ExitLegendsSignal;
import svera.untiered.legends.control.HonorListUpdateSignal;
import svera.untiered.legends.control.RequestHonorListCommand;
import svera.untiered.legends.control.RequestHonorListSignal;
import svera.untiered.legends.model.LegendFactory;
import svera.untiered.legends.model.LegendsModel;
import svera.untiered.legends.view.LegendsMediator;
import svera.untiered.legends.view.LegendsView;

public class LegendsModule implements IModule {

    public function LegendsModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(LegendFactory).asSingleton();
        context.injector.map(LegendsModel).asSingleton();
        context.injector.map(HonorListUpdateSignal).asSingleton();
        context.mediators.map(LegendsView, LegendsMediator);
        context.commands.map(RequestHonorListSignal).toCommand(RequestHonorListCommand);
        context.commands.map(ExitLegendsSignal).toCommand(ExitLegendsCommand);
    }
}
}
</file>

<file path="src/svera/untiered/minimap/MiniMapModule.as">
package svera.untiered.minimap {
import org.swiftsuspenders.Injector;

import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.untiered.minimap.control.MiniMapZoomSignal;
import svera.untiered.minimap.control.SetMiniMapMapSignal;
import svera.untiered.minimap.control.UpdateGameObjectTileSignal;
import svera.untiered.minimap.control.UpdateGroundTileSignal;
import svera.untiered.minimap.view.MiniMap;
import svera.untiered.minimap.view.MiniMapMediator;

public class MiniMapModule implements IModule {

    public function MiniMapModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(MiniMapZoomSignal).asSingleton();
        context.injector.map(SetMiniMapMapSignal).asSingleton();
        context.injector.map(UpdateGameObjectTileSignal).asSingleton();
        context.injector.map(UpdateGroundTileSignal).asSingleton();
        context.mediators.map(MiniMap, MiniMapMediator);
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Stage3DModule.as">
// FILE: src/svera/untiered/stage3D/Stage3DModule.as
package svera.untiered.stage3D {
import com.company.assembleegameclient.engine3d.Model3D;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.Stage3DProxy;
import com.company.assembleegameclient.util.StageProxy;

import flash.display3D.Context3DBlendFactor;
import flash.display3D.Context3DCompareMode;
import flash.events.ErrorEvent;
import flash.events.Event;

import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;
import svera.lib.framework.IModule;
import svera.untiered.stage3D.graphic3D.Graphic3D;
import svera.untiered.stage3D.graphic3D.Graphic3DHelper;
import svera.untiered.stage3D.graphic3D.IndexBufferFactory;
import svera.untiered.stage3D.graphic3D.TextureFactory;
import svera.untiered.stage3D.graphic3D.VertexBufferFactory;
import svera.untiered.stage3D.proxies.Context3DProxy;

public class Stage3DModule implements IModule {

    public static var WIDTH:int = 600;
    public static var HALF_WIDTH:int = WIDTH / 2;
    public static var HEIGHT:int = 600;
    public static var HALF_HEIGHT:int = HEIGHT / 2;

    private var stageProxy:StageProxy;
    private var renderer:Renderer;
    private var stage3D:Stage3DProxy;

    // ⭐ Store injector reference instead of using StaticInjectorContext
    private var injector:Injector;

    public static function Dimensions():void {
        var mscale:Number = Parameters.data_.mScale;
        var WidthScaled:Number = GameClient.StageWidth / mscale;
        var HeightScaled:Number = GameClient.StageHeight / mscale;
        WIDTH = WidthScaled;
        HALF_WIDTH = WidthScaled / 2;
        HEIGHT = HeightScaled;
        HALF_HEIGHT = HeightScaled / 2;
    }

    public function configure(context:AppContext):void {
        // ⭐ Store the injector for later use
        this.injector = context.injector;

        // Get stage proxy from injector
        this.stageProxy = context.injector.getInstance(StageProxy);

        // Map singletons
        this.mapSingletons(context);

        // Initialize Stage3D
        this.stage3D = this.stageProxy.getStage3Ds(0);
        this.stage3D.addEventListener(ErrorEvent.ERROR, Parameters.clearGpuRenderEvent);
        this.stage3D.addEventListener(Event.CONTEXT3D_CREATE, this.onContextCreate);
        this.stage3D.requestContext3D();
    }

    private function mapSingletons(context:AppContext):void {
        context.injector.map(Renderer).asSingleton();
        context.injector.map(Graphic3D).asSingleton();
        context.injector.map(Render3D).asSingleton();
        context.injector.map(TextureFactory).asSingleton();
        context.injector.map(IndexBufferFactory).asSingleton();
        context.injector.map(VertexBufferFactory).asSingleton();
    }

    private function onContextCreate(e:Event):void {
        this.stage3D.removeEventListener(Event.CONTEXT3D_CREATE, this.onContextCreate);
        var context3D:Context3DProxy = this.stage3D.getContext3D();

        if (context3D.GetContext3D().driverInfo.toLowerCase().indexOf("software") != -1) {
            Parameters.clearGpuRender();
        }

        context3D.configureBackBuffer(WIDTH, HEIGHT, 2);
        context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);
        context3D.setDepthTest(false, Context3DCompareMode.LESS_EQUAL);

        // Use stored injector instead of StaticInjectorContext
        this.injector.map(Context3DProxy).toValue(context3D);

        // Map Graphic3D helper BEFORE creating Renderer
        // This sets up IndexBuffer3DProxy and VertexBuffer3DProxy providers
        Graphic3DHelper.map(this.injector);

        // Get the renderer and initialize with unwrapped Context3D
        this.renderer = this.injector.getInstance(Renderer);
        this.renderer.init(context3D.GetContext3D());

        // Initialize Model3D buffers
        Model3D.Create3dBuffer(context3D.GetContext3D());
    }
}
}
</file>

<file path="src/svera/untiered/startup/StartupModule.as">
package svera.untiered.startup {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.startup.control.StartupCommand;
import svera.untiered.startup.control.StartupSequence;
import svera.untiered.startup.control.StartupSignal;

public class StartupModule implements IModule {

    public function StartupModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.injector.map(StartupSequence).asSingleton();
        context.injector.map(StartupSignal).asSingleton();
        context.commands.map(StartupSignal).toCommand(StartupCommand);
    }
}
}
</file>

<file path="src/svera/untiered/tooltips/TooltipsModule.as">
package svera.untiered.tooltips {
import svera.lib.framework.IModule;
import svera.lib.framework.AppContext;

import svera.untiered.tooltips.view.TooltipsMediator;
import svera.untiered.tooltips.view.TooltipsView;

public class TooltipsModule implements IModule {

    public function TooltipsModule() {
        super();
    }

    public function configure(context:AppContext):void {
        context.mediators.map(TooltipsView, TooltipsMediator);
    }
}
}
</file>

<file path="src/svera/untiered/ui/UIModule.as">
package svera.untiered.ui {
import com.company.assembleegameclient.account.ui.unboxing.UnboxResultBox;
import com.company.assembleegameclient.account.ui.unboxing.UnboxResultBoxMediator;
import com.company.assembleegameclient.mapeditor.MapEditor;
import com.company.assembleegameclient.screens.AccountScreen;
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;
import com.company.assembleegameclient.screens.LoadingScreen;
import com.company.assembleegameclient.screens.NewCharacterScreen;
import com.company.assembleegameclient.screens.NewsLine;
import com.company.assembleegameclient.screens.charrects.CharacterRectList;
import com.company.assembleegameclient.screens.charrects.CurrentCharacterRect;
import com.company.assembleegameclient.ui.dialogs.ErrorDialog;
import com.company.assembleegameclient.ui.menu.PlayerGroupMenu;
import com.company.assembleegameclient.ui.panels.InteractPanel;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.assembleegameclient.ui.panels.mediators.InteractPanelMediator;
import com.company.assembleegameclient.ui.panels.mediators.ItemGridMediator;

import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

import svera.lib.framework.IModule;

import svera.untiered.account.core.services.GetCharListTask;
import svera.untiered.account.core.services.LoadAccountTask;
import svera.untiered.account.core.view.AccountInfoMediator;
import svera.untiered.account.core.view.AccountInfoView;
import svera.untiered.account.core.view.RegisterPromptDialog;
import svera.untiered.account.core.view.RegisterPromptDialogMediator;
import svera.untiered.game.model.PotionInventoryModel;
import svera.untiered.startup.control.StartupSequence;
import svera.untiered.storage.VaultWindow;
import svera.untiered.storage.mediator.VaultWindowMediator;
import svera.untiered.storage.signals.VaultSlotUpdateSignal;
import svera.untiered.storage.signals.VaultUpdateSignal;
import svera.untiered.ui.commands.EnterGameCommand;
import svera.untiered.ui.commands.HUDInitCommand;
import svera.untiered.ui.commands.ShowLoadingUICommand;
import svera.untiered.ui.commands.ShowTitleUICommand;
import svera.untiered.ui.commands.ShowSplashUICommand;
import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.signals.EnterGameSignal;
import svera.untiered.ui.signals.HUDModelInitialized;
import svera.untiered.ui.signals.HUDSetupStarted;
import svera.untiered.ui.signals.NameChangedSignal;
import svera.untiered.ui.signals.ShowLoadingUISignal;
import svera.untiered.ui.signals.ShowTitleUISignal;
import svera.untiered.ui.signals.ShowSplashUISignal;
import svera.untiered.ui.signals.UpdateHUDSignal;
import svera.untiered.ui.signals.UpdatePotionInventorySignal;
import svera.untiered.ui.view.AccountScreenMediator;
import svera.untiered.ui.view.CharacterDetailsMediator;
import svera.untiered.ui.view.CharacterDetailsView;
import svera.untiered.ui.view.CharacterRectListMediator;
import svera.untiered.ui.view.CharacterSlotNeedTsavoriteDialog;
import svera.untiered.ui.view.CharacterSlotNeedTsavoriteMediator;
import svera.untiered.ui.view.CharacterSlotRegisterDialog;
import svera.untiered.ui.view.CharacterSlotRegisterMediator;
import svera.untiered.ui.view.ChooseNameRegisterDialog;
import svera.untiered.ui.view.ChooseNameRegisterMediator;
import svera.untiered.ui.view.CurrentCharacterMediator;
import svera.untiered.ui.view.CurrentCharacterRectMediator;
import svera.untiered.ui.view.ErrorDialogMediator;
import svera.untiered.ui.view.HUDMediator;
import svera.untiered.ui.view.HUDView;
import svera.untiered.ui.view.LoadingMediator;
import svera.untiered.ui.view.MapEditorMediator;
import svera.untiered.ui.view.MessageCloseDialog;
import svera.untiered.ui.view.MessageCloseMediator;
import svera.untiered.ui.view.NewCharacterMediator;
import svera.untiered.ui.view.NewsLineMediator;
import svera.untiered.ui.view.NotEnoughTsavoriteDialog;
import svera.untiered.ui.view.NotEnoughTsavoriteMediator;
import svera.untiered.ui.view.SplashMediator;
import svera.untiered.ui.view.SplashView;
import svera.untiered.ui.view.StatMetersMediator;
import svera.untiered.ui.view.StatMetersView;
import svera.untiered.ui.view.TitleMediator;
import svera.untiered.ui.view.TitleView;
import svera.untiered.ui.view.components.PotionSlotMediator;
import svera.untiered.ui.view.components.PotionSlotView;

public class UIModule implements IModule {

    public function UIModule() {
        super();
    }

    public function configure(context:AppContext):void {
        trace("[UIModule] Configuring...");
        context.injector.map(ShowSplashUISignal).asSingleton();
        context.injector.map(ShowLoadingUISignal).asSingleton();
        context.injector.map(ShowTitleUISignal).asSingleton();
        context.injector.map(EnterGameSignal).asSingleton();
        context.injector.map(HUDSetupStarted).asSingleton();
        context.injector.map(NameChangedSignal).asSingleton();
        context.injector.map(PotionInventoryModel).asSingleton();
        context.injector.map(UpdatePotionInventorySignal).asSingleton();
        context.injector.map(VaultUpdateSignal).asSingleton();
        context.injector.map(VaultSlotUpdateSignal).asSingleton();
        context.commands.map(ShowSplashUISignal).toCommand(ShowSplashUICommand);
        context.commands.map(ShowLoadingUISignal).toCommand(ShowLoadingUICommand);
        context.commands.map(ShowTitleUISignal).toCommand(ShowTitleUICommand);
        context.commands.map(EnterGameSignal).toCommand(EnterGameCommand);
        context.mediators.map(SplashView, SplashMediator);
        context.mediators.map(LoadingScreen, LoadingMediator);
        context.mediators.map(CharacterSelectionAndNewsScreen, CurrentCharacterMediator);
        context.mediators.map(AccountInfoView, AccountInfoMediator);
        context.mediators.map(AccountScreen, AccountScreenMediator);
        context.mediators.map(TitleView, TitleMediator);
        context.mediators.map(NewCharacterScreen, NewCharacterMediator);
        context.mediators.map(MapEditor, MapEditorMediator);
        context.mediators.map(CurrentCharacterRect, CurrentCharacterRectMediator);
        context.mediators.map(CharacterRectList, CharacterRectListMediator);
        context.mediators.map(ErrorDialog, ErrorDialogMediator);
        context.mediators.map(NewsLine, NewsLineMediator);
        context.mediators.map(NotEnoughTsavoriteDialog, NotEnoughTsavoriteMediator);
        context.mediators.map(MessageCloseDialog, MessageCloseMediator);
        context.mediators.map(InteractPanel, InteractPanelMediator);
        context.mediators.map(ItemGrid, ItemGridMediator);
        context.mediators.map(ChooseNameRegisterDialog, ChooseNameRegisterMediator);
        context.mediators.map(CharacterSlotRegisterDialog, CharacterSlotRegisterMediator);
        context.mediators.map(RegisterPromptDialog, RegisterPromptDialogMediator);
        context.mediators.map(CharacterSlotNeedTsavoriteDialog, CharacterSlotNeedTsavoriteMediator);
        context.mediators.map(PlayerGroupMenu, PlayerGroupMenuMediator);
        context.mediators.map(StatMetersView, StatMetersMediator);
        context.mediators.map(HUDView, HUDMediator);
        context.mediators.map(PotionSlotView, PotionSlotMediator);
        context.mediators.map(VaultWindow, VaultWindowMediator);
        context.mediators.map(UnboxResultBox, UnboxResultBoxMediator);

        this.setupCharacterWindow(context);
        var startup:StartupSequence = context.injector.getInstance(StartupSequence);
        //this.startup.addSignal(ShowLoadingUISignal, -1);
        startup.addTask(LoadAccountTask);
        startup.addTask(GetCharListTask);
        startup.addSignal(ShowTitleUISignal, StartupSequence.LAST);
    }

    private function setupCharacterWindow(context:AppContext):void {
        context.injector.map(HUDModel).asSingleton();
        context.injector.map(UpdateHUDSignal).asSingleton();
        context.injector.map(HUDModelInitialized).asSingleton();
        context.commands.map(HUDSetupStarted).toCommand(HUDInitCommand);
        context.mediators.map(CharacterDetailsView, CharacterDetailsMediator);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/components/CharSelectionBackground.as">
package svera.untiered.ui.view.components {
import mx.core.BitmapAsset;

[Embed(source="CharSelectionBackground.png")]
public class CharSelectionBackground extends BitmapAsset {
    public function CharSelectionBackground() {
        super();

    }
}
}
</file>

<file path="src/svera/untiered/ui/view/components/DefaultBackground.as">
package svera.untiered.ui.view.components {
import mx.core.BitmapAsset;

[Embed(source="DefaultBackground.png")]
public class DefaultBackground extends BitmapAsset {
    public function DefaultBackground() {
        super();

    }
}
}
</file>

<file path="src/svera/untiered/ui/view/components/HomescreenBackground.as">
package svera.untiered.ui.view.components {
import mx.core.BitmapAsset;

[Embed(source="HomescreenBackground.png")]
public class HomescreenBackground extends BitmapAsset {
    public function HomescreenBackground() {
        super();

    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/MarketInput.as">
package com.company.assembleegameclient.account.ui
{
import com.company.ui.SimpleText;
import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

public class MarketInput extends Sprite
{
    public static const HEIGHT:int = 88;

    public var nameText_:SimpleText;

    public var inputText_:SimpleText;

    public var errorText_:SimpleText;

    public function MarketInput(name:String, isPassword:Boolean, error:String)
    {
        super();
        this.nameText_ = new SimpleText(18,11776947,false,0,0);
        this.nameText_.setBold(true);
        this.nameText_.text = name;
        this.nameText_.updateMetrics();
        this.nameText_.filters = [new DropShadowFilter(0,0,0)];
        addChild(this.nameText_);
        this.inputText_ = new SimpleText(20,11776947,true,238,30);
        this.inputText_.y = 30;
        this.inputText_.x = 6;
        this.inputText_.border = false;
        this.inputText_.displayAsPassword = isPassword;
        this.inputText_.updateMetrics();
        addChild(this.inputText_);
        graphics.lineStyle(2,4539717,1,false,LineScaleMode.NORMAL,CapsStyle.ROUND,JointStyle.ROUND);
        graphics.beginFill(3355443,1);
        graphics.drawRect(0,this.inputText_.y,238,30);
        graphics.endFill();
        graphics.lineStyle();
        this.inputText_.addEventListener(Event.CHANGE,this.onInputChange);
        this.errorText_ = new SimpleText(12,16549442,false,0,0);
        this.errorText_.y = this.inputText_.y + 32;
        this.errorText_.text = error;
        this.errorText_.updateMetrics();
        this.errorText_.filters = [new DropShadowFilter(0,0,0)];
        addChild(this.errorText_);
    }

    public function text() : String
    {
        return this.inputText_.text;
    }

    public function setError(error:String) : void
    {
        this.errorText_.text = error;
        this.errorText_.updateMetrics();
    }

    public function onInputChange(event:Event) : void
    {
        this.setError("");
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/EmbedMysteryInv.as">
/**
 * Created by club5_000 on 1/21/2016.
 */
package com.company.assembleegameclient.account.ui.unboxing {
import mx.core.BitmapAsset;

[Embed(source="MysteryInv.png")]
public class EmbedMysteryInv extends BitmapAsset {
    public function EmbedMysteryInv() {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/EmbedUnboxSquare.as">
/**
 * Created by club5_000 on 1/21/2016.
 */
package com.company.assembleegameclient.account.ui.unboxing {
import mx.core.BitmapAsset;

[Embed(source="UnboxSquare.png")]
public class EmbedUnboxSquare extends BitmapAsset {
    public function EmbedUnboxSquare() {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/UnboxResultBoxMediator.as">
package com.company.assembleegameclient.account.ui.unboxing
{
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.sound.SoundEffectLibrary;


import svera.lib.framework.Mediator;

import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class UnboxResultBoxMediator extends Mediator
{

    [Inject]
    public var view:UnboxResultBox;
    [Inject]
    public var closeDialogs:CloseDialogsSignal;
    [Inject]
    private var gameSprite:GameSprite;
    [Inject]
    public var unboxScroll:UnboxScroll;
    [Inject]
    public var openDialog:OpenDialogSignal;

    override public function initialize():void
    {
        this.gameSprite = this.view.gameSprite;
        this.unboxScroll = this.view.unboxScroll_;
        this.view.cancel.add(this.onCancel);
        this.view.hideInventory.add(this.onHideInventory);
        this.view.completed.add(this.onCompleted)
    }

    override public function destroy():void
    {
        this.view.cancel.remove(this.onCancel);
        this.view.hideInventory.remove(this.onHideInventory);
        this.view.completed.remove(this.onCompleted);
    }
    private function onCompleted():void{
        SoundEffectLibrary.play("enter_realm");
        this.closeDialogs.dispatch()
        this.openDialog.dispatch(new ItemResultBox(this.gameSprite, unboxScroll.itemTypes_[45]));
    }

    private function onHideInventory():void{
        //this.hideMInventory.dispatch();
    }



    private function onCancel():void
    {
        this.closeDialogs.dispatch();
    }


}
}//package com.company.assembleegameclient.account.ui.Unboxing
</file>

<file path="src/com/company/assembleegameclient/constants/InventoryOwnerTypes.as">
package com.company.assembleegameclient.constants {
public class InventoryOwnerTypes {

    public static const CURRENT_PLAYER:String = "CURRENT_PLAYER";

    public static const OTHER_PLAYER:String = "OTHER_PLAYER";

    public static const NPC:String = "NPC";


    public function InventoryOwnerTypes() {
        super();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/editor/Command.as">
package com.company.assembleegameclient.editor {
public class Command {


    public function Command() {
        super();
    }

    public function execute():void {
    }

    public function unexecute():void {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/editor/CommandList.as">
package com.company.assembleegameclient.editor {
public class CommandList {


    private var list_:Vector.<Command>;

    public function CommandList() {
        this.list_ = new Vector.<Command>();
        super();
    }

    public function empty():Boolean {
        return this.list_.length == 0;
    }

    public function addCommand(command:Command):void {
        this.list_.push(command);
    }

    public function execute():void {
        var command:Command = null;
        for each(command in this.list_) {
            command.execute();
        }
    }

    public function unexecute():void {
        var command:Command = null;
        for each(command in this.list_) {
            command.unexecute();
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/editor/CommandQueue.as">
package com.company.assembleegameclient.editor {
public class CommandQueue {


    private var list_:Vector.<CommandList>;

    private var currPos:int = 0;

    public function CommandQueue() {
        this.list_ = new Vector.<CommandList>();
        super();
    }

    public function addCommandList(commandList:CommandList):void {
        this.list_.length = this.currPos;
        commandList.execute();
        this.list_.push(commandList);
        this.currPos++;
    }

    public function undo():void {
        if (this.currPos == 0) {
            return;
        }
        this.list_[--this.currPos].unexecute();
    }

    public function redo():void {
        if (this.currPos == this.list_.length) {
            return;
        }
        this.list_[this.currPos++].execute();
    }

    public function clear():void {
        this.currPos = 0;
        this.list_.length = 0;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/animation/AnimationData.as">
package com.company.assembleegameclient.objects.animation {
public class AnimationData {


    public var prob_:Number = 1.0;

    public var period_:int;

    public var periodJitter_:int;

    public var sync_:Boolean = false;

    public var frames:Vector.<FrameData>;

    public function AnimationData(xml:XML) {
        var frameXML:XML = null;
        this.frames = new Vector.<FrameData>();
        super();
        if ("@prob" in xml) {
            this.prob_ = Number(xml.@prob);
        }
        this.period_ = int(Number(xml.@period) * 1000);
        this.periodJitter_ = int(Number(xml.@periodJitter) * 1000);
        this.sync_ = String(xml.@sync) == "true";
        for each(frameXML in xml.Frame) {
            this.frames.push(new FrameData(frameXML));
        }
    }

    private function getPeriod():int {
        if (this.periodJitter_ == 0) {
            return this.period_;
        }
        return this.period_ - this.periodJitter_ + 2 * Math.random() * this.periodJitter_;
    }

    public function getLastRun(time:int):int {
        if (this.sync_) {
            return int(time / this.period_) * this.period_;
        }
        return time + this.getPeriod() + 200 * Math.random();
    }

    public function getNextRun(time:int):int {
        if (this.sync_) {
            return int(time / this.period_) * this.period_ + this.period_;
        }
        return time + this.getPeriod();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/animation/AnimationsData.as">
package com.company.assembleegameclient.objects.animation {
public class AnimationsData {


    public var animations:Vector.<AnimationData>;

    public function AnimationsData(xml:XML) {
        var animationXML:XML = null;
        this.animations = new Vector.<AnimationData>();
        super();
        for each(animationXML in xml.Animation) {
            this.animations.push(new AnimationData(animationXML));
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Character.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.objects.particles.ExplosionEffect;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.util.BloodComposition;

public class Character extends GameObject {


    public var hurtSound_:String;

    public var deathSound_:String;

    public function Character(objectXML:XML) {
        super(objectXML);
        this.hurtSound_ = Boolean(objectXML.hasOwnProperty("HitSound")) ? String(objectXML.HitSound) : "monster/default_hit";
        SoundEffectLibrary.load(this.hurtSound_);
        this.deathSound_ = Boolean(objectXML.hasOwnProperty("DeathSound")) ? String(objectXML.DeathSound) : "monster/default_death";
        SoundEffectLibrary.load(this.deathSound_);
    }

    override public function damage(damageAmount:int, effects:Vector.<uint>, proj:Projectile):void {
        super.damage(damageAmount, effects, proj);
        SoundEffectLibrary.play(this.hurtSound_);
    }

    public function explode():void {
        if (Parameters.data_.particles) {
            var colors:Vector.<uint> = BloodComposition.getBloodComposition(this.objectType_, this.texture_, this.props_.bloodProb_, this.props_.bloodColor_);
            map_.addObj(new ExplosionEffect(colors, this.size_, 30), x_, y_);
        }
        SoundEffectLibrary.play(this.deathSound_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ClosedGiftChest.as">
package com.company.assembleegameclient.objects {
public class ClosedGiftChest extends GameObject {
    public function ClosedGiftChest(objectXML:XML) {
        super(objectXML);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/MarketObject.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.Panel;

import svera.untiered.memMarket.MemMarketPanel;

public class MarketObject extends GameObject implements IInteractiveObject {

    public function MarketObject(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new MemMarketPanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/EffectProperties.as">
package com.company.assembleegameclient.objects.particles {
public class EffectProperties {


    public var id:String;

    public var particle:String;

    public var cooldown:Number;

    public var color:uint;

    public var rate:Number;

    public var speed:Number;

    public var speedVariance:Number;

    public var spread:Number;

    public var life:Number;

    public var lifeVariance:Number;

    public var size:int;

    public var friction:Number;

    public var rise:Number;

    public var riseVariance:Number;

    public var riseAcc:Number;

    public var rangeX:int;

    public var rangeY:int;

    public var zOffset:Number;

    public var bitmapFile:String;

    public var bitmapIndex:uint;

    public function EffectProperties(effectXML:XML) {
        super();
        this.id = effectXML.toString();
        this.particle = effectXML.@particle;
        this.cooldown = effectXML.@cooldown;
        this.color = effectXML.@color;
        this.rate = Number(effectXML.@rate) || Number(5);
        this.speed = Number(effectXML.@speed) || Number(0);
        this.speedVariance = Number(effectXML.@speedVariance) || Number(0.5);
        this.spread = Number(effectXML.@spread) || Number(0);
        this.life = Number(effectXML.@life) || Number(1);
        this.lifeVariance = Number(effectXML.@lifeVariance) || Number(0);
        this.size = int(effectXML.@size) || int(3);
        this.rise = Number(effectXML.@rise) || Number(3);
        this.riseVariance = Number(effectXML.@riseVariance) || Number(0);
        this.riseAcc = Number(effectXML.@riseAcc) || Number(0);
        this.rangeX = int(effectXML.@rangeX) || int(0);
        this.rangeY = int(effectXML.@rangeY) || int(0);
        this.zOffset = Number(effectXML.@zOffset) || Number(0);
        this.bitmapFile = effectXML.@bitmapFile;
        this.bitmapIndex = effectXML.@bitmapIndex;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/GasParticle.as">
package com.company.assembleegameclient.objects.particles {
public class GasParticle extends SparkParticle {


    private var noise:Number;

    public function GasParticle(size:int, color:int, lifetime:int, noise:Number, z:Number, dx:Number, dy:Number) {
        this.noise = noise;
        super(size, color, lifetime, z, dx, dy);
    }

    override public function update(time:int, dt:int):Boolean {
        var varY:Number = NaN;
        timeLeft_ = timeLeft_ - dt;
        if (timeLeft_ <= 0) {
            return false;
        }
        if (square_.obj_ && square_.obj_.props_.static_) {
            return false;
        }
        var varX:Number = Math.random() * this.noise;
        varY = Math.random() * this.noise;
        x_ = x_ + dx_ * varX * dt / 1000;
        y_ = y_ + dy_ * varY * dt / 1000;
        setSize(timeLeft_ / lifetime_ * initialSize_);
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ParticleLibrary.as">
package com.company.assembleegameclient.objects.particles {
public class ParticleLibrary {

    public static const propsLibrary_:Object = {};


    public function ParticleLibrary() {
        super();
    }

    public static function parseFromXML(xml:XML):void {
        var particleXML:XML = null;
        for each(particleXML in xml.Particle) {
            propsLibrary_[particleXML.@id] = new ParticleProperties(particleXML);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/SparkParticle.as">
package com.company.assembleegameclient.objects.particles {
public class SparkParticle extends Particle {


    public var lifetime_:int;

    public var timeLeft_:int;

    public var initialSize_:int;

    public var dx_:Number;

    public var dy_:Number;

    public function SparkParticle(size:int, color:int, lifetime:int, z:Number, dx:Number, dy:Number) {
        super(color, z, size);
        this.initialSize_ = size;
        this.lifetime_ = this.timeLeft_ = lifetime;
        this.dx_ = dx;
        this.dy_ = dy;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        x_ = x_ + this.dx_ * dt / 1000;
        y_ = y_ + this.dy_ * dt / 1000;
        setSize(this.timeLeft_ / this.lifetime_ * this.initialSize_);
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Traits.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.panels.TraitsPanel;

public class Traits extends GameObject implements IInteractiveObject {
    public function Traits(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new TraitsPanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/sound/Music.as">
package com.company.assembleegameclient.sound {
import com.company.assembleegameclient.parameters.Parameters;

public class Music {
    public static const MENU_MUSIC:String = "waterfall";
    public static const DEATH_MUSIC:String = "good_night";

    private static var musicName_:String = "";

    private static var song:Song = null;


    public function Music() {
        super();
    }

    public static function load(name:String):void {
        if (musicName_ == name) {
            return;
        }
        musicName_ = name;

        if (Parameters.data_.playMusic) {
            transitionNewMusic();
        }
    }

    private static function transitionNewMusic():void {
        if (song) {
            song.stop();
        }
        if (musicName_ == null || musicName_ == "") {
            return;
        }
        song = new Song(musicName_);
        song.play();
    }

    public static function setPlayMusic(play:Boolean):void {
        Parameters.data_.playMusic = play;
        Parameters.save();
        if (play) {
            transitionNewMusic();
        } else if (song) {
            song.stop(true);
            song = null;
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/sound/Song.as">
package com.company.assembleegameclient.sound {
import com.company.assembleegameclient.parameters.Parameters;
import com.gskinner.motion.GTween;

import flash.media.Sound;
import flash.media.SoundChannel;
import flash.media.SoundTransform;
import flash.net.URLRequest;

public class Song {

    private var sound:Sound;
    private var transform:SoundTransform;
    private var channel:SoundChannel;
    private var tween:GTween;


    public function Song(name:String) {
        sound = new Sound();
        sound.load(new URLRequest(Parameters.appServerAddress() + "/music/" + name + ".mp3"));
        transform = new SoundTransform(0);
        tween = new GTween(transform);
        tween.onChange = updateTransform;
    }

    public function play(volume:Number = 1.0, fadeTime:Number = 2, loops:int = int.MAX_VALUE):void {
        if (channel) {
            channel.stop();
        }
        tween.duration = fadeTime;
        tween.setValue("volume", volume);
        channel = sound.play(0, loops, transform);
    }

    public function stop(noFade:Boolean = false):void {
        if (channel) {
            tween.onComplete = stopChannel;
            tween.setValue("volume", 0);
            if (noFade) {
                transform.volume = 0;
            }
        }
    }

    public function get volume():Number {
        return transform.volume;
    }

    public function set volume(volume:Number):void {
        transform.volume = volume;
        tween.setValue("volume", volume);
    }

    private function updateTransform(tween:GTween = null):void {
        if (channel) {
            channel.soundTransform = transform;
        }
    }

    private function stopChannel(tween:GTween):void {
        channel.stop();
        channel = null;
    }


}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/TraitsPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Player;

import flash.events.MouseEvent;

import svera.untiered.traits.TraitsGUI;

public class TraitsPanel extends ButtonPanel {
    public function TraitsPanel(gs:GameSprite) {
        super(gs, "Traits", "View");
    }

    override protected function onButtonClick(event:MouseEvent):void {
        var p:Player = gs_.map.player_;
        if (p == null) {
            return;
        }
        gs_.addChild(new TraitsGUI());
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/RandomUtil.as">
package com.company.assembleegameclient.util {
public class RandomUtil {


    public function RandomUtil() {
        super();
    }

    public static function plusMinus(range:Number):Number {
        return Math.random() * range * 2 - range;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/TimeUtil.as">
package com.company.assembleegameclient.util {
public class TimeUtil {

    public static const DAY_IN_MS:int = 86400000;

    public static const DAY_IN_S:int = 86400;


    public function TimeUtil() {
        super();
    }

    public static function secondsToDays(time:Number):Number {
        return time / DAY_IN_S;
    }
}
}
</file>

<file path="src/com/company/ui/fonts/MyriadProBoldCFF.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.ui.fonts {
import mx.core.*;

[Embed(source="MyriadProBold.otf", fontName="MyriadProBoldCFF", fontFamily="MyriadPro", fontStyle="Bold", fontWeight="bold", embedAsCFF="true", mimeType="application/x-font")]
public class MyriadProBoldCFF extends FontAsset {
    public function MyriadProBoldCFF() {
        super();

    }
}
}//package svera.untiered.text.model
</file>

<file path="src/com/company/ui/fonts/MyriadProCFF.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.ui.fonts {
import mx.core.*;

[Embed(source="MyriadPro.otf", fontName="MyriadProCFF", fontFamily="MyriadPro", fontStyle="Regular", embedAsCFF="true", mimeType="application/x-font")]
public class MyriadProCFF extends FontAsset {
    public function MyriadProCFF() {
        super();

    }
}
}//package svera.untiered.text.model
</file>

<file path="src/com/company/untiered/graphics/HonorIconBackgroundDesign.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.untiered.graphics {
import flash.display.MovieClip;

[Embed(source="HonorIconBackgroundDesign.swf", symbol="com.company.rotmg.graphics.FameIconBackgroundDesign")]
public dynamic class HonorIconBackgroundDesign extends MovieClip {
    public function HonorIconBackgroundDesign() {
        super();
    }
}
}//package com.company.rotmg.graphics
</file>

<file path="src/com/company/untiered/graphics/LockedCharBoxGraphic.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.untiered.graphics {
import flash.display.MovieClip;

[Embed(source="LockedCharBoxGraphic.swf", symbol="com.company.rotmg.graphics.LockedCharBoxGraphic")]
public dynamic class LockedCharBoxGraphic extends MovieClip {
    public function LockedCharBoxGraphic() {
        super();
    }
}
}//package com.company.rotmg.graphics
</file>

<file path="src/com/company/untiered/graphics/StarGraphic.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.untiered.graphics {
import flash.display.MovieClip;

[Embed(source="StarGraphic.swf", symbol="com.company.rotmg.graphics.StarGraphic")]
public dynamic class StarGraphic extends MovieClip {
    public function StarGraphic() {
        super();
    }
}
}//package com.company.rotmg.graphics
</file>

<file path="src/com/company/util/ArrayIterator.as">
package com.company.util {
public class ArrayIterator implements IIterator {


    private var objects_:Array;

    private var index_:int;

    public function ArrayIterator(objects:Array) {
        super();
        this.objects_ = objects;
        this.index_ = 0;
    }

    public function reset():void {
        this.index_ = 0;
    }

    public function next():Object {
        return this.objects_[this.index_++];
    }

    public function hasNext():Boolean {
        return this.index_ < this.objects_.length;
    }
}
}
</file>

<file path="src/com/company/util/DateFormatterReplacement.as">
package com.company.util {
public class DateFormatterReplacement {

    private const months:Array = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];

    public var formatString:String;


    public function format(date:Date):String {
        var ret:String = this.formatString;
        ret = ret.replace("D", date.date);
        ret = ret.replace("YYYY", date.fullYear);
        return ret.replace("MMMM", this.months[date.month]);
    }


}
}//package com.company.util
</file>

<file path="src/com/company/util/Extents2D.as">
package com.company.util {
public class Extents2D {


    public var minX_:Number;

    public var minY_:Number;

    public var maxX_:Number;

    public var maxY_:Number;

    public function Extents2D() {
        super();
        this.clear();
    }

    public function add(x:Number, y:Number):void {
        if (x < this.minX_) {
            this.minX_ = x;
        }
        if (y < this.minY_) {
            this.minY_ = y;
        }
        if (x > this.maxX_) {
            this.maxX_ = x;
        }
        if (y > this.maxY_) {
            this.maxY_ = y;
        }
    }

    public function clear():void {
        this.minX_ = Number.MAX_VALUE;
        this.minY_ = Number.MAX_VALUE;
        this.maxX_ = Number.MIN_VALUE;
        this.maxY_ = Number.MIN_VALUE;
    }

    public function toString():String {
        return "min:(" + this.minX_ + ", " + this.minY_ + ") max:(" + this.maxX_ + ", " + this.maxY_ + ")";
    }
}
}
</file>

<file path="src/com/company/util/IIterator.as">
package com.company.util {
public interface IIterator {


    function reset():void;

    function next():Object;

    function hasNext():Boolean;
}
}
</file>

<file path="src/com/company/util/KeyCodes.as">
package com.company.util {
public class KeyCodes {

    public static const A:uint = 65;

    public static const ALTERNATE:uint = 18;

    public static const B:uint = 66;

    public static const BACKQUOTE:uint = 192;

    public static const BACKSLASH:uint = 220;

    public static const BACKSPACE:uint = 8;

    public static const C:uint = 67;

    public static const CAPS_LOCK:uint = 20;

    public static const COMMA:uint = 188;

    public static const COMMAND:uint = 15;

    public static const CONTROL:uint = 17;

    public static const D:uint = 68;

    public static const DELETE:uint = 46;

    public static const DOWN:uint = 40;

    public static const E:uint = 69;

    public static const END:uint = 35;

    public static const ENTER:uint = 13;

    public static const EQUAL:uint = 187;

    public static const ESCAPE:uint = 27;

    public static const F:uint = 70;

    public static const F1:uint = 112;

    public static const F10:uint = 121;

    public static const F11:uint = 122;

    public static const F12:uint = 123;

    public static const F13:uint = 124;

    public static const F14:uint = 125;

    public static const F15:uint = 126;

    public static const F2:uint = 113;

    public static const F3:uint = 114;

    public static const F4:uint = 115;

    public static const F5:uint = 116;

    public static const F6:uint = 117;

    public static const F7:uint = 118;

    public static const F8:uint = 119;

    public static const F9:uint = 120;

    public static const G:uint = 71;

    public static const H:uint = 72;

    public static const HOME:uint = 36;

    public static const I:uint = 73;

    public static const INSERT:uint = 45;

    public static const J:uint = 74;

    public static const K:uint = 75;

    public static const L:uint = 76;

    public static const LEFT:uint = 37;

    public static const LEFTBRACKET:uint = 219;

    public static const M:uint = 77;

    public static const MINUS:uint = 189;

    public static const N:uint = 78;

    public static const NUMBER_0:uint = 48;

    public static const NUMBER_1:uint = 49;

    public static const NUMBER_2:uint = 50;

    public static const NUMBER_3:uint = 51;

    public static const NUMBER_4:uint = 52;

    public static const NUMBER_5:uint = 53;

    public static const NUMBER_6:uint = 54;

    public static const NUMBER_7:uint = 55;

    public static const NUMBER_8:uint = 56;

    public static const NUMBER_9:uint = 57;

    public static const NUMLOCK:uint = 144;

    public static const NUMPAD:uint = 21;

    public static const NUMPAD_0:uint = 96;

    public static const NUMPAD_1:uint = 97;

    public static const NUMPAD_2:uint = 98;

    public static const NUMPAD_3:uint = 99;

    public static const NUMPAD_4:uint = 100;

    public static const NUMPAD_5:uint = 101;

    public static const NUMPAD_6:uint = 102;

    public static const NUMPAD_7:uint = 103;

    public static const NUMPAD_8:uint = 104;

    public static const NUMPAD_9:uint = 105;

    public static const NUMPAD_ADD:uint = 107;

    public static const NUMPAD_DECIMAL:uint = 110;

    public static const NUMPAD_DIVIDE:uint = 111;

    public static const NUMPAD_ENTER:uint = 108;

    public static const NUMPAD_MULTIPLY:uint = 106;

    public static const NUMPAD_SUBTRACT:uint = 109;

    public static const O:uint = 79;

    public static const P:uint = 80;

    public static const PAGE_DOWN:uint = 34;

    public static const PAGE_UP:uint = 33;

    public static const PAUSE:uint = 19;

    public static const PERIOD:uint = 190;

    public static const Q:uint = 81;

    public static const QUOTE:uint = 222;

    public static const R:uint = 82;

    public static const RIGHT:uint = 39;

    public static const RIGHTBRACKET:uint = 221;

    public static const S:uint = 83;

    public static const SCROLLLOCK:uint = 145;

    public static const SEMICOLON:uint = 186;

    public static const SHIFT:uint = 16;

    public static const SLASH:uint = 191;

    public static const SPACE:uint = 32;

    public static const T:uint = 84;

    public static const TAB:uint = 9;

    public static const U:uint = 85;

    public static const UP:uint = 38;

    public static const V:uint = 86;

    public static const W:uint = 87;

    public static const X:uint = 88;

    public static const Y:uint = 89;

    public static const Z:uint = 90;

    public static const UNSET:uint = 0;

    public static const CharCodeStrings:Array = ["[Unset]", "", "", "", "", "", "", "", "Backspace", "Tab", "", "", "Clear", "Enter", "", "Cmd", "Shift", "Ctrl", "Alt", "Pause", "CapsLock", "", "", "", "", "", "", "Esc", "", "", "", "", "Space", "PgUp", "PgDn", "End", "Home", "Left", "Up", "Right", "Down", "", "", "", "", "Insert", "Delete", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "", "Win", "Menu", "", "", "Numpad 0", "Numpad 1", "Numpad 2", "Numpad 3", "Numpad 4", "Numpad 5", "Numpad 6", "Numpad 7", "Numpad 8", "Numpad 9", "Numpad *", "Numpad +", "Numpad Enter", "Numpad -", "Numpad .", "Numpad /", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "NumLock", "ScrLock", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ";", "=", ",", "-", ".", "/", "`", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[", "\\", "]", "\'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];


    public function KeyCodes() {
        super();
    }
}
}
</file>

<file path="src/com/company/util/MoreDateUtil.as">
package com.company.util {

public class MoreDateUtil {


    public function MoreDateUtil() {
        super();
    }

    public static function getDayStringInPT():String {
        var date:Date = new Date();
        var num:Number = date.getTime();
        num = num + (date.timezoneOffset - 420) * 60 * 1000;
        date.setTime(num);
        var df:DateFormatterReplacement = new DateFormatterReplacement();
        df.formatString = "MMMM D, YYYY";
        return df.format(date);
    }
}
}
</file>

<file path="src/com/company/util/MoreObjectUtil.as">
package com.company.util {
public class MoreObjectUtil {


    public function MoreObjectUtil() {
        super();
    }

    public static function addToObject(dest:Object, source:Object):void {
        var key:* = null;
        for (key in source) {
            dest[key] = source[key];
        }
    }
}
}
</file>

<file path="src/svera/lib/json/JsonParser.as">
package svera.lib.json {
public interface JsonParser {


    function stringify(param1:Object):String;

    function parse(param1:String):Object;
}
}
</file>

<file path="src/svera/lib/loopedprocs/LoopedCallback.as">
package svera.lib.loopedprocs {
public class LoopedCallback extends LoopedProcess {


    public var callback:Function;

    public var parameters:Array;

    public function LoopedCallback(runInterval:int, callbackFunc:Function, ...params) {
        super(runInterval);
        this.callback = callbackFunc;
        this.parameters = params;
    }

    override protected function run():void {
        this.callback.apply(this.parameters);
    }

    override protected function onDestroyed():void {
        this.callback = null;
        this.parameters = null;
    }
}
}
</file>

<file path="src/svera/lib/net/api/MessageHandlerProxy.as">
package svera.lib.net.api {
public interface MessageHandlerProxy {


    function getMethod():Function;
}
}
</file>

<file path="src/svera/lib/net/api/MessageMap.as">
package svera.lib.net.api {
public interface MessageMap {


    function map(param1:int):MessageMapping;

    function unmap(param1:int):void;
}
}
</file>

<file path="src/svera/lib/net/impl/MessagePool.as">
package svera.lib.net.impl {
public class MessagePool {


    public var type:Class;

    public var callback:Function;

    public var id:int;

    private var tail:Message;

    private var count:int = 0;

    public function MessagePool(id:int, type:Class, callback:Function) {
        super();
        this.type = type;
        this.id = id;
        this.callback = callback;
    }

    public function populate(count:int):MessagePool {
        var message:Message = null;
        this.count = this.count + count;
        while (count--) {
            message = new this.type(this.id, this.callback);
            message.pool = this;
            this.tail && (this.tail.next = message);
            message.prev = this.tail;
            this.tail = message;
        }
        return this;
    }

    public function require():Message {
        var message:Message = this.tail;
        if (message) {
            this.tail = this.tail.prev;
            message.prev = null;
            message.next = null;
        } else {
            message = new this.type(this.id, this.callback);
            message.pool = this;
            this.count++;
        }
        return message;
    }

    public function getCount():int {
        return this.count;
    }

    public function append(message:Message):void {
        this.tail && (this.tail.next = message);
        message.prev = this.tail;
        this.tail = message;
    }

    public function dispose():void {
        this.tail = null;
    }
}
}
</file>

<file path="src/svera/lib/tasks/BranchingTask.as">
package svera.lib.tasks {
public class BranchingTask extends BaseTask {


    private var task:Task;

    private var success:Task;

    private var failure:Task;

    public function BranchingTask(task:Task, success:Task = null, failure:Task = null) {
        super();
        this.task = task;
        this.success = success;
        this.failure = failure;
    }

    public function addSuccessTask(task:Task):void {
        this.success = task;
    }

    public function addFailureTask(task:Task):void {
        this.failure = task;
    }

    override protected function startTask():void {
        this.task.finished.addOnce(this.onTaskFinished);
        this.task.start();
    }

    private function onTaskFinished(task:Task, isOK:Boolean, error:String = ""):void {
        if (isOK) {
            this.handleBranchTask(this.success);
        } else {
            this.handleBranchTask(this.failure);
        }
    }

    private function handleBranchTask(task:Task):void {
        if (task) {
            task.finished.addOnce(this.onBranchComplete);
            task.start();
        } else {
            completeTask(true);
        }
    }

    private function onBranchComplete(task:Task, isOK:Boolean, error:String = ""):void {
        completeTask(isOK, error);
    }
}
}
</file>

<file path="src/svera/lib/tasks/TaskGroup.as">
package svera.lib.tasks {
public class TaskGroup extends BaseTask {


    private var tasks:Vector.<BaseTask>;

    private var pending:int;

    public function TaskGroup() {
        super();
        this.tasks = new Vector.<BaseTask>();
    }

    public function add(task:BaseTask):void {
        this.tasks.push(task);
    }

    override protected function startTask():void {
        this.pending = this.tasks.length;
        if (this.pending > 0) {
            this.startAllTasks();
        } else {
            completeTask(true);
        }
    }

    override protected function onReset():void {
        var task:BaseTask = null;
        for each(task in this.tasks) {
            task.reset();
        }
    }

    private function startAllTasks():void {
        var i:int = this.pending;
        while (i--) {
            this.tasks[i].lastly.addOnce(this.onTaskFinished);
            this.tasks[i].start();
        }
    }

    private function onTaskFinished(task:BaseTask, isOK:Boolean, error:String):void {
        if (isOK) {
            if (--this.pending == 0) {
                completeTask(true);
            }
        } else {
            completeTask(false, error);
        }
    }

    public function toString():String {
        return "[TaskGroup(" + this.tasks.join(",") + ")]";
    }
}
}
</file>

<file path="src/svera/lib/tasks/TaskMonitor.as">
package svera.lib.tasks {
public class TaskMonitor {


    private var tasks:Vector.<Task>;

    public function TaskMonitor() {
        super();
        this.tasks = new Vector.<Task>(0);
    }

    public function add(task:Task):void {
        this.tasks.push(task);
        task.finished.addOnce(this.onTaskFinished);
    }

    public function has(task:Task):Boolean {
        return this.tasks.indexOf(task) != -1;
    }

    private function onTaskFinished(task:Task, isOK:Boolean, error:String = ""):void {
        this.tasks.splice(this.tasks.indexOf(task), 1);
    }
}
}
</file>

<file path="src/svera/lib/tasks/TaskSequence.as">
package svera.lib.tasks {
public class TaskSequence extends BaseTask {


    private var tasks:Vector.<Task>;

    private var index:int;

    private var continueOnFail:Boolean;

    public function TaskSequence() {
        super();
        this.tasks = new Vector.<Task>();
    }

    public function getContinueOnFail():Boolean {
        return this.continueOnFail;
    }

    public function setContinueOnFail(value:Boolean):void {
        this.continueOnFail = value;
    }

    public function add(task:Task):void {
        this.tasks.push(task);
    }

    override protected function startTask():void {
        this.index = 0;
        this.doNextTaskOrComplete();
    }

    override protected function onReset():void {
        var task:Task = null;
        for each(task in this.tasks) {
            task.reset();
        }
    }

    private function doNextTaskOrComplete():void {
        if (this.isAnotherTask()) {
            this.doNextTask();
        } else {
            completeTask(true);
        }
    }

    private function isAnotherTask():Boolean {
        return this.index < this.tasks.length;
    }

    private function doNextTask():void {
        var task:Task = this.tasks[this.index++];
        task.lastly.addOnce(this.onTaskFinished);
        task.start();
    }

    private function onTaskFinished(task:Task, isOK:Boolean, error:String):void {
        if (isOK || this.continueOnFail) {
            this.doNextTaskOrComplete();
        } else {
            completeTask(false, error);
        }
    }
}
}
</file>

<file path="src/svera/lib/ui/api/Size.as">
package svera.lib.ui.api {
public class Size {


    public var width:int;

    public var height:int;

    public function Size(width:int = 0, height:int = 0) {
        super();
        this.width = width;
        this.height = height;
    }
}
}
</file>

<file path="src/svera/lib/util/DateValidator.as">
package svera.lib.util {
public class DateValidator {

    private static const DAYS_IN_MONTH:Vector.<int> = Vector.<int>([31, -1, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]);

    private static const FEBRUARY:int = 2;


    private var thisYear:int;

    public function DateValidator() {
        super();
        this.thisYear = new Date().getFullYear();
    }

    public function isValidMonth(value:int):Boolean {
        return value > 0 && value <= 12;
    }

    public function isValidDay(value:int, givenMonth:int = -1, givenYear:int = -1):Boolean {
        return value > 0 && value <= this.getDaysInMonth(givenMonth, givenYear);
    }

    public function getDaysInMonth(givenMonth:int = -1, givenYear:int = -1):int {
        if (givenMonth == -1) {
            return 31;
        }
        return givenMonth == FEBRUARY ? int(this.getDaysInFebruary(givenYear)) : int(DAYS_IN_MONTH[givenMonth - 1]);
    }

    private function getDaysInFebruary(givenYear:int):int {
        if (givenYear == -1 || this.isLeapYear(givenYear)) {
            return 29;
        }
        return 28;
    }

    public function isLeapYear(givenYear:int):Boolean {
        var isDivisibleBy4:Boolean = givenYear % 4 == 0;
        var isDivisibleBy100:Boolean = givenYear % 100 == 0;
        var isDivisibleBy400:Boolean = givenYear % 400 == 0;
        return isDivisibleBy4 && (!isDivisibleBy100 || isDivisibleBy400);
    }

    public function isValidDate(month:int, day:int, year:int, maxYearsAgo:int):Boolean {
        return this.isValidYear(year, maxYearsAgo) && this.isValidMonth(month) && this.isValidDay(day, month, year);
    }

    public function isValidYear(year:int, maxYearsAgo:int):Boolean {
        return year <= this.thisYear && year > this.thisYear - maxYearsAgo;
    }
}
}
</file>

<file path="src/svera/lib/util/GIF.as">
package svera.lib.util {
import flash.display.Bitmap;
import flash.display.Sprite;
import flash.utils.clearInterval;
import flash.utils.setInterval;

import mx.core.BitmapAsset;

public class GIF extends Sprite {
    public function GIF(frameDelay:int, frames:Vector.<BitmapAsset>) {
        this._frameDelay = frameDelay;
        this._frames = frames;

        this._currentFrame = 0;
        this._maxFrames = frames.length;
        this._isPlaying = false;

        this._bitmap = new Bitmap();
        this._bitmap.bitmapData = frames[0].bitmapData;

        addChild(this._bitmap);
    }

    private var _bitmap:Bitmap;
    private var _maxFrames:int;
    private var _frameDelay:int;
    private var _frames:Vector.<BitmapAsset>;
    private var _id:uint;
    private var _isPlaying:Boolean;
    private var _currentFrame:int;

    public function play():void {
        if (this._isPlaying)
            return;

        this._isPlaying = true;
        this._id = setInterval(this.playFrames, this._frameDelay);
    }

    public function stop():void {
        if (!this._isPlaying)
            return;

        this._isPlaying = false;

        clearInterval(this._id);
    }

    private function playFrames():void {
        if (this._currentFrame >= this._maxFrames) {
            this._currentFrame = 0;
            if (this.contains(this._bitmap)) {
                this.stop();
                this.removeChild(this._bitmap);
            }
        }

        this._bitmap.bitmapData = this._frames[this._currentFrame++].bitmapData;
    }
}
}
</file>

<file path="src/svera/lib/util/TimeWriter.as">
package svera.lib.util {
public class TimeWriter {


    private var timeStringStarted:Boolean = false;

    private var seconds:int;

    private var minutes:int;

    private var hours:int;

    private var days:int;

    private var textValues:Array;

    public function TimeWriter() {
        super();
    }

    public function parseTime(time:Number):String {
        this.seconds = Math.floor(time / 1000);
        this.minutes = Math.floor(this.seconds / 60);
        this.hours = Math.floor(this.minutes / 60);
        this.days = Math.floor(this.hours / 24);
        this.seconds = this.seconds % 60;
        this.minutes = this.minutes % 60;
        this.hours = this.hours % 24;
        this.timeStringStarted = false;
        this.textValues = [];
        this.formatUnit(this.days, "d");
        this.formatUnit(this.hours, "h");
        this.formatUnit(this.minutes, "m", 2);
        this.formatUnit(this.seconds, "s", 2);
        this.timeStringStarted = false;
        return this.textValues.join(" ");
    }

    private function formatUnit(value:int, measurement:String, stringLength:int = -1):void {
        if (value == 0 && !this.timeStringStarted) {
            return;
        }
        this.timeStringStarted = true;
        var string:String = value.toString();
        if (stringLength == -1) {
            stringLength = string.length;
        }
        var prefix:String = "";
        for (var i:int = string.length; i < stringLength; i++) {
            prefix = prefix + "0";
        }
        string = prefix + string + measurement;
        this.textValues.push(string);
    }
}
}
</file>

<file path="src/svera/lib/util/VectorAS3Util.as">
package svera.lib.util {
public class VectorAS3Util {


    public function VectorAS3Util() {
        super();
    }

    public static function toArray(forEachAble:Object):Array {
        var value:Object = null;
        var array:Array = [];
        for each(value in forEachAble) {
            array.push(value);
        }
        return array;
    }
}
}
</file>

<file path="src/svera/untiered/account/core/Account.as">
package svera.untiered.account.core {
public interface Account {
    function updateUser(guid:String, password:String):void;

    function getUserName():String;

    function getUsername():String;

    function getPassword():String;

    function getCredentials():Object;

    function isRegistered():Boolean;

    function clear():void;

    function reportIntStat(name:String, value:int):void;
}
}
</file>

<file path="src/svera/untiered/account/core/model/JSInitializedModel.as">
package svera.untiered.account.core.model {
public class JSInitializedModel {


    public var isInitialized:Boolean;

    public function JSInitializedModel() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/model/ChangePasswordData.as">
package svera.untiered.account.web.model {
public class ChangePasswordData {


    public var currentPassword:String;

    public var newPassword:String;

    public function ChangePasswordData() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/assets/model/CharacterTemplate.as">
package svera.untiered.assets.model {
public class CharacterTemplate {


    public var file:String;

    public var index:int;

    public function CharacterTemplate(file:String, index:int) {
        super();
        this.file = file;
        this.index = index;
    }
}
}
</file>

<file path="src/svera/untiered/assets/Models/bigcube.dat">
# cube.obj
#
 
g cube
 
v -0.5 -0.5 0
v -0.5 -0.5 1
v -0.5 0.5 0
v -0.5 0.5 1
v 0.5 -0.5 0
v 0.5 -0.5 1
v 0.5 0.5 0
v 0.5 0.5 1

vn  0.0  0.0  1.0
vn  0.0  0.0 -1.0
vn  0.0  1.0  0.0
vn  0.0 -1.0  0.0
vn  1.0  0.0  0.0
vn -1.0  0.0  0.0
 
f  1//2  7//2  5//2
f  1//2  3//2  7//2 
f  1//6  4//6  3//6 
f  1//6  2//6  4//6 
f  3//3  8//3  7//3 
f  3//3  4//3  8//3 
f  5//5  7//5  8//5 
f  5//5  8//5  6//5 
f  1//4  5//4  6//4 
f  1//4  6//4  2//4 
f  2//1  6//1  8//1 
f  2//1  8//1  4//1
</file>

<file path="src/svera/untiered/assets/Models/brokenPillar.dat">
# 8 vertexes
v -.25 -.25  0
v .25 -.25  0
v .25  .25  0
v -.25  .25  0
v -.25 -.25  .25
v .25 -.25  .45
v .25  .25  .65
v -.25  .25  .45

# 12 texture vertexes
vt .3333 0
vt .6666 0
vt 0 .3333
vt .3333 .3333
vt .6666 .3333
vt 1.0 .3333
vt 0 .6666
vt .3333 .6666
vt .6666 .6666
vt 1.0 .6666
vt .3333 1.0
vt .6666 1.0

# 5 faces
f 6/5 5/4 1/1 2/2
f 7/9 6/5 2/6 3/10
f 8/8 7/9 3/12 4/11
f 5/4 8/8 4/7 1/3
f 5/4 6/5 7/9 8/8
</file>

<file path="src/svera/untiered/assets/Models/crate.dat">
# Alias OBJ Model File
# Exported from SketchUp, (c) 2000-2006 Google, Inc.
# File units = meters

mtllib crate.mtl

g Mesh1 Model

usemtl M_4Quad
v -0.45 0.45 0.5
vt 0 -1
vn 0 1 -0
v 0.45 0.45 0.5
vt 0.5 -1
v 0.45 0.45 0
vt 0.5 -0.5
v -0.45 0.45 0
vt 0 -0.5
f 1/1/1 2/2/1 3/3/1 4/4/1 

v -0.45 -0.45 0.5
vn 0 0 1
v 0.45 -0.45 0.5
vt 0.5 -0.5
vt 0.5 0
vt 0 0
f 5/4/2 6/5/2 2/6/2 1/7/2 

vt -1 -1
vn 0 -1 -0
vt -0.5 -1
v -0.45 -0.45 0
vt -0.5 -0.5
v 0.45 -0.45 0
vt -1 -0.5
f 6/8/3 5/9/3 7/10/3 8/11/3 

vt 7.21911e-016 0.5
vn -1 0 -0
vt 0.5 -7.77156e-016
vt 0.5 0.5
f 7/12/4 5/7/4 1/13/4 4/14/4 

vt -1.5 -0.5
vn 0 0 -1
vt -1 0
vt -1.5 0
f 8/15/5 7/11/5 4/16/5 3/17/5 

vt -0.5 -6.10623e-016
vn 1 0 -0
vt -0.5 0.5
vt -1 0.5
vt -1 -5.55112e-017
f 6/18/6 8/19/6 3/20/6 2/21/6
</file>

<file path="src/svera/untiered/assets/Models/cube.dat">
# Alias OBJ Model File
# Exported from SketchUp, (c) 2000-2006 Google, Inc.
# File units = meters

mtllib cube.mtl

g Mesh1 Model

usemtl M_4Quad
v -0.5 0.5 0.5
vt 0 -1
vn 0 1 -0
v 0.5 0.5 0.5
vt 0.5 -1
v 0.5 0.5 0
vt 0.5 -0.5
v -0.5 0.5 0
vt 0 -0.5
f 1/1/1 2/2/1 3/3/1 4/4/1 

v -0.5 -0.5 0.5
vn 0 0 1
v 0.5 -0.5 0.5
vt 0.5 -0.5
vt 0.5 0
vt 0 0
f 5/4/2 6/5/2 2/6/2 1/7/2 

vt -1 -1
vn 0 -1 -0
vt -0.5 -1
v -0.5 -0.5 0
vt -0.5 -0.5
v 0.5 -0.5 0
vt -1 -0.5
f 6/8/3 5/9/3 7/10/3 8/11/3 

vn -1 0 -0
vt 0.5 0
vt 0.5 0.5
vt 0 0.5
f 7/7/4 5/12/4 1/13/4 4/14/4 

vt -1.5 -0.5
vn 0 0 -1
vt -1 0
vt -1.5 0
f 8/15/5 7/11/5 4/16/5 3/17/5 

vn 1 0 -0
vt -0.5 0
vt -0.5 0.5
vt -1 0.5
f 6/16/6 8/18/6 3/19/6 2/20/6
</file>

<file path="src/svera/untiered/assets/Models/dodecahedron.dat">
# OBJ file created by ply_to_obj.c
#
g Object001

v -0.309017 -0.309017 0.809017
v 0.5 0.190983 0.5
v 0.5 -0.190983 0.5
v -0.5 0.190983 0.5
v -0.5 -0.190983 0.5
v 0 0.5 0.690983
v 0 0.5 0.309017
v 0.190983 0 0
v -0.190983 0 0
v 0 -0.5 0.309017
v 0 -0.5 0.690983
v 0.190983 0 1
v -0.190983 0 1
v 0.309017 0.309017 0.190983
v 0.309017 0.309017 0.809017
v -0.309017 0.309017 0.190983
v -0.309017 0.309017 0.809017
v 0.309017 -0.309017 0.190983
v 0.309017 -0.309017 0.809017
v -0.309017 -0.309017 0.190983

f  19  3  2
f  12  19  2
f  15  12  2
f  8  14  2
f  18  8  2
f  3  18  2
f  20  5  4
f  9  20  4
f  16  9  4
f  13  17  4
f  1  13  4
f  5  1  4
f  7  16  4
f  6  7  4
f  17  6  4
f  6  15  2
f  7  6  2
f  14  7  2
f  10  18  3
f  11  10  3
f  19  11  3
f  11  1  5
f  10  11  5
f  20  10  5
f  20  9  8
f  10  20  8
f  18  10  8
f  9  16  7
f  8  9  7
f  14  8  7
f  12  15  6
f  13  12  6
f  17  13  6
f  13  1  11
f  12  13  11
f  19  12  11
</file>

<file path="src/svera/untiered/assets/Models/icosahedron.dat">
# OBJ file created by ply_to_obj.c
#
g Object001

v 0 -0.309017 1
v 0.5 0 0.809017
v 0.5 0 0.190983
v -0.5 0 0.190983
v -0.5 0 0.809017
v -0.309017 0.5 0.5
v 0.309017 0.5 0.5
v 0.309017 -0.5 0.5
v -0.309017 -0.5 0.5
v 0 -0.309017 0
v 0 0.309017 0
v 0 0.309017 1

f  2  3  7
f  2  8  3
f  4  5  6
f  5  4  9
f  7  6  12
f  6  7  11
f  10  11  3
f  11  10  4
f  8  9  10
f  9  8  1
f  12  1  2
f  1  12  5
f  7  3  11
f  2  7  12
f  4  6  11
f  6  5  12
f  3  8  10
f  8  2  1
f  4  10  9
f  5  9  1
</file>

<file path="src/svera/untiered/assets/Models/obelisk.dat">
# 9 vertexes
v -.25 -.25  0
v .25 -.25  0
v .25  .25  0
v -.25  .25  0
v -.15 -.15  .75
v .15 -.15  .75
v .15  .15  .75
v -.15  .15  .75
v 0 0 .85

# 9 texture vertexes
vt 0 1
vt 1 1
vt 0 1
vt 1 1
vt 0 .125
vt 1 .125
vt 0 .125
vt 1 .125
vt .5 0

# 8 faces
f 6/6 5/5 1/1 2/2
f 7/7 6/6 2/2 3/3
f 8/8 7/7 3/3 4/4
f 5/5 8/8 4/4 1/1
f 9/9 5/5 6/6
f 9/9 6/6 7/7
f 9/9 7/7 8/8
f 9/9 8/8 5/5
</file>

<file path="src/svera/untiered/assets/Models/octahedron.dat">
# OBJ file created by ply_to_obj.c
#
g Object001

v 0.5 0 0.5
v 0 -0.5 0.5
v -0.5 0 0.5
v 0 0.5 0.5
v 0 0 1
v 0 0 0

f  2  1  5
f  3  2  5
f  4  3  5
f  1  4  5
f  1  2  6
f  2  3  6
f  3  4  6
f  4  1  6
</file>

<file path="src/svera/untiered/assets/Models/pillar.dat">
# 8 vertexes
v -.25 -.25  0
v .25 -.25  0
v .25  .25  0
v -.25  .25  0
v -.25 -.25  .75
v .25 -.25  .75
v .25  .25  .75
v -.25  .25  .75

# 12 texture vertexes
vt .3333 0
vt .6666 0
vt 0 .3333
vt .3333 .3333
vt .6666 .3333
vt 1.0 .3333
vt 0 .6666
vt .3333 .6666
vt .6666 .6666
vt 1.0 .6666
vt .3333 1.0
vt .6666 1.0

# 5 faces
f 6/5 5/4 1/1 2/2
f 7/9 6/5 2/6 3/10
f 8/8 7/9 3/12 4/11
f 5/4 8/8 4/7 1/3
f 5/4 6/5 7/9 8/8
</file>

<file path="src/svera/untiered/assets/Models/pyramid.dat">
# OBJ file created by ply_to_obj.c
#
g Object001

v -0.5 -0.5 0
v 0.5 -0.5 0
v 0.5 0.5 0
v -0.5 0.5 0
v 0 0 1.6

f  4  2  1
f  4  3  2
f  5  1  2
f  5  4  1
f  5  3  4
f  5  2  3
</file>

<file path="src/svera/untiered/assets/Models/sign.dat">
# 8 vertexes
v -.4 -.05 .0
v  .4 -.05 .0
v -.4 -.05 .8
v  .4 -.05 .8
v -.4 .1 0
v -.4 .1 .8
v  .4 .1 .8
v  .4 .1 0

# 12 texture vertexes
vt .3333 0
vt .6666 0
vt 0 .3333
vt 0 .1
vt 1 .1
vt 1 .3333
vt 0 .6666
vt 0 0
vt 1 0
vt 1 0
vt 0 1
vt 1 1

# 5 faces
f 4/5 3/4 1/1 2/2
f 7/9 4/5 2/6 8/10
f 6/8 7/9 8/12 5/11
f 3/4 6/8 5/7 1/3
f 3/4 4/5 7/9 6/8
</file>

<file path="src/svera/untiered/assets/Models/table.dat">
# OBJ rewritten thus: ./rewriteObj.py table.obj
# Alias OBJ Model File
# Exported from SketchUp, (c) 2000-2006 Google, Inc.
# File units = meters

mtllib table.mtl

g Mesh1 Model

usemtl Material1
v 0.5 0.5 0.4
vt 1 1
vn 0 0 1
v -0.5 0.5 0.4
vt 0 1
v -0.5 -0.5 0.4
vt 0 0
v 0.5 -0.5 0.4
vt 1 0
f 1/1/1 2/2/1 3/3/1 4/4/1 

usemtl Solid1
v 0.5 0.5 0.2
vt 39.3701 -7.87402
vn 0 1 -0
v -0.5 0.5 0.2
vt 0 -7.87402
vt 0 -15.748
vt 39.3701 -15.748
f 5/5/2 6/6/2 2/7/2 1/8/2 

vt 7.87402 39.3701
vn -1 0 -0
v -0.5 -0.5 0.2
vt 7.87402 0
vt 15.748 0
vt 15.748 39.3701
f 6/9/3 7/10/3 3/11/3 2/12/3 

vn 0 -1 -0
v 0.5 -0.5 0.2
vt -39.3701 -7.87402
vt -39.3701 -15.748
f 7/6/4 8/13/4 4/14/4 3/7/4 

vt -7.87402 0
vn 1 0 -0
vt -7.87402 39.3701
vt -15.748 39.3701
vt -15.748 0
f 8/15/5 5/16/5 1/17/5 4/18/5
</file>

<file path="src/svera/untiered/assets/Models/tableEdge.dat">
# OBJ rewritten thus: ./rewriteObj.py tableedge.obj
# Alias OBJ Model File
# Exported from SketchUp, (c) 2000-2006 Google, Inc.
# File units = meters

mtllib tableedge.mtl

g Mesh1 Model

usemtl Material1
v 0.5 0.5 0.4
vt 1 1
vn 0 0 1
v -0.5 0.5 0.4
vt 0 1
v -0.5 -0.5 0.4
vt 0 0
v 0.5 -0.5 0.4
vt 1 0
f 1/1/1 2/2/1 3/3/1 4/4/1 

usemtl Solid1
vt 39.3701 -15.748
vn 0 1 -0
v 0.5 0.5 0.2
vt 39.3701 -7.87402
v -0.5 0.5 0.2
vt 0 -7.87402
vt 0 -15.748
f 1/5/2 5/6/2 6/7/2 2/8/2 

v 0.5 -0.5 0.2
vt -7.87402 0
vn 1 0 -0
vt -7.87402 39.3701
vt -15.748 39.3701
vt -15.748 0
f 7/9/3 5/10/3 1/11/3 4/12/3 

vn 0 -1 -0
v -0.5 -0.5 0.2
vt 0 -7.87402
v -0.3 -0.5 0.2
vt -7.87402 -7.87402
vt -39.3701 -7.87402
vt -39.3701 -15.748
f 3/8/4 8/13/4 9/14/4 7/15/4 4/16/4 

vt 7.87402 39.3701
vn -1 0 -0
v -0.5 -0.3 0.2
vt 7.87402 7.87402
vt 7.87402 0
vt 15.748 0
vt 15.748 39.3701
f 6/17/5 10/18/5 8/19/5 3/20/5 2/21/5 

v -0.5 -0.5 -0
vt -4.44089e-016 0
v -0.5 -0.3 -0
vt -4.44089e-016 7.87402
f 11/22/5 8/19/5 10/18/5 12/23/5 

v -0.3 -0.5 -0
vt -7.87402 4.44089e-016
vt 0 4.44089e-016
f 13/24/4 9/14/4 8/13/4 11/25/4 

v -0.3 -0.3 0.2
vt -7.87402 7.87402
vt 4.44089e-016 0
v -0.3 -0.3 -0
vt 4.44089e-016 7.87402
f 14/26/3 9/9/3 13/27/3 15/28/3 

vt 7.87402 -7.87402
vt 7.87402 4.44089e-016
f 10/7/2 14/29/2 15/30/2 12/25/2
</file>

<file path="src/svera/untiered/assets/Models/tetrahedron.dat">
# tetrahedron.obj created by hand.
#
 
g tetrahedron
 
v -0.5 -0.5 0
v 0.5 -0.5 0
v -0.5 0.5 0
v -0.5 -0.5 1
 
f 1 3 2
f 1 4 3
f 1 2 4
f 2 3 4
</file>

<file path="src/svera/untiered/assets/Models/tower.dat">
# 8 vertexes
v -.25 -.25  0
v .25 -.25  0
v .25  .25  0
v -.25  .25  0
v -.10 -.10  .75
v .10 -.10  .75
v .10  .10  .75
v -.10  .10  .75

# 12 texture vertexes
vt .3333 0
vt .6666 0
vt 0 .3333
vt .3333 .3333
vt .6666 .3333
vt 1.0 .3333
vt 0 .6666
vt .3333 .6666
vt .6666 .6666
vt 1.0 .6666
vt .3333 1.0
vt .6666 1.0

# 5 faces
f 6/5 5/4 1/1 2/2
f 7/9 6/5 2/6 3/10
f 8/8 7/9 3/12 4/11
f 5/4 8/8 4/7 1/3
f 5/4 6/5 7/9 8/8
</file>

<file path="src/svera/untiered/assets/Models/web.dat">
# 3 vertexes
v -.5 0 .0
v -.5 0 .8
v .05 0 .0

# 3 texture vertexes
vt 0 1
vt 0 0
vt 1 1

# 2 faces
f 1/1 2/2 3/3
f 1/1 3/3 2/2
</file>

<file path="src/svera/untiered/classes/model/CharacterClassStat.as">
package svera.untiered.classes.model {
public class CharacterClassStat {


    public var initial:int;

    public var max:int;

    public var rampMin:int;

    public var rampMax:int;

    public function CharacterClassStat() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/classes/model/CharacterClassUnlock.as">
package svera.untiered.classes.model {
public class CharacterClassUnlock {


    public var level:int;

    public var character:CharacterClass;

    public function CharacterClassUnlock() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/classes/model/CharacterSkinState.as">
package svera.untiered.classes.model {
public class CharacterSkinState {
    public static const OWNED:CharacterSkinState = new CharacterSkinState(false, "OWNED");
    public static const PURCHASABLE:CharacterSkinState = new CharacterSkinState(true, "PURCHASABLE");
    public static const PURCHASING:CharacterSkinState = new CharacterSkinState(true, "PURCHASING");
    public static const NULL:CharacterSkinState = new CharacterSkinState(true, "NULL");

    private var _isDisabled:Boolean;
    private var name:String;

    public function CharacterSkinState(isDisabled:Boolean, name:String) {
        super();
        this._isDisabled = isDisabled;
        this.name = name;
    }

    public function isDisabled():Boolean {
        return this._isDisabled;
    }

    public function toString():String {
        return "[CharacterSkinState {NAME}]".replace("{NAME}", this.name);
    }
}
}
</file>

<file path="src/svera/untiered/constants/ActivationType.as">
package svera.untiered.constants {
public class ActivationType {
    public static const UNLOCK_PORTAL:String = "UnlockPortal";
    public static const SHOOT:String = "Shoot";
    public static const DECOY:String = "Decoy";
    public static const DAZE_BLAST:String = "DazeBlast";
    public static const BULLET_NOVA:String = "BulletNova";
    public static const REMOVE_NEG_COND_SELF:String = "RemoveNegativeConditionsSelf";
    public static const INCREMENT_STAT:String = "IncrementStat";
    public static const HEAL:String = "Heal";
    public static const HEAL_NOVA:String = "HealNova";
    public static const MAGIC:String = "Magic";
    public static const MAGIC_NOVA:String = "MagicNova";
    public static const STAT_BOOST_SELF:String = "StatBoostSelf";
    public static const STAT_BOOST_AURA:String = "StatBoostAura";
    public static const COND_EFFECT_SELF:String = "ConditionEffectSelf";
    public static const CLEAR_COND_EFFECT_SELF:String = "ClearConditionEffectSelf";
    public static const COND_EFFECT_AURA:String = "ConditionEffectAura";
    public static const CLEAR_COND_EFFECT_AURA:String = "ClearConditionEffectAura";
    public static const POISON_GRENADE:String = "PoisonGrenade";
    public static const VAMPIRE_BLAST:String = "VampireBlast";
    public static const TRAP:String = "Trap";
    public static const STASIS_BLAST:String = "StasisBlast";
    public static const PET:String = "Pet";
    public static const PERMA_PET:String = "PermaPet";
    public static const TELEPORT:String = "Teleport";
    public static const LIGHTNING:String = "Lightning";
    public static const CREATE:String = "Create";
    public static const REMOVE_NEG_COND:String = "RemoveNegativeConditions";
    public static const SHURIKEN:String = "Shuriken";
    public static const DYE:String = "Dye";
    public static const SMALL_DIG:String = "Small_Dig";
    public static const FILL:String = "Fill";

    public function ActivationType() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/constants/GeneralConstants.as">
package svera.untiered.constants {
public class GeneralConstants {

    public static const MAXIMUM_INTERACTION_DISTANCE:int = 1;

    public static const NUM_EQUIPMENT_SLOTS:int = 5;

    public static const NUM_INVENTORY_SLOTS:int = 24;


    public function GeneralConstants() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/model/ScreenModel.as">
package svera.untiered.core.model {
public class ScreenModel {


    public var currentType:Class;

    public function ScreenModel() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/game/model/AddTextLineVO.as">
package svera.untiered.game.model {
public class AddTextLineVO {


    public var name:String;

    public var objectId:int;

    public var numStars:int;

    public var recipient:String;

    public var text:String;

    public function AddTextLineVO(name:String, text:String, objectId:int = -1, numStars:int = -1, recipient:String = "") {
        super();
        this.name = name;
        this.objectId = objectId;
        this.numStars = numStars;
        this.recipient = recipient;
        this.text = text;
    }
}
}
</file>

<file path="src/svera/untiered/game/model/UsePotionVO.as">
package svera.untiered.game.model {
public class UsePotionVO {

    public static var SHIFTCLICK:String = "shift_click";

    public static var CONTEXTBUY:String = "context_buy";


    public var objectId:int;

    public var source:String;

    public function UsePotionVO(objectId:int, source:String) {
        super();
        this.objectId = objectId;
        this.source = source;
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/ShowChatInputSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class ShowChatInputSignal extends Signal {
    public function ShowChatInputSignal() {
        super(String);
    }
}
}
</file>

<file path="src/svera/untiered/honor/control/ShowHonorViewCommand.as">
package svera.untiered.honor.control {
import svera.lib.framework.ICommand;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.honor.model.HonorModel;
import svera.untiered.honor.model.HonorVO;
import svera.untiered.honor.view.HonorView;

public class ShowHonorViewCommand implements ICommand {


    [Inject]
    public var vo:HonorVO;

    [Inject]
    public var model:HonorModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    public function ShowHonorViewCommand() {
        super();
    }

    public function execute():void {
        this.model.accountId = this.vo.getAccountId();
        this.model.characterId = this.vo.getCharacterId();
        this.setScreen.dispatch(new HonorView());
    }
}
}
</file>

<file path="src/svera/untiered/honor/control/ShowHonorViewSignal.as">
package svera.untiered.honor.control {
import org.osflash.signals.Signal;

import svera.untiered.honor.model.HonorVO;

public class ShowHonorViewSignal extends Signal {


    public function ShowHonorViewSignal() {
        super(HonorVO);
    }
}
}
</file>

<file path="src/svera/untiered/honor/model/HonorModel.as">
package svera.untiered.honor.model {
public class HonorModel {


    public var accountId:int;

    public var characterId:int;

    public function HonorModel() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/honor/model/HonorVO.as">
package svera.untiered.honor.model {
public interface HonorVO {


    function getAccountId():int;

    function getCharacterId():int;
}
}
</file>

<file path="src/svera/untiered/honor/model/SimpleHonorVO.as">
package svera.untiered.honor.model {
public class SimpleHonorVO implements HonorVO {


    private var accountId:int;

    private var characterId:int;

    public function SimpleHonorVO(accountId:int, characterId:int) {
        super();
        this.accountId = accountId;
        this.characterId = characterId;
    }

    public function getAccountId():int {
        return this.accountId;
    }

    public function getCharacterId():int {
        return this.characterId;
    }
}
}
</file>

<file path="src/svera/untiered/honor/view/HonorMediator.as">
package svera.untiered.honor.view {
import flash.display.BitmapData;

import svera.lib.framework.Mediator;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.core.signals.GotoPreviousScreenSignal;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.death.model.DeathModel;
import svera.untiered.honor.model.HonorModel;
import svera.untiered.honor.service.RequestCharacterHonorTask;
import svera.untiered.legends.view.LegendsView;
import svera.untiered.messaging.impl.incoming.Death;

public class HonorMediator extends Mediator {


    [Inject]
    public var view:HonorView;

    [Inject]
    public var honorModel:HonorModel;

    [Inject]
    public var deathModel:DeathModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var gotoPrevious:GotoPreviousScreenSignal;

    [Inject]
    public var task:RequestCharacterHonorTask;

    [Inject]
    public var factory:CharacterFactory;

    private var isFreshDeath:Boolean;

    private var death:Death;

    public function HonorMediator() {
        super();
    }

    override public function initialize():void {
        this.view.closed.add(this.onClosed);
        this.setViewDataFromDeath();
        this.requestHonorData();
    }

    override public function destroy():void {
        this.view.closed.remove(this.onClosed);
        this.view.clearBackground();
        this.death && this.death.disposeBackground();
        this.task.finished.removeAll();
    }

    private function setViewDataFromDeath():void {
        this.isFreshDeath = this.deathModel.getIsDeathViewPending();
        this.view.setIsAnimation(this.isFreshDeath);
        this.death = this.deathModel.getLastDeath();
        if (this.death && this.death.background) {
            this.view.setBackground(this.death.background);
        }
    }

    private function requestHonorData():void {
        this.task.accountId = this.honorModel.accountId;
        this.task.charId = this.honorModel.characterId;
        this.task.finished.addOnce(this.onHonorResponse);
        this.task.start();
    }

    private function onHonorResponse(task:RequestCharacterHonorTask, isOK:Boolean, error:String = ""):void {
        var icon:BitmapData = this.makeIcon();
        this.view.setCharacterInfo(task.name, task.level, task.type);
        this.view.setDeathInfo(task.deathDate, task.killer);
        this.view.setIcon(icon);
        this.view.setScore(task.totalHonor, task.xml);
    }

    private function makeIcon():BitmapData {
        //if(this.isFreshDeath && this.death.isZombie)
        //{
        //   return this.makeZombieTexture();
        //}
        return this.makeNormalTexture();
    }

    private function makeNormalTexture():BitmapData {
        return this.factory.makeIcon(this.task.template, 250, this.task.texture1, this.task.texture2);
    }

    /*private function makeZombieTexture() : BitmapData
    {
       var textureData:TextureData = ObjectLibrary.typeToTextureData_[this.death.zombieType];
       var animatedChar:AnimatedChar = textureData.animatedChar_;
       var image:MaskedImage = animatedChar.imageFromDir(AnimatedChar.RIGHT,AnimatedChar.STAND,0);
       return TextureRedrawer.resize(image.image_,image.mask_,250,true,this.task.texture1,this.task.texture2);
    }*/

    private function onClosed():void {
        if (this.isFreshDeath) {
            this.setScreen.dispatch(new LegendsView());
        } else {
            this.gotoPrevious.dispatch();
        }
    }
}
}
</file>

<file path="src/svera/untiered/hud/HUD_Overlay.as">
package svera.untiered.hud {

import mx.core.*;

[Embed(source="HUD_Overlay.png")]
public class HUD_Overlay extends BitmapAsset {
    public function HUD_Overlay() {
        super();

    }
}
}
</file>

<file path="src/svera/untiered/itemdata/ActivateEffectsData.as">
package svera.untiered.itemdata {

public class ActivateEffectsData {

    public var idx:int;
    public var Effect:String;

    public var ObjectId:String;
    public var Id:String;
    public var DungeonName:String;
    public var LockedName:String;
    public var SkinType:int;
    public var SkinType2:int;
    public var Size:int;
    public var CurrencyType:String;
    public var Gifts:Array;
    public var PetType:int;
    public var Chance:int;
    public var Explode:Boolean;

    public var Stats:int;
    public var Stats2:int;
    public var Stats3:int;
    public var Amount:int;
    public var Amount2:int;
    public var Amount3:int;
    public var Range:Number;
    public var IsPerc:Boolean;
    public var DurationMS:int;
    public var DurationSec:Number;
    public var ConditionEffect:String;
    public var CheckExistingEffect:String;
    public var EffectDuration:Number;
    public var Radius:Number;
    public var TotalDamage:int;
    public var ImpactDamage:int;
    public var ThrowTime:int;
    public var AngleOffset:int;
    public var MaxTargets:int;
    public var Color:int;
    public var NoStack:Boolean;
    public var UseWisMod:Boolean;
    public var UseWisMod2:Boolean;
    public var UseVitMod:Boolean;
    public var UseAtkMod:Boolean;
    public var Target:String;
    public var Center:String;
    public var VisualEffect:int;
    public var Players:Boolean;
    public var RandVals:Array;
    public var ObjType:int;
    public var NumShots:int;

    public function ActivateEffectsData(idx:int) {
        this.idx = idx;
    }

    public static function parseFromXml(xml:XML, idx:int): ActivateEffectsData {
        var ae:ActivateEffectsData = new ActivateEffectsData(idx);
        //ae.Effect = LinkUtils.parseElementString(xml, "Activate");
        ae.Effect = xml.toString(); //Bruh
        ae.ObjectId = LinkUtils.parseAttributeString(xml, "@objectId");
        ae.Id = LinkUtils.parseAttributeString(xml, "@id");
        ae.DungeonName = LinkUtils.parseAttributeString(xml, "@dungeonName");
        ae.LockedName = LinkUtils.parseAttributeString(xml, "@lockedName");
        ae.SkinType = LinkUtils.parseAttributeInt(xml, "@skinType");
        ae.SkinType2 = LinkUtils.parseAttributeInt(xml, "@skinType2");
        ae.Size = LinkUtils.parseAttributeInt(xml, "@size");
        ae.CurrencyType = LinkUtils.parseAttributeString(xml, "@currencyType");
        ae.Gifts = []; //Unused client side
        ae.PetType = LinkUtils.parseAttributeInt(xml, "@petType");
        ae.Chance = LinkUtils.parseAttributeInt(xml, "@chance");
        ae.Explode = LinkUtils.parseAttributeBool(xml, "@explode");
        ae.Stats = LinkUtils.parseAttributeInt(xml, "@stat");
        ae.Stats2 = LinkUtils.parseAttributeInt(xml, "@stat2");
        ae.Stats3 = LinkUtils.parseAttributeInt(xml, "@stat3");
        ae.Amount = LinkUtils.parseAttributeInt(xml, "@amount");
        ae.Amount2 = LinkUtils.parseAttributeInt(xml, "@amount2");
        ae.Amount3 = LinkUtils.parseAttributeInt(xml, "@amount3");
        ae.Range = LinkUtils.parseAttributeFloat(xml, "@range");
        ae.IsPerc = LinkUtils.parseAttributeBool(xml, "@isPerc");
        ae.DurationMS = int(LinkUtils.parseAttributeFloat(xml, "@duration") * 1000);
        ae.DurationSec = LinkUtils.parseAttributeFloat(xml, "@duration");
        ae.ConditionEffect = LinkUtils.parseAttributeString(xml, "@effect");
        ae.ConditionEffect = LinkUtils.parseAttributeString(xml, "@condEffect", ae.ConditionEffect);// Bruh
        ae.CheckExistingEffect = LinkUtils.parseAttributeString(xml, "@checkExistingEffect");
        ae.EffectDuration = LinkUtils.parseAttributeFloat(xml, "@condDuration");
        ae.Radius = LinkUtils.parseAttributeFloat(xml, "@radius");
        ae.TotalDamage = LinkUtils.parseAttributeInt(xml, "@totalDamage");
        ae.ImpactDamage = LinkUtils.parseAttributeInt(xml, "@impactDamage");
        ae.ThrowTime = LinkUtils.parseAttributeInt(xml, "@throwTime");
        ae.AngleOffset = LinkUtils.parseAttributeInt(xml, "@angleOffset");
        ae.MaxTargets = LinkUtils.parseAttributeInt(xml, "@maxTargets");
        ae.Color = LinkUtils.parseAttributeInt(xml, "@color");
        ae.NoStack = LinkUtils.parseAttributeBool(xml, "@noStack");
        ae.UseWisMod = LinkUtils.parseAttributeBool(xml, "@useWisMod");
        ae.UseWisMod2 = LinkUtils.parseAttributeBool(xml, "@useWisMod2", ae.UseWisMod);
        ae.UseVitMod = LinkUtils.parseAttributeBool(xml, "@useVitMod")
        ae.UseAtkMod = LinkUtils.parseAttributeBool(xml, "@useAtkMod");
        ae.Target = LinkUtils.parseAttributeString(xml, "@target");
        ae.Center = LinkUtils.parseAttributeString(xml, "@center");
        ae.VisualEffect = LinkUtils.parseAttributeInt(xml, "@visualEffect");
        ae.Players = LinkUtils.parseAttributeBool(xml, "@players");
        ae.RandVals = LinkUtils.parseAttributeString(xml, "@randVals").replace(" ", "").split(",");
        ae.ObjType = LinkUtils.parseAttributeInt(xml, "@objType");
        ae.NumShots = LinkUtils.parseAttributeInt(xml, "@numShots");
        return ae;
    }
}
}
</file>

<file path="src/svera/untiered/itemdata/DataKeys.as">
package svera.untiered.itemdata {
public class DataKeys {

    private static var value:int = 0;

    public static const Uuid:int = value++;
    public static const CommandTag:int = value++;
    public static const KillTracker:int = value++;
    public static const Soulbound:int = value++;
}
}
</file>

<file path="src/svera/untiered/itemdata/LinkUtils.as">
package svera.untiered.itemdata {
import svera.untiered.messaging.impl.data.StatData;

public class LinkUtils {

    public static function parseElementInt(xml:XML, name:String, def:int = 0, base:int = 10): int {
        if (xml.hasOwnProperty(name))
            return parseInt(xml.child(name), base);
        return def;
    }

    public static function parseElementFloat(xml:XML, name:String, def:Number = 0): Number {
        if (xml.hasOwnProperty(name))
            return parseFloat(xml.child(name));
        return def;
    }

    public static function parseElementString(xml:XML, name:String, def:String = ""): String {
        if (xml.hasOwnProperty(name))
            return String(xml.child(name));
        return def;
    }

    public static function parseElementBool(xml:XML, name:String): Boolean {
        return xml.hasOwnProperty(name);
    }

    public static function parseAttributeInt(xml:XML, name:String, def:int = 0, base:int = 10): int {
        if (xml.hasOwnProperty(name))
            return parseInt(xml.attribute(name.slice(1)), base);
        return def;
    }

    public static function parseAttributeFloat(xml:XML, name:String, def:Number = 0): Number {
        if (xml.hasOwnProperty(name))
            return parseFloat(xml.attribute(name.slice(1)));
        return def;
    }

    public static function parseAttributeString(xml:XML, name:String, def:String = ""): String {
        if (xml.hasOwnProperty(name))
            return String(xml.attribute(name.slice(1)));
        return def;
    }

    public static function parseAttributeBool(xml:XML, name:String, def:Boolean = false): Boolean {
        if (xml.hasOwnProperty(name))
                return xml.attribute(name.slice(1)) == "true";
        return def;
    }

    public static function parseAttributeFromElementString(xml:XML, name:String, att:String, def:String = ""): String {
        if (xml.hasOwnProperty(name))
                return String(xml.elements(name)[0].attribute(att.slice(1)));
        return def;
    }

    public static function parseAttributeFromElementInt(xml:XML, name:String, att:String, def:int = -1, base:int = 10): int {
        if (xml.hasOwnProperty(name))
            return parseInt(xml.elements(name)[0].attribute(att.slice(1)), base);
        return def;
    }

    public static function getStatIndex(stat:int): int {
        switch (stat) {
            case StatData.MAXHP:
                return 0;
            case StatData.MAXRP:
                return 1;
            case StatData.ATTACK:
                return 2;
            case StatData.ARMOR:
                return 3;
            case StatData.SPEED:
                return 4;
            case StatData.DEXTERITY:
                return 5;
            case StatData.VIGOR: //TODO: It was vitality
                return 6;
            case StatData.INTELLECT:
                return 7;
            case StatData.MIGHT:
                return 8;
            case StatData.LUCK:
                return 9;
            case StatData.RESTORATION:
                return 10;
            case StatData.PROTECTION:
                return 11;
            case StatData.FORTUNE:
                return 14;
            case StatData.EVASION:
                return 15;
            default:
                return -1;
        }
    }

    public static function statIndexToName(statId:int):String {
        switch (statId) {
            case 0:
                return "Maximum HP";
            case 1:
                return "Maximum MP";
            case 2:
                return "Attack";
            case 3:
                return "Damage Resistance";
            case 4:
                return "Speed"
            case 5:
                return "Dexterity";
            case 6:
                return "Vigor";
            case 7:
                return "Intellect";
            case 8:
                return "Critical Damage";
            case 9:
                return "Critical Chance";
            case 10:
                return "Restoration";
            case 11:
                return "Overshield";
            case 14:
                return "Fortune";
            case 15:
                return "Evasion";
        }
        return "Unknown Stat";
    }

    public static function getTierType(id:int): String {
        switch (id) {
            case 0: return "";
            case 1: return "Common";
            case 2: return "Uncommon";
            case 3: return "Tarnished";
            case 4: return "Artifact";
            case 5: return "Ancestral";
            case 6: return "Valiant";
            case 7: return "Relic";
            case 8: return "Exiled";
            case 9: return "Celestial";
            default: return "UnknownTierType";
        }
    }

    public static function getContainerType(id:int): String {
        switch (id) {
            case 0: return "PlayerDropped";
            case 1: return "Soulbound";
            case 2: return "Common";
            case 3: return "Stat";
            case 4: return "Uncommon";
            case 5: return "Tarnished";
            case 6: return "Artifact";
            case 7: return "Ancestral";
            case 8: return "Valiant";
            case 9: return "Relic";
            case 10: return "Exiled";
            default: return "UnknowContainerType";
        }
    }

    public static function getTargetingType(id:int): String {
        switch (id) {
            case 0: return "enemy";
            case 1: return "player";
            case 2: return "mouse";
            default: return "UnknowTargetingType";
        }
    }

    public static function getSlotType(slot:int): String {
        switch (slot) {
            case 1: return "Sword";
            case 2: return "Dagger";
            case 3: return "Bow";
            case 4: return "Tome";
            case 5: return "Shield";
            case 6: return "Medium Armor";
            case 7: return "Heavy Armor";
            case 8: return "Wand";
            case 9: return "Ring";
            case 10: return "Non Equipment";
            case 11: return "Spell";
            case 12: return "Seal";
            case 13: return "Cloak";
            case 14: return "Light Armor";
            case 15: return "Quiver";
            case 16: return "Helmet";
            case 17: return "Staff";
            case 18: return "Poison";
            case 19: return "Skull";
            case 20: return "Trap";
            case 21: return "Orb";
            case 22: return "Prism";
            case 23: return "Scepter";
            case 24: return "Katana";
            case 25: return "Shuriken";
            case 26: return "Eggs";
            case 27: return "Sheath";
            case 28: return "Banner";
            case 29: return "Lance";
            case 30: return "Siphon";
            case 31: return "Turret";
            case 32: return "Charm";
            case 33: return "Dice";
            case 34: return "Dual Blades";
            case 35: return "Jacket";
            case 36: return "Talisman";
            case 37: return "Crafting Ingredient";
            case 38: return "Consumable";
            case 39: return "Capsule";
            case 40: return "";
            case 41: return "";
            default: return "UnknownSlotType";
        }
    }
}
}
</file>

<file path="src/svera/untiered/itemdata/ProjectileData.as">
package svera.untiered.itemdata {
import com.company.assembleegameclient.util.ConditionEffect;

public class ProjectileData {

    public var BulletType:int;
    public var ObjectId:String
    public var LifetimeMS:int;
    public var Speed:Number;
    public var Size:int;
    public var MinDamage:int;
    public var MaxDamage:int;
    public var Damage:int;
    public var MultiHit:Boolean;
    public var PassesCover:Boolean;
    public var ArmorPiercing:Boolean;
    public var ParticleTrail:Boolean;
    public var ParticleTrailIntensity:int;
    public var ParticleTrailLifetimeMS:int;
    public var ParticleTrailColor:int;
    public var Wavy:Boolean;
    public var Parametric:Boolean;
    public var Boomerang:Boolean;
    public var Amplitude:Number;
    public var Frequency:Number;
    public var Magnitude:Number;
    public var FaceDir:Boolean;
    public var NoRotation:Boolean;

    public var Effects:Array;
    public var EffectsId:Array;
    public var ChanceEffects:Array;

    public function ProjectileData() {}

    public static function parseFromXml(xml:XML): ProjectileData {
        var proj:ProjectileData = new ProjectileData();
        proj.BulletType = LinkUtils.parseAttributeInt(xml, "@id");
        proj.ObjectId = LinkUtils.parseElementString(xml, "ObjectId");
        proj.LifetimeMS = LinkUtils.parseElementInt(xml, "LifetimeMS");
        proj.Speed = LinkUtils.parseElementInt(xml, "Speed");
        proj.Size = LinkUtils.parseElementInt(xml, "Size", -1);

        if (xml.hasOwnProperty("Damage")) {
            proj.MinDamage = proj.MaxDamage = LinkUtils.parseElementInt(xml, "Damage");
        }
        else
        {
            proj.MinDamage = LinkUtils.parseElementInt(xml, "MinDamage");
            proj.MaxDamage = LinkUtils.parseElementInt(xml, "MaxDamage");
        }

        proj.MultiHit = LinkUtils.parseElementBool(xml, "MultiHit");
        proj.PassesCover = LinkUtils.parseElementBool(xml, "PassesCover");
        proj.ArmorPiercing = LinkUtils.parseElementBool(xml, "ArmorPiercing");

        proj.ParticleTrail = LinkUtils.parseElementBool(xml, "ParticleTrail");
        if (proj.ParticleTrail) {
            var elem:XML = xml.elements("ParticleTrail")[0];
            proj.ParticleTrailIntensity = LinkUtils.parseAttributeInt(elem, "@intensity") * 100;
            proj.ParticleTrailLifetimeMS = LinkUtils.parseAttributeInt(elem, "@lifetimeMS");
            proj.ParticleTrailColor = LinkUtils.parseElementFloat(elem, "ParticleTrail", 0xFF00FF);
            if (proj.ParticleTrailColor == 0) proj.ParticleTrailColor = 0xFF00FF;
        }

        proj.Wavy = LinkUtils.parseElementBool(xml, "Wavy");
        proj.Parametric = LinkUtils.parseElementBool(xml, "Parametric");
        proj.Boomerang = LinkUtils.parseElementBool(xml, "Boomerang");
        proj.Amplitude = LinkUtils.parseElementFloat(xml, "Amplitude");
        proj.Frequency = LinkUtils.parseElementFloat(xml, "Frequency", 1);
        proj.Magnitude = LinkUtils.parseElementFloat(xml, "Magnitude", 3);
        proj.FaceDir = LinkUtils.parseElementBool(xml, "FaceDir");
        proj.NoRotation = LinkUtils.parseElementBool(xml, "NoRotation");

        proj.Effects = [];//Tooltips
        proj.EffectsId = [];//GameObject.damage()
        for each (elem in xml.elements("ConditionEffect")) {
            proj.Effects.push({"Effect": elem, "Duration": LinkUtils.parseAttributeFloat(elem, "@duration")});
            proj.EffectsId.push(ConditionEffect.getConditionEffectFromName(LinkUtils.parseElementString(elem, "ConditionEffect")));
        }

        proj.ChanceEffects = [];
        for each (elem in xml.elements("CondChance")) {
            proj.ChanceEffects.push({"Effect": LinkUtils.parseAttributeString(elem, "@effect"), "Duration": LinkUtils.parseAttributeFloat(elem, "@duration"), "Chance": LinkUtils.parseAttributeFloat(elem, "@chance")});
        }

        return proj;
    }
}
}
</file>

<file path="src/svera/untiered/itemdata/TierHelper.as">
package svera.untiered.itemdata {
import com.company.ui.SimpleText;

public class TierHelper {

    // Untiered Tiers
    public static const COMMON_COLOR:uint = 0x69747a;

    public static const UNCOMMON_COLOR:uint = 0x177e2b;

    public static const TARNISHED_COLOR:uint = 0x224a98;

    public static const ARTIFACT_COLOR:uint = 0x45c3ff;

    public static const ANCESTRAL_COLOR:uint = 0xbc4a9b;

    public static const VALIANT_COLOR:uint = 0xffd647;

    public static const RELIC_COLOR:uint = 0x73172D;

    public static const EXILED_COLOR:uint = 0xeb015f;

    public static const CELESTIAL_COLOR:uint = 0xd1d3ea;

    public static function setTierText(text:SimpleText, tier:String): Boolean {
        switch (tier) {
            case "Celestial":
                text.setColor(CELESTIAL_COLOR);
                text.text = "CL";
                return true;
            case "Exiled":
                text.setColor(EXILED_COLOR);
                text.text = "EX";
                return true;
            case "Relic":
                text.setColor(RELIC_COLOR);
                text.text = "R";
                return true;
            case "Valiant":
                text.setColor(VALIANT_COLOR);
                text.text = "VL";
                return true;
            case "Ancestral":
                text.setColor(ANCESTRAL_COLOR);
                text.text = "AN";
                return true;
            case "Artifact":
                text.setColor(ARTIFACT_COLOR);
                text.text = "A";
                return true;
            case "Tarnished":
                text.setColor(TARNISHED_COLOR);
                text.text = "T";
                return true;
            case "Uncommon":
                text.setColor(UNCOMMON_COLOR);
                text.text = "UC";
                return true;
            case "Stat":
                text.setColor(16777215);
                text.text = "S";
                return true;
            case "Common":
                text.setColor(COMMON_COLOR);
                text.text = "C";
                return true;
            default:
                return false;
        }
    }
}
}
</file>

<file path="src/svera/untiered/legends/control/HonorListUpdateSignal.as">
package svera.untiered.legends.control {
import org.osflash.signals.Signal;

public class HonorListUpdateSignal extends Signal {


    public function HonorListUpdateSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/legends/control/RequestHonorListCommand.as">
package svera.untiered.legends.control {
import svera.lib.framework.ICommand;
import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.lib.tasks.TaskMonitor;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.death.model.DeathModel;
import svera.untiered.honor.model.HonorModel;
import svera.untiered.legends.service.GetLegendsListTask;

public class RequestHonorListCommand implements ICommand {


    [Inject]
    public var task:GetLegendsListTask;

    [Inject]
    public var update:HonorListUpdateSignal;

    [Inject]
    public var error:TaskErrorSignal;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var death:DeathModel;

    [Inject]
    public var model:HonorModel;

    public function RequestHonorListCommand() {
        super();
    }

    public function execute():void {
        this.task.charId = this.getCharId();
        var branch:BranchingTask = new BranchingTask(this.task, this.makeSuccess(), this.makeFailure());
        this.monitor.add(branch);
        branch.start();
    }

    private function getCharId():int {
        if (this.player.hasAccount() && this.death.getIsDeathViewPending()) {
            return this.death.getLastDeath().charId_;
        }
        return -1;
    }

    private function makeSuccess():Task {
        return new DispatchSignalTask(this.update);
    }

    private function makeFailure():Task {
        return new DispatchSignalTask(this.error, this.task);
    }
}
}
</file>

<file path="src/svera/untiered/legends/control/RequestHonorListSignal.as">
package svera.untiered.legends.control {
import org.osflash.signals.Signal;

import svera.untiered.legends.model.Timespan;

public class RequestHonorListSignal extends Signal {


    public function RequestHonorListSignal() {
        super(Timespan);
    }
}
}
</file>

<file path="src/svera/untiered/legends/model/LegendsModel.as">
package svera.untiered.legends.model {
public class LegendsModel {


    private var timespan:Timespan;

    private const map:Object = {};

    public function LegendsModel() {
        this.timespan = Timespan.WEEK;
        super();
    }

    public function getTimespan():Timespan {
        return this.timespan;
    }

    public function setTimespan(value:Timespan):void {
        this.timespan = value;
    }

    public function hasLegendList():Boolean {
        return this.map[this.timespan.getId()] != null;
    }

    public function getLegendList():Vector.<Legend> {
        return this.map[this.timespan.getId()];
    }

    public function setLegendList(legends:Vector.<Legend>):void {
        this.map[this.timespan.getId()] = legends;
    }

    public function clear():void {
        var key:* = null;
        for (key in this.map) {
            this.dispose(this.map[key]);
            delete this.map[key];
        }
    }

    private function dispose(legends:Vector.<Legend>):void {
        var legend:Legend = null;
        for each(legend in legends) {
            legend.character && this.removeLegendCharacter(legend);
        }
    }

    private function removeLegendCharacter(legend:Legend):void {
        legend.character.dispose();
        legend.character = null;
    }
}
}
</file>

<file path="src/svera/untiered/legends/model/Timespan.as">
package svera.untiered.legends.model {
public class Timespan {

    public static const WEEK:Timespan = new Timespan("Week", "week");

    public static const MONTH:Timespan = new Timespan("Month", "month");

    public static const ALL:Timespan = new Timespan("All Time", "all");

    public static const TIMESPANS:Vector.<Timespan> = new <Timespan>[WEEK, MONTH, ALL];


    private var name:String;

    private var id:String;

    public function Timespan(name:String, id:String) {
        super();
        this.name = name;
        this.id = id;
    }

    public function getName():String {
        return this.name;
    }

    public function getId():String {
        return this.id;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/MemMarketPanel.as">
package svera.untiered.memMarket {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.appengine.SavedCharactersList;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.ui.panels.ButtonPanel;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.ui.SimpleText;

import flash.events.Event;

import flash.events.MouseEvent;

import flash.filters.DropShadowFilter;

import flash.text.TextFieldAutoSize;

public class MemMarketPanel extends ButtonPanel
{
    public function MemMarketPanel(gameSprite:GameSprite)
    {
        super(gameSprite, "Market", "Open");
    }

    override protected function onButtonClick(event:MouseEvent) : void
    {
        //if (this.gs_.model.isAdmin())
        //{
        //    return;
        //}
        this.gs_.mui_.setEnablePlayerInput(false); /* Disable player movement */
        this.gs_.addChild(new MemMarket(this.gs_.mui_.gs_));
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/tabs/MemMarketTab.as">
package svera.untiered.memMarket.tabs {
import com.company.assembleegameclient.game.GameSprite;

import flash.display.Sprite;

public class MemMarketTab extends Sprite
{
    public var gameSprite_:GameSprite;

    /* Not an actual tab, but provides the base variables and functions for each tab */
    public function MemMarketTab(gameSprite:GameSprite)
    {
        this.gameSprite_ = gameSprite;

        /* Draw vertical line */
        graphics.clear();
        graphics.lineStyle(1,6184542);
        graphics.moveTo(265,100);
        graphics.lineTo(265,525);
        graphics.lineStyle();
    }

    /* Clear */
    public function dispose() : void
    {
        this.gameSprite_ = null;

        /* Remove all children */
        for (var i:int = numChildren - 1; i >= 0; i--)
        {
            removeChildAt(i);
        }
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/utils/ItemUtils.as">
package svera.untiered.memMarket.utils {
import com.company.assembleegameclient.objects.ObjectLibrary;

public class ItemUtils
{
    /* Add restricted values to this */
    public static function isBanned(itemType:int) : Boolean
    {
        return ObjectLibrary.isMarketBanned(itemType);
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/utils/TintUtils.as">
package svera.untiered.memMarket.utils {
import flash.display.Shape;
import flash.geom.ColorTransform;

public class TintUtils
{
    public static function addTint(shape:Shape, color:uint, alpha:Number) : void
    {
        var transform:ColorTransform = shape.transform.colorTransform;
        transform.color = color;
        var rgb:Number = alpha / (1 - (transform.redMultiplier + transform.greenMultiplier + transform.blueMultiplier) / 3);
        transform.redOffset = transform.redOffset * rgb;
        transform.greenOffset = transform.greenOffset * rgb;
        transform.blueOffset = transform.blueOffset * rgb;
        transform.redMultiplier = transform.greenMultiplier = transform.blueMultiplier = 1 - alpha;
        shape.transform.colorTransform = transform;
    }

    public static function removeTint(shape:Shape) : void
    {
        shape.transform.colorTransform = new ColorTransform();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/MarketData.as">
package svera.untiered.messaging.impl.data
{
   import flash.utils.ByteArray;
import flash.utils.IDataInput;

public class MarketData
   {
      public var id_:int;
      public var itemType_:Number;
      public var itemData_:ByteArray;
      public var sellerName_:String;
      public var sellerId_:int;
      public var currency_:int;
      public var price_:int;
      public var startTime_:int;
      public var timeLeft_:int;

      public function MarketData()
      {
         super();
         itemData_ = new ByteArray();
         itemData_.endian = "littleEndian";
      }
      
      public function parseFromInput(data:IDataInput) : void
      {
         itemData_.length = itemData_.position = 0;
         this.id_ = data.readInt();
         this.itemType_ = data.readUnsignedShort();
         this.sellerName_ = data.readUTF();
         this.sellerId_ = data.readInt();
         this.currency_ = data.readInt();
         this.price_ = data.readInt();
         this.startTime_ = data.readInt();
         this.timeLeft_ = data.readInt();
         var len:int = data.readUnsignedShort();
         data.readBytes(itemData_, 0, len);
      }
   }
}
</file>

<file path="src/svera/untiered/messaging/impl/data/MarketOffer.as">
/**
 * Created by Fabian on 17.07.2015.
 */
package svera.untiered.messaging.impl.data {
import flash.utils.ByteArray;

public class MarketOffer {

    public var price:int;
    public var objectSlot:SlotObjectData;

    public function MarketOffer() {
        this.objectSlot = new SlotObjectData();
    }

    public function parseFromInput(rdr:ByteArray):void {
        this.price = rdr.readInt();
        this.objectSlot.parseFromInput(rdr);
    }

    public function writeToOutput(wtr:ByteArray):void {
        wtr.writeInt(this.price);
        objectSlot.writeToOutput(wtr);
    }

    public function toString():String {
        return "price: " + this.price + " objectSlot: " + objectSlot.toString();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/ObjectDropData.as">
package svera.untiered.messaging.impl.data {
import flash.utils.IDataInput;

public class ObjectDropData {
    public var objectId_:int;
    public var explode_:Boolean;

    public function parseFromInput(data:IDataInput):void {
        this.objectId_ = data.readInt();
        this.explode_ = data.readBoolean();
    }

    public function toString():String {
        return "objectId_: " + this.objectId_ + " explode_: " + this.explode_;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/PlayerShopItem.as">
/**
 * Created by Fabian on 14.07.2015.
 */
package svera.untiered.messaging.impl.data {
import flash.utils.ByteArray;

public class PlayerShopItem {

    public var id:int;
    public var itemId:uint;
    public var price:int;
    public var insertTime:int;
    public var count:int;
    public var isLast:Boolean;

    public function parseFromInput(rdr:ByteArray):void {
        this.id = rdr.readUnsignedInt();
        this.itemId = rdr.readUnsignedShort();
        this.price = rdr.readInt();
        this.insertTime = rdr.readInt();
        this.count = rdr.readInt();
        this.isLast = rdr.readBoolean();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/market/MarketAddResult.as">
package svera.untiered.messaging.impl.incoming.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;


import svera.untiered.messaging.impl.incoming.IncomingMessage;

public class MarketAddResult  extends IncomingMessage
{
    public var code_:int;
    public var description_:String;

    public function MarketAddResult(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function parseFromInput(data:IDataInput) : void
    {
        this.code_ = data.readInt();
        this.description_ = data.readUTF();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/market/MarketBuyResult.as">
package svera.untiered.messaging.impl.incoming.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;


import svera.untiered.messaging.impl.incoming.IncomingMessage;

public class MarketBuyResult  extends IncomingMessage
{
    public var code_:int;
    public var description_:String;
    public var offerId_:int;

    public function MarketBuyResult(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function parseFromInput(data:IDataInput) : void
    {
        this.code_ = data.readInt();
        this.description_ = data.readUTF();
        this.offerId_ = data.readInt();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/market/MarketRemoveResult.as">
package svera.untiered.messaging.impl.incoming.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;


import svera.untiered.messaging.impl.incoming.IncomingMessage;

public class MarketRemoveResult  extends IncomingMessage
{
    public var code_:int;
    public var description_:String;

    public function MarketRemoveResult(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function parseFromInput(data:IDataInput) : void
    {
        this.code_ = data.readInt();
        this.description_ = data.readUTF();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/MarketResult.as">
/**
 * Created by Fabian on 14.07.2015.
 */
package svera.untiered.messaging.impl.incoming {
import flash.utils.ByteArray;

import svera.untiered.messaging.impl.data.PlayerShopItem;

public class MarketResult extends IncomingMessage {

    public static const MARKET_ERROR:int = 0;
    public static const MARKET_SUCCESS:int = 1;
    public static const MARKET_REQUEST_RESULT:int = 2;

    public var commandId:int;
    public var message:String;
    public var error:Boolean;
    public var items:Vector.<PlayerShopItem>;

    public function MarketResult(packetId:uint, callback:Function) {
        this.items = new Vector.<PlayerShopItem>();
        super(packetId, callback);
    }

    override public function parseFromInput(rdr:ByteArray):void {

        commandId = rdr.readByte();
        switch (commandId) {
            case MARKET_ERROR:
            case MARKET_SUCCESS:
                message = rdr.readUTF();
                error = commandId == MARKET_ERROR;
                break;
            case MARKET_REQUEST_RESULT:
                this.items.length = 0;
                var len:int = rdr.readInt();
                for(var i:int = 0; i < len; i++) {
                    var item:PlayerShopItem = new PlayerShopItem();
                    item.parseFromInput(rdr);
                    this.items.push(item);
                }
                break;
        }
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/SetFocus.as">
/**
 * Created by cp-nilly on 6/9/2017.
 */
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class SetFocus extends IncomingMessage {
    public var objectId_:int;

    public function SetFocus(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(_arg1:IDataInput):void {
        this.objectId_ = _arg1.readInt();
    }

    override public function toString():String {
        return formatToString("SET_FOCUS", "objectId_");
    }


}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/SwitchMusic.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class SwitchMusic extends IncomingMessage {

    public var music_:String;

    public function SwitchMusic(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.music_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("SWITCHMUSIC", "music_");
    }


}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/TradeChanged.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class TradeChanged extends IncomingMessage {


    public var offer_:Vector.<Boolean>;

    public function TradeChanged(id:uint, callback:Function) {
        this.offer_ = new Vector.<Boolean>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.offer_.length = 0;
        var num:int = data.readByte();
        for (var i:int = 0; i < num; i++) {
            this.offer_.push(data.readBoolean());
        }
    }

    override public function toString():String {
        return formatToString("TRADECHANGED", "offer_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/TradeDone.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class TradeDone extends IncomingMessage {

    public static const TRADE_SUCCESSFUL:int = 0;

    public static const PLAYER_CANCELED:int = 1;

    public static const TRADE_ERROR:int = 2;


    public var code_:int;

    public var description_:String;

    public function TradeDone(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.code_ = data.readByte();
        switch (code_) {
            case 0:
                description_ = "Trade Successful";
                break;
            case 1:
                description_ = "Trade Canceled";
                break;
            case 2:
                description_ = "An error occurred while trading"
        }
    }

    override public function toString():String {
        return formatToString("TRADEDONE", "code_", "description_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/TradeRequested.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class TradeRequested extends IncomingMessage {
    public var name:String;

    public function TradeRequested(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.name = data.readUTF();
    }

    override public function toString():String {
        return formatToString("TRADEREQUESTED", "name");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/CancelTrade.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class CancelTrade extends OutgoingMessage {
    public function CancelTrade(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
    }

    override public function toString():String {
        return formatToString("CANCELTRADE");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/ChangeTrade.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class ChangeTrade extends OutgoingMessage {


    public var offer_:Vector.<Boolean>;

    public function ChangeTrade(id:uint, callback:Function) {
        this.offer_ = new Vector.<Boolean>();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeByte(this.offer_.length);
        for (var i:int = 0; i < this.offer_.length; i++) {
            data.writeBoolean(this.offer_[i]);
        }
    }

    override public function toString():String {
        return formatToString("CHANGETRADE", "offer_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/market/MarketAdd.as">
package svera.untiered.messaging.impl.outgoing.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.outgoing.OutgoingMessage;

public class MarketAdd extends OutgoingMessage
{
    public var slots_:Vector.<int>;
    public var price_:int;
    public var currency_:int;
    public var hours_:int;

    public function MarketAdd(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function writeToOutput(data:IDataOutput) : void
    {
        data.writeByte(this.slots_.length);
        for (var i:int = 0; i < this.slots_.length; i++)
        {
            data.writeByte(this.slots_[i]);
        }
        data.writeInt(this.price_);
        data.writeInt(this.currency_);
        data.writeInt(this.hours_);
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/market/MarketAll.as">
package svera.untiered.messaging.impl.outgoing.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.outgoing.OutgoingMessage;

public class MarketAll extends OutgoingMessage
{

    public function MarketAll(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function writeToOutput(data:IDataOutput) : void
    {

    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/market/MarketBuy.as">
package svera.untiered.messaging.impl.outgoing.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.outgoing.OutgoingMessage;

public class MarketBuy extends OutgoingMessage
{
    public var id_:int;

    public function MarketBuy(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function writeToOutput(data:IDataOutput) : void
    {
        data.writeInt(this.id_);
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/market/MarketMyOffers.as">
package svera.untiered.messaging.impl.outgoing.market
{

import flash.utils.ByteArray;
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.outgoing.OutgoingMessage;

public class MarketMyOffers extends OutgoingMessage
{

    public function MarketMyOffers(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function writeToOutput(data:IDataOutput) : void
    {
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/market/MarketRemove.as">
package svera.untiered.messaging.impl.outgoing.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.outgoing.OutgoingMessage;

public class MarketRemove extends OutgoingMessage
{
    public var id_:int;

    public function MarketRemove(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function writeToOutput(data:IDataOutput) : void
    {
        data.writeInt(this.id_);
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/market/MarketSearch.as">
package svera.untiered.messaging.impl.outgoing.market
{

import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.outgoing.OutgoingMessage;

public class MarketSearch extends OutgoingMessage
{
    public var itemType_:int;

    public function MarketSearch(id:uint, callback:Function)
    {
        super(id,callback);
    }

    override public function writeToOutput(data:IDataOutput) : void
    {
        data.writeInt(this.itemType_);
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/TradeRequest.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class TradeRequest extends OutgoingMessage {
    public var name:String;

    public function TradeRequest(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.name);
    }

    override public function toString():String {
        return formatToString("TRADEREQUEST", "name");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/OutstandingBuy.as">
package svera.untiered.messaging.impl {
public class OutstandingBuy {


    private var id_:String;

    public var price_:int;

    public var currency_:int;

    function OutstandingBuy(id:String, price:int, currency:int) {
        super();
        this.id_ = id;
        this.price_ = price;
        this.currency_ = currency;
    }
}
}
</file>

<file path="src/svera/untiered/minimap/model/UpdateGroundTileVO.as">
package svera.untiered.minimap.model {
public class UpdateGroundTileVO {


    public var tileX:int;

    public var tileY:int;

    public var tileType:uint;

    public function UpdateGroundTileVO(tileX:int, tileY:int, tileType:uint) {
        super();
        this.tileX = tileX;
        this.tileY = tileY;
        this.tileType = tileType;
    }
}
}
</file>

<file path="src/svera/untiered/Particles/Recallingbase.as">
package svera.untiered.Particles {
import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class Recallingbase extends GIF {
    [Embed(source="Recallingbase_0.png")]
    private const Recallingbase_0:Class;
    [Embed(source="Recallingbase_1.png")]
    private const Recallingbase_1:Class;
    [Embed(source="Recallingbase_2.png")]
    private const Recallingbase_2:Class;
    [Embed(source="Recallingbase_3.png")]
    private const Recallingbase_3:Class;
    [Embed(source="Recallingbase_00.png")]
    private const Recallingbase_00:Class;
    [Embed(source="Recallingbase_11.png")]
    private const Recallingbase_11:Class;
    [Embed(source="Recallingbase_22.png")]
    private const Recallingbase_22:Class;
    [Embed(source="Recallingbase_33.png")]
    private const Recallingbase_33:Class;

    public function Recallingbase() {
        super(100, new <BitmapAsset>[
            new this.Recallingbase_0 as BitmapAsset,
            new this.Recallingbase_1 as BitmapAsset,
            new this.Recallingbase_2 as BitmapAsset,
            new this.Recallingbase_3 as BitmapAsset,
            new this.Recallingbase_00 as BitmapAsset,
            new this.Recallingbase_11 as BitmapAsset,
            new this.Recallingbase_22 as BitmapAsset,
            new this.Recallingbase_33 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/storage/signals/GiftSlotUpdateSignal.as">
package svera.untiered.storage.signals {
import org.osflash.signals.Signal;

public class GiftSlotUpdateSignal extends Signal {
    public function GiftSlotUpdateSignal() {
        super(int, int, int);
    }
}
}
</file>

<file path="src/svera/untiered/traits/background.as">
package svera.untiered.traits {
import mx.core.*;

[Embed(source="background.png")]
public class background extends BitmapAsset {
    public function background() {
        super();

    }
}
}
</file>

<file path="src/svera/untiered/ui/commands/ShowSplashUICommand.as">
package svera.untiered.ui.commands {
import svera.lib.framework.ICommand;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.ui.view.SplashView;

public class ShowSplashUICommand implements ICommand {
    [Inject]
    public var setScreen:SetScreenSignal;

    public function ShowSplashUICommand() {
        super();
    }

    public function execute():void {
        this.setScreen.dispatch(new SplashView());
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/ShowSplashUISignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class ShowSplashUISignal extends Signal {
    public function ShowSplashUISignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/SplashMediator.as">
package svera.untiered.ui.view {
import svera.lib.framework.Mediator;

import svera.untiered.startup.control.StartupSequence;

public class SplashMediator extends Mediator {
    [Inject]
    public var view:SplashView;

    [Inject]
    public var startup:StartupSequence;

    public function SplashMediator() {
        super();
        trace("SplashMediator: Constructor called");
    }

    override public function initialize():void {
        trace("SplashMediator: Initialize called");
        this.view.fadeCompleted.add(this.onSplashComplete);
        trace("SplashMediator: fadeCompleted listener added");
    }

    override public function destroy():void {
        trace("SplashMediator: Destroy called");
        this.view.fadeCompleted.remove(this.onSplashComplete);
        this.view.destroy();
    }

    private function onSplashComplete():void {
        trace("SplashMediator: Splash completed, starting main startup sequence");
        // Start the main startup sequence after splash completes
        this.startup.start();
        trace("SplashMediator: Startup sequence started");
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/tiernotifications/CelestialPopup.as">
package svera.untiered.ui.view.tiernotifications {

import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class CelestialPopup extends GIF {
    [Embed(source="celestial/Celestial_Frame_1.png")]
    private const Celestial_frame_1:Class;
    [Embed(source="celestial/Celestial_Frame_2.png")]
    private const Celestial_frame_2:Class;
    [Embed(source="celestial/Celestial_Frame_3.png")]
    private const Celestial_frame_3:Class;
    [Embed(source="celestial/Celestial_Frame_4.png")]
    private const Celestial_frame_4:Class;
    [Embed(source="celestial/Celestial_Frame_5.png")]
    private const Celestial_frame_5:Class;
    [Embed(source="celestial/Celestial_Frame_6.png")]
    private const Celestial_frame_6:Class;
    [Embed(source="celestial/Celestial_Frame_7.png")]
    private const Celestial_frame_7:Class;
    [Embed(source="celestial/Celestial_Frame_8.png")]
    private const Celestial_frame_8:Class;
    [Embed(source="celestial/Celestial_Frame_9.png")]
    private const Celestial_frame_9:Class;
    [Embed(source="celestial/Celestial_Frame_10.png")]
    private const Celestial_frame_10:Class;
    [Embed(source="celestial/Celestial_Frame_11.png")]
    private const Celestial_frame_11:Class;
    [Embed(source="celestial/Celestial_Frame_12.png")]
    private const Celestial_frame_12:Class;
    [Embed(source="celestial/Celestial_Frame_13.png")]
    private const Celestial_frame_13:Class;
    [Embed(source="celestial/Celestial_Frame_14.png")]
    private const Celestial_frame_14:Class;
    [Embed(source="celestial/Celestial_Frame_15.png")]
    private const Celestial_frame_15:Class;
    [Embed(source="celestial/Celestial_Frame_16.png")]
    private const Celestial_frame_16:Class;
    [Embed(source="celestial/Celestial_Frame_17.png")]
    private const Celestial_frame_17:Class;
    [Embed(source="celestial/Celestial_Frame_18.png")]
    private const Celestial_frame_18:Class;
    [Embed(source="celestial/Celestial_Frame_19.png")]
    private const Celestial_frame_19:Class;
    [Embed(source="celestial/Celestial_Frame_20.png")]
    private const Celestial_frame_20:Class;
    [Embed(source="celestial/Celestial_Frame_21.png")]
    private const Celestial_frame_21:Class;
    [Embed(source="celestial/Celestial_Frame_22.png")]
    private const Celestial_frame_22:Class;
    [Embed(source="celestial/Celestial_Frame_23.png")]
    private const Celestial_frame_23:Class;
    [Embed(source="celestial/Celestial_Frame_24.png")]
    private const Celestial_frame_24:Class;
    [Embed(source="celestial/Celestial_Frame_25.png")]
    private const Celestial_frame_25:Class;
    [Embed(source="celestial/Celestial_Frame_26.png")]
    private const Celestial_frame_26:Class;
    [Embed(source="celestial/Celestial_Frame_27.png")]
    private const Celestial_frame_27:Class;
    [Embed(source="celestial/Celestial_Frame_28.png")]
    private const Celestial_frame_28:Class;
    [Embed(source="celestial/Celestial_Frame_29.png")]
    private const Celestial_frame_29:Class;
    [Embed(source="celestial/Celestial_Frame_30.png")]
    private const Celestial_frame_30:Class;
    [Embed(source="celestial/Celestial_Frame_31.png")]
    private const Celestial_frame_31:Class;
    [Embed(source="celestial/Celestial_Frame_32.png")]
    private const Celestial_frame_32:Class;

    public function CelestialPopup() {
        super(100, new <BitmapAsset>[
            new this.Celestial_frame_1 as BitmapAsset,
            new this.Celestial_frame_2 as BitmapAsset,
            new this.Celestial_frame_3 as BitmapAsset,
            new this.Celestial_frame_4 as BitmapAsset,
            new this.Celestial_frame_5 as BitmapAsset,
            new this.Celestial_frame_6 as BitmapAsset,
            new this.Celestial_frame_7 as BitmapAsset,
            new this.Celestial_frame_8 as BitmapAsset,
            new this.Celestial_frame_9 as BitmapAsset,
            new this.Celestial_frame_10 as BitmapAsset,
            new this.Celestial_frame_11 as BitmapAsset,
            new this.Celestial_frame_12 as BitmapAsset,
            new this.Celestial_frame_13 as BitmapAsset,
            new this.Celestial_frame_14 as BitmapAsset,
            new this.Celestial_frame_15 as BitmapAsset,
            new this.Celestial_frame_16 as BitmapAsset,
            new this.Celestial_frame_17 as BitmapAsset,
            new this.Celestial_frame_18 as BitmapAsset,
            new this.Celestial_frame_19 as BitmapAsset,
            new this.Celestial_frame_20 as BitmapAsset,
            new this.Celestial_frame_21 as BitmapAsset,
            new this.Celestial_frame_22 as BitmapAsset,
            new this.Celestial_frame_23 as BitmapAsset,
            new this.Celestial_frame_24 as BitmapAsset,
            new this.Celestial_frame_25 as BitmapAsset,
            new this.Celestial_frame_26 as BitmapAsset,
            new this.Celestial_frame_27 as BitmapAsset,
            new this.Celestial_frame_28 as BitmapAsset,
            new this.Celestial_frame_29 as BitmapAsset,
            new this.Celestial_frame_30 as BitmapAsset,
            new this.Celestial_frame_31 as BitmapAsset,
            new this.Celestial_frame_32 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/tiernotifications/ExiledPopup.as">
package svera.untiered.ui.view.tiernotifications {

import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class ExiledPopup extends GIF {
    [Embed(source="exiled/Exiled_Frame_1.png")]
    private const Exiled_frame_1:Class;
    [Embed(source="exiled/Exiled_Frame_2.png")]
    private const Exiled_frame_2:Class;
    [Embed(source="exiled/Exiled_Frame_3.png")]
    private const Exiled_frame_3:Class;
    [Embed(source="exiled/Exiled_Frame_4.png")]
    private const Exiled_frame_4:Class;
    [Embed(source="exiled/Exiled_Frame_5.png")]
    private const Exiled_frame_5:Class;
    [Embed(source="exiled/Exiled_Frame_6.png")]
    private const Exiled_frame_6:Class;
    [Embed(source="exiled/Exiled_Frame_7.png")]
    private const Exiled_frame_7:Class;
    [Embed(source="exiled/Exiled_Frame_8.png")]
    private const Exiled_frame_8:Class;
    [Embed(source="exiled/Exiled_Frame_9.png")]
    private const Exiled_frame_9:Class;
    [Embed(source="exiled/Exiled_Frame_10.png")]
    private const Exiled_frame_10:Class;
    [Embed(source="exiled/Exiled_Frame_11.png")]
    private const Exiled_frame_11:Class;
    [Embed(source="exiled/Exiled_Frame_12.png")]
    private const Exiled_frame_12:Class;
    [Embed(source="exiled/Exiled_Frame_13.png")]
    private const Exiled_frame_13:Class;
    [Embed(source="exiled/Exiled_Frame_14.png")]
    private const Exiled_frame_14:Class;
    [Embed(source="exiled/Exiled_Frame_15.png")]
    private const Exiled_frame_15:Class;
    [Embed(source="exiled/Exiled_Frame_16.png")]
    private const Exiled_frame_16:Class;
    [Embed(source="exiled/Exiled_Frame_17.png")]
    private const Exiled_frame_17:Class;
    [Embed(source="exiled/Exiled_Frame_18.png")]
    private const Exiled_frame_18:Class;
    [Embed(source="exiled/Exiled_Frame_19.png")]
    private const Exiled_frame_19:Class;
    [Embed(source="exiled/Exiled_Frame_20.png")]
    private const Exiled_frame_20:Class;
    [Embed(source="exiled/Exiled_Frame_21.png")]
    private const Exiled_frame_21:Class;
    [Embed(source="exiled/Exiled_Frame_22.png")]
    private const Exiled_frame_22:Class;
    [Embed(source="exiled/Exiled_Frame_23.png")]
    private const Exiled_frame_23:Class;
    [Embed(source="exiled/Exiled_Frame_24.png")]
    private const Exiled_frame_24:Class;
    [Embed(source="exiled/Exiled_Frame_25.png")]
    private const Exiled_frame_25:Class;
    [Embed(source="exiled/Exiled_Frame_26.png")]
    private const Exiled_frame_26:Class;
    [Embed(source="exiled/Exiled_Frame_27.png")]
    private const Exiled_frame_27:Class;
    [Embed(source="exiled/Exiled_Frame_28.png")]
    private const Exiled_frame_28:Class;
    [Embed(source="exiled/Exiled_Frame_29.png")]
    private const Exiled_frame_29:Class;
    [Embed(source="exiled/Exiled_Frame_30.png")]
    private const Exiled_frame_30:Class;
    [Embed(source="exiled/Exiled_Frame_31.png")]
    private const Exiled_frame_31:Class;
    [Embed(source="exiled/Exiled_Frame_32.png")]
    private const Exiled_frame_32:Class;

    public function ExiledPopup() {
        super(100, new <BitmapAsset>[
            new this.Exiled_frame_1 as BitmapAsset,
            new this.Exiled_frame_2 as BitmapAsset,
            new this.Exiled_frame_3 as BitmapAsset,
            new this.Exiled_frame_4 as BitmapAsset,
            new this.Exiled_frame_5 as BitmapAsset,
            new this.Exiled_frame_6 as BitmapAsset,
            new this.Exiled_frame_7 as BitmapAsset,
            new this.Exiled_frame_8 as BitmapAsset,
            new this.Exiled_frame_9 as BitmapAsset,
            new this.Exiled_frame_10 as BitmapAsset,
            new this.Exiled_frame_11 as BitmapAsset,
            new this.Exiled_frame_12 as BitmapAsset,
            new this.Exiled_frame_13 as BitmapAsset,
            new this.Exiled_frame_14 as BitmapAsset,
            new this.Exiled_frame_15 as BitmapAsset,
            new this.Exiled_frame_16 as BitmapAsset,
            new this.Exiled_frame_17 as BitmapAsset,
            new this.Exiled_frame_18 as BitmapAsset,
            new this.Exiled_frame_19 as BitmapAsset,
            new this.Exiled_frame_20 as BitmapAsset,
            new this.Exiled_frame_21 as BitmapAsset,
            new this.Exiled_frame_22 as BitmapAsset,
            new this.Exiled_frame_23 as BitmapAsset,
            new this.Exiled_frame_24 as BitmapAsset,
            new this.Exiled_frame_25 as BitmapAsset,
            new this.Exiled_frame_26 as BitmapAsset,
            new this.Exiled_frame_27 as BitmapAsset,
            new this.Exiled_frame_28 as BitmapAsset,
            new this.Exiled_frame_29 as BitmapAsset,
            new this.Exiled_frame_30 as BitmapAsset,
            new this.Exiled_frame_31 as BitmapAsset,
            new this.Exiled_frame_32 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/tiernotifications/RelicPopup.as">
package svera.untiered.ui.view.tiernotifications {
import mx.core.*;

import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class RelicPopup extends GIF {
    [Embed(source="relic/Relic_Frame_1.png")]
    private const Relic_frame_1:Class;
    [Embed(source="relic/Relic_Frame_2.png")]
    private const Relic_frame_2:Class;
    [Embed(source="relic/Relic_Frame_3.png")]
    private const Relic_frame_3:Class;
    [Embed(source="relic/Relic_Frame_4.png")]
    private const Relic_frame_4:Class;
    [Embed(source="relic/Relic_Frame_5.png")]
    private const Relic_frame_5:Class;
    [Embed(source="relic/Relic_Frame_6.png")]
    private const Relic_frame_6:Class;
    [Embed(source="relic/Relic_Frame_7.png")]
    private const Relic_frame_7:Class;
    [Embed(source="relic/Relic_Frame_8.png")]
    private const Relic_frame_8:Class;
    [Embed(source="relic/Relic_Frame_9.png")]
    private const Relic_frame_9:Class;
    [Embed(source="relic/Relic_Frame_10.png")]
    private const Relic_frame_10:Class;
    [Embed(source="relic/Relic_Frame_11.png")]
    private const Relic_frame_11:Class;
    [Embed(source="relic/Relic_Frame_12.png")]
    private const Relic_frame_12:Class;
    [Embed(source="relic/Relic_Frame_13.png")]
    private const Relic_frame_13:Class;
    [Embed(source="relic/Relic_Frame_14.png")]
    private const Relic_frame_14:Class;
    [Embed(source="relic/Relic_Frame_15.png")]
    private const Relic_frame_15:Class;
    [Embed(source="relic/Relic_Frame_16.png")]
    private const Relic_frame_16:Class;

    public function RelicPopup() {
        super(100, new <BitmapAsset>[
            new this.Relic_frame_1 as BitmapAsset,
            new this.Relic_frame_2 as BitmapAsset,
            new this.Relic_frame_3 as BitmapAsset,
            new this.Relic_frame_4 as BitmapAsset,
            new this.Relic_frame_5 as BitmapAsset,
            new this.Relic_frame_6 as BitmapAsset,
            new this.Relic_frame_7 as BitmapAsset,
            new this.Relic_frame_8 as BitmapAsset,
            new this.Relic_frame_9 as BitmapAsset,
            new this.Relic_frame_10 as BitmapAsset,
            new this.Relic_frame_11 as BitmapAsset,
            new this.Relic_frame_12 as BitmapAsset,
            new this.Relic_frame_13 as BitmapAsset,
            new this.Relic_frame_14 as BitmapAsset,
            new this.Relic_frame_15 as BitmapAsset,
            new this.Relic_frame_16 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/tiernotifications/TarnishedPopup.as">
package svera.untiered.ui.view.tiernotifications {
import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class TarnishedPopup extends GIF {
    [Embed(source="tarnished/Tarnished_Frame_1.png")]
    private const Tarnished_frame_1:Class;
    [Embed(source="tarnished/Tarnished_Frame_2.png")]
    private const Tarnished_frame_2:Class;
    [Embed(source="tarnished/Tarnished_Frame_3.png")]
    private const Tarnished_frame_3:Class;
    [Embed(source="tarnished/Tarnished_Frame_4.png")]
    private const Tarnished_frame_4:Class;
    [Embed(source="tarnished/Tarnished_Frame_5.png")]
    private const Tarnished_frame_5:Class;
    [Embed(source="tarnished/Tarnished_Frame_6.png")]
    private const Tarnished_frame_6:Class;
    [Embed(source="tarnished/Tarnished_Frame_7.png")]
    private const Tarnished_frame_7:Class;
    [Embed(source="tarnished/Tarnished_Frame_8.png")]
    private const Tarnished_frame_8:Class;
    [Embed(source="tarnished/Tarnished_Frame_9.png")]
    private const Tarnished_frame_9:Class;
    [Embed(source="tarnished/Tarnished_Frame_10.png")]
    private const Tarnished_frame_10:Class;
    [Embed(source="tarnished/Tarnished_Frame_11.png")]
    private const Tarnished_frame_11:Class;
    [Embed(source="tarnished/Tarnished_Frame_12.png")]
    private const Tarnished_frame_12:Class;
    [Embed(source="tarnished/Tarnished_Frame_13.png")]
    private const Tarnished_frame_13:Class;
    [Embed(source="tarnished/Tarnished_Frame_14.png")]
    private const Tarnished_frame_14:Class;
    [Embed(source="tarnished/Tarnished_Frame_15.png")]
    private const Tarnished_frame_15:Class;
    [Embed(source="tarnished/Tarnished_Frame_16.png")]
    private const Tarnished_frame_16:Class;
    [Embed(source="tarnished/Tarnished_Frame_17.png")]
    private const Tarnished_frame_17:Class;
    [Embed(source="tarnished/Tarnished_Frame_18.png")]
    private const Tarnished_frame_18:Class;
    [Embed(source="tarnished/Tarnished_Frame_19.png")]
    private const Tarnished_frame_19:Class;
    [Embed(source="tarnished/Tarnished_Frame_20.png")]
    private const Tarnished_frame_20:Class;
    [Embed(source="tarnished/Tarnished_Frame_21.png")]
    private const Tarnished_frame_21:Class;
    [Embed(source="tarnished/Tarnished_Frame_22.png")]
    private const Tarnished_frame_22:Class;
    [Embed(source="tarnished/Tarnished_Frame_23.png")]
    private const Tarnished_frame_23:Class;
    [Embed(source="tarnished/Tarnished_Frame_24.png")]
    private const Tarnished_frame_24:Class;

    public function TarnishedPopup() {
        super(100, new <BitmapAsset>[
            new this.Tarnished_frame_1 as BitmapAsset,
            new this.Tarnished_frame_2 as BitmapAsset,
            new this.Tarnished_frame_3 as BitmapAsset,
            new this.Tarnished_frame_4 as BitmapAsset,
            new this.Tarnished_frame_5 as BitmapAsset,
            new this.Tarnished_frame_6 as BitmapAsset,
            new this.Tarnished_frame_7 as BitmapAsset,
            new this.Tarnished_frame_8 as BitmapAsset,
            new this.Tarnished_frame_9 as BitmapAsset,
            new this.Tarnished_frame_10 as BitmapAsset,
            new this.Tarnished_frame_11 as BitmapAsset,
            new this.Tarnished_frame_12 as BitmapAsset,
            new this.Tarnished_frame_13 as BitmapAsset,
            new this.Tarnished_frame_14 as BitmapAsset,
            new this.Tarnished_frame_15 as BitmapAsset,
            new this.Tarnished_frame_16 as BitmapAsset,
            new this.Tarnished_frame_17 as BitmapAsset,
            new this.Tarnished_frame_18 as BitmapAsset,
            new this.Tarnished_frame_19 as BitmapAsset,
            new this.Tarnished_frame_20 as BitmapAsset,
            new this.Tarnished_frame_21 as BitmapAsset,
            new this.Tarnished_frame_22 as BitmapAsset,
            new this.Tarnished_frame_23 as BitmapAsset,
            new this.Tarnished_frame_24 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/tiernotifications/UncommonPopup.as">
package svera.untiered.ui.view.tiernotifications {

import mx.core.*;

import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class UncommonPopup extends GIF {
    [Embed(source="uncommon/Uncommon_Frame_1.png")]
    private const Uncommon_frame_1:Class;
    [Embed(source="uncommon/Uncommon_Frame_2.png")]
    private const Uncommon_frame_2:Class;
    [Embed(source="uncommon/Uncommon_Frame_3.png")]
    private const Uncommon_frame_3:Class;
    [Embed(source="uncommon/Uncommon_Frame_4.png")]
    private const Uncommon_frame_4:Class;
    [Embed(source="uncommon/Uncommon_Frame_5.png")]
    private const Uncommon_frame_5:Class;
    [Embed(source="uncommon/Uncommon_Frame_6.png")]
    private const Uncommon_frame_6:Class;
    [Embed(source="uncommon/Uncommon_Frame_7.png")]
    private const Uncommon_frame_7:Class;
    [Embed(source="uncommon/Uncommon_Frame_8.png")]
    private const Uncommon_frame_8:Class;
    [Embed(source="uncommon/Uncommon_Frame_9.png")]
    private const Uncommon_frame_9:Class;
    [Embed(source="uncommon/Uncommon_Frame_10.png")]
    private const Uncommon_frame_10:Class;
    [Embed(source="uncommon/Uncommon_Frame_11.png")]
    private const Uncommon_frame_11:Class;
    [Embed(source="uncommon/Uncommon_Frame_12.png")]
    private const Uncommon_frame_12:Class;
    [Embed(source="uncommon/Uncommon_Frame_13.png")]
    private const Uncommon_frame_13:Class;
    [Embed(source="uncommon/Uncommon_Frame_14.png")]
    private const Uncommon_frame_14:Class;
    [Embed(source="uncommon/Uncommon_Frame_15.png")]
    private const Uncommon_frame_15:Class;
    [Embed(source="uncommon/Uncommon_Frame_16.png")]
    private const Uncommon_frame_16:Class;

    public function UncommonPopup() {
        super(100, new <BitmapAsset>[
            new this.Uncommon_frame_1 as BitmapAsset,
            new this.Uncommon_frame_2 as BitmapAsset,
            new this.Uncommon_frame_3 as BitmapAsset,
            new this.Uncommon_frame_4 as BitmapAsset,
            new this.Uncommon_frame_5 as BitmapAsset,
            new this.Uncommon_frame_6 as BitmapAsset,
            new this.Uncommon_frame_7 as BitmapAsset,
            new this.Uncommon_frame_8 as BitmapAsset,
            new this.Uncommon_frame_9 as BitmapAsset,
            new this.Uncommon_frame_10 as BitmapAsset,
            new this.Uncommon_frame_11 as BitmapAsset,
            new this.Uncommon_frame_12 as BitmapAsset,
            new this.Uncommon_frame_13 as BitmapAsset,
            new this.Uncommon_frame_14 as BitmapAsset,
            new this.Uncommon_frame_15 as BitmapAsset,
            new this.Uncommon_frame_16 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/tiernotifications/ValiantPopup.as">
package svera.untiered.ui.view.tiernotifications {

import mx.core.*;

import mx.core.BitmapAsset;

import svera.lib.util.GIF;

public class ValiantPopup extends GIF {
    [Embed(source="valiant/Valiant_Frame_1.png")]
    private const Valiant_frame_1:Class;
    [Embed(source="valiant/Valiant_Frame_2.png")]
    private const Valiant_frame_2:Class;
    [Embed(source="valiant/Valiant_Frame_3.png")]
    private const Valiant_frame_3:Class;
    [Embed(source="valiant/Valiant_Frame_4.png")]
    private const Valiant_frame_4:Class;
    [Embed(source="valiant/Valiant_Frame_5.png")]
    private const Valiant_frame_5:Class;
    [Embed(source="valiant/Valiant_Frame_6.png")]
    private const Valiant_frame_6:Class;
    [Embed(source="valiant/Valiant_Frame_7.png")]
    private const Valiant_frame_7:Class;
    [Embed(source="valiant/Valiant_Frame_8.png")]
    private const Valiant_frame_8:Class;
    [Embed(source="valiant/Valiant_Frame_9.png")]
    private const Valiant_frame_9:Class;
    [Embed(source="valiant/Valiant_Frame_10.png")]
    private const Valiant_frame_10:Class;
    [Embed(source="valiant/Valiant_Frame_11.png")]
    private const Valiant_frame_11:Class;
    [Embed(source="valiant/Valiant_Frame_12.png")]
    private const Valiant_frame_12:Class;
    [Embed(source="valiant/Valiant_Frame_13.png")]
    private const Valiant_frame_13:Class;
    [Embed(source="valiant/Valiant_Frame_14.png")]
    private const Valiant_frame_14:Class;
    [Embed(source="valiant/Valiant_Frame_15.png")]
    private const Valiant_frame_15:Class;
    [Embed(source="valiant/Valiant_Frame_16.png")]
    private const Valiant_frame_16:Class;
    [Embed(source="valiant/Valiant_Frame_17.png")]
    private const Valiant_frame_17:Class;
    [Embed(source="valiant/Valiant_Frame_18.png")]
    private const Valiant_frame_18:Class;
    [Embed(source="valiant/Valiant_Frame_19.png")]
    private const Valiant_frame_19:Class;
    [Embed(source="valiant/Valiant_Frame_20.png")]
    private const Valiant_frame_20:Class;
    [Embed(source="valiant/Valiant_Frame_21.png")]
    private const Valiant_frame_21:Class;
    [Embed(source="valiant/Valiant_Frame_22.png")]
    private const Valiant_frame_22:Class;
    [Embed(source="valiant/Valiant_Frame_23.png")]
    private const Valiant_frame_23:Class;
    [Embed(source="valiant/Valiant_Frame_24.png")]
    private const Valiant_frame_24:Class;

    public function ValiantPopup() {
        super(100, new <BitmapAsset>[
            new this.Valiant_frame_1 as BitmapAsset,
            new this.Valiant_frame_2 as BitmapAsset,
            new this.Valiant_frame_3 as BitmapAsset,
            new this.Valiant_frame_4 as BitmapAsset,
            new this.Valiant_frame_5 as BitmapAsset,
            new this.Valiant_frame_6 as BitmapAsset,
            new this.Valiant_frame_7 as BitmapAsset,
            new this.Valiant_frame_8 as BitmapAsset,
            new this.Valiant_frame_9 as BitmapAsset,
            new this.Valiant_frame_10 as BitmapAsset,
            new this.Valiant_frame_11 as BitmapAsset,
            new this.Valiant_frame_12 as BitmapAsset,
            new this.Valiant_frame_13 as BitmapAsset,
            new this.Valiant_frame_14 as BitmapAsset,
            new this.Valiant_frame_15 as BitmapAsset,
            new this.Valiant_frame_16 as BitmapAsset,
            new this.Valiant_frame_17 as BitmapAsset,
            new this.Valiant_frame_18 as BitmapAsset,
            new this.Valiant_frame_19 as BitmapAsset,
            new this.Valiant_frame_20 as BitmapAsset,
            new this.Valiant_frame_21 as BitmapAsset,
            new this.Valiant_frame_22 as BitmapAsset,
            new this.Valiant_frame_23 as BitmapAsset,
            new this.Valiant_frame_24 as BitmapAsset
        ]);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/HorizontalScrollbar.as">
package svera.untiered.util.components {
import svera.untiered.util.components.api.*;

import flash.display.Sprite;

import org.osflash.signals.Signal;

import svera.lib.ui.api.Scrollbar;

public class HorizontalScrollbar extends Sprite implements Scrollbar {
    public static const HEIGHT:int = 20;
    public static const BEVEL:int = 4;
    public static const PADDING:int = 0;

    private var _positionChanged:Signal;
    public const groove:HorizontalScrollbarGroove = new HorizontalScrollbarGroove();
    public const bar:HorizontalScrollbarBar = new HorizontalScrollbarBar();

    private var position:Number = 0;
    private var range:int;
    private var invRange:Number;
    private var isEnabled:Boolean = true;

    public function HorizontalScrollbar() {
        super();
        addChild(this.groove);
        addChild(this.bar);
        this.addMouseListeners();
    }

    public function get positionChanged():Signal {
        return this._positionChanged = this._positionChanged || new Signal(Number);
    }

    public function getIsEnabled():Boolean {
        return this.isEnabled;
    }

    public function setIsEnabled(isEnabled:Boolean):void {
        if (this.isEnabled != isEnabled) {
            this.isEnabled = isEnabled;
            if (isEnabled) {
                this.addMouseListeners();
            } else {
                this.removeMouseListeners();
            }
        }
    }

    private function addMouseListeners():void {
        this.groove.addMouseListeners();
        this.groove.clicked.add(this.onGrooveClicked);
        this.bar.addMouseListeners();
        this.bar.dragging.add(this.onBarDrag);
    }

    private function removeMouseListeners():void {
        this.groove.removeMouseListeners();
        this.groove.clicked.remove(this.onGrooveClicked);
        this.bar.removeMouseListeners();
        this.bar.dragging.remove(this.onBarDrag);
    }

    public function setSize(barSize:int, grooveSize:int):void {
        this.bar.rect.width = barSize;
        this.groove.rect.width = grooveSize;
        this.range = grooveSize - barSize - PADDING * 2;
        this.invRange = 1 / this.range;
        this.groove.redraw();
        this.bar.redraw();
        this.setPosition(this.getPosition());
    }

    public function getBarSize():int {
        return this.bar.rect.width;
    }

    public function getGrooveSize():int {
        return this.groove.rect.width;
    }

    public function getPosition():Number {
        return this.position;
    }

    public function setPosition(value:Number):void {
        if (value < 0) {
            value = 0;
        } else if (value > 1) {
            value = 1;
        }
        this.position = value;
        this.bar.x = PADDING + this.range * this.position;
        this._positionChanged && this._positionChanged.dispatch(this.position);
    }

    public function scrollPosition(value:Number):void {
        var position:Number = this.position + value;
        this.setPosition(position);
    }

    private function onBarDrag(value:int):void {
        this.setPosition((value - PADDING) * this.invRange);
    }

    private function onGrooveClicked(value:int):void {
        var barWidth:int = this.bar.rect.width;
        var numerator:int = value - barWidth * 0.5;
        var denominator:int = this.groove.rect.width - barWidth;
        this.setPosition(numerator / denominator);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/HorizontalScrollbarBar.as">
package svera.untiered.util.components {
import svera.untiered.util.components.*;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.util.graphics.BevelRect;
import svera.untiered.util.graphics.GraphicsHelper;

public final class HorizontalScrollbarBar extends Sprite {
    public static const HEIGHT:int = HorizontalScrollbar.HEIGHT;
    public static const BEVEL:int = HorizontalScrollbar.BEVEL;
    public static const PADDING:int = HorizontalScrollbar.PADDING;

    public const dragging:Signal = new Signal(int);
    public const rect:BevelRect = new BevelRect(0, HEIGHT - PADDING * 2, BEVEL);
    private const helper:GraphicsHelper = new GraphicsHelper();
    private var downOffset:Number;
    private var isOver:Boolean;
    private var isDown:Boolean;

    function HorizontalScrollbarBar() {
        super();
    }

    public function redraw():void {
        var color:int = this.isOver || this.isDown ? int(16767876) : int(13421772);
        graphics.clear();
        graphics.beginFill(color);
        this.helper.drawBevelRect(0, PADDING, this.rect, graphics);
        graphics.endFill();
    }

    public function addMouseListeners():void {
        addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
    }

    public function removeMouseListeners():void {
        removeEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        removeEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        this.onMouseUp();
    }

    private function onMouseDown(event:MouseEvent = null):void {
        this.isDown = true;
        this.downOffset = parent.mouseX - x;
        stage.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        addEventListener(Event.ENTER_FRAME, this.iterate);
        this.redraw();
    }

    private function onMouseUp(event:MouseEvent = null):void {
        this.isDown = false;
        stage.removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        removeEventListener(Event.ENTER_FRAME, this.iterate);
        this.redraw();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.isOver = true;
        this.redraw();
    }

    private function onMouseOut(event:MouseEvent):void {
        this.isOver = false;
        this.redraw();
    }

    private function iterate(event:Event):void {
        this.dragging.dispatch(int(parent.mouseX - this.downOffset));
    }
}
}
</file>

<file path="src/svera/untiered/util/components/HorizontalScrollbarGroove.as">
package svera.untiered.util.components {
import svera.untiered.util.components.*;

import flash.display.Sprite;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.util.graphics.BevelRect;
import svera.untiered.util.graphics.GraphicsHelper;

public final class HorizontalScrollbarGroove extends Sprite {

    public static const HEIGHT:int = HorizontalScrollbar.HEIGHT;

    public static const BEVEL:int = HorizontalScrollbar.BEVEL + HorizontalScrollbar.PADDING * 0.5;


    public const clicked:Signal = new Signal(int);

    public const rect:BevelRect = new BevelRect(0, HEIGHT, BEVEL);

    private const helper:GraphicsHelper = new GraphicsHelper();

    function HorizontalScrollbarGroove() {
        super();
    }

    public function redraw():void {
        graphics.clear();
        graphics.beginFill(5526612);
        this.helper.drawBevelRect(0, 0, this.rect, graphics);
        graphics.endFill();
    }

    public function addMouseListeners():void {
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function removeMouseListeners():void {
        removeEventListener(MouseEvent.CLICK, this.onClick);
    }

    private function onClick(event:MouseEvent):void {
        this.clicked.dispatch(int(mouseY));
    }
}
}
</file>

<file path="src/svera/untiered/util/graphics/BevelRect.as">
package svera.untiered.util.graphics {
public class BevelRect {


    public var topLeftBevel:Boolean = true;

    public var topRightBevel:Boolean = true;

    public var bottomLeftBevel:Boolean = true;

    public var bottomRightBevel:Boolean = true;

    public var width:int;

    public var height:int;

    public var bevel:int;

    public function BevelRect(width:int, height:int, bevel:int) {
        super();
        this.width = width;
        this.height = height;
        this.bevel = bevel;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/TextInputField.as">
package com.company.assembleegameclient.account.ui {
import com.company.ui.SimpleText;

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

public class TextInputField extends Sprite {

    public static const HEIGHT:int = 88;


    public var nameText_:SimpleText;

    public var inputText_:SimpleText;

    public var errorText_:SimpleText;

    public function TextInputField(name:String, isPassword:Boolean, error:String, width:int = 238) {
        super();
        this.nameText_ = new SimpleText(18, 11776947, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.text = name;
        this.nameText_.updateMetrics();
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.nameText_);
        this.inputText_ = new SimpleText(20, 11776947, true, width, 30);
        this.inputText_.y = 30;
        this.inputText_.x = 6;
        this.inputText_.border = false;
        this.inputText_.displayAsPassword = isPassword;
        this.inputText_.updateMetrics();
        addChild(this.inputText_);
        graphics.lineStyle(2, 4539717, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);
        graphics.beginFill(3355443, 1);
        graphics.drawRect(0, this.inputText_.y, width, 30);
        graphics.endFill();
        graphics.lineStyle();
        this.inputText_.addEventListener(Event.CHANGE, this.onInputChange);
        this.errorText_ = new SimpleText(12, 16549442, false, 0, 0);
        this.errorText_.y = this.inputText_.y + 32;
        this.errorText_.text = error;
        this.errorText_.updateMetrics();
        this.errorText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.errorText_);
    }

    public function text():String {
        return this.inputText_.text;
    }

    public function setError(error:String):void {
        this.errorText_.text = error;
        this.errorText_.updateMetrics();
    }

    public function onInputChange(event:Event):void {
        this.setError("");
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/ItemResultBox.as">
package com.company.assembleegameclient.account.ui.unboxing {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.util.BitmapUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.events.Event;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

public class ItemResultBox extends Frame2 {

    public const cancel:Signal = new Signal();
    public const showInventory:Signal = new Signal();

    public var gameSprite:GameSprite;
    private var itemType_:int;
    private var itemBitmap_:Bitmap;

    public function ItemResultBox(_arg_1:GameSprite, _arg_2:int) {
        this.gameSprite = _arg_1;
        this.itemType_ = _arg_2;
        super("You unboxed a " + ObjectLibrary.typeToDisplayId_[this.itemType_], "", 288);
        XButton.addEventListener(MouseEvent.CLICK, this.onClose);
        var _local3:BitmapData = ObjectLibrary.getRedrawnTextureFromType(this.itemType_, 60, true, true, 5);
        _local3 = BitmapUtil.cropToBitmapData(_local3, 4, 4, _local3.width - 8, _local3.height - 8);
        this.itemBitmap_ = new Bitmap(_local3);
        addEventListener(Event.ENTER_FRAME, showInventory_);
        this.itemBitmap_.scaleX = this.itemBitmap_.scaleY = 3;
        this.addDisplayObject(this.itemBitmap_, this.w_ / 2 - this.itemBitmap_.width / 2 - 10);
    }

    private function onClose(e:Event) : void {
        //stage.focus = null;
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function showInventory_(event:Event):void {
        this.showInventory.dispatch();
    }

}
}//package com.company.assembleegameclient.account.ui
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/UnboxResultBox.as">
/**
 * Created by club5_000 on 9/13/2014.
 */
package com.company.assembleegameclient.account.ui.unboxing {

import com.company.assembleegameclient.game.GameSprite;

import flash.events.Event;

import org.osflash.signals.Signal;

public class UnboxResultBox extends FrameuBox {


    public const cancel:Signal = new Signal();
    public const completed:Signal = new Signal();
    public const hideInventory:Signal = new Signal();

    public function UnboxResultBox(_gs:GameSprite, _items:Vector.<int>) {
        super("Unboxing...", "", 300);
        this.gameSprite = _gs;
        this.unboxScroll_ = new UnboxScroll(444 + Math.random() * 8, _items);
        this.unboxScroll_.x = this.w_ / 2 - UnboxScroll.WIDTH / 2 - 4;
        this.unboxScroll_.y = this.h_ - 66;
        addChild(this.unboxScroll_);
        this.offsetH(UnboxScroll.HEIGHT);
        addEventListener(Event.ENTER_FRAME, hideInventory_);
        this.unboxScroll_.addEventListener(Event.COMPLETE, onComplete);
    }
    public var gameSprite:GameSprite;
    public var unboxScroll_:UnboxScroll;

    private function onComplete(event:Event):void {
        this.completed.dispatch();
    }

    private function hideInventory_(event:Event):void {
        this.hideInventory.dispatch();
    }

}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/UnboxScroll.as">
/**
 * Created by club5_000 on 1/21/2016.
 */
package com.company.assembleegameclient.account.ui.unboxing {

import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.util.GraphicsUtil;

import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.display.Sprite;
import flash.events.Event;

public class UnboxScroll extends Sprite {
    public static const WIDTH:int = 250;
    public static const HEIGHT:int = 85;

    public function UnboxScroll(_scrollSpeed:Number, _itemTypes:Vector.<int>) {
        this.scrollSpeed_ = _scrollSpeed;
        this.itemTypes_ = _itemTypes;
        addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);
    }

    private var unboxSquareHolder_:Sprite;
    private var unboxSquares_:Vector.<UnboxSquare>;
    public var scrollSpeed_:Number;
    public var currentScrollSpeed_:Number = 1;
    public var currentBox_:int = 0;
    public var itemTypes_:Vector.<int>;

    private function draw():void {
        graphics.clear();
        graphics.beginGradientFill("linear", [0x000000, 0x1a1919, 0x272727], null, null, null, "pad", "rgb");
        graphics.drawRect(0, 0, WIDTH, HEIGHT);
        graphics.endFill();
        var _local1:GraphicsSolidFill = new GraphicsSolidFill(0xFFFFFF, 1);
        var _local2:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        var _local3:Vector.<IGraphicsData> = new <IGraphicsData>[_local1, _local2, GraphicsUtil.END_FILL];
        GraphicsUtil.drawTriangle(WIDTH / 2 - 5, 0, 10, 5, false, _local2);
        graphics.drawGraphicsData(_local3);
        GraphicsUtil.clearPath(_local2);
        GraphicsUtil.drawTriangle(WIDTH / 2 - 5, HEIGHT - 5, 10, 5, true, _local2);
        graphics.drawGraphicsData(_local3);
    }

    private function initSquares():void {
        if(this.unboxSquareHolder_ != null) {
            removeChild(this.unboxSquareHolder_);
        }
        var _local2:Sprite = new Sprite();
        _local2.graphics.beginFill(0x000000, 1);
        _local2.graphics.drawRect(0, 0, WIDTH, HEIGHT);
        _local2.graphics.endFill();
        _local2.visible = false;
        addChild(_local2);
        this.unboxSquareHolder_ = new Sprite();
        this.unboxSquareHolder_.mask = _local2;
        this.unboxSquares_ = new Vector.<UnboxSquare>();
        for(var i:int=0;i<itemTypes_.length;i++) {
            var _local1:UnboxSquare = new UnboxSquare(this.itemTypes_[i], i);
            _local1.x = i * (75 + 15) - 75 / 2;
            _local1.y = 0;
            this.unboxSquares_.push(_local1);
            this.unboxSquareHolder_.addChild(_local1);
        }
        this.unboxSquareHolder_.x = WIDTH / 2;
        this.unboxSquareHolder_.y = 5;
        addChild(this.unboxSquareHolder_);

        this.currentScrollSpeed_ = 1;
        this.currentBox_ = 0;
    }

    private function onEnterFrame(event:Event):void {
        if(this.unboxSquareHolder_ == null) {
            return;
        }
        for each(var i:UnboxSquare in this.unboxSquares_) {
            i.x -= this.currentScrollSpeed_ * 18;
        }
        if(this.unboxSquares_[this.currentBox_ + 1].x <= 0) {
            this.currentBox_++;
            SoundEffectLibrary.play("inventory_move_item");
        }
        this.currentScrollSpeed_ -= 1 / this.scrollSpeed_;
        if(this.currentScrollSpeed_ <= 0) {
            this.currentScrollSpeed_ = 0;
            dispatchEvent(new Event(Event.COMPLETE));
            trace(this.currentBox_);
        }
    }

    private function onAddedToStage(event:Event):void {
        this.draw();
        this.initSquares();
        addEventListener(Event.ENTER_FRAME, onEnterFrame);
    }

    private function onRemovedFromStage(event:Event):void {
        removeEventListener(Event.ENTER_FRAME, onEnterFrame);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/UnboxSquare.as">
/**
 * Created by club5_000 on 1/21/2016.
 */
package com.company.assembleegameclient.account.ui.unboxing {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.ui.tooltip.TooltipHelper;
import com.company.ui.SimpleText;
import com.company.util.BitmapUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.text.TextFormatAlign;

public class UnboxSquare extends Sprite {
    public function UnboxSquare(_item:int, _id:int=0) {
        this.itemType_ = _item;
        this.id_ = _id;
        addIcon();
    }

    public var itemType_:int;
    public var background:Sprite;
    public var itemBitmap_:Bitmap;
    public var itemName_:SimpleText;
    public var id_:int;

    private function addIcon() : void {
        var _local1:XML = ObjectLibrary.xmlLibrary_[this.itemType_];
        var _local2:Number = 5;
        if (_local1.hasOwnProperty("ScaleValue")) {
            _local2 = _local1.ScaleValue;
        }
        var _local5:uint = 0xA9A9A9;
        if(_local1.hasOwnProperty("TierType")) {
            if (String(_local1.TierType).match(/Exiled$/i)) {
                _local5 = TooltipHelper.EXILED_COLOR;
            }
            if (String(_local1.TierType).match(/Relic$/i)) {
                _local5 = TooltipHelper.RELIC_COLOR;
            }
            if (String(_local1.TierType).match(/Valiant$/i)) {
                _local5 = TooltipHelper.VALIANT_COLOR;
            }
            if (String(_local1.TierType).match(/Ancestral$/i)) {
                _local5 = TooltipHelper.ANCESTRAL_COLOR;
            }
            if (String(_local1.TierType).match(/Artifact$/i)) {
                _local5 = TooltipHelper.ARTIFACT_COLOR;
            }
            if (String(_local1.TierType).match(/Tarnished$/i)) {
                _local5 = TooltipHelper.TARNISHED_COLOR;
            }
            if (String(_local1.TierType).match(/Uncommon$/i)) {
                _local5 = TooltipHelper.UNCOMMON_COLOR;
            }
        }
        if (_local1.hasOwnProperty("Outfit")) {
            _local5 = 0xADD8E6;
        }
        if (_local1.hasOwnProperty("Fabled")) {
            _local5 = 0x880000;
        }
        if (!_local1.hasOwnProperty("Tier")) {
            _local5 = 0xc13ec1;
        }
        if (_local1.Tier >= 12) {
            _local5 = 0x78a065;
        }
        if (_local1.hasOwnProperty("Potion")) {
            _local5 = 0xaa9e63;
        }
        this.background = new Sprite();
        this.background.graphics.beginFill(_local5);
        this.background.graphics.drawRect(0, 0, 75, 75);
        this.background.graphics.endFill();
        this.background.addChild(new EmbedUnboxSquare());
        addChild(this.background);
        var _local3:BitmapData = ObjectLibrary.getRedrawnTextureFromType(this.itemType_, 60, true, true, _local2);
        _local3 = BitmapUtil.cropToBitmapData(_local3, 4, 4, _local3.width - 8, _local3.height - 8);
        this.itemBitmap_ = new Bitmap(_local3);
        this.itemBitmap_.x = 75 / 2 - this.itemBitmap_.width / 2;
        this.itemBitmap_.y = 50 / 2 - this.itemBitmap_.height / 2;
        addChild(this.itemBitmap_);
        this.itemName_ = new SimpleText(10, 0x000000, false, 77, 0);
        this.itemName_.setBold(true);
        this.itemName_.setAlignment(TextFormatAlign.CENTER);
        this.itemName_.text = ObjectLibrary.typeToDisplayId_[this.itemType_];
        this.itemName_.wordWrap = true;
        this.itemName_.updateMetrics();
        this.itemName_.y = (25 / 2 + 50) - this.itemName_.textHeight / 2 - 3;
        this.itemName_.x = -1;
        addChild(this.itemName_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/background/Background.as">
package com.company.assembleegameclient.background {
import com.company.assembleegameclient.map.Camera;

import flash.display.Sprite;

public class Background extends Sprite {

    public static const NO_BACKGROUND:int = 0;

    public static const STAR_BACKGROUND:int = 1;

    public static const NEXUS_BACKGROUND:int = 2;

    public static const NUM_BACKGROUND:int = 3;


    public function Background() {
        super();
    }

    public static function getBackground(type:int):Background {
        switch (type) {
            case NO_BACKGROUND:
                return null;
            case STAR_BACKGROUND:
                return new StarBackground();
            case NEXUS_BACKGROUND:
                return new NexusBackground();
            default:
                return null;
        }
    }

    public function draw(camera:Camera, time:int):void {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/background/NexusBackground.as">
package com.company.assembleegameclient.background {
import com.company.assembleegameclient.map.Camera;
import com.company.util.GraphicsUtil;

import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Rectangle;

public class NexusBackground extends Background {

    public static const MOVEMENT:Point = new Point(0.01, 0.01);


    private var water_:BitmapData;

    private var islands_:Vector.<Island>;

    protected var graphicsData_:Vector.<IGraphicsData> = new Vector.<IGraphicsData>();

    private var bitmapFill_:GraphicsBitmapFill = new GraphicsBitmapFill(null, new Matrix(), true, false);

    private var path_:GraphicsPath = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, new Vector.<Number>());

    public function NexusBackground() {
        this.islands_ = new Vector.<Island>();
        super();
        this.water_ = new BitmapData(1024, 1024, false, 0);
        this.water_.perlinNoise(1024, 1024, 8, Math.random(), true, true, BitmapDataChannel.BLUE, false, null);
    }

    override public function draw(camera:Camera, time:int):void {
        this.graphicsData_.length = 0;
        var m:Matrix = this.bitmapFill_.matrix;
        m.identity();
        m.translate(time * MOVEMENT.x, time * MOVEMENT.y);
        m.rotate(-camera.angleRad_);
        this.bitmapFill_.bitmapData = this.water_;
        this.graphicsData_.push(this.bitmapFill_);
        this.path_.data.length = 0;
        var r:Rectangle = camera.clipRect_;
        this.path_.data.push(r.left, r.top, r.right, r.top, r.right, r.bottom, r.left, r.bottom);
        this.graphicsData_.push(this.path_);
        this.graphicsData_.push(GraphicsUtil.END_FILL);
        this.drawIslands(camera, time);
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData_);
    }

    private function drawIslands(camera:Camera, time:int):void {
        var island:Island = null;
        for (var i:int = 0; i < this.islands_.length; i++) {
            island = this.islands_[i];
            island.draw(camera, time, this.graphicsData_);
        }
    }
}
}

import com.company.assembleegameclient.background.NexusBackground;
import com.company.assembleegameclient.map.Camera;
import com.company.util.AssetLibrary;
import com.company.util.GraphicsUtil;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;
import flash.geom.Point;

class Island {


    public var center_:Point;

    public var startTime_:int;

    public var bitmapData_:BitmapData;

    private var bitmapFill_:GraphicsBitmapFill = new GraphicsBitmapFill(null, new Matrix(), true, false);

    private var path_:GraphicsPath = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, new Vector.<Number>());

    function Island(x:Number, y:Number, startTime:int) {
        super();
        this.center_ = new Point(x, y);
        this.startTime_ = startTime;
        this.bitmapData_ = AssetLibrary.getImage("stars");
    }

    public function draw(camera:Camera, time:int, graphicsData:Vector.<IGraphicsData>):void {
        var dt:int = time - this.startTime_;
        var x:Number = this.center_.x + dt * NexusBackground.MOVEMENT.x;
        var y:Number = this.center_.y + dt * NexusBackground.MOVEMENT.y;
        var m:Matrix = this.bitmapFill_.matrix;
        m.identity();
        m.translate(x, y);
        m.rotate(-camera.angleRad_);
        this.bitmapFill_.bitmapData = this.bitmapData_;
        graphicsData.push(this.bitmapFill_);
        this.path_.data.length = 0;
        var topLeft:Point = m.transformPoint(new Point(x, y));
        var bottomRight:Point = m.transformPoint(new Point(x + this.bitmapData_.width, y + this.bitmapData_.height));
        this.path_.data.push(topLeft.x, topLeft.y, bottomRight.x, topLeft.y, bottomRight.x, bottomRight.y, topLeft.x, bottomRight.y);
        graphicsData.push(this.path_);
        graphicsData.push(GraphicsUtil.END_FILL);
    }
}
</file>

<file path="src/com/company/assembleegameclient/background/StarBackground.as">
package com.company.assembleegameclient.background {
import com.company.assembleegameclient.map.Camera;
import com.company.util.AssetLibrary;
import com.company.util.ImageSet;
import com.company.util.PointUtil;

import flash.display.IGraphicsData;

public class StarBackground extends Background {


    public var stars_:Vector.<Star>;

    protected var graphicsData_:Vector.<IGraphicsData>;

    public function StarBackground() {
        this.stars_ = new Vector.<Star>();
        this.graphicsData_ = new Vector.<IGraphicsData>();
        super();
        for (var i:int = 0; i < 100; i++) {
            this.tryAddStar();
        }
    }

    override public function draw(camera:Camera, time:int):void {
        var star:Star = null;
        this.graphicsData_.length = 0;
        for each(star in this.stars_) {
            star.draw(this.graphicsData_, camera, time);
        }
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData_);
    }

    private function tryAddStar():void {
        var star:Star = null;
        var starSet:ImageSet = AssetLibrary.getImageSet("stars");
        var newStar:Star = new Star(Math.random() * 1000 - 500, Math.random() * 1000 - 500, 4 * (0.5 + 0.5 * Math.random()), starSet.images_[int(starSet.images_.length * Math.random())]);
        for each(star in this.stars_) {
            if (PointUtil.distanceXY(newStar.x_, newStar.y_, star.x_, star.y_) < 3) {
                return;
            }
        }
        this.stars_.push(newStar);
    }
}
}

import com.company.assembleegameclient.map.Camera;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsEndFill;
import flash.display.GraphicsPath;
import flash.display.GraphicsPathCommand;
import flash.display.IGraphicsData;
import flash.geom.Matrix;

class Star {

    protected static const sqCommands:Vector.<int> = new <int>[GraphicsPathCommand.MOVE_TO, GraphicsPathCommand.LINE_TO, GraphicsPathCommand.LINE_TO, GraphicsPathCommand.LINE_TO];

    protected static const END_FILL:GraphicsEndFill = new GraphicsEndFill();


    public var x_:Number;

    public var y_:Number;

    public var scale_:Number;

    public var bitmap_:BitmapData;

    private var w_:Number;

    private var h_:Number;

    protected var bitmapFill_:GraphicsBitmapFill;

    protected var path_:GraphicsPath;

    function Star(x:Number, y:Number, scale:Number, bitmap:BitmapData) {
        this.bitmapFill_ = new GraphicsBitmapFill(null, new Matrix(), false, false);
        this.path_ = new GraphicsPath(sqCommands, new Vector.<Number>());
        super();
        this.x_ = x;
        this.y_ = y;
        this.scale_ = scale;
        this.bitmap_ = bitmap;
        this.w_ = this.bitmap_.width * this.scale_;
        this.h_ = this.bitmap_.height * this.scale_;
    }

    public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var nx:Number = this.x_ * Math.cos(-camera.angleRad_) - this.y_ * Math.sin(-camera.angleRad_);
        var ny:Number = this.x_ * Math.sin(-camera.angleRad_) + this.y_ * Math.cos(-camera.angleRad_);
        var m:Matrix = this.bitmapFill_.matrix;
        m.identity();
        m.translate(-this.bitmap_.width / 2, -this.bitmap_.height / 2);
        m.scale(this.scale_, this.scale_);
        m.translate(nx, ny);
        this.bitmapFill_.bitmapData = this.bitmap_;
        this.path_.data.length = 0;
        var sx:Number = nx - this.w_ / 2;
        var sy:Number = ny - this.h_ / 2;
        this.path_.data.push(sx, sy, sx + this.w_, sy, sx + this.w_, sy + this.h_, sx, sy + this.h_);
        graphicsData.push(this.bitmapFill_);
        graphicsData.push(this.path_);
        graphicsData.push(END_FILL);
    }
}
</file>

<file path="src/com/company/assembleegameclient/constants/ScreenTypes.as">
package com.company.assembleegameclient.constants {
public class ScreenTypes {
    public static const PLAY:String = "Play Game";
    public static const SERVERS:String = "SERVERS";
    public static const LEGENDS:String = "Legends";
    public static const ACCOUNT:String = "Account";
    public static const EDITOR:String = "Editor";

    public function ScreenTypes() {
        super();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/editor/CommandEvent.as">
package com.company.assembleegameclient.editor {
import flash.events.Event;

public class CommandEvent extends Event {

    public static const UNDO_COMMAND_EVENT:String = "UNDO_COMMAND_EVENT";

    public static const REDO_COMMAND_EVENT:String = "REDO_COMMAND_EVENT";

    public static const CLEAR_COMMAND_EVENT:String = "CLEAR_COMMAND_EVENT";

    public static const LOAD_COMMAND_EVENT:String = "LOAD_COMMAND_EVENT";

    public static const SAVE_COMMAND_EVENT:String = "SAVE_COMMAND_EVENT";

    public static const TEST_COMMAND_EVENT:String = "TEST_COMMAND_EVENT";

    public static const BACK_COMMAND_EVENT:String = "BACK_COMMAND_EVENT";


    public function CommandEvent(type:String) {
        super(type);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/editor/CommandMenu.as">
package com.company.assembleegameclient.editor {
import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.utils.Dictionary;

public class CommandMenu extends Sprite {


    private var keyCodeDict_:Dictionary;

    private var yOffset_:int = 0;

    private var selected_:CommandMenuItem = null;

    public function CommandMenu() {
        this.keyCodeDict_ = new Dictionary();
        super();
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function getCommand():int {
        return this.selected_.command_;
    }

    public function setCommand(command:int):void {
        var item:CommandMenuItem = null;
        for (var c:int = 0; c < numChildren; c++) {
            item = getChildAt(c) as CommandMenuItem;
            if (item != null) {
                if (item.command_ == command) {
                    this.setSelected(item);
                    break;
                }
            }
        }
    }

    protected function setSelected(item:CommandMenuItem):void {
        if (this.selected_ != null) {
            this.selected_.setSelected(false);
        }
        this.selected_ = item;
        this.selected_.setSelected(true);
    }

    private function onAddedToStage(event:Event):void {
        stage.addEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
    }

    private function onKeyDown(event:KeyboardEvent):void {
        if (stage.focus != null) {
            return;
        }
        var item:CommandMenuItem = this.keyCodeDict_[event.keyCode];
        if (item == null) {
            return;
        }
        item.callback_(item);
    }

    protected function addCommandMenuItem(label:String, keyCode:int, callback:Function, command:int):void {
        var commandMenuItem:CommandMenuItem = new CommandMenuItem(label, callback, command);
        commandMenuItem.y = this.yOffset_;
        addChild(commandMenuItem);
        this.keyCodeDict_[keyCode] = commandMenuItem;
        if (this.selected_ == null) {
            this.setSelected(commandMenuItem);
        }
        this.yOffset_ = this.yOffset_ + 30;
    }

    protected function addBreak():void {
        this.yOffset_ = this.yOffset_ + 30;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/editor/CommandMenuItem.as">
package com.company.assembleegameclient.editor {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.MouseEvent;

public class CommandMenuItem extends Sprite {

    private static const WIDTH:int = 80;

    private static const HEIGHT:int = 25;


    public var callback_:Function;

    public var command_:int;

    private var over_:Boolean = false;

    private var down_:Boolean = false;

    private var selected_:Boolean = false;

    private var text_:SimpleText;

    public function CommandMenuItem(label:String, callback:Function, command:int) {
        super();
        this.callback_ = callback;
        this.command_ = command;
        this.text_ = new SimpleText(16, 16777215, false, 0, 0);
        this.text_.setBold(true);
        this.text_.text = label;
        this.text_.updateMetrics();
        this.text_.x = 2;
        addChild(this.text_);
        this.redraw();
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function setSelected(selected:Boolean):void {
        this.selected_ = selected;
        this.redraw();
    }

    public function setLabel(label:String):void {
        this.text_.text = label;
        this.text_.updateMetrics();
    }

    private function redraw():void {
        graphics.clear();
        if (this.selected_ || this.down_) {
            graphics.lineStyle(2, 16777215);
            graphics.beginFill(8355711, 1);
            graphics.drawRect(0, 0, WIDTH, HEIGHT);
            graphics.endFill();
            graphics.lineStyle();
        } else if (this.over_) {
            graphics.lineStyle(2, 16777215);
            graphics.beginFill(0, 0);
            graphics.drawRect(0, 0, WIDTH, HEIGHT);
            graphics.endFill();
            graphics.lineStyle();
        } else {
            graphics.lineStyle(1, 16777215);
            graphics.beginFill(0, 0);
            graphics.drawRect(0, 0, WIDTH, HEIGHT);
            graphics.endFill();
            graphics.lineStyle();
        }
    }

    private function onMouseOver(event:MouseEvent):void {
        this.over_ = true;
        this.redraw();
    }

    private function onMouseOut(event:MouseEvent):void {
        this.over_ = false;
        this.down_ = false;
        this.redraw();
    }

    private function onMouseDown(event:MouseEvent):void {
        this.down_ = true;
        this.redraw();
    }

    private function onMouseUp(event:MouseEvent):void {
        this.down_ = false;
        this.redraw();
    }

    private function onClick(event:MouseEvent):void {
        this.callback_(this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/game/events/DeathEvent.as">
package com.company.assembleegameclient.game.events {
import com.company.assembleegameclient.objects.Player;

import flash.display.BitmapData;
import flash.events.Event;

public class DeathEvent extends Event {

    public static const DEATH:String = "DEATH";


    public var background_:BitmapData;

    public var player_:Player;

    public var accountId_:int;

    public var charId_:int;

    public function DeathEvent(background:BitmapData, accountId:int, charId:int) {
        super(DEATH);
        this.background_ = background;
        this.accountId_ = accountId;
        this.charId_ = charId;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/game/events/GuildResultEvent.as">
package com.company.assembleegameclient.game.events {
import flash.events.Event;

public class GuildResultEvent extends Event {

    public static const EVENT:String = "GUILDRESULTEVENT";


    public var success_:Boolean;

    public var errorText_:String;

    public function GuildResultEvent(success:Boolean, errorText:String) {
        super(EVENT);
        this.success_ = success;
        this.errorText_ = errorText;
    }

    override public function toString():String {
        return formatToString("GUILDRESULTEVENT", "success_", "errorText_");
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/game/events/NameResultEvent.as">
package com.company.assembleegameclient.game.events {
import flash.events.Event;

public class NameResultEvent extends Event {

    public static const NAMERESULTEVENT:String = "NAMERESULTEVENT";


    public var m_:NameResult;

    public function NameResultEvent(m:NameResult) {
        super(NAMERESULTEVENT);
        this.m_ = m;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/game/events/ReconnectEvent.as">
package com.company.assembleegameclient.game.events {
import flash.events.Event;

public class ReconnectEvent extends Event {
    public static const RECONNECT:String = "RECONNECT_EVENT";

    public var gameId_:int;

    public var createCharacter_:Boolean;

    public var charId_:int;

    public function ReconnectEvent(gameId:int, createCharacter:Boolean, charId:int) {
        super(RECONNECT);
        this.gameId_ = gameId;
        this.createCharacter_ = createCharacter;
        this.charId_ = charId;
    }

    override public function clone():Event {
        return new ReconnectEvent(this.gameId_, this.createCharacter_, this.charId_);
    }

    override public function toString():String {
        return formatToString(RECONNECT, "server_", "gameId_", "charId_");
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/animation/Animations.as">
package com.company.assembleegameclient.objects.animation {
import flash.display.BitmapData;

public class Animations {


    public var animationsData_:AnimationsData;

    public var nextRun_:Vector.<int> = null;

    public var running_:RunningAnimation = null;

    public function Animations(animationsData:AnimationsData) {
        super();
        this.animationsData_ = animationsData;
    }

    public function getTexture(time:int):BitmapData {
        var animationData:AnimationData = null;
        var texture:BitmapData = null;
        var start:int = 0;
        if (this.nextRun_ == null) {
            this.nextRun_ = new Vector.<int>();
            for each(animationData in this.animationsData_.animations) {
                this.nextRun_.push(animationData.getLastRun(time));
            }
        }
        if (this.running_ != null) {
            texture = this.running_.getTexture(time);
            if (texture != null) {
                return texture;
            }
            this.running_ = null;
        }
        for (var i:int = 0; i < this.nextRun_.length; i++) {
            if (time > this.nextRun_[i]) {
                start = this.nextRun_[i];
                animationData = this.animationsData_.animations[i];
                this.nextRun_[i] = animationData.getNextRun(time);
                if (!(animationData.prob_ != 1 && Math.random() > animationData.prob_)) {
                    this.running_ = new RunningAnimation(animationData, start);
                    return this.running_.getTexture(time);
                }
            }
        }
        return null;
    }
}
}

import com.company.assembleegameclient.objects.animation.AnimationData;
import com.company.assembleegameclient.objects.animation.FrameData;

import flash.display.BitmapData;

class RunningAnimation {


    public var animationData_:AnimationData;

    public var start_:int;

    public var frameId_:int;

    public var frameStart_:int;

    public var texture_:BitmapData;

    function RunningAnimation(animationData:AnimationData, start:int) {
        super();
        this.animationData_ = animationData;
        this.start_ = start;
        this.frameId_ = 0;
        this.frameStart_ = start;
        this.texture_ = null;
    }

    public function getTexture(time:int):BitmapData {
        var frame:FrameData = this.animationData_.frames[this.frameId_];
        while (time - this.frameStart_ > frame.time_) {
            if (this.frameId_ >= this.animationData_.frames.length - 1) {
                return null;
            }
            this.frameStart_ = this.frameStart_ + frame.time_;
            this.frameId_++;
            frame = this.animationData_.frames[this.frameId_];
            this.texture_ = null;
        }
        if (this.texture_ == null) {
            this.texture_ = frame.textureData_.getTexture(Math.random() * 100);
        }
        return this.texture_;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/animation/FrameData.as">
package com.company.assembleegameclient.objects.animation {
import com.company.assembleegameclient.objects.TextureData;

public class FrameData {


    public var time_:int;

    public var textureData_:TextureData;

    public function FrameData(xml:XML) {
        super();
        this.time_ = int(Number(xml.@time) * 1000);
        this.textureData_ = new TextureData(xml);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/BasicObject.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.map.Square;

import flash.display.IGraphicsData;

import svera.untiered.stage3D.Object3D.Object3DStage3D;

public class BasicObject {
    private static var nextFakeObjectId_:int = 0;

    public var map_:Map;
    public var square_:Square;
    public var objectId_:int;
    public var x_:Number = 3;
    public var y_:Number = 3;
    public var z_:Number;
    public var hasShadow_:Boolean;
    public var drawn_:Boolean;
    public var posW_:Vector.<Number>;
    public var posS_:Vector.<Number>;
    public var sortVal_:int;

    public function BasicObject() {
        this.posW_ = new Vector.<Number>();
        this.posS_ = new Vector.<Number>();
        super();
        this.clear();
    }

    public static function getNextFakeObjectId():int {
        return 2130706432 | nextFakeObjectId_++;
    }

    public function clear():void {
        this.map_ = null;
        this.square_ = null;
        this.objectId_ = -1;
        this.x_ = 0;
        this.y_ = 0;
        this.z_ = 0;
        this.hasShadow_ = false;
        this.drawn_ = false;
        this.posW_.length = 0;
        this.posS_.length = 0;
        this.sortVal_ = 0;
    }

    public function dispose():void {
        this.map_ = null;
        this.square_ = null;
        this.posW_ = null;
        this.posS_ = null;
    }

    public function update(time:int, dt:int):Boolean {
        return true;
    }

    public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
    }

    public function draw3d(graphicsData3d:Vector.<Object3DStage3D>):void {
    }

    public function drawShadow(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
    }

    public function computeSortVal(camera:Camera):void {
        this.posW_.length = 0;
        this.posW_.push(this.x_, this.y_, 0, this.x_, this.y_, this.z_);
        this.posS_.length = 0;
        camera.wToS_.transformVectors(this.posW_, this.posS_);
        this.sortVal_ = int(this.posS_[1]);
    }

    public function addTo(map:Map, x:Number, y:Number):Boolean {
        this.map_ = map;
        this.square_ = this.map_.getSquare(x, y);
        if (this.square_ == null) {
            this.map_ = null;
            return false;
        }
        this.x_ = x;
        this.y_ = y;
        return true;
    }

    public function removeFromMap():void {
        this.map_ = null;
        this.square_ = null;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/CharacterChanger.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.CharacterChangerPanel;
import com.company.assembleegameclient.ui.panels.Panel;

public class CharacterChanger extends GameObject implements IInteractiveObject {


    public function CharacterChanger(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new CharacterChangerPanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ClosedVaultChest.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;

import flash.display.BitmapData;

public class ClosedVaultChest extends SellableObject {


    public function ClosedVaultChest(objectXML:XML) {
        super(objectXML);
    }

    override public function soldObjectName():String {
        return "Vault Chest";
    }

    override public function soldObjectInternalName():String {
        return "Vault Chest";
    }

    override public function getTooltip():ToolTip {
        var toolTip:ToolTip = new TextToolTip(3552822, 10197915, this.soldObjectName(), "A chest that will safely store 8 items and is " + "accessible by all of your characters.", 200);
        return toolTip;
    }

    override public function getIcon():BitmapData {
        return ObjectLibrary.getRedrawnTextureFromType(ObjectLibrary.idToType_["Vault Chest"], 80, true);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ConnectedObject.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.engine3d.Object3D;
import com.company.assembleegameclient.engine3d.ObjectFace3D;
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Square;

import flash.display.BitmapData;
import flash.display.IGraphicsData;
import flash.geom.Utils3D;
import flash.geom.Vector3D;
import flash.utils.Dictionary;

public class ConnectedObject extends GameObject {

    protected static const DOT_TYPE:int = 0;

    protected static const SHORT_LINE_TYPE:int = 1;

    protected static const L_TYPE:int = 2;

    protected static const LINE_TYPE:int = 3;

    protected static const T_TYPE:int = 4;

    protected static const CROSS_TYPE:int = 5;

    private static var dict_:Dictionary = null;

    protected static const N0:Vector3D = new Vector3D(-1, -1, 0);

    protected static const N1:Vector3D = new Vector3D(0, -1, 0);

    protected static const N2:Vector3D = new Vector3D(1, -1, 0);

    protected static const N3:Vector3D = new Vector3D(1, 0, 0);

    protected static const N4:Vector3D = new Vector3D(1, 1, 0);

    protected static const N5:Vector3D = new Vector3D(0, 1, 0);

    protected static const N6:Vector3D = new Vector3D(-1, 1, 0);

    protected static const N7:Vector3D = new Vector3D(-1, 0, 0);

    protected static const N8:Vector3D = new Vector3D(0, 0, 1);


    protected var rotation_:int = 0;

    public function ConnectedObject(objectXML:XML) {
        super(objectXML);
        hasShadow_ = false;
    }

    private static function init():void {
        dict_ = new Dictionary();
        initHelper(33686018, DOT_TYPE);
        initHelper(16908802, SHORT_LINE_TYPE);
        initHelper(16843266, L_TYPE);
        initHelper(16908546, LINE_TYPE);
        initHelper(16843265, T_TYPE);
        initHelper(16843009, CROSS_TYPE);
    }

    private static function getConnectedResults(connectType:int):ConnectedResults {
        if (dict_ == null) {
            init();
        }
        var pat:int = connectType & 252645135;
        return dict_[pat];
    }

    private static function initHelper(val:int, type:int):void {
        var byte:int = 0;
        for (var rotation:int = 0; rotation < 4; rotation++) {
            if (!dict_.hasOwnProperty(val)) {
                dict_[val] = new ConnectedResults(type, rotation);
                byte = val & 255;
                val = val >> 8 | byte << 24;
            }
        }
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var face:ObjectFace3D = null;
        var nx:int = 0;
        var ny:int = 0;
        var texture:BitmapData = null;
        var sq:Square = null;
        if (obj3D_ == null) {
            this.rebuild3D();
        }
        Utils3D.projectVectors(camera.wToS_, obj3D_.vW_, obj3D_.vS_, obj3D_.uvts_);
        for each(face in obj3D_.faces_) {
            nx = face.normalW_.x > 0.4 ? int(1) : face.normalW_.x < -0.4 ? int(-1) : int(0);
            ny = face.normalW_.y > 0.4 ? int(1) : face.normalW_.y < -0.4 ? int(-1) : int(0);
            texture = face.texture_;
            if (nx != 0 || ny != 0) {
                sq = map_.lookupSquare(x_ + nx, y_ + ny);
                if (sq == null || sq.texture_ == null) {
                    texture = null;
                }
            }
            face.draw(graphicsData, 0, texture);
        }
    }

    public function rebuild3D():void {
        obj3D_ = new Object3D();
        var connectedResults:ConnectedResults = getConnectedResults(connectType_);
        if (connectedResults == null) {
            trace("UNSUPPORTED TYPE: 0x" + connectType_.toString(16));
            obj3D_ = null;
            return;
        }
        this.rotation_ = connectedResults.rotation_;
        switch (connectedResults.type_) {
            case DOT_TYPE:
                this.buildDot();
                break;
            case SHORT_LINE_TYPE:
                this.buildShortLine();
                break;
            case L_TYPE:
                this.buildL();
                break;
            case LINE_TYPE:
                this.buildLine();
                break;
            case T_TYPE:
                this.buildT();
                break;
            case CROSS_TYPE:
                this.buildCross();
                break;
            default:
                trace("INVALID TYPE: " + connectedResults.type_ + " (0x" + connectType_.toString(16) + ")");
                obj3D_ = null;
                return;
        }
        obj3D_.setPosition(x_, y_, 0, this.rotation_ * 90);
    }

    protected function buildDot():void {
    }

    protected function buildShortLine():void {
    }

    protected function buildL():void {
    }

    protected function buildLine():void {
    }

    protected function buildT():void {
    }

    protected function buildCross():void {
    }
}
}

class ConnectedResults {


    public var type_:int;

    public var rotation_:int;

    function ConnectedResults(type:int, rotation:int) {
        super();
        this.type_ = type;
        this.rotation_ = rotation;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/Container.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.panels.itemgrids.ContainerGrid;
import com.company.util.PointUtil;

public class Container extends GameObject implements IInteractiveObject {
    public var isLoot_:Boolean;
    public var ownerId_:int;

    public function Container(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
        this.isLoot_ = objectXML.hasOwnProperty("Loot");
        this.ownerId_ = -1;
    }

    public function setOwnerId(ownerId:int):void {
        this.ownerId_ = ownerId;
        isInteractive_ = this.ownerId_ < 0 || this.isBoundToCurrentAccount();
    }

    public function isBoundToCurrentAccount():Boolean {
        return map_.player_.accountId_ == this.ownerId_;
    }

    override public function addTo(map:Map, x:Number, y:Number):Boolean {
        if (!super.addTo(map, x, y)) {
            return false;
        }
        if (map_.player_ == null) {
            return true;
        }
        var dist:Number = PointUtil.distanceXY(map_.player_.x_, map_.player_.y_, x, y);
        if (this.isLoot_ && dist < 10) {
            SoundEffectLibrary.play("loot_appears");
        }
        return true;
    }

    public function getPanel(gs:GameSprite):Panel {
        var player:Player = gs && gs.map ? gs.map.player_ : null;
        var invPanel:ContainerGrid = new ContainerGrid(this, player);
        return invPanel;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/FlashDescription.as">
package com.company.assembleegameclient.objects {
import flash.display.BitmapData;
import flash.geom.ColorTransform;

import svera.untiered.stage3D.GraphicsFillExtra;

public class FlashDescription {


    public var startTime_:int;

    public var color_:uint;

    public var periodMS_:int;

    public var repeats_:int;

    public var targetR:int;

    public var targetG:int;

    public var targetB:int;

    public function FlashDescription(startTime:int, color:uint, period_:Number, repeats:int) {
        super();
        this.startTime_ = startTime;
        this.color_ = color;
        this.periodMS_ = period_ * 1000;
        this.repeats_ = repeats;
        this.targetR = color >> 16 & 255;
        this.targetG = color >> 8 & 255;
        this.targetB = color & 255;
    }

    public function apply(texture:BitmapData, time:int):BitmapData {
        var t:int = (time - this.startTime_) % this.periodMS_;
        var v:Number = Math.sin(t / this.periodMS_ * Math.PI);
        var mv:Number = v * 0.5;
        var ct:ColorTransform = new ColorTransform(1 - mv, 1 - mv, 1 - mv, 1, mv * this.targetR, mv * this.targetG, mv * this.targetB, 0);
        var newTexture:BitmapData = texture.clone();
        newTexture.colorTransform(newTexture.rect, ct);
        return newTexture;
    }

    public function applyGPUTextureColorTransform(texture:BitmapData, time:int):void {
        var t:int = (time - this.startTime_) % this.periodMS_;
        var v:Number = Math.sin(t / this.periodMS_ * Math.PI);
        var mv:Number = v * 0.5;
        var ct:ColorTransform = new ColorTransform(1 - mv, 1 - mv, 1 - mv, 1, mv * this.targetR, mv * this.targetG, mv * this.targetB, 0);
        GraphicsFillExtra.setColorTransform(texture, ct);
    }

    public function doneAt(time:int):Boolean {
        return time > this.startTime_ + this.periodMS_ * this.repeats_;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/GuildBoard.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.GuildBoardPanel;
import com.company.assembleegameclient.ui.panels.Panel;

public class GuildBoard extends GameObject implements IInteractiveObject {


    public function GuildBoard(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new GuildBoardPanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/GuildChronicle.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.GuildChroniclePanel;
import com.company.assembleegameclient.ui.panels.Panel;

public class GuildChronicle extends GameObject implements IInteractiveObject {


    public function GuildChronicle(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new GuildChroniclePanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/GuildHallPortal.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.GuildHallPortalPanel;
import com.company.assembleegameclient.ui.panels.Panel;

public class GuildHallPortal extends GameObject implements IInteractiveObject {
    public function GuildHallPortal(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new GuildHallPortalPanel(gs, this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/GuildMerchant.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.assembleegameclient.util.Currency;
import com.company.assembleegameclient.util.GuildUtil;

import flash.display.BitmapData;

public class GuildMerchant extends SellableObject implements IInteractiveObject {


    public var description_:String;

    public function GuildMerchant(objectXML:XML) {
        super(objectXML);
        price_ = int(objectXML.Price);
        currency_ = Currency.GUILD_FAME;
        this.description_ = objectXML.Description;
        guildRankReq_ = GuildUtil.LEADER;
    }

    override public function soldObjectName():String {
        return ObjectLibrary.typeToDisplayId_[objectType_];
    }

    override public function soldObjectInternalName():String {
        var objectXML:XML = ObjectLibrary.xmlLibrary_[objectType_];
        return objectXML.@id.toString();
    }

    override public function getTooltip():ToolTip {
        var toolTip:ToolTip = new TextToolTip(3552822, 10197915, this.soldObjectName(), this.description_, 200);
        return toolTip;
    }

    override public function getIcon():BitmapData {
        return ObjectLibrary.getRedrawnTextureFromType(objectType_, 80, true);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/GuildRegister.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.GuildRegisterPanel;
import com.company.assembleegameclient.ui.panels.Panel;

public class GuildRegister extends GameObject implements IInteractiveObject {


    public function GuildRegister(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new GuildRegisterPanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/IInteractiveObject.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.Panel;

public interface IInteractiveObject {


    function getPanel(param1:GameSprite):Panel;
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ObjectProperties.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.sound.SoundEffectLibrary;

import flash.utils.Dictionary;

public class ObjectProperties {


    public var type_:int;

    public var id_:String;

    public var displayId_:String;

    public var shadowSize_:int;

    public var isPlayer_:Boolean = false;

    public var isEnemy_:Boolean = false;

    public var drawOnGround_:Boolean = false;

    public var drawUnder_:Boolean = false;

    public var occupySquare_:Boolean = false;

    public var fullOccupy_:Boolean = false;

    public var enemyOccupySquare_:Boolean = false;

    public var static_:Boolean = false;

    public var noMiniMap_:Boolean = false;

    public var protectFromGroundDamage_:Boolean = false;

    public var protectFromSink_:Boolean = false;

    public var z_:Number = 0;

    public var flying_:Boolean = false;

    public var color_:uint = 16777215;

    public var showName_:Boolean = false;

    public var dontFaceAttacks_:Boolean = false;

    public var bloodProb_:Number = 0.0;

    public var bloodColor_:uint = 16711680;

    public var shadowColor_:uint = 0;

    public var sounds_:Object = null;

    public var portrait_:TextureData = null;

    public var minSize_:int = 100;

    public var maxSize_:int = 100;

    public var sizeStep_:int = 5;

    public var whileMoving_:WhileMovingProperties = null;

    public var oldSound_:String = null;

    public var projectiles_:Dictionary;

    public var angleCorrection_:Number = 0;

    public var rotation_:Number = 0;

    public function ObjectProperties(objectXML:XML) {
        var projectileXML:XML = null;
        var soundXML:XML = null;
        var bulletType:int = 0;
        this.projectiles_ = new Dictionary();
        super();
        if (objectXML == null) {
            return;
        }
        this.type_ = int(objectXML.@type);
        this.id_ = String(objectXML.@id);
        this.displayId_ = this.id_;
        if (objectXML.hasOwnProperty("DisplayId")) {
            this.displayId_ = objectXML.DisplayId;
        }
        this.shadowSize_ = Boolean(objectXML.hasOwnProperty("ShadowSize")) ? int(objectXML.ShadowSize) : int(100);
        this.isPlayer_ = objectXML.hasOwnProperty("Player");
        this.isEnemy_ = objectXML.hasOwnProperty("Enemy");
        this.drawOnGround_ = objectXML.hasOwnProperty("DrawOnGround");
        if (this.drawOnGround_ || objectXML.hasOwnProperty("DrawUnder")) {
            this.drawUnder_ = true;
        }
        this.occupySquare_ = objectXML.hasOwnProperty("OccupySquare");
        this.fullOccupy_ = objectXML.hasOwnProperty("FullOccupy");
        this.enemyOccupySquare_ = objectXML.hasOwnProperty("EnemyOccupySquare");
        this.static_ = objectXML.hasOwnProperty("Static");
        this.noMiniMap_ = objectXML.hasOwnProperty("NoMiniMap");
        this.protectFromGroundDamage_ = objectXML.hasOwnProperty("ProtectFromGroundDamage");
        this.protectFromSink_ = objectXML.hasOwnProperty("ProtectFromSink");
        this.flying_ = objectXML.hasOwnProperty("Flying");
        this.showName_ = objectXML.hasOwnProperty("ShowName");
        this.dontFaceAttacks_ = objectXML.hasOwnProperty("DontFaceAttacks");
        if (objectXML.hasOwnProperty("Z")) {
            this.z_ = Number(objectXML.Z);
        }
        if (objectXML.hasOwnProperty("Color")) {
            this.color_ = uint(objectXML.Color);
        }
        if (objectXML.hasOwnProperty("Size")) {
            this.minSize_ = this.maxSize_ = objectXML.Size;
        } else {
            if (objectXML.hasOwnProperty("MinSize")) {
                this.minSize_ = objectXML.MinSize;
            }
            if (objectXML.hasOwnProperty("MaxSize")) {
                this.maxSize_ = objectXML.MaxSize;
            }
            if (objectXML.hasOwnProperty("SizeStep")) {
                this.sizeStep_ = objectXML.SizeStep;
            }
        }
        this.oldSound_ = Boolean(objectXML.hasOwnProperty("OldSound")) ? String(objectXML.OldSound) : null;
        for each(projectileXML in objectXML.Projectile) {
            bulletType = int(projectileXML.@id);
            this.projectiles_[bulletType] = new ProjectileProperties(projectileXML);
        }
        this.angleCorrection_ = Boolean(objectXML.hasOwnProperty("AngleCorrection")) ? Number(Number(objectXML.AngleCorrection) * Math.PI / 4) : Number(0);
        this.rotation_ = Boolean(objectXML.hasOwnProperty("Rotation")) ? Number(objectXML.Rotation) : Number(0);
        if (objectXML.hasOwnProperty("BloodProb")) {
            this.bloodProb_ = Number(objectXML.BloodProb);
        }
        if (objectXML.hasOwnProperty("BloodColor")) {
            this.bloodColor_ = uint(objectXML.BloodColor);
        }
        if (objectXML.hasOwnProperty("ShadowColor")) {
            this.shadowColor_ = uint(objectXML.ShadowColor);
        }
        for each(soundXML in objectXML.Sound) {
            if (this.sounds_ == null) {
                this.sounds_ = {};
            }
            this.sounds_[int(soundXML.@id)] = soundXML.toString();
        }
        if (objectXML.hasOwnProperty("Portrait")) {
            this.portrait_ = new TextureData(XML(objectXML.Portrait));
        }
        if (objectXML.hasOwnProperty("WhileMoving")) {
            this.whileMoving_ = new WhileMovingProperties(XML(objectXML.WhileMoving));
        }
    }

    public function loadSounds():void {
        var sound:String = null;
        if (this.sounds_ == null) {
            return;
        }
        for each(sound in this.sounds_) {
            SoundEffectLibrary.load(sound);
        }
    }

    public function getSize():int {
        if (this.minSize_ == this.maxSize_) {
            return this.minSize_;
        }
        var maxSteps:int = (this.maxSize_ - this.minSize_) / this.sizeStep_;
        return this.minSize_ + int(Math.random() * maxSteps) * this.sizeStep_;
    }
}
}

class WhileMovingProperties {


    public var z_:Number = 0.0;

    public var flying_:Boolean = false;

    function WhileMovingProperties(whileMovingXML:XML) {
        super();
        if (whileMovingXML.hasOwnProperty("Z")) {
            this.z_ = Number(whileMovingXML.Z);
        }
        this.flying_ = whileMovingXML.hasOwnProperty("Flying");
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/OneWayContainer.as">
package com.company.assembleegameclient.objects {
public class OneWayContainer extends Container {
    public function OneWayContainer(objectXML:XML) {
        super(objectXML);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/AOEEffect.as">
package com.company.assembleegameclient.objects.particles {
import flash.geom.Point;

public class AOEEffect extends ParticleEffect {


    public var start_:Point;

    public var novaRadius_:Number;

    public var color_:int;

    public function AOEEffect(start:Point, radius:Number, color:int) {
        super();
        this.start_ = start;
        this.novaRadius_ = radius;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var p:Point = null;
        var part:Particle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var SIZE:int = 200;
        var LIFETIME:int = 200;
        var numPoints:int = 4 + this.novaRadius_ * 2;
        for (var i:int = 0; i < numPoints; i++) {
            angle = i * 2 * Math.PI / numPoints;
            p = new Point(this.start_.x + this.novaRadius_ * Math.cos(angle), this.start_.y + this.novaRadius_ * Math.sin(angle));
            part = new SparkerParticle(SIZE, this.color_, LIFETIME, this.start_, p);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/BaseParticle.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.objects.BasicObject;
import com.company.util.GraphicsUtil;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;

public class BaseParticle extends BasicObject {


    public var timeLeft:Number = 0;

    public var spdX:Number;

    public var spdY:Number;

    public var spdZ:Number;

    protected var vS_:Vector.<Number>;

    protected var fillMatrix_:Matrix;

    protected var path_:GraphicsPath;

    protected var bitmapFill_:GraphicsBitmapFill;

    public function BaseParticle(bitmapData:BitmapData) {
        this.vS_ = new Vector.<Number>(8);
        this.fillMatrix_ = new Matrix();
        this.path_ = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, null);
        this.bitmapFill_ = new GraphicsBitmapFill(null, null, false, false);
        super();
        this.bitmapFill_.bitmapData = bitmapData;
        objectId_ = getNextFakeObjectId();
    }

    public function initialize(totalTime:Number, speedX:Number, speedY:Number, speedZ:Number, zPos:int):void {
        this.timeLeft = totalTime;
        this.spdX = speedX;
        this.spdY = speedY;
        this.spdZ = speedZ;
        z_ = zPos;
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var halfW:Number = this.bitmapFill_.bitmapData.width / 2;
        var halfH:Number = this.bitmapFill_.bitmapData.height / 2;
        this.vS_[6] = this.vS_[0] = posS_[3] - halfW;
        this.vS_[3] = this.vS_[1] = posS_[4] - halfH;
        this.vS_[4] = this.vS_[2] = posS_[3] + halfW;
        this.vS_[7] = this.vS_[5] = posS_[4] + halfH;
        this.path_.data = this.vS_;
        this.fillMatrix_.identity();
        this.fillMatrix_.translate(this.vS_[0], this.vS_[1]);
        this.bitmapFill_.matrix = this.fillMatrix_;
        graphicsData.push(this.bitmapFill_);
        graphicsData.push(this.path_);
        graphicsData.push(GraphicsUtil.END_FILL);
    }

    override public function removeFromMap():void {
        map_ = null;
        square_ = null;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/BubbleEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.FreeList;

public class BubbleEffect extends ParticleEffect {

    private static const PERIOD_MAX:Number = 400;


    private var poolID:String;

    public var go_:GameObject;

    public var lastUpdate_:int = -1;

    public var rate_:Number;

    private var fxProps:EffectProperties;

    public function BubbleEffect(go:GameObject, props:EffectProperties) {
        super();
        this.go_ = go;
        this.fxProps = props;
        this.rate_ = (1 - props.rate) * PERIOD_MAX + 1;
        this.poolID = "BubbleEffect_" + Math.random();
    }

    override public function update(time:int, dt:int):Boolean {
        var start:int = 0;
        var t:int = 0;
        var angle:Number = NaN;
        var d:Number = NaN;
        var part:BubbleParticle = null;
        var x:Number = NaN;
        var y:Number = NaN;
        if (this.go_.map_ == null) {
            return false;
        }
        if (!this.lastUpdate_) {
            this.lastUpdate_ = time;
            return true;
        }
        start = int(this.lastUpdate_ / this.rate_);
        var end:int = int(time / this.rate_);
        var posX:Number = this.go_.x_;
        var posY:Number = this.go_.y_;
        if (this.lastUpdate_ < 0) {
            this.lastUpdate_ = Math.max(0, time - PERIOD_MAX);
        }
        x_ = posX;
        y_ = posY;
        for (var i:int = start; i < end; i++) {
            t = i * this.rate_;
            part = BubbleParticle.create(this.poolID, this.fxProps.color, this.fxProps.speed, this.fxProps.life, this.fxProps.lifeVariance, this.fxProps.speedVariance, this.fxProps.spread);
            part.restart(t, time);
            angle = Math.random() * Math.PI;
            d = Math.random() * 0.4;
            x = posX + d * Math.cos(angle);
            y = posY + d * Math.sin(angle);
            map_.addObj(part, x, y);
        }
        this.lastUpdate_ = time;
        return true;
    }

    override public function removeFromMap():void {
        super.removeFromMap();
        FreeList.dump(this.poolID);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/BubbleParticle.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.util.FreeList;

public class BubbleParticle extends Particle {


    private const SPREAD_DAMPER:Number = 0.0025;

    public var startTime:int;

    public var speed:Number;

    public var spread:Number;

    public var dZ:Number;

    public var life:Number;

    public var lifeVariance:Number;

    public var speedVariance:Number;

    public var timeLeft:Number;

    public var frequencyX:Number;

    public var frequencyY:Number;

    public function BubbleParticle(color:uint, zSpeed:Number, life:Number, lifeVariance:Number, speedVariance:Number, spread:Number) {
        super(color, 0, 75 + Math.random() * 50);
        this.dZ = zSpeed;
        this.life = life * 1000;
        this.lifeVariance = lifeVariance;
        this.speedVariance = speedVariance;
        this.spread = spread;
        this.frequencyX = 0;
        this.frequencyY = 0;
    }

    public static function create(poolID:*, color:uint, zSpeed:Number, life:Number, lifeVariance:Number, speedVariance:Number, spread:Number):BubbleParticle {
        var bubble:BubbleParticle = FreeList.getObject(poolID) as BubbleParticle;
        if (!bubble) {
            bubble = new BubbleParticle(color, zSpeed, life, lifeVariance, speedVariance, spread);
        }
        return bubble;
    }

    public function restart(startTime:int, time:int):void {
        this.startTime = startTime;
        var r:Number = Math.random();
        this.speed = (this.dZ - this.dZ * (r * (1 - this.speedVariance))) * 10;
        if (this.spread > 0) {
            this.frequencyX = Math.random() * this.spread - 0.1;
            this.frequencyY = Math.random() * this.spread - 0.1;
        }
        var t:Number = (time - startTime) / 1000;
        this.timeLeft = this.life - this.life * (r * (1 - this.lifeVariance));
        z_ = this.speed * t;
    }

    override public function removeFromMap():void {
        super.removeFromMap();
    }

    override public function update(time:int, dt:int):Boolean {
        var t:Number = (time - this.startTime) / 1000;
        this.timeLeft = this.timeLeft - dt;
        if (this.timeLeft <= 0) {
            return false;
        }
        z_ = this.speed * t;
        if (this.spread > 0) {
            moveTo(x_ + this.frequencyX * dt * this.SPREAD_DAMPER, y_ + this.frequencyY * dt * this.SPREAD_DAMPER);
        }
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/BurstEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class BurstEffect extends ParticleEffect {


    public var center_:Point;

    public var edgePoint_:Point;

    public var color_:int;

    public function BurstEffect(go:GameObject, center:WorldPosData, edgePoint:WorldPosData, color:int) {
        super();
        this.center_ = new Point(center.x_, center.y_);
        this.edgePoint_ = new Point(edgePoint.x_, edgePoint.y_);
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var p:Point = null;
        var part:Particle = null;
        x_ = this.center_.x;
        y_ = this.center_.y;
        var radius:Number = Point.distance(this.center_, this.edgePoint_);
        var SIZE:int = 100;
        var NUMPOINTS:int = 24;
        for (var i:int = 0; i < NUMPOINTS; i++) {
            angle = i * 2 * Math.PI / NUMPOINTS;
            p = new Point(this.center_.x + radius * Math.cos(angle), this.center_.y + radius * Math.sin(angle));
            part = new SparkerParticle(SIZE, this.color_, 100 + Math.random() * 200, this.center_, p);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/CollapseEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class CollapseEffect extends ParticleEffect {


    public var center_:Point;

    public var edgePoint_:Point;

    public var color_:int;

    public function CollapseEffect(go:GameObject, center:WorldPosData, edgePoint:WorldPosData, color:int) {
        super();
        this.center_ = new Point(center.x_, center.y_);
        this.edgePoint_ = new Point(edgePoint.x_, edgePoint.y_);
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var p:Point = null;
        var part:Particle = null;
        x_ = this.center_.x;
        y_ = this.center_.y;
        var radius:Number = Point.distance(this.center_, this.edgePoint_);
        var SIZE:int = 300;
        var LIFETIME:int = 200;
        var NUMPOINTS:int = 24;
        for (var i:int = 0; i < NUMPOINTS; i++) {
            angle = i * 2 * Math.PI / NUMPOINTS;
            p = new Point(this.center_.x + radius * Math.cos(angle), this.center_.y + radius * Math.sin(angle));
            part = new SparkerParticle(SIZE, this.color_, LIFETIME, p, this.center_);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ConeBlastEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class ConeBlastEffect extends ParticleEffect {


    public var start_:Point;

    public var target_:WorldPosData;

    public var blastRadius_:Number;

    public var color_:int;

    public function ConeBlastEffect(go:GameObject, target:WorldPosData, radius:Number, color:int) {
        super();
        this.start_ = new Point(go.x_, go.y_);
        this.target_ = target;
        this.blastRadius_ = radius;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var p:Point = null;
        var part:Particle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var SIZE:int = 200;
        var LIFETIME:int = 100;
        var ARC:Number = Math.PI / 3;
        var NUMPOINTS:int = 7;
        var aimAngle:Number = Math.atan2(this.target_.y_ - this.start_.y, this.target_.x_ - this.start_.x);
        for (var i:int = 0; i < NUMPOINTS; i++) {
            angle = aimAngle - ARC / 2 + i * ARC / NUMPOINTS;
            p = new Point(this.start_.x + this.blastRadius_ * Math.cos(angle), this.start_.y + this.blastRadius_ * Math.sin(angle));
            part = new SparkerParticle(SIZE, this.color_, LIFETIME, this.start_, p);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ExplosionEffect.as">
package com.company.assembleegameclient.objects.particles {
public class ExplosionEffect extends ParticleEffect {


    public var colors_:Vector.<uint>;

    public var numParts_:int;

    public function ExplosionEffect(colors:Vector.<uint>, size:int, numParts:int) {
        super();
        this.colors_ = colors;
        size_ = size;
        this.numParts_ = numParts;
    }

    override public function update(time:int, dt:int):Boolean {
        var color:uint = 0;
        var part:Particle = null;
        if (this.colors_.length == 0) {
            return false;
        }
        for (var i:int = 0; i < this.numParts_; i++) {
            color = this.colors_[int(this.colors_.length * Math.random())];
            part = new ExplosionParticle(color, 0.5, size_, 200 + Math.random() * 100, Math.random() - 0.5, Math.random() - 0.5, 0);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;

import flash.geom.Vector3D;

class ExplosionParticle extends Particle {


    public var lifetime_:int;

    public var timeLeft_:int;

    protected var moveVec_:Vector3D;

    function ExplosionParticle(color:uint, z:Number, size:int, lifetime:int, moveVecX:Number, moveVecY:Number, moveVecZ:Number) {
        this.moveVec_ = new Vector3D();
        super(color, z, size);
        this.timeLeft_ = this.lifetime_ = lifetime;
        this.moveVec_.x = moveVecX;
        this.moveVec_.y = moveVecY;
        this.moveVec_.z = moveVecZ;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        x_ = x_ + this.moveVec_.x * dt * 0.008;
        y_ = y_ + this.moveVec_.y * dt * 0.008;
        z_ = z_ + this.moveVec_.z * dt * 0.008;
        return true;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/FlowEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class FlowEffect extends ParticleEffect {


    public var start_:Point;

    public var go_:GameObject;

    public var color_:int;

    public function FlowEffect(start:WorldPosData, go:GameObject, color:int) {
        super();
        this.start_ = new Point(start.x_, start.y_);
        this.go_ = go;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var size:int = 0;
        var part:Particle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var NUM:int = 5;
        for (var i:int = 0; i < NUM; i++) {
            size = (3 + int(Math.random() * 5)) * 20;
            part = new FlowParticle(0.5, size, this.color_, this.start_, this.go_);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}

import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.particles.Particle;

import flash.geom.Point;

class FlowParticle extends Particle {


    public var start_:Point;

    public var go_:GameObject;

    public var maxDist_:Number;

    public var flowSpeed_:Number;

    function FlowParticle(z:Number, size:int, color:int, start:Point, go:GameObject) {
        super(color, z, size);
        this.start_ = start;
        this.go_ = go;
        var here:Point = new Point(x_, y_);
        var target:Point = new Point(this.go_.x_, this.go_.y_);
        this.maxDist_ = Point.distance(here, target);
        this.flowSpeed_ = Math.random() * 5;
    }

    override public function update(time:int, dt:int):Boolean {
        var ACCEL:Number = 8;
        var here:Point = new Point(x_, y_);
        var target:Point = new Point(this.go_.x_, this.go_.y_);
        var distToGo:Number = Point.distance(here, target);
        if (distToGo < 0.5) {
            return false;
        }
        this.flowSpeed_ = this.flowSpeed_ + ACCEL * dt / 1000;
        this.maxDist_ = this.maxDist_ - this.flowSpeed_ * dt / 1000;
        var targetDist:Number = distToGo - this.flowSpeed_ * dt / 1000;
        if (targetDist > this.maxDist_) {
            targetDist = this.maxDist_;
        }
        var dx:Number = this.go_.x_ - x_;
        var dy:Number = this.go_.y_ - y_;
        dx = dx * (targetDist / distToGo);
        dy = dy * (targetDist / distToGo);
        moveTo(this.go_.x_ - dx, this.go_.y_ - dy);
        return true;
    }
}

class FlowParticle2 extends Particle {


    public var start_:Point;

    public var go_:GameObject;

    public var accel_:Number;

    public var dx_:Number;

    public var dy_:Number;

    function FlowParticle2(z:Number, size:int, color:int, accel:Number, start:Point, go:GameObject) {
        super(color, z, size);
        this.start_ = start;
        this.go_ = go;
        this.accel_ = accel;
        this.dx_ = Math.random() - 0.5;
        this.dy_ = Math.random() - 0.5;
    }

    override public function update(time:int, dt:int):Boolean {
        var here:Point = new Point(x_, y_);
        var target:Point = new Point(this.go_.x_, this.go_.y_);
        var distToGo:Number = Point.distance(here, target);
        if (distToGo < 0.5) {
            return false;
        }
        var angle:Number = Math.atan2(this.go_.y_ - y_, this.go_.x_ - x_);
        this.dx_ = this.dx_ + this.accel_ * Math.cos(angle) * dt / 1000;
        this.dy_ = this.dy_ + this.accel_ * Math.sin(angle) * dt / 1000;
        var x:Number = x_ + this.dx_ * dt / 1000;
        var y:Number = y_ + this.dy_ * dt / 1000;
        moveTo(x, y);
        return true;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/GasEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.RandomUtil;

public class GasEffect extends ParticleEffect {


    public var go_:GameObject;

    public var props:EffectProperties;

    public var color_:int;

    public var rate:Number;

    public var type:String;

    public function GasEffect(go:GameObject, props:EffectProperties) {
        super();
        this.go_ = go;
        this.color_ = props.color;
        this.rate = props.rate;
        this.props = props;
    }

    override public function update(time:int, dt:int):Boolean {
        var size:Number = NaN;
        var r:Number = NaN;
        var speedX:Number = NaN;
        var speedY:Number = NaN;
        var life:Number = NaN;
        var p:GasParticle = null;
        if (this.go_.map_ == null) {
            return false;
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        var num:int = 20;
        for (var i:int = 0; i < this.rate; i++) {
            size = (Math.random() + 0.3) * 200;
            r = Math.random();
            speedX = RandomUtil.plusMinus(this.props.speed - this.props.speed * (r * (1 - this.props.speedVariance)));
            speedY = RandomUtil.plusMinus(this.props.speed - this.props.speed * (r * (1 - this.props.speedVariance)));
            life = this.props.life * 1000 - this.props.life * 1000 * (r * this.props.lifeVariance);
            p = new GasParticle(size, this.color_, life, this.props.spread, 0.75, speedX, speedY);
            map_.addObj(p, x_, y_);
        }
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/HealEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

public class HealEffect extends ParticleEffect {


    public var go_:GameObject;

    public var color_:uint;

    public function HealEffect(go:GameObject, color:uint) {
        super();
        this.go_ = go;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var size:int = 0;
        var dist:Number = NaN;
        var part:HealParticle = null;
        if (this.go_.map_ == null) {
            return false;
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        var num:int = 10;
        for (var i:int = 0; i < num; i++) {
            angle = 2 * Math.PI * (i / num);
            size = (3 + int(Math.random() * 5)) * 20;
            dist = 0.3 + 0.4 * Math.random();
            part = new HealParticle(this.color_, Math.random() * 0.3, size, 1000, 0.1 + Math.random() * 0.1, this.go_, angle, dist);
            map_.addObj(part, x_ + dist * Math.cos(angle), y_ + dist * Math.sin(angle));
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/HealingEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

public class HealingEffect extends ParticleEffect {


    public var go_:GameObject;

    public var lastPart_:int;

    public function HealingEffect(go:GameObject) {
        super();
        this.go_ = go;
        this.lastPart_ = 0;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var size:int = 0;
        var dist:Number = NaN;
        var part:HealParticle = null;
        if (this.go_.map_ == null) {
            return false;
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        var sinceLast:int = time - this.lastPart_;
        if (sinceLast > 500) {
            angle = 2 * Math.PI * Math.random();
            size = (3 + int(Math.random() * 5)) * 20;
            dist = 0.3 + 0.4 * Math.random();
            part = new HealParticle(16777215, Math.random() * 0.3, size, 1000, 0.1 + Math.random() * 0.1, this.go_, angle, dist);
            map_.addObj(part, x_ + dist * Math.cos(angle), y_ + dist * Math.sin(angle));
            this.lastPart_ = time;
        }
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/HealParticle.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Vector3D;

public class HealParticle extends Particle {


    public var timeLeft_:int;

    public var go_:GameObject;

    public var angle_:Number;

    public var dist_:Number;

    protected var moveVec_:Vector3D;

    public function HealParticle(color:uint, z:Number, size:int, lifetime:int, moveVecZ:Number, go:GameObject, angle:Number, dist:Number) {
        this.moveVec_ = new Vector3D();
        super(color, z, size);
        this.moveVec_.z = moveVecZ;
        this.timeLeft_ = lifetime;
        this.go_ = go;
        this.angle_ = angle;
        this.dist_ = dist;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        x_ = this.go_.x_ + this.dist_ * Math.cos(this.angle_);
        y_ = this.go_.y_ + this.dist_ * Math.sin(this.angle_);
        z_ = z_ + this.moveVec_.z * dt * 0.008;
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/HitEffect.as">
package com.company.assembleegameclient.objects.particles {
public class HitEffect extends ParticleEffect {


    public var colors_:Vector.<uint>;

    public var numParts_:int;

    public var angle_:Number;

    public var speed_:Number;

    public function HitEffect(colors:Vector.<uint>, size:int, numParts:int, angle:Number, speed:Number) {
        super();
        this.colors_ = colors;
        size_ = size;
        this.numParts_ = numParts;
        this.angle_ = angle;
        this.speed_ = speed;
    }

    override public function update(time:int, dt:int):Boolean {
        var color:uint = 0;
        var part:Particle = null;
        if (this.colors_.length == 0) {
            return false;
        }
        var moveVecX:Number = this.speed_ / 600 * Math.cos(this.angle_ + Math.PI);
        var moveVecY:Number = this.speed_ / 600 * Math.sin(this.angle_ + Math.PI);
        for (var i:int = 0; i < this.numParts_; i++) {
            color = this.colors_[int(this.colors_.length * Math.random())];
            part = new HitParticle(color, 0.5, size_, 200 + Math.random() * 100, moveVecX + (Math.random() - 0.5) * 0.4, moveVecY + (Math.random() - 0.5) * 0.4, 0);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;

import flash.geom.Vector3D;

class HitParticle extends Particle {


    public var lifetime_:int;

    public var timeLeft_:int;

    protected var moveVec_:Vector3D;

    function HitParticle(color:uint, z:Number, size:int, lifetime:int, moveVecX:Number, moveVecY:Number, moveVecZ:Number) {
        this.moveVec_ = new Vector3D();
        super(color, z, size);
        this.timeLeft_ = this.lifetime_ = lifetime;
        this.moveVec_.x = moveVecX;
        this.moveVec_.y = moveVecY;
        this.moveVec_.z = moveVecZ;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        x_ = x_ + this.moveVec_.x * dt * 0.008;
        y_ = y_ + this.moveVec_.y * dt * 0.008;
        z_ = z_ + this.moveVec_.z * dt * 0.008;
        return true;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/LightningEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.RandomUtil;

import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class LightningEffect extends ParticleEffect {


    public var start_:Point;

    public var end_:Point;

    public var color_:int;

    public var particleSize_:int;

    public function LightningEffect(go:GameObject, end:WorldPosData, color:int, particleSize:int) {
        super();
        this.start_ = new Point(go.x_, go.y_);
        this.end_ = new Point(end.x_, end.y_);
        this.color_ = color;
        this.particleSize_ = particleSize;
    }

    override public function update(time:int, dt:int):Boolean {
        var p:Point = null;
        var part:Particle = null;
        var factor:Number = NaN;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var distance:Number = Point.distance(this.start_, this.end_);
        var num:int = distance * 3;
        for (var i:int = 0; i < num; i++) {
            p = Point.interpolate(this.start_, this.end_, i / num);
            part = new SparkParticle(this.particleSize_, this.color_, 1000 - i / num * 900, 0.5, 0, 0);
            factor = Math.min(i, num - i);
            map_.addObj(part, p.x + RandomUtil.plusMinus(distance / 200 * factor), p.y + RandomUtil.plusMinus(distance / 200 * factor));
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/LineEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.RandomUtil;

import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class LineEffect extends ParticleEffect {


    public var start_:Point;

    public var end_:Point;

    public var color_:int;

    public function LineEffect(go:GameObject, end:WorldPosData, color:int) {
        super();
        this.start_ = new Point(go.x_, go.y_);
        this.end_ = new Point(end.x_, end.y_);
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var p:Point = null;
        var part:Particle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var NUM:int = 30;
        for (var i:int = 0; i < NUM; i++) {
            p = Point.interpolate(this.start_, this.end_, i / NUM);
            part = new SparkParticle(100, this.color_, 700, 0.5, RandomUtil.plusMinus(1), RandomUtil.plusMinus(1));
            map_.addObj(part, p.x, p.y);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/NovaEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Point;

public class NovaEffect extends ParticleEffect {


    public var start_:Point;

    public var novaRadius_:Number;

    public var color_:int;

    public function NovaEffect(go:GameObject, radius:Number, color:int) {
        super();
        this.start_ = new Point(go.x_, go.y_);
        this.novaRadius_ = radius;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var p:Point = null;
        var part:Particle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var SIZE:int = 200;
        var LIFETIME:int = 200;
        var numPoints:int = 4 + this.novaRadius_ * 2;
        for (var i:int = 0; i < numPoints; i++) {
            angle = i * 2 * Math.PI / numPoints;
            p = new Point(this.start_.x + this.novaRadius_ * Math.cos(angle), this.start_.y + this.novaRadius_ * Math.sin(angle));
            part = new SparkerParticle(SIZE, this.color_, LIFETIME, this.start_, p);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ParticleEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.parameters.Parameters;

import flash.display.IGraphicsData;

public class ParticleEffect extends GameObject {


    public function ParticleEffect() {
        super(null);
        objectId_ = getNextFakeObjectId();
        hasShadow_ = false;
    }

    public static function fromProps(effectProps:EffectProperties, go:GameObject):ParticleEffect {
        if (!Parameters.data_.particles) {
            return null;
        }
        switch (effectProps.id) {
            case "Healing":
                return new HealingEffect(go);
            case "Fountain":
                return new FountainEffect(go);
            case "Gas":
                return new GasEffect(go, effectProps);
            case "Vent":
                return new VentEffect(go);
            case "Bubbles":
                return new BubbleEffect(go, effectProps);
            case "XMLEffect":
                return new XMLEffect(go, effectProps);
            case "CustomParticles":
                return ParticleGenerator.attachParticleGenerator(effectProps, go);
            default:
                trace("ERROR: unable to create effect: " + effectProps.id);
                return null;
        }
    }

    override public function update(time:int, dt:int):Boolean {
        return false;
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ParticleProperties.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.TextureData;
import com.company.assembleegameclient.objects.animation.AnimationsData;

public class ParticleProperties {


    public var id_:String;

    public var textureData_:TextureData;

    public var size_:int = 100;

    public var z_:Number = 0.0;

    public var duration_:Number = 0.0;

    public var animationsData_:AnimationsData = null;

    public function ParticleProperties(particleXML:XML) {
        super();
        this.id_ = particleXML.@id;
        this.textureData_ = new TextureData(particleXML);
        if (particleXML.hasOwnProperty("Size")) {
            this.size_ = Number(particleXML.Size);
        }
        if (particleXML.hasOwnProperty("Z")) {
            this.z_ = Number(particleXML.Z);
        }
        if (particleXML.hasOwnProperty("Duration")) {
            this.duration_ = Number(particleXML.Duration);
        }
        if (particleXML.hasOwnProperty("Animation")) {
            this.animationsData_ = new AnimationsData(particleXML);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/PoisonEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.RandomUtil;

public class PoisonEffect extends ParticleEffect {


    public var go_:GameObject;

    public var color_:int;

    public function PoisonEffect(go:GameObject, color:int) {
        super();
        this.go_ = go;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        if (this.go_.map_ == null) {
            return false;
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        var num:int = 10;
        for (var i:int = 0; i < num; i++) {
            map_.addObj(new SparkParticle(100, this.color_, 400, 0.75, RandomUtil.plusMinus(4), RandomUtil.plusMinus(4)), x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/RingEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

import flash.geom.Point;

public class RingEffect extends ParticleEffect {


    public var start_:Point;

    public var novaRadius_:Number;

    public var color_:int;

    public function RingEffect(go:GameObject, radius:Number, color:int) {
        super();
        this.start_ = new Point(go.x_, go.y_);
        this.novaRadius_ = radius;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var p:Point = null;
        var q:Point = null;
        var part:Particle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var SIZE:int = 0;
        var NUMPOINTS:int = 12;
        var LIFETIME:int = 200;
        for (var i:int = 0; i < NUMPOINTS; i++) {
            angle = i * 2 * Math.PI / NUMPOINTS;
            p = new Point(this.start_.x + this.novaRadius_ * Math.cos(angle), this.start_.y + this.novaRadius_ * Math.sin(angle));
            q = new Point(this.start_.x + this.novaRadius_ * 0.9 * Math.cos(angle), this.start_.y + this.novaRadius_ * 0.9 * Math.sin(angle));
            part = new SparkerParticle(SIZE, this.color_, LIFETIME, q, p);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/SparkerParticle.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.util.RandomUtil;

import flash.geom.Point;

public class SparkerParticle extends Particle {


    public var lifetime_:int;

    public var timeLeft_:int;

    public var initialSize_:int;

    public var start_:Point;

    public var end_:Point;

    public var dx_:Number;

    public var dy_:Number;

    public var pathX_:Number;

    public var pathY_:Number;

    public function SparkerParticle(size:int, color:int, lifetime:int, start:Point, end:Point) {
        super(color, 0, size);
        this.lifetime_ = this.timeLeft_ = lifetime;
        this.initialSize_ = size;
        this.start_ = start;
        this.end_ = end;
        this.dx_ = (this.end_.x - this.start_.x) / this.timeLeft_;
        this.dy_ = (this.end_.y - this.start_.y) / this.timeLeft_;
        var speed:Number = Point.distance(start, end) / this.timeLeft_;
        this.pathX_ = x_ = this.start_.x;
        this.pathY_ = y_ = this.start_.y;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        this.pathX_ = this.pathX_ + this.dx_ * dt;
        this.pathY_ = this.pathY_ + this.dy_ * dt;
        moveTo(this.pathX_, this.pathY_);
        map_.addObj(new SparkParticle(100 * (z_ + 1), color_, 600, z_, RandomUtil.plusMinus(1), RandomUtil.plusMinus(1)), this.pathX_, this.pathY_);
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/StreamEffect.as">
package com.company.assembleegameclient.objects.particles {
import flash.geom.Point;

import svera.untiered.messaging.impl.data.WorldPosData;

public class StreamEffect extends ParticleEffect {


    public var start_:Point;

    public var end_:Point;

    public var color_:int;

    public function StreamEffect(start:WorldPosData, end:WorldPosData, color:int) {
        super();
        this.start_ = new Point(start.x_, start.y_);
        this.end_ = new Point(end.x_, end.y_);
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        var size:int = 0;
        var part:StreamParticle = null;
        x_ = this.start_.x;
        y_ = this.start_.y;
        var num:int = 5;
        for (var i:int = 0; i < num; i++) {
            size = (3 + int(Math.random() * 5)) * 20;
            part = new StreamParticle(1.85, size, this.color_, 1500 + Math.random() * 3000, 0.1 + Math.random() * 0.1, this.start_, this.end_);
            map_.addObj(part, x_, y_);
        }
        return false;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;

import flash.geom.Point;
import flash.geom.Vector3D;

class StreamParticle extends Particle {


    public var timeLeft_:int;

    protected var moveVec_:Vector3D;

    public var start_:Point;

    public var end_:Point;

    public var dx_:Number;

    public var dy_:Number;

    public var pathX_:Number;

    public var pathY_:Number;

    public var xDeflect_:Number;

    public var yDeflect_:Number;

    public var period_:Number;

    function StreamParticle(z:Number, size:int, color:int, lifetime:int, moveVecZ:Number, start:Point, end:Point) {
        this.moveVec_ = new Vector3D();
        super(color, z, size);
        this.moveVec_.z = moveVecZ;
        this.timeLeft_ = lifetime;
        this.start_ = start;
        this.end_ = end;
        this.dx_ = (this.end_.x - this.start_.x) / this.timeLeft_;
        this.dy_ = (this.end_.y - this.start_.y) / this.timeLeft_;
        var speed:Number = Point.distance(start, end) / this.timeLeft_;
        var deflect:Number = 0.25;
        this.xDeflect_ = this.dy_ / speed * deflect;
        this.yDeflect_ = -this.dx_ / speed * deflect;
        this.pathX_ = x_ = this.start_.x;
        this.pathY_ = y_ = this.start_.y;
        this.period_ = 0.25 + Math.random() * 0.5;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        this.pathX_ = this.pathX_ + this.dx_ * dt;
        this.pathY_ = this.pathY_ + this.dy_ * dt;
        var deflectFactor:Number = Math.sin(this.timeLeft_ / 1000 / this.period_);
        moveTo(this.pathX_ + this.xDeflect_ * deflectFactor, this.pathY_ + this.yDeflect_ * deflectFactor);
        return true;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/TeleportEffect.as">
package com.company.assembleegameclient.objects.particles {
public class TeleportEffect extends ParticleEffect {


    public function TeleportEffect() {
        super();
    }

    override public function update(time:int, dt:int):Boolean {
        var angle:Number = NaN;
        var dist:Number = NaN;
        var lifetime:int = 0;
        var part:TeleportParticle = null;
        var num:int = 20;
        for (var i:int = 0; i < num; i++) {
            angle = 2 * Math.PI * Math.random();
            dist = 0.7 * Math.random();
            lifetime = 500 + 1000 * Math.random();
            part = new TeleportParticle(255, 50, 0.1, lifetime);
            map_.addObj(part, x_ + dist * Math.cos(angle), y_ + dist * Math.sin(angle));
        }
        return false;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;

import flash.geom.Vector3D;

class TeleportParticle extends Particle {


    public var timeLeft_:int;

    protected var moveVec_:Vector3D;

    function TeleportParticle(color:uint, size:int, moveVecZ:Number, lifetime:int) {
        this.moveVec_ = new Vector3D();
        super(color, 0, size);
        this.moveVec_.z = moveVecZ;
        this.timeLeft_ = lifetime;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        z_ = z_ + this.moveVec_.z * dt * 0.008;
        return true;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ThrowEffect.as">
package com.company.assembleegameclient.objects.particles {
import flash.geom.Point;

public class ThrowEffect extends ParticleEffect {


    public var start_:Point;

    public var end_:Point;

    public var color_:int;

    public function ThrowEffect(start:Point, end:Point, color:int) {
        super();
        this.start_ = start;
        this.end_ = end;
        this.color_ = color;
    }

    override public function update(time:int, dt:int):Boolean {
        x_ = this.start_.x;
        y_ = this.start_.y;
        var size:int = 200;
        var part:ThrowParticle = new ThrowParticle(size, this.color_, 1500, this.start_, this.end_);
        map_.addObj(part, x_, y_);
        return false;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;
import com.company.assembleegameclient.objects.particles.SparkParticle;
import com.company.assembleegameclient.util.RandomUtil;

import flash.geom.Point;

class ThrowParticle extends Particle {


    public var lifetime_:int;

    public var timeLeft_:int;

    public var initialSize_:int;

    public var start_:Point;

    public var end_:Point;

    public var dx_:Number;

    public var dy_:Number;

    public var pathX_:Number;

    public var pathY_:Number;

    function ThrowParticle(size:int, color:int, lifetime:int, start:Point, end:Point) {
        super(color, 0, size);
        this.lifetime_ = this.timeLeft_ = lifetime;
        this.initialSize_ = size;
        this.start_ = start;
        this.end_ = end;
        this.dx_ = (this.end_.x - this.start_.x) / this.timeLeft_;
        this.dy_ = (this.end_.y - this.start_.y) / this.timeLeft_;
        var speed:Number = Point.distance(start, end) / this.timeLeft_;
        this.pathX_ = x_ = this.start_.x;
        this.pathY_ = y_ = this.start_.y;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        z_ = Math.sin(this.timeLeft_ / this.lifetime_ * Math.PI) * 2;
        setSize(0);
        this.pathX_ = this.pathX_ + this.dx_ * dt;
        this.pathY_ = this.pathY_ + this.dy_ * dt;
        moveTo(this.pathX_, this.pathY_);
        map_.addObj(new SparkParticle(100 * (z_ + 1), color_, 400, z_, RandomUtil.plusMinus(1), RandomUtil.plusMinus(1)), this.pathX_, this.pathY_);
        return true;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/XMLEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

public class XMLEffect extends ParticleEffect {


    private var go_:GameObject;

    private var partProps_:ParticleProperties;

    private var cooldown_:Number;

    private var cooldownLeft_:Number;

    public function XMLEffect(go:GameObject, effectProps:EffectProperties) {
        super();
        this.go_ = go;
        this.partProps_ = ParticleLibrary.propsLibrary_[effectProps.particle];
        this.cooldown_ = effectProps.cooldown;
        this.cooldownLeft_ = 0;
    }

    override public function update(time:int, dt:int):Boolean {
        if (this.go_.map_ == null) {
            return false;
        }
        var fdt:Number = dt / 1000;
        this.cooldownLeft_ = this.cooldownLeft_ - fdt;
        if (this.cooldownLeft_ >= 0) {
            return true;
        }
        this.cooldownLeft_ = this.cooldown_;
        map_.addObj(new XMLParticle(this.partProps_), this.go_.x_, this.go_.y_);
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Party.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.map.Map;
import com.company.util.PointUtil;

import flash.utils.Dictionary;

import svera.untiered.messaging.impl.incoming.AccountList;

public class Party {

    public static const NUM_MEMBERS:int = 6;

    private static const SORT_ON_FIELDS:Array = ["starred_", "distSqFromThisPlayer_", "objectId_"];

    private static const SORT_ON_PARAMS:Array = [Array.NUMERIC | Array.DESCENDING, Array.NUMERIC, Array.NUMERIC];

    private static const PARTY_DISTANCE_SQ:int = 50 * 50;


    public var map_:Map;

    public var members_:Array;

    private var starred_:Dictionary;

    private var ignored_:Dictionary;

    private var lastUpdate_:int = -2147483648;

    public function Party(map:Map) {
        this.members_ = [];
        this.starred_ = new Dictionary(true);
        this.ignored_ = new Dictionary(true);
        super();
        this.map_ = map;
    }

    public function update(time:int, dt:int):void {
        var go:GameObject = null;
        var oPlayer:Player = null;
        if (time < this.lastUpdate_ + 500) {
            return;
        }
        this.lastUpdate_ = time;
        this.members_.length = 0;
        var player:Player = this.map_.player_;
        if (player == null) {
            return;
        }
        for each(go in this.map_.goDict_) {
            oPlayer = go as Player;
            if (!(oPlayer == null || oPlayer == player)) {
                if (this.starred_[oPlayer.accountId_] != undefined) {
                    oPlayer.starred_ = true;
                }
                oPlayer.ignored_ = this.ignored_[oPlayer.accountId_] != undefined;
                oPlayer.distSqFromThisPlayer_ = PointUtil.distanceSquaredXY(player.x_, player.y_, oPlayer.x_, oPlayer.y_);
                if (!(oPlayer.distSqFromThisPlayer_ > PARTY_DISTANCE_SQ && !oPlayer.starred_)) {
                    this.members_.push(oPlayer);
                }
            }
        }
        this.members_.sortOn(SORT_ON_FIELDS, SORT_ON_PARAMS);
        if (this.members_.length > NUM_MEMBERS) {
            this.members_.length = NUM_MEMBERS;
        }
    }

    public function lockPlayer(player:Player):void {
        this.starred_[player.accountId_] = 1;
        this.lastUpdate_ = int.MIN_VALUE;
        this.map_.gs_.gsc_.editAccountList(0, true, player.objectId_);
    }

    public function unlockPlayer(player:Player):void {
        delete this.starred_[player.accountId_];
        player.starred_ = false;
        this.lastUpdate_ = int.MIN_VALUE;
        this.map_.gs_.gsc_.editAccountList(0, false, player.objectId_);
    }

    public function setStars(starList:AccountList):void {
        var accountId:int = 0;
        for (var i:int = 0; i < starList.accountIds_.length; i++) {
            accountId = starList.accountIds_[i];
            this.starred_[accountId] = 1;
            this.lastUpdate_ = int.MIN_VALUE;
        }
    }

    public function ignorePlayer(player:Player):void {
        this.ignored_[player.accountId_] = 1;
        this.lastUpdate_ = int.MIN_VALUE;
        this.map_.gs_.gsc_.editAccountList(1, true, player.objectId_);
    }

    public function unignorePlayer(player:Player):void {
        delete this.ignored_[player.accountId_];
        player.ignored_ = false;
        this.lastUpdate_ = int.MIN_VALUE;
        this.map_.gs_.gsc_.editAccountList(1, false, player.objectId_);
    }

    public function setIgnores(ignoreList:AccountList):void {
        var accountId:int = 0;
        this.ignored_ = new Dictionary(true);
        for (var i:int = 0; i < ignoreList.accountIds_.length; i++) {
            accountId = ignoreList.accountIds_[i];
            this.ignored_[accountId] = 1;
            this.lastUpdate_ = int.MIN_VALUE;
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Portal.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.panels.PortalPanel;

import flash.display.IGraphicsData;

public class Portal extends GameObject implements IInteractiveObject {


    public var nexusPortal_:Boolean;

    public var lockedPortal_:Boolean;

    public var active_:Boolean = true;

    public function Portal(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
        this.nexusPortal_ = objectXML.hasOwnProperty("NexusPortal");
        this.lockedPortal_ = objectXML.hasOwnProperty("LockedPortal");
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        super.draw(graphicsData, camera, time);
        if (this.nexusPortal_) {
            drawName(graphicsData, camera);
        }
    }

    public function getPanel(gs:GameSprite):Panel {
        return new PortalPanel(gs, this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ProjectileProperties.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.util.ConditionEffect;

public class ProjectileProperties {


    public var bulletType_:int;

    public var objectId_:String;

    public var lifetime_:int;

    public var speed_:int;

    public var size_:int;

    public var minDamage_:int;

    public var maxDamage_:int;

    public var effects_:Vector.<uint> = null;

    public var multiHit_:Boolean;

    public var passesCover_:Boolean;

    public var armorPiercing_:Boolean;

    public var particleTrail_:Boolean;

    public var wavy_:Boolean;

    public var parametric_:Boolean;

    public var boomerang_:Boolean;

    public var amplitude_:Number;

    public var frequency_:Number;

    public var magnitude_:Number;

    public var accelerate_:Boolean;

    public var decelerate_:Boolean;

    public function ProjectileProperties(projectileXML:XML) {
        var condEffectXML:XML = null;
        super();
        this.bulletType_ = int(projectileXML.@id);
        this.objectId_ = projectileXML.ObjectId;
        this.lifetime_ = int(projectileXML.LifetimeMS);
        this.speed_ = int(projectileXML.Speed);
        this.size_ = Boolean(projectileXML.hasOwnProperty("Size")) ? int(Number(projectileXML.Size)) : int(-1);
        if (projectileXML.hasOwnProperty("Damage")) {
            this.minDamage_ = this.maxDamage_ = int(projectileXML.Damage);
        } else {
            this.minDamage_ = int(projectileXML.MinDamage);
            this.maxDamage_ = int(projectileXML.MaxDamage);
        }
        for each(condEffectXML in projectileXML.ConditionEffect) {
            if (this.effects_ == null) {
                this.effects_ = new Vector.<uint>();
            }
            this.effects_.push(ConditionEffect.getConditionEffectFromName(String(condEffectXML)));
        }
        this.multiHit_ = projectileXML.hasOwnProperty("MultiHit");
        this.passesCover_ = projectileXML.hasOwnProperty("PassesCover");
        this.armorPiercing_ = projectileXML.hasOwnProperty("ArmorPiercing");
        this.particleTrail_ = projectileXML.hasOwnProperty("ParticleTrail");
        this.wavy_ = projectileXML.hasOwnProperty("Wavy");
        this.parametric_ = projectileXML.hasOwnProperty("Parametric");
        this.boomerang_ = projectileXML.hasOwnProperty("Boomerang");
        this.amplitude_ = Boolean(projectileXML.hasOwnProperty("Amplitude")) ? Number(Number(projectileXML.Amplitude)) : Number(0);
        this.frequency_ = Boolean(projectileXML.hasOwnProperty("Frequency")) ? Number(Number(projectileXML.Frequency)) : Number(1);
        this.magnitude_ = Boolean(projectileXML.hasOwnProperty("Magnitude")) ? Number(Number(projectileXML.Magnitude)) : Number(3);
        this.accelerate_ = Boolean(projectileXML.hasOwnProperty("Accelerate"));
        this.decelerate_ = Boolean(projectileXML.hasOwnProperty("Decelerate"));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ReskinVendor.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.Panel;

import svera.untiered.characters.reskin.view.ReskinPanel;

public class ReskinVendor extends GameObject implements IInteractiveObject {


    public function ReskinVendor(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new ReskinPanel(gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/SellableObject.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.tooltip.ToolTip;

import flash.display.BitmapData;

import svera.untiered.game.view.SellableObjectPanel;

public class SellableObject extends GameObject implements IInteractiveObject {


    public var price_:int = 0;

    public var currency_:int = -1;

    public var rankReq_:int = 0;

    public var guildRankReq_:int = -1;

    public function SellableObject(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function setPrice(price:int):void {
        this.price_ = price;
    }

    public function setCurrency(currency:int):void {
        this.currency_ = currency;
    }

    public function setRankReq(rankReq:int):void {
        this.rankReq_ = rankReq;
    }

    public function soldObjectName():String {
        return null;
    }

    public function soldObjectInternalName():String {
        return null;
    }

    public function getTooltip():ToolTip {
        return null;
    }

    public function getIcon():BitmapData {
        return null;
    }

    public function getPanel(gs:GameSprite):Panel {
        return new SellableObjectPanel(gs, this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Sign.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.util.TextureRedrawer;

import flash.display.BitmapData;
import flash.text.TextField;
import flash.text.TextFieldAutoSize;
import flash.text.TextFormat;
import flash.text.TextFormatAlign;

public class Sign extends GameObject {


    public function Sign(objectXML:XML) {
        super(objectXML);
        texture_ = null;
    }

    override protected function getTexture(camera:Camera, time:int):BitmapData {
        if (texture_ != null) {
            return texture_;
        }
        var txt:TextField = new TextField();
        txt.multiline = true;
        txt.wordWrap = false;
        txt.autoSize = TextFieldAutoSize.LEFT;
        txt.textColor = 16777215;
        txt.embedFonts = true;
        var newFormat:TextFormat = new TextFormat();
        newFormat.align = TextFormatAlign.CENTER;
        newFormat.font = "Myriad Pro";
        newFormat.size = 24;
        newFormat.color = 16777215;
        newFormat.bold = true;
        txt.defaultTextFormat = newFormat;
        txt.text = name_.split("|").join("\n");
        var bitmapData:BitmapData = new BitmapData(txt.width, txt.height, true, 0);
        bitmapData.draw(txt);
        texture_ = TextureRedrawer.redraw(bitmapData, size_, false, 0);
        return texture_;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Stalagmite.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.engine3d.Object3D;
import com.company.assembleegameclient.engine3d.ObjectFace3D;

public class Stalagmite extends GameObject {

    private static const bs:Number = Math.PI / 6;

    private static const cs:Number = Math.PI / 3;


    public function Stalagmite(objectXML:XML) {
        super(objectXML);
        var a1:Number = bs + cs * Math.random();
        var a2:Number = 2 * cs + bs + cs * Math.random();
        var a3:Number = 4 * cs + bs + cs * Math.random();
        obj3D_ = new Object3D();
        obj3D_.vL_.push(Math.cos(a1) * 0.3, Math.sin(a1) * 0.3, 0, Math.cos(a2) * 0.3, Math.sin(a2) * 0.3, 0, Math.cos(a3) * 0.3, Math.sin(a3) * 0.3, 0, 0, 0, 0.6 + 0.6 * Math.random());
        obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[0, 1, 3]), new ObjectFace3D(obj3D_, new <int>[1, 2, 3]), new ObjectFace3D(obj3D_, new <int>[2, 0, 3]));
        obj3D_.uvts_.push(0, 1, 0, 0.5, 1, 0, 1, 1, 0, 0.5, 0, 0);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/thrown/ThrownObject.as">
package com.company.assembleegameclient.objects.thrown {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Square;
import com.company.assembleegameclient.objects.BasicObject;
import com.company.util.GraphicsUtil;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;

public class ThrownObject extends BasicObject {


    protected var bitmapFill_:GraphicsBitmapFill;

    protected var path_:GraphicsPath;

    protected var vS_:Vector.<Number>;

    protected var fillMatrix_:Matrix;

    public var size_:int;

    private var _bitmapData:BitmapData;

    protected var _rotationDelta:Number = 0;

    private var _rotation:Number = 0;

    public function ThrownObject(z:Number, bitmapData:BitmapData) {
        this.bitmapFill_ = new GraphicsBitmapFill(null, null, false, false);
        this.path_ = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, null);
        this.vS_ = new Vector.<Number>();
        this.fillMatrix_ = new Matrix();
        super();
        hasShadow_ = false;
        objectId_ = getNextFakeObjectId();
        this._bitmapData = bitmapData;
        z_ = z;
    }

    public function moveTo(x:Number, y:Number):Boolean {
        var square:Square = map_.getSquare(x, y);
        if (!square) {
            return false;
        }
        x_ = x;
        y_ = y;
        square_ = square;
        return true;
    }

    public function setSize(size:int):void {
        this.size_ = size / 100 * 5;
    }

    override public function drawShadow(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        trace("denied");
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var texture:BitmapData = this._bitmapData;
        var w:int = texture.width;
        var h:int = texture.height;
        this.vS_.length = 0;
        this.vS_.push(posS_[3] - w / 2, posS_[4] - h / 2, posS_[3] + w / 2, posS_[4] - h / 2, posS_[3] + w / 2, posS_[4] + h / 2, posS_[3] - w / 2, posS_[4] + h / 2);
        this.path_.data = this.vS_;
        this.bitmapFill_.bitmapData = texture;
        this.fillMatrix_.identity();
        if (this._rotationDelta) {
            this._rotation = this._rotation + this._rotationDelta;
            this.fillMatrix_.translate(-w / 2, -h / 2);
            this.fillMatrix_.rotate(this._rotation);
            this.fillMatrix_.translate(w / 2, h / 2);
        }
        this.fillMatrix_.translate(this.vS_[0], this.vS_[1]);
        this.bitmapFill_.matrix = this.fillMatrix_;
        graphicsData.push(this.bitmapFill_);
        graphicsData.push(this.bitmapFill_);
        graphicsData.push(this.path_);
        graphicsData.push(GraphicsUtil.END_FILL);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/thrown/ThrownProjectile.as">
package com.company.assembleegameclient.objects.thrown {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.util.TextureRedrawer;

import flash.display.BitmapData;
import flash.geom.Point;

public class ThrownProjectile extends ThrownObject {


    public var lifetime_:int;

    public var timeLeft_:int;

    public var start_:Point;

    public var end_:Point;

    public var dx_:Number;

    public var dy_:Number;

    public var pathX_:Number;

    public var pathY_:Number;

    private var bitmapData:BitmapData;

    public function ThrownProjectile(id:uint, lifetime:int, start:Point, end:Point) {
        this.bitmapData = ObjectLibrary.getTextureFromType(id);
        this.bitmapData = TextureRedrawer.redraw(this.bitmapData, 80, true, 0, false);
        _rotationDelta = 0.2;
        super(0, this.bitmapData);
        this.lifetime_ = this.timeLeft_ = lifetime;
        this.start_ = start;
        this.end_ = end;
        this.dx_ = (this.end_.x - this.start_.x) / this.timeLeft_;
        this.dy_ = (this.end_.y - this.start_.y) / this.timeLeft_;
        var speed:Number = Point.distance(start, end) / this.timeLeft_;
        this.pathX_ = x_ = this.start_.x;
        this.pathY_ = y_ = this.start_.y;
    }

    override public function update(time:int, dt:int):Boolean {
        this.timeLeft_ = this.timeLeft_ - dt;
        if (this.timeLeft_ <= 0) {
            return false;
        }
        z_ = Math.sin(this.timeLeft_ / this.lifetime_ * Math.PI) * 2;
        setSize(z_);
        this.pathX_ = this.pathX_ + this.dx_ * dt;
        this.pathY_ = this.pathY_ + this.dy_ * dt;
        moveTo(this.pathX_, this.pathY_);
        return true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/thrown/ThrowProjectileEffect.as">
package com.company.assembleegameclient.objects.thrown {
import com.company.assembleegameclient.objects.particles.ParticleEffect;

import flash.geom.Point;

public class ThrowProjectileEffect extends ParticleEffect {


    public var start_:Point;

    public var end_:Point;

    public var id_:uint;

    public function ThrowProjectileEffect(objectId:int, start:Point, end:Point) {
        super();
        this.start_ = start;
        this.end_ = end;
        this.id_ = objectId;
    }

    override public function update(time:int, dt:int):Boolean {
        x_ = this.start_.x;
        y_ = this.start_.y;
        var size:int = 10000;
        var projectile:ThrownProjectile = new ThrownProjectile(this.id_, 1500, this.start_, this.end_);
        map_.addObj(projectile, x_, y_);
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/AccountLoadingScreen.as">
package com.company.assembleegameclient.screens {
import com.company.ui.SimpleText;
import com.company.untiered.graphics.ScreenGraphic;

import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

public class AccountLoadingScreen extends Sprite {


    private var loadingText_:SimpleText;

    public function AccountLoadingScreen() {
        super();
        addChild(new ScreenGraphic());
        this.loadingText_ = new SimpleText(30, 16777215, false, 0, 0);
        this.loadingText_.setBold(true);
        this.loadingText_.htmlText = "<p align=\"center\">Loading...</p>";
        this.loadingText_.autoSize = TextFieldAutoSize.CENTER;
        this.loadingText_.updateMetrics();
        this.loadingText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4)];
        addChild(this.loadingText_);
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
    }

    protected function onAddedToStage(event:Event):void {
        removeEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        this.loadingText_.x = stage.stageWidth / 2 - this.loadingText_.width / 2;
        this.loadingText_.y = 526;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/CharacterList.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.screens.charrects.CharacterRectList;

import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;

import svera.untiered.core.model.PlayerModel;

public class CharacterList extends Sprite {

    public static const WIDTH:int = 760;

    public static const HEIGHT:int = 430;


    public var charRectList_:CharacterRectList;

    public function CharacterList(model:PlayerModel) {
        var shape:Shape = null;
        var g:Graphics = null;
        super();
        this.charRectList_ = new CharacterRectList();
        addChild(this.charRectList_);
        if (height > 400) {
            shape = new Shape();
            g = shape.graphics;
            g.beginFill(0);
            g.drawRect(0, 0, WIDTH, HEIGHT);
            g.endFill();
            addChild(shape);
            mask = shape;
        }
    }

    public function setPos(pos:Number):void {
        this.charRectList_.y = pos;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/events/DeleteCharacterEvent.as">
package com.company.assembleegameclient.screens.events {
import com.company.assembleegameclient.appengine.SavedCharacter;

import flash.events.Event;

public class DeleteCharacterEvent extends Event {

    public static const DELETE_CHARACTER_EVENT:String = "DELETE_CHARACTER_EVENT";


    public var savedChar_:SavedCharacter;

    public function DeleteCharacterEvent(savedChar:SavedCharacter) {
        super(DELETE_CHARACTER_EVENT);
        this.savedChar_ = savedChar;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/ScoreTextLine.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.ui.SimpleText;

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.utils.getTimer;

public class ScoreTextLine extends Sprite {

    public static var textTooltip_:TextToolTip = new TextToolTip(3552822, 10197915, null, "", 150);


    public var name_:String;

    public var desc_:String;

    public var number_:int;

    public var numberPrefix_:String;

    public var unit_:String;

    private var startTime_:int = 0;

    private var nameText_:SimpleText;

    private var numberText_:SimpleText;

    private var unitIcon_:DisplayObject;

    public function ScoreTextLine(size:int, nameColor:uint, numColor:uint, name:String, desc:String, number:int, numberPrefix:String, unit:String, unitIcon:DisplayObject) {
        super();
        this.name_ = name;
        this.desc_ = desc;
        this.number_ = number;
        this.numberPrefix_ = numberPrefix;
        this.unit_ = unit;
        this.nameText_ = new SimpleText(size, nameColor, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.text = this.name_;
        this.nameText_.updateMetrics();
        this.nameText_.x = 410 - this.nameText_.textWidth;
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        addChild(this.nameText_);
        if (this.number_ != -1) {
            this.numberText_ = new SimpleText(size, numColor, false, 0, 0);
            this.numberText_.setBold(true);
            this.numberText_.text = numberPrefix + "0" + " " + unit;
            this.numberText_.updateMetrics();
            this.numberText_.x = 450;
            this.numberText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
            addChild(this.numberText_);
        }
        if (unitIcon != null) {
            this.unitIcon_ = unitIcon;
            if (this.numberText_ != null) {
                this.unitIcon_.x = this.numberText_.x + this.numberText_.width - 4;
                unitIcon.y = this.numberText_.height / 2 - this.unitIcon_.height / 2 + 2;
            } else {
                this.unitIcon_.x = 450;
                unitIcon.y = this.nameText_.height / 2 - this.unitIcon_.height / 2 + 2;
            }
            addChild(this.unitIcon_);
        }
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function skip():void {
        this.startTime_ = -1000000;
    }

    private function onAddedToStage(event:Event):void {
        if (this.startTime_ == 0) {
            this.startTime_ = getTimer();
        }
        addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    private function onRemovedFromStage(event:Event):void {
        this.removeTextTooltip();
        removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        removeEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        removeEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    public function onEnterFrame(event:Event):void {
        var n:int = 0;
        var t:Number = Math.min(1, (getTimer() - this.startTime_) / 500);
        if (this.numberText_ != null) {
            n = this.number_ * t;
            this.numberText_.text = this.numberPrefix_ + n.toString() + " " + this.unit_;
            this.numberText_.updateMetrics();
            if (this.unitIcon_ != null) {
                this.unitIcon_.x = this.numberText_.x + this.numberText_.width - 4;
                this.unitIcon_.y = this.numberText_.height / 2 - this.unitIcon_.height / 2 + 2;
            }
        }
        if (t == 1) {
            removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
    }

    public function onMouseOver(event:Event):void {
        this.removeTextTooltip();
        if (this.desc_ == null) {
            return;
        }
        textTooltip_.setText(this.desc_);
        stage.addChild(textTooltip_);
    }

    public function onRollOut(event:Event):void {
        this.removeTextTooltip();
    }

    private function removeTextTooltip():void {
        if (textTooltip_.parent != null) {
            textTooltip_.parent.removeChild(textTooltip_);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/UnpackEmbed.as">
package com.company.assembleegameclient.screens {
import flash.display.Loader;
import flash.display.LoaderInfo;
import flash.display.MovieClip;
import flash.events.Event;

import mx.core.MovieClipAsset;

import org.osflash.signals.Signal;

public class UnpackEmbed {


    private var _ready:Signal;

    private var _asset:MovieClipAsset;

    private var _content:MovieClip;

    public function UnpackEmbed(assetClass:Class) {
        super();
        this._asset = new assetClass();
        this._ready = new Signal(UnpackEmbed);
        var loader:Loader = Loader(this._asset.getChildAt(0));
        var info:LoaderInfo = loader.contentLoaderInfo;
        info.addEventListener(Event.COMPLETE, this.onLoadComplete);
    }

    private function onLoadComplete(event:Event):void {
        var info:LoaderInfo = LoaderInfo(event.target);
        info.removeEventListener(Event.COMPLETE, this.onLoadComplete);
        this._content = MovieClip(info.loader.content);
        this._ready.dispatch(this);
    }

    public function get content():MovieClip {
        return this._content;
    }

    public function get ready():Signal {
        return this._ready;
    }

    public function get asset():MovieClipAsset {
        return this._asset;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/sound/SFX.as">
package com.company.assembleegameclient.sound {
import com.company.assembleegameclient.parameters.Parameters;

public class SFX {
    public function SFX() {
        super();
    }

    public static function setPlaySFX(playSFX:Boolean):void {
        Parameters.data_.playSFX = playSFX;
        Parameters.save();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/board/EditBoard.as">
package com.company.assembleegameclient.ui.board {
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.Graphics;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

public class EditBoard extends Sprite {

    public static const TEXT_WIDTH:int = 400;

    public static const TEXT_HEIGHT:int = 400;


    private var text_:String;

    public var w_:int;

    public var h_:int;

    private var boardText_:SimpleText;

    private var mainSprite_:Sprite;

    private var fullTextSprite_:Sprite;

    private var scrollBar_:Scrollbar;

    private var cancelButton_:TextButton;

    private var saveButton_:TextButton;

    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(3355443, 1);

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(2, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[lineStyle_, backgroundFill_, path_, GraphicsUtil.END_FILL, GraphicsUtil.END_STROKE];

    function EditBoard(text:String) {
        super();
        this.text_ = text;
        this.mainSprite_ = new Sprite();
        var shape:Shape = new Shape();
        var g:Graphics = shape.graphics;
        g.beginFill(0);
        g.drawRect(0, 0, TEXT_WIDTH, TEXT_HEIGHT);
        g.endFill();
        this.mainSprite_.addChild(shape);
        this.mainSprite_.mask = shape;
        addChild(this.mainSprite_);
        this.boardText_ = new SimpleText(16, 11776947, true, TEXT_WIDTH, TEXT_HEIGHT);
        this.boardText_.border = false;
        this.boardText_.mouseEnabled = true;
        this.boardText_.multiline = true;
        this.boardText_.wordWrap = true;
        this.boardText_.text = text;
        this.boardText_.useTextDimensions();
        this.boardText_.addEventListener(Event.CHANGE, this.onTextChange);
        this.boardText_.addEventListener(Event.SCROLL, this.onTextChange);
        this.mainSprite_.addChild(this.boardText_);
        this.scrollBar_ = new Scrollbar(16, TEXT_HEIGHT - 4);
        this.scrollBar_.x = TEXT_WIDTH + 6;
        this.scrollBar_.y = 0;
        this.scrollBar_.setIndicatorSize(400, this.boardText_.height);
        this.scrollBar_.addEventListener(Event.CHANGE, this.onScrollBarChange);
        addChild(this.scrollBar_);
        this.w_ = TEXT_WIDTH + 26;
        this.cancelButton_ = new TextButton(14, "Cancel", 120);
        this.cancelButton_.x = 4;
        this.cancelButton_.y = TEXT_HEIGHT + 4;
        this.cancelButton_.addEventListener(MouseEvent.CLICK, this.onCancel);
        addChild(this.cancelButton_);
        this.saveButton_ = new TextButton(14, "Save", 120);
        this.saveButton_.x = this.w_ - this.saveButton_.width - 4;
        this.saveButton_.y = TEXT_HEIGHT + 4;
        this.saveButton_.addEventListener(MouseEvent.CLICK, this.onSave);
        addChild(this.saveButton_);
        this.h_ = TEXT_HEIGHT + this.saveButton_.height + 8;
        graphics.clear();
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(-6, -6, this.w_ + 12, this.h_ + 12, 4, [1, 1, 1, 1], this.path_);
        graphics.drawGraphicsData(this.graphicsData_);
        this.scrollBar_.setIndicatorSize(TEXT_HEIGHT, this.boardText_.textHeight, false);
    }

    public function getText():String {
        return this.boardText_.text;
    }

    private function onScrollBarChange(event:Event):void {
        this.boardText_.scrollV = 1 + this.scrollBar_.pos() * this.boardText_.maxScrollV;
    }

    private function onCancel(event:Event):void {
        dispatchEvent(new Event(Event.CANCEL));
    }

    private function onSave(event:Event):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function onTextChange(event:Event):void {
        if (this.scrollBar_ == null) {
            return;
        }
        this.scrollBar_.setIndicatorSize(TEXT_HEIGHT, this.boardText_.textHeight, false);
        if (this.boardText_.maxScrollV == 1) {
            this.scrollBar_.setPos(0);
        } else {
            this.scrollBar_.setPos((this.boardText_.scrollV - 1) / (this.boardText_.maxScrollV - 1));
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/ClickableText.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class ClickableText extends Sprite {


    public var text_:SimpleText;

    public var actualWidth_:int;

    public var actualHeight_:int;

    public var defaultColor_:uint = 16777215;

    public function ClickableText(textSize:int, bold:Boolean, text:String) {
        super();
        this.text_ = new SimpleText(textSize, 16777215, false, 0, 0);
        this.text_.setBold(bold);
        this.text_.text = text;
        this.text_.updateMetrics();
        addChild(this.text_);
        this.text_.filters = [new DropShadowFilter(0, 0, 0)];
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        addEventListener(MouseEvent.CLICK, this.onMouseClick);
    }

    public function makeStatic(text:String):void {
        this.text_.text = text;
        this.text_.updateMetrics();
        this.setDefaultColor(11776947);
        mouseEnabled = false;
        mouseChildren = false;
    }

    public function setColor(color:uint):void {
        this.text_.setColor(color);
    }

    public function setDefaultColor(color:uint):void {
        this.defaultColor_ = color;
        this.setColor(this.defaultColor_);
    }

    private function onMouseOver(event:MouseEvent):void {
        this.setColor(16768133);
    }

    private function onMouseOut(event:MouseEvent):void {
        this.setColor(this.defaultColor_);
    }

    private function onMouseClick(event:MouseEvent):void {
        SoundEffectLibrary.play("button_click");
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/components/TimerDisplay.as">
package com.company.assembleegameclient.ui.components {
import com.company.ui.SimpleText;

import flash.display.Sprite;

import svera.lib.util.TimeWriter;

public class TimerDisplay extends Sprite {


    private var _textField:SimpleText;

    private var stringifier:TimeWriter;

    public function TimerDisplay(textField:SimpleText) {
        this.stringifier = new TimeWriter();
        super();
        this.initTextField(textField);
    }

    private function initTextField(textField:SimpleText):void {
        addChild(this._textField = textField);
    }

    public function update(time:Number):void {
        this._textField.text = this.stringifier.parseTime(time);
        this._textField.updateMetrics();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/dropdown/DropDownItem.as">
package com.company.assembleegameclient.ui.dropdown {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class DropDownItem extends Sprite {


    public var w_:int;

    public var h_:int;

    private var nameText_:SimpleText;

    public function DropDownItem(name:String, w:int, h:int) {
        super();
        this.w_ = w;
        this.h_ = h;
        this.nameText_ = new SimpleText(16, 11776947, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.text = name;
        this.nameText_.updateMetrics();
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.nameText_.x = this.w_ / 2 - this.nameText_.width / 2;
        this.nameText_.y = this.h_ / 2 - this.nameText_.height / 2;
        addChild(this.nameText_);
        this.drawBackground(3552822);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
    }

    public function getValue():String {
        return this.nameText_.text;
    }

    private function onMouseOver(event:MouseEvent):void {
        this.drawBackground(5658198);
    }

    private function onMouseOut(event:MouseEvent):void {
        this.drawBackground(3552822);
    }

    private function drawBackground(color:uint):void {
        graphics.clear();
        graphics.lineStyle(1, 11776947);
        graphics.beginFill(color, 1);
        graphics.drawRect(0, 0, this.w_, this.h_);
        graphics.endFill();
        graphics.lineStyle();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/ElementFormats.as">
package com.company.assembleegameclient.ui {
import flash.text.engine.CFFHinting;
import flash.text.engine.ElementFormat;
import flash.text.engine.FontDescription;
import flash.text.engine.FontLookup;
import flash.text.engine.FontPosture;
import flash.text.engine.FontWeight;
import flash.text.engine.RenderingMode;

public class ElementFormats {
    private static var FONT_DESCRIPTION:String = "MyriadProBoldCFF,_sans";

    public var normalFormat_:ElementFormat = null;
    public var serverFormat_:ElementFormat = null;
    public var clientFormat_:ElementFormat = null;
    public var helpFormat_:ElementFormat = null;
    public var errorFormat_:ElementFormat = null;
    public var adminFormat_:ElementFormat = null;
    public var enemyFormat_:ElementFormat = null;
    public var playerFormat_:ElementFormat = null;
    public var sepFormat_:ElementFormat = null;
    public var tellFormat_:ElementFormat = null;
    public var guildFormat_:ElementFormat = null;

    public function ElementFormats() {
        super();
        this.normalFormat_ = this.newDefaultFormat();
        this.normalFormat_.color = 16777215;
        this.serverFormat_ = this.newDefaultFormat();
        this.serverFormat_.color = 16776960;
        this.clientFormat_ = this.newDefaultFormat();
        this.clientFormat_.color = 255;
        this.helpFormat_ = this.newDefaultFormat();
        this.helpFormat_.color = 16734981;
        this.errorFormat_ = this.newDefaultFormat();
        this.errorFormat_.color = 16711680;
        this.adminFormat_ = this.newDefaultFormat();
        this.adminFormat_.color = 16776960;
        this.enemyFormat_ = this.newDefaultFormat();
        this.enemyFormat_.color = 16754688;
        this.playerFormat_ = this.newDefaultFormat();
        this.playerFormat_.color = 65280;
        this.sepFormat_ = this.newDefaultFormat();
        this.sepFormat_.color = 3552822;
        this.tellFormat_ = this.newDefaultFormat();
        this.tellFormat_.color = 61695;
        this.guildFormat_ = this.newDefaultFormat();
        this.guildFormat_.color = 10944349;
    }

    private function newDefaultFormat():ElementFormat {
        var elementFormat:ElementFormat = new ElementFormat();
        elementFormat.fontDescription = new FontDescription(FONT_DESCRIPTION, FontWeight.BOLD, FontPosture.NORMAL, FontLookup.EMBEDDED_CFF, RenderingMode.CFF, CFFHinting.HORIZONTAL_STEM);
        elementFormat.fontSize = 14;
        return elementFormat;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/guild/GuildPlayerListEvent.as">
package com.company.assembleegameclient.ui.guild {
import flash.events.Event;

public class GuildPlayerListEvent extends Event {

    public static const SET_RANK:String = "SET_RANK";

    public static const REMOVE_MEMBER:String = "REMOVE_MEMBER";


    public var name_:String;

    public var rank_:int;

    public function GuildPlayerListEvent(type:String, name:String, rank:int = -1) {
        super(type, true);
        this.name_ = name;
        this.rank_ = rank;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/GuildText.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.util.GuildUtil;
import com.company.ui.SimpleText;
import com.company.util.SpriteUtil;

import flash.display.Bitmap;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;

public class GuildText extends Sprite {


    private var name_:String;

    private var rank_:int;

    private var icon_:Bitmap;

    private var guildName_:SimpleText;

    public function GuildText(name:String, rank:int, w:int = 0) {
        super();
        this.icon_ = new Bitmap(null);
        this.icon_.y = -8;
        this.icon_.x = -8;
        var stWidth:int = w == 0 ? int(0) : int(w - (this.icon_.width - 16));
        this.guildName_ = new SimpleText(16, 16777215, false, stWidth, 0);
        this.guildName_.filters = [new DropShadowFilter(0, 0, 0)];
        this.guildName_.x = 24;
        this.draw(name, rank);
    }

    public function draw(name:String, rank:int):void {
        if (this.name_ == name && this.rank_ == rank) {
            return;
        }
        this.name_ = name;
        this.rank_ = rank;
        if (this.name_ == null || this.name_ == "") {
            SpriteUtil.safeRemoveChild(this, this.icon_);
            SpriteUtil.safeRemoveChild(this, this.guildName_);
        } else {
            this.icon_.bitmapData = GuildUtil.rankToIcon(this.rank_, 20);
            SpriteUtil.safeAddChild(this, this.icon_);
            this.guildName_.text = this.name_;
            this.guildName_.useTextDimensions();
            SpriteUtil.safeAddChild(this, this.guildName_);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/IconButton.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.KeyCodes;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;

public class IconButton extends Sprite {

    protected static const mouseOverCT:ColorTransform = new ColorTransform(1, 220 / 255, 133 / 255);


    protected var origIconBitmapData_:BitmapData;

    protected var iconBitmapData_:BitmapData;

    protected var icon_:Bitmap;

    protected var hotkeyName_:String;

    protected var ct_:ColorTransform = null;

    protected var toolTip_:TextToolTip = null;

    public function IconButton(bitmapData:BitmapData, toolTipTitle:String, hotkeyName:String) {
        super();
        this.origIconBitmapData_ = bitmapData;
        this.iconBitmapData_ = TextureRedrawer.redraw(this.origIconBitmapData_, 320 / this.origIconBitmapData_.width, true, 0);
        this.icon_ = new Bitmap(this.iconBitmapData_);
        this.icon_.x = -12;
        this.icon_.y = -12;
        addChild(this.icon_);
        this.hotkeyName_ = hotkeyName;
        if (toolTipTitle != "") {
            this.toolTip_ = new TextToolTip(3552822, 10197915, toolTipTitle, "", 200);
        }
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
    }

    public function setColorTransform(ct:ColorTransform):void {
        if (ct == this.ct_) {
            return;
        }
        this.ct_ = ct;
        if (this.ct_ == null) {
            transform.colorTransform = MoreColorUtil.identity;
        } else {
            transform.colorTransform = this.ct_;
        }
    }

    private function onRemovedFromStage(event:Event):void {
        if (this.toolTip_ != null && this.toolTip_.parent != null) {
            this.toolTip_.parent.removeChild(this.toolTip_);
        }
    }

    protected function onMouseOver(event:MouseEvent):void {
        this.setColorTransform(mouseOverCT);
        if (this.toolTip_ != null && !stage.contains(this.toolTip_)) {
            this.toolTip_.setText("Hotkey: " + KeyCodes.CharCodeStrings[Parameters.data_[this.hotkeyName_]]);
            stage.addChild(this.toolTip_);
        }
    }

    protected function onMouseOut(event:MouseEvent):void {
        this.setColorTransform(null);
        if (this.toolTip_ != null && this.toolTip_.parent != null) {
            this.toolTip_.parent.removeChild(this.toolTip_);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/LineBreakDesign.as">
package com.company.assembleegameclient.ui {
import com.company.util.GraphicsUtil;

import flash.display.GraphicsPath;
import flash.display.GraphicsPathWinding;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.display.Shape;

public class LineBreakDesign extends Shape {


    private var designFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var designPath_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>(), GraphicsPathWinding.NON_ZERO);

    private const designGraphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[designFill_, designPath_, GraphicsUtil.END_FILL];

    public function LineBreakDesign(width:int, color:uint) {
        super();
        this.setWidthColor(width, color);
    }

    public function setWidthColor(width:int, color:uint):void {
        graphics.clear();
        this.designFill_.color = color;
        GraphicsUtil.clearPath(this.designPath_);
        GraphicsUtil.drawDiamond(0, 0, 4, this.designPath_);
        GraphicsUtil.drawDiamond(width, 0, 4, this.designPath_);
        GraphicsUtil.drawRect(0, -1, width, 2, this.designPath_);
        graphics.drawGraphicsData(this.designGraphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/menu/Menu.as">
package com.company.assembleegameclient.ui.menu {
import com.company.util.GraphicsUtil;
import com.company.util.RectangleUtil;

import flash.display.CapsStyle;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.Rectangle;

public class Menu extends Sprite {


    private var background_:uint;

    private var outline_:uint;

    private var yOffset:int;

    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(0, 1);

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(0, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[lineStyle_, backgroundFill_, path_, GraphicsUtil.END_FILL, GraphicsUtil.END_STROKE];

    public function Menu(background:uint, outline:uint) {
        super();
        this.background_ = background;
        this.outline_ = outline;
        this.yOffset = 40;
        filters = [new DropShadowFilter(0, 0, 0, 1, 16, 16)];
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    protected function addOption(option:MenuOption):void {
        option.x = 8;
        option.y = this.yOffset;
        addChild(option);
        this.yOffset = this.yOffset + 28;
    }

    protected function onAddedToStage(event:Event):void {
        this.draw();
        this.position();
        addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    protected function onRemovedFromStage(event:Event):void {
        removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        removeEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    protected function onEnterFrame(event:Event):void {
        if (stage == null) {
            return;
        }
        var rect:Rectangle = getRect(stage);
        var dist:Number = RectangleUtil.pointDist(rect, stage.mouseX, stage.mouseY);
        if (dist > 40) {
            this.remove();
        }
    }

    private function position():void {
        if (stage == null) {
            return;
        }
        if (stage.mouseX < stage.stageWidth / 2) {
            x = stage.mouseX + 12;
        } else {
            x = stage.mouseX - width - 1;
        }
        if (x < 12) {
            x = 12;
        }
        if (stage.mouseY < stage.stageHeight / 3) {
            y = stage.mouseY + 12;
        } else {
            y = stage.mouseY - height - 1;
        }
        if (y < 12) {
            y = 12;
        }
    }

    protected function onRollOut(event:Event):void {
        this.remove();
    }

    protected function remove():void {
        if (parent != null) {
            parent.removeChild(this);
        }
    }

    protected function draw():void {
        this.backgroundFill_.color = this.background_;
        this.outlineFill_.color = this.outline_;
        graphics.clear();
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(-6, -6, Math.max(154, width + 12), height + 12, 4, [1, 1, 1, 1], this.path_);
        graphics.drawGraphicsData(this.graphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/menu/MenuOption.as">
package com.company.assembleegameclient.ui.menu {
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.ui.SimpleText;
import com.company.util.CachingColorTransformer;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

public class MenuOption extends Sprite {

    protected static const mouseOverCT:ColorTransform = new ColorTransform(1, 220 / 255, 133 / 255);


    protected var origIconBitmapData_:BitmapData;

    protected var iconBitmapData_:BitmapData;

    protected var icon_:Bitmap;

    protected var text_:SimpleText;

    protected var ct_:ColorTransform = null;

    public function MenuOption(origIconBitmapData:BitmapData, color:uint, textStr:String) {
        super();
        this.origIconBitmapData_ = origIconBitmapData;
        this.iconBitmapData_ = TextureRedrawer.redraw(origIconBitmapData, this.redrawSize(), true, 0);
        this.icon_ = new Bitmap(this.iconBitmapData_);
        this.icon_.filters = [new DropShadowFilter(0, 0, 0)];
        this.icon_.x = -12;
        this.icon_.y = -12;
        addChild(this.icon_);
        this.text_ = new SimpleText(18, color, false, 0, 0);
        this.text_.setBold(true);
        this.text_.text = textStr;
        this.text_.updateMetrics();
        this.text_.filters = [new DropShadowFilter(0, 0, 0)];
        this.text_.x = 20;
        this.text_.y = -6;
        addChild(this.text_);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
    }

    public function setColorTransform(ct:ColorTransform):void {
        var transformedBitmapData:BitmapData = null;
        if (ct == this.ct_) {
            return;
        }
        this.ct_ = ct;
        if (this.ct_ == null) {
            this.icon_.bitmapData = this.iconBitmapData_;
            this.text_.transform.colorTransform = MoreColorUtil.identity;
        } else {
            transformedBitmapData = CachingColorTransformer.transformBitmapData(this.origIconBitmapData_, this.ct_);
            transformedBitmapData = TextureRedrawer.redraw(transformedBitmapData, this.redrawSize(), true, 0);
            this.icon_.bitmapData = transformedBitmapData;
            this.text_.transform.colorTransform = this.ct_;
        }
    }

    protected function onMouseOver(event:MouseEvent):void {
        this.setColorTransform(mouseOverCT);
    }

    protected function onMouseOut(event:MouseEvent):void {
        this.setColorTransform(null);
    }

    protected function redrawSize():int {
        return 40 / (this.origIconBitmapData_.width / 8);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/menu/PlayerGroupMenu.as">
package com.company.assembleegameclient.ui.menu {
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.assembleegameclient.ui.LineBreakDesign;

import flash.events.Event;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

public class PlayerGroupMenu extends Menu {


    public var map_:Map;

    public var players_:Vector.<Player>;

    public var teleportOption_:MenuOption;

    public var lineBreakDesign_:LineBreakDesign;

    private var playerPanels_:Vector.<GameObjectListItem>;

    public var unableToTeleport:Signal;

    public function PlayerGroupMenu(map:Map, players:Vector.<Player>) {
        var player:Player = null;
        var playerPlanel:GameObjectListItem = null;
        this.playerPanels_ = new Vector.<GameObjectListItem>();
        super(3552822, 16777215);
        this.map_ = map;
        this.players_ = players.concat();
        this.unableToTeleport = new Signal();
        var yVal:int = 4;
        if (this.map_.allowPlayerTeleport_) {
            this.teleportOption_ = new TeleportMenuOption(this.map_.player_);
            this.teleportOption_.x = 8;
            this.teleportOption_.y = 8;
            this.teleportOption_.addEventListener(MouseEvent.CLICK, this.onTeleport);
            addChild(this.teleportOption_);
            this.lineBreakDesign_ = new LineBreakDesign(width - 24, 1842204);
            this.lineBreakDesign_.x = 6;
            this.lineBreakDesign_.y = 40;
            addChild(this.lineBreakDesign_);
            yVal = 52;
        }
        for each(player in this.players_) {
            playerPlanel = new GameObjectListItem(11776947, true, player);
            playerPlanel.x = 0;
            playerPlanel.y = yVal;
            addChild(playerPlanel);
            this.playerPanels_.push(playerPlanel);
            yVal = yVal + 32;
        }
    }

    private function onTeleport(event:Event):void {
        var player:Player = null;
        var myPlayer:Player = this.map_.player_;
        var targetPlayer:Player = null;
        for each(player in this.players_) {
            if (myPlayer.isTeleportEligible(player)) {
                targetPlayer = player;
                break;
            }
        }
        if (targetPlayer != null) {
            myPlayer.teleportTo(targetPlayer);
        } else {
            this.unableToTeleport.dispatch();
        }
        remove();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/menu/PlayerMenu.as">
package com.company.assembleegameclient.ui.menu {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.assembleegameclient.util.GuildUtil;
import com.company.util.AssetLibrary;

import flash.events.Event;
import flash.events.MouseEvent;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.game.signals.ShowChatInputSignal;

public class PlayerMenu extends Menu {


    public var gs_:GameSprite;

    public var playerName_:String;

    public var player_:Player;

    public var playerPanel_:GameObjectListItem;

    public function PlayerMenu(gs:GameSprite, player:Player) {
        var option:MenuOption = null;
        super(3552822, 16777215);
        this.gs_ = gs;
        this.playerName_ = player.name_;
        this.player_ = player;
        this.playerPanel_ = new GameObjectListItem(11776947, true, this.player_);
        addChild(this.playerPanel_);
        if (this.gs_.map.allowPlayerTeleport_ && this.player_.isTeleportEligible(this.player_)) {
            option = new TeleportMenuOption(this.gs_.map.player_);
            option.addEventListener(MouseEvent.CLICK, this.onTeleport);
            addOption(option);
        }
        if (this.gs_.map.player_.guildRank_ >= GuildUtil.OFFICER && (player.guildName_ == null || player.guildName_.length == 0)) {
            option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterfaceBig", 10), 16777215, "Invite");
            option.addEventListener(MouseEvent.CLICK, this.onInvite);
            addOption(option);
        }
        if (!this.player_.starred_) {
            option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterface2", 5), 16777215, "Lock");
            option.addEventListener(MouseEvent.CLICK, this.onLock);
            addOption(option);
        } else {
            option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterface2", 6), 16777215, "Unlock");
            option.addEventListener(MouseEvent.CLICK, this.onUnlock);
            addOption(option);
        }
        option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterfaceBig", 7), 16777215, "Trade");
        option.addEventListener(MouseEvent.CLICK, this.onTrade);
        addOption(option);
        option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterfaceBig", 21), 16777215, "Whisper");
        option.addEventListener(MouseEvent.CLICK, this.onWhisper);
        addOption(option);
        if (this.player_.isFellowGuild_) {
            option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterfaceBig", 21), 16777215, "Guild Chat");
            option.addEventListener(MouseEvent.CLICK, this.onGuildMessage);
            addOption(option);
        }
        if (!this.player_.ignored_) {
            option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterfaceBig", 8), 16777215, "Ignore");
            option.addEventListener(MouseEvent.CLICK, this.onIgnore);
            addOption(option);
        } else {
            option = new MenuOption(AssetLibrary.getImageFromSet("lofiInterfaceBig", 9), 16777215, "Unignore");
            option.addEventListener(MouseEvent.CLICK, this.onUnignore);
            addOption(option);
        }
    }

    private function onTeleport(event:Event):void {
        this.gs_.map.player_.teleportTo(this.player_);
        remove();
    }

    private function onInvite(event:Event):void {
        this.gs_.gsc_.guildInvite(this.playerName_);
        remove();
    }

    private function onLock(event:Event):void {
        this.gs_.map.party_.lockPlayer(this.player_);
        remove();
    }

    private function onUnlock(event:Event):void {
        this.gs_.map.party_.unlockPlayer(this.player_);
        remove();
    }

    private function onTrade(event:Event):void {
        this.gs_.gsc_.tradeRequest(this.playerName_);
        remove();
    }

    private function onWhisper(event:Event):void {
        var chatSignal:ShowChatInputSignal = StaticInjectorContext.getInjector().getInstance(ShowChatInputSignal);
        chatSignal.dispatch("/tell " + this.playerName_ + " ");
        remove();
    }

    private function onGuildMessage(event:Event):void {
        var chatSignal:ShowChatInputSignal = StaticInjectorContext.getInjector().getInstance(ShowChatInputSignal);
        chatSignal.dispatch("/g ");
        remove();
    }

    private function onIgnore(event:Event):void {
        this.gs_.map.party_.ignorePlayer(this.player_);
        remove();
    }

    private function onUnignore(event:Event):void {
        this.gs_.map.party_.unignorePlayer(this.player_);
        remove();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/menu/TeleportMenuOption.as">
package com.company.assembleegameclient.ui.menu {
import com.company.assembleegameclient.objects.Player;
import com.company.ui.SimpleText;
import com.company.util.AssetLibrary;

import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;

public class TeleportMenuOption extends MenuOption {

    private static const inactiveCT:ColorTransform = new ColorTransform(84 / 255, 84 / 255, 84 / 255);


    private var player_:Player;

    private var mouseOver_:Boolean = false;

    private var barText_:SimpleText;

    private var barTextOrigWidth_:int;

    public function TeleportMenuOption(player:Player) {
        super(AssetLibrary.getImageFromSet("lofiInterface2", 3), 16777215, "Teleport");
        this.player_ = player;
        this.barText_ = new SimpleText(18, 16777215, false, 0, 0);
        this.barText_.setBold(true);
        this.barText_.text = "Teleport";
        this.barText_.updateMetrics();
        this.barText_.x = text_.x;
        this.barText_.y = text_.y;
        this.barTextOrigWidth_ = this.barText_.width;
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private function onAddedToStage(event:Event):void {
        addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
    }

    private function onRemovedFromStage(event:Event):void {
        removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
    }

    private function onEnterFrame(event:Event):void {
        var msUtilTeleport:int = this.player_.msUtilTeleport();
        if (msUtilTeleport > 0) {
            if (!contains(this.barText_)) {
                addChild(this.barText_);
            }
            this.barText_.width = this.barTextOrigWidth_ * (1 - msUtilTeleport / Player.MS_BETWEEN_TELEPORT);
            setColorTransform(inactiveCT);
        } else {
            if (contains(this.barText_)) {
                removeChild(this.barText_);
            }
            if (this.mouseOver_) {
                setColorTransform(mouseOverCT);
            } else {
                setColorTransform(null);
            }
        }
    }

    override protected function onMouseOver(event:MouseEvent):void {
        this.mouseOver_ = true;
    }

    override protected function onMouseOut(event:MouseEvent):void {
        this.mouseOver_ = false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/ChoiceOption.as">
package com.company.assembleegameclient.ui.options {
import com.company.assembleegameclient.parameters.Parameters;

import flash.events.Event;

public class ChoiceOption extends Option {


    private var callback_:Function;

    private var choiceBox_:ChoiceBox;

    public function ChoiceOption(paramName:String, labels:Vector.<String>, values:Array, desc:String, tooltipText:String, callback:Function) {
        super(paramName, desc, tooltipText);
        this.callback_ = callback;
        this.choiceBox_ = new ChoiceBox(labels, values, Parameters.data_[paramName_]);
        this.choiceBox_.addEventListener(Event.CHANGE, this.onChange);
        addChild(this.choiceBox_);
    }

    override public function refresh():void {
        this.choiceBox_.setValue(Parameters.data_[paramName_]);
    }

    private function onChange(event:Event):void {
        Parameters.data_[paramName_] = this.choiceBox_.value();
        Parameters.save();
        if (this.callback_ != null) {
            this.callback_();
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/KeyCodeBox.as">
package com.company.assembleegameclient.ui.options {
import com.company.ui.SimpleText;
import com.company.util.KeyCodes;

import flash.display.Graphics;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.utils.getTimer;

public class KeyCodeBox extends Sprite {

    public static const WIDTH:int = 80;

    public static const HEIGHT:int = 32;


    public var keyCode_:uint;

    public var selected_:Boolean;

    public var inputMode_:Boolean;

    private var char_:SimpleText = null;

    public function KeyCodeBox(keyCode:uint) {
        super();
        this.keyCode_ = keyCode;
        this.selected_ = false;
        this.inputMode_ = false;
        this.char_ = new SimpleText(16, 16777215, false, 0, 0);
        this.char_.setBold(true);
        this.char_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        addChild(this.char_);
        this.drawBackground();
        this.setNormalMode();
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    public function value():uint {
        return this.keyCode_;
    }

    public function setKeyCode(keyCode:uint):void {
        if (keyCode == this.keyCode_) {
            return;
        }
        this.keyCode_ = keyCode;
        this.setText(KeyCodes.CharCodeStrings[this.keyCode_]);
        dispatchEvent(new Event(Event.CHANGE, true));
    }

    private function drawBackground():void {
        var g:Graphics = graphics;
        g.clear();
        g.lineStyle(2, this.selected_ || this.inputMode_ ? uint(11776947) : uint(4473924));
        g.beginFill(3355443);
        g.drawRect(0, 0, WIDTH, HEIGHT);
        g.endFill();
        g.lineStyle();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.selected_ = true;
        this.drawBackground();
    }

    private function onRollOut(event:MouseEvent):void {
        this.selected_ = false;
        this.drawBackground();
    }

    private function setText(text:String):void {
        this.char_.text = text;
        this.char_.updateMetrics();
        this.char_.x = WIDTH / 2 - this.char_.width / 2;
        this.char_.y = HEIGHT / 2 - this.char_.height / 2 - 2;
        this.drawBackground();
    }

    private function setNormalMode():void {
        this.inputMode_ = false;
        removeEventListener(Event.ENTER_FRAME, this.onInputEnterFrame);
        if (stage != null) {
            removeEventListener(KeyboardEvent.KEY_DOWN, this.onInputKeyDown);
            stage.removeEventListener(MouseEvent.MOUSE_DOWN, this.onInputMouseDown, true);
        }
        this.setText(KeyCodes.CharCodeStrings[this.keyCode_]);
        addEventListener(MouseEvent.CLICK, this.onNormalClick);
    }

    private function setInputMode():void {
        if (stage == null) {
            return;
        }
        stage.stageFocusRect = false;
        stage.focus = this;
        this.inputMode_ = true;
        removeEventListener(MouseEvent.CLICK, this.onNormalClick);
        addEventListener(Event.ENTER_FRAME, this.onInputEnterFrame);
        addEventListener(KeyboardEvent.KEY_DOWN, this.onInputKeyDown);
        stage.addEventListener(MouseEvent.MOUSE_DOWN, this.onInputMouseDown, true);
    }

    private function onNormalClick(event:MouseEvent):void {
        this.setInputMode();
    }

    private function onInputEnterFrame(event:Event):void {
        var t:int = getTimer() / 400;
        this.setText(t % 2 == 0 ? "" : "[Hit Key]");
    }

    private function onInputKeyDown(event:KeyboardEvent):void {
        event.stopImmediatePropagation();
        this.keyCode_ = event.keyCode;
        this.setNormalMode();
        dispatchEvent(new Event(Event.CHANGE, true));
    }

    private function onInputMouseDown(event:MouseEvent):void {
        this.setNormalMode();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/Option.as">
package com.company.assembleegameclient.ui.options {
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class Option extends Sprite {

    private static var tooltip_:ToolTip;


    public var paramName_:String;

    public var tooltipText_:String;

    private var desc_:SimpleText;

    public function Option(paramName:String, desc:String, tooltipText:String) {
        super();
        this.paramName_ = paramName;
        this.tooltipText_ = tooltipText;
        this.desc_ = new SimpleText(18, 11776947, false, 0, 0);
        this.desc_.text = desc;
        this.desc_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        this.desc_.updateMetrics();
        this.desc_.x = KeyCodeBox.WIDTH + 24;
        this.desc_.y = KeyCodeBox.HEIGHT / 2 - this.desc_.height / 2 - 2;
        this.desc_.mouseEnabled = true;
        this.desc_.addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        this.desc_.addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        addChild(this.desc_);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function refresh():void {
    }

    private function onMouseOver(event:MouseEvent):void {
        tooltip_ = new TextToolTip(2565927, 8553090, null, this.tooltipText_, 150);
        stage.addChild(tooltip_);
    }

    private function onRollOut(event:MouseEvent):void {
        this.removeToolTip();
    }

    private function onRemovedFromStage(event:Event):void {
        this.removeToolTip();
    }

    private function removeToolTip():void {
        if (tooltip_ != null && stage.contains(tooltip_)) {
            stage.removeChild(tooltip_);
            tooltip_ = null;
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/ButtonPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

public class ButtonPanel extends Panel {


    private var titleText_:SimpleText;

    protected var button_:TextButton;

    public function ButtonPanel(gs:GameSprite, title:String, button:String) {
        super(gs);
        this.titleText_ = new SimpleText(18, 16777215, false, WIDTH, 0);
        this.titleText_.setBold(true);
        this.titleText_.htmlText = "<p align=\"center\">" + title + "</p>";
        this.titleText_.wordWrap = true;
        this.titleText_.multiline = true;
        this.titleText_.autoSize = TextFieldAutoSize.CENTER;
        this.titleText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.titleText_.y = 6;
        addChild(this.titleText_);
        this.button_ = new TextButton(16, button);
        this.button_.addEventListener(MouseEvent.CLICK, this.onButtonClick);
        this.button_.x = WIDTH / 2 - this.button_.width / 2;
        this.button_.y = HEIGHT - this.button_.height - 4;
        addChild(this.button_);
    }

    protected function onButtonClick(event:MouseEvent):void {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/CharacterChangerPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;

import flash.events.MouseEvent;

public class CharacterChangerPanel extends ButtonPanel {


    public function CharacterChangerPanel(gs:GameSprite) {
        super(gs, "Change Characters", "Change");
    }

    override protected function onButtonClick(event:MouseEvent):void {
        gs_.closed.dispatch();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/GuildBoardPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.board.GuildBoardWindow;
import com.company.assembleegameclient.util.GuildUtil;

import flash.events.MouseEvent;

public class GuildBoardPanel extends ButtonPanel {


    public function GuildBoardPanel(gs:GameSprite) {
        super(gs, "Guild Board", "View");
    }

    override protected function onButtonClick(event:MouseEvent):void {
        var p:Player = gs_.map.player_;
        if (p == null) {
            return;
        }
        gs_.addChild(new GuildBoardWindow(p.guildRank_ >= GuildUtil.OFFICER));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/GuildChroniclePanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.guild.GuildChronicleScreen;

import flash.events.MouseEvent;

public class GuildChroniclePanel extends ButtonPanel {


    public function GuildChroniclePanel(gs:GameSprite) {
        super(gs, "Guild Chronicle", "View");
    }

    override protected function onButtonClick(event:MouseEvent):void {
        gs_.mui_.clearInput();
        gs_.addChild(new GuildChronicleScreen(gs_));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/GuildHallPortalPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.GuildHallPortal;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.TextBox;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

public class GuildHallPortalPanel extends Panel {
    private var owner_:GuildHallPortal;
    private var nameText_:SimpleText;
    private var enterButton_:TextButton;
    private var noGuildText_:SimpleText;

    public function GuildHallPortalPanel(gs:GameSprite, owner:GuildHallPortal) {
        super(gs);
        this.owner_ = owner;
        if (gs_.map == null || gs_.map.player_ == null) {
            return;
        }
        var p:Player = gs_.map.player_;
        this.nameText_ = new SimpleText(18, 16777215, false, WIDTH, 0);
        this.nameText_.setBold(true);
        this.nameText_.htmlText = "<p align=\"center\">Guild Hall</p>";
        this.nameText_.wordWrap = true;
        this.nameText_.multiline = true;
        this.nameText_.autoSize = TextFieldAutoSize.CENTER;
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.nameText_.y = 6;
        addChild(this.nameText_);
        if (p.guildName_ != null && p.guildName_.length > 0) {
            this.enterButton_ = new TextButton(16, "Enter");
            this.enterButton_.addEventListener(MouseEvent.CLICK, this.onEnterSpriteClick);
            this.enterButton_.x = WIDTH / 2 - this.enterButton_.width / 2;
            this.enterButton_.y = HEIGHT - this.enterButton_.height - 4;
            addChild(this.enterButton_);
            addEventListener(Event.ADDED_TO_STAGE, this.onAdded);
            addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        } else {
            this.noGuildText_ = new SimpleText(18, 16711680, false, WIDTH, 0);
            this.noGuildText_.setBold(true);
            this.noGuildText_.htmlText = "<p align=\"center\">Not In Guild</p>";
            this.noGuildText_.autoSize = TextFieldAutoSize.CENTER;
            this.noGuildText_.filters = [new DropShadowFilter(0, 0, 0)];
            this.noGuildText_.y = HEIGHT - this.noGuildText_.height - 12;
            addChild(this.noGuildText_);
        }
    }

    private function onAdded(event:Event):void {
        stage.addEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
    }

    private function onEnterSpriteClick(event:MouseEvent):void {
        this.enterPortal();
    }

    private function onKeyDown(event:KeyboardEvent):void {
        if (event.keyCode == Parameters.data_.interact && !TextBox.isInputtingText) {
            this.enterPortal();
        }
    }

    private function enterPortal():void {
        gs_.gsc_.usePortal(this.owner_.objectId_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/GuildInvitePanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.TimerEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;
import flash.utils.Timer;

public class GuildInvitePanel extends Panel {


    public var name_:String;

    private var title_:SimpleText;

    private var guildName_:String;

    private var guildNameText_:SimpleText;

    private var rejectButton_:TextButton;

    private var acceptButton_:TextButton;

    private var timer_:Timer;

    public function GuildInvitePanel(gs:GameSprite, name:String, guildName:String) {
        super(gs);
        this.name_ = name;
        this.guildName_ = guildName;
        this.title_ = new SimpleText(16, 16777215, false, WIDTH, 0);
        this.title_.setBold(true);
        this.title_.htmlText = "<p align=\"center\">" + name + " invited you to:</p>";
        this.title_.autoSize = TextFieldAutoSize.CENTER;
        this.title_.filters = [new DropShadowFilter(0, 0, 0)];
        this.title_.y = 0;
        addChild(this.title_);
        this.guildNameText_ = new SimpleText(16, 16777215, false, WIDTH, 0);
        this.guildNameText_.setBold(true);
        this.guildNameText_.htmlText = "<p align=\"center\">" + this.guildName_ + "</p>";
        this.guildNameText_.autoSize = TextFieldAutoSize.CENTER;
        this.guildNameText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.guildNameText_.y = 20;
        addChild(this.guildNameText_);
        this.rejectButton_ = new TextButton(16, "Reject");
        this.rejectButton_.addEventListener(MouseEvent.CLICK, this.onRejectClick);
        this.rejectButton_.x = WIDTH / 4 - this.rejectButton_.width / 2;
        this.rejectButton_.y = HEIGHT - this.rejectButton_.height - 4;
        addChild(this.rejectButton_);
        this.acceptButton_ = new TextButton(16, "Accept");
        this.acceptButton_.addEventListener(MouseEvent.CLICK, this.onAcceptClick);
        this.acceptButton_.x = 3 * WIDTH / 4 - this.acceptButton_.width / 2;
        this.acceptButton_.y = HEIGHT - this.acceptButton_.height - 4;
        addChild(this.acceptButton_);
        this.timer_ = new Timer(20 * 1000, 1);
        this.timer_.start();
        this.timer_.addEventListener(TimerEvent.TIMER, this.onTimer);
    }

    private function onTimer(event:TimerEvent):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function onRejectClick(event:MouseEvent):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function onAcceptClick(event:MouseEvent):void {
        gs_.gsc_.joinGuild(this.guildName_);
        dispatchEvent(new Event(Event.COMPLETE));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/ItemTileEvent.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import flash.events.Event;

public class ItemTileEvent extends Event {

    public static const ITEM_MOVE:String = "ITEM_MOVE";

    public static const ITEM_DOUBLE_CLICK:String = "ITEM_DOUBLE_CLICK";

    public static const ITEM_SHIFT_CLICK:String = "ITEM_SHIFT_CLICK";

    public static const ITEM_CLICK:String = "ITEM_CLICK";

    public static const ITEM_HOTKEY_PRESS:String = "ITEM_HOTKEY_PRESS";

    public static const ITEM_CTRL_CLICK:String = "ITEM_CTRL_CLICK";


    public var tile:InteractiveItemTile;

    public function ItemTileEvent(type:String, itemTile:InteractiveItemTile) {
        super(type, true);
        this.tile = itemTile;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/mediators/InteractPanelMediator.as">
package com.company.assembleegameclient.ui.panels.mediators {
import com.company.assembleegameclient.objects.IInteractiveObject;
import com.company.assembleegameclient.ui.panels.InteractPanel;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.MapModel;

public class InteractPanelMediator extends Mediator {


    [Inject]
    public var view:InteractPanel;

    [Inject]
    public var mapModel:MapModel;

    public function InteractPanelMediator() {
        super();
    }

    override public function initialize():void {
        this.view.requestInteractive = this.provideInteractive;
    }

    override public function destroy():void {
        super.destroy();
    }

    public function provideInteractive():IInteractiveObject {
        return this.mapModel.currentInteractiveTarget;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/mediators/InventoryGridMediator.as">
package com.company.assembleegameclient.ui.panels.mediators {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.InventoryGrid;

import svera.lib.framework.Mediator;

import svera.untiered.ui.signals.UpdateHUDSignal;

public class InventoryGridMediator extends Mediator {


    [Inject]
    public var view:InventoryGrid;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    public function InventoryGridMediator() {
        super();
    }

    override public function initialize():void {
        this.updateHUD.add(this.onUpdateHUD);
    }

    override public function destroy():void {
        this.updateHUD.remove(this.onUpdateHUD);
    }

    private function onUpdateHUD(player:Player):void {
        this.view.draw();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/PortalPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Portal;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.TextBox;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

import org.osflash.signals.Signal;

public class PortalPanel extends Panel {
    public var owner_:Portal;
    private var nameText_:SimpleText;
    private var enterButton_:TextButton;
    private var fullText_:SimpleText;
    public const exitGameSignal:Signal = new Signal();

    public function PortalPanel(gs:GameSprite, owner:Portal) {
        super(gs);
        this.owner_ = owner;
        this.nameText_ = new SimpleText(18, 16777215, false, WIDTH, 0);
        this.nameText_.setBold(true);
        this.nameText_.htmlText = "<p align=\"center\">Portal</p>";
        this.nameText_.wordWrap = true;
        this.nameText_.multiline = true;
        this.nameText_.autoSize = TextFieldAutoSize.CENTER;
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.nameText_);
        this.enterButton_ = new TextButton(16, "Enter");
        addChild(this.enterButton_);
        this.fullText_ = new SimpleText(18, 16711680, false, WIDTH, 0);
        this.fullText_.setBold(true);
        if (this.owner_.lockedPortal_) {
            this.fullText_.htmlText = "<p align=\"center\">Locked</p>";
        } else {
            this.fullText_.htmlText = "<p align=\"center\">Full</p>";
        }
        this.fullText_.autoSize = TextFieldAutoSize.CENTER;
        this.fullText_.filters = [new DropShadowFilter(0, 0, 0)];
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private function onAddedToStage(event:Event):void {
        this.nameText_.y = 6;
        this.enterButton_.x = WIDTH / 2 - this.enterButton_.width / 2;
        this.enterButton_.y = HEIGHT - this.enterButton_.height - 4;
        this.fullText_.y = HEIGHT - this.fullText_.height - 12;
        this.enterButton_.addEventListener(MouseEvent.CLICK, this.onEnterSpriteClick);
        stage.addEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
    }

    private function onEnterSpriteClick(event:MouseEvent):void {
        this.enterPortal();
    }

    private function onKeyDown(event:KeyboardEvent):void {
        if (event.keyCode == Parameters.data_.interact && !TextBox.isInputtingText) {
            this.enterPortal();
        }
    }

    private function enterPortal():void {
        gs_.gsc_.usePortal(this.owner_.objectId_);
    }

    override public function draw():void {
        var name:String = this.owner_.getName();
        var lockedStr:String = "Locked ";
        if (this.owner_.lockedPortal_ && name.indexOf(lockedStr) == 0) {
            name = name.substr(lockedStr.length);
        }
        this.nameText_.htmlText = "<p align=\"center\">" + name + "</p>";
        this.nameText_.useTextDimensions();
        if (this.nameText_.height > 30) {
            this.nameText_.y = 0;
        } else {
            this.nameText_.y = 6;
        }
        if (!this.owner_.lockedPortal_ && this.owner_.active_ && contains(this.fullText_)) {
            removeChild(this.fullText_);
            addChild(this.enterButton_);
        } else if ((this.owner_.lockedPortal_ || !this.owner_.active_) && contains(this.enterButton_)) {
            removeChild(this.enterButton_);
            addChild(this.fullText_);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/TradeRequestPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.TimerEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;
import flash.utils.Timer;

public class TradeRequestPanel extends Panel {


    public var name_:String;

    private var title_:SimpleText;

    private var rejectButton_:TextButton;

    private var acceptButton_:TextButton;

    private var timer_:Timer;

    public function TradeRequestPanel(gs:GameSprite, name:String) {
        super(gs);
        this.name_ = name;
        this.title_ = new SimpleText(18, 16777215, false, WIDTH, 0);
        this.title_.setBold(true);
        this.title_.htmlText = "<p align=\"center\">" + name + " wants to trade with you</p>";
        this.title_.wordWrap = true;
        this.title_.multiline = true;
        this.title_.autoSize = TextFieldAutoSize.CENTER;
        this.title_.filters = [new DropShadowFilter(0, 0, 0)];
        this.title_.y = 0;
        addChild(this.title_);
        this.rejectButton_ = new TextButton(16, "Reject");
        this.rejectButton_.addEventListener(MouseEvent.CLICK, this.onRejectClick);
        this.rejectButton_.x = WIDTH / 4 - this.rejectButton_.width / 2;
        this.rejectButton_.y = HEIGHT - this.rejectButton_.height - 4;
        addChild(this.rejectButton_);
        this.acceptButton_ = new TextButton(16, "Accept");
        this.acceptButton_.addEventListener(MouseEvent.CLICK, this.onAcceptClick);
        this.acceptButton_.x = 3 * WIDTH / 4 - this.acceptButton_.width / 2;
        this.acceptButton_.y = HEIGHT - this.acceptButton_.height - 4;
        addChild(this.acceptButton_);
        this.timer_ = new Timer(20 * 1000, 1);
        this.timer_.start();
        this.timer_.addEventListener(TimerEvent.TIMER, this.onTimer);
    }

    private function onTimer(event:TimerEvent):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function onRejectClick(event:MouseEvent):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function onAcceptClick(event:MouseEvent):void {
        gs_.gsc_.tradeRequest(this.name_);
        dispatchEvent(new Event(Event.COMPLETE));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/SoundIcon.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.sound.Music;
import com.company.assembleegameclient.sound.SFX;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.GlowFilter;

public class SoundIcon extends Sprite {


    private var bitmap_:Bitmap;

    public function SoundIcon() {
        this.bitmap_ = new Bitmap();
        super();
        addChild(this.bitmap_);
        this.bitmap_.scaleX = 2;
        this.bitmap_.scaleY = 2;
        this.setBitmap();
        addEventListener(MouseEvent.CLICK, this.onIconClick);
        filters = [new GlowFilter(0, 1, 4, 4, 2, 1)];
    }

    private function setBitmap():void {
        this.bitmap_.bitmapData = Parameters.data_.playMusic || Parameters.data_.playSFX ? AssetLibrary.getImageFromSet("lofiInterfaceBig", 3) : AssetLibrary.getImageFromSet("lofiInterfaceBig", 4);
    }

    private function onIconClick(event:MouseEvent):void {
        var value:Boolean = !(Parameters.data_.playMusic || Parameters.data_.playSFX);
        Music.setPlayMusic(value);
        SFX.setPlaySFX(value);
        Parameters.data_.playPewPew = value;
        Parameters.save();
        this.setBitmap();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/PlayerGroupToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.ui.SimpleText;

import flash.filters.DropShadowFilter;

public class PlayerGroupToolTip extends ToolTip {


    public var players_:Vector.<Player> = null;

    private var playerPanels_:Vector.<GameObjectListItem>;

    private var clickMessage_:SimpleText;

    public function PlayerGroupToolTip(players:Vector.<Player>, followMouse:Boolean = true) {
        this.playerPanels_ = new Vector.<GameObjectListItem>();
        super(3552822, 0.5, 16777215, 1, followMouse);
        this.clickMessage_ = new SimpleText(12, 11776947, false, 0, 0);
        this.clickMessage_.text = "(Click to open menu)";
        this.clickMessage_.updateMetrics();
        this.clickMessage_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.clickMessage_);
        this.setPlayers(players);
        if (!followMouse) {
            filters = [];
        }
    }

    public function setPlayers(players:Vector.<Player>):void {
        var player:Player = null;
        var playerPlanel:GameObjectListItem = null;
        this.clear();
        this.players_ = players.slice();
        if (this.players_ == null || this.players_.length == 0) {
            return;
        }
        var yVal:int = 0;
        for each(player in players) {
            playerPlanel = new GameObjectListItem(11776947, true, player);
            playerPlanel.x = 0;
            playerPlanel.y = yVal;
            addChild(playerPlanel);
            this.playerPanels_.push(playerPlanel);
            yVal = yVal + 32;
        }
        this.clickMessage_.x = width / 2 - this.clickMessage_.width / 2;
        this.clickMessage_.y = yVal;
        draw();
    }

    private function clear():void {
        var playerPanel:GameObjectListItem = null;
        graphics.clear();
        for each(playerPanel in this.playerPanels_) {
            removeChild(playerPanel);
        }
        this.playerPanels_.length = 0;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/PortraitToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.objects.GameObject;
import com.company.util.BitmapUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;

public class PortraitToolTip extends ToolTip {


    private var portrait_:Bitmap;

    public function PortraitToolTip(go:GameObject) {
        super(6036765, 1, 16549442, 1, false);
        this.portrait_ = new Bitmap();
        this.portrait_.x = 0;
        this.portrait_.y = 0;
        var portraitBD:BitmapData = go.getPortrait();
        portraitBD = BitmapUtil.cropToBitmapData(portraitBD, 10, 10, portraitBD.width - 20, portraitBD.height - 20);
        this.portrait_.bitmapData = portraitBD;
        addChild(this.portrait_);
        filters = [];
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/QuestToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.ui.SimpleText;

import flash.filters.DropShadowFilter;

public class QuestToolTip extends ToolTip {


    private var text_:SimpleText;

    public var enemyGOLI_:GameObjectListItem;

    public function QuestToolTip(go:GameObject) {
        super(6036765, 1, 16549442, 1, false);
        this.text_ = new SimpleText(22, 16549442, false, 0, 0);
        this.text_.setBold(true);
        this.text_.text = "Quest!";
        this.text_.updateMetrics();
        this.text_.filters = [new DropShadowFilter(0, 0, 0)];
        this.text_.x = 0;
        this.text_.y = 0;
        addChild(this.text_);
        this.enemyGOLI_ = new GameObjectListItem(11776947, true, go);
        this.enemyGOLI_.x = 0;
        this.enemyGOLI_.y = 32;
        addChild(this.enemyGOLI_);
        filters = [];
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/TextToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.ui.SimpleText;

import flash.filters.DropShadowFilter;

public class TextToolTip extends ToolTip {


    public var titleText_:SimpleText;

    public var tipText_:SimpleText;

    public function TextToolTip(background:uint, outline:uint, title:String, text:String, maxWidth:int) {
        super(background, 1, outline, 1);
        if (title != null) {
            this.titleText_ = new SimpleText(20, 16777215, false, maxWidth, 0);
            this.titleText_.setBold(true);
            this.titleText_.wordWrap = true;
            this.titleText_.text = title;
            this.titleText_.updateMetrics();
            this.titleText_.filters = [new DropShadowFilter(0, 0, 0)];
            addChild(this.titleText_);
        }
        if (text != null) {
            this.tipText_ = new SimpleText(14, 11776947, false, maxWidth, 0);
            this.tipText_.wordWrap = true;
            this.tipText_.y = this.titleText_ != null ? Number(this.titleText_.height + 8) : Number(0);
            this.tipText_.text = text;
            this.tipText_.useTextDimensions();
            this.tipText_.filters = [new DropShadowFilter(0, 0, 0)];
            addChild(this.tipText_);
        }
    }

    public function setTitle(title:String):void {
        this.titleText_.text = title;
        this.titleText_.updateMetrics();
        draw();
    }

    public function setText(text:String):void {
        this.tipText_.text = text;
        this.tipText_.useTextDimensions();
        draw();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/ToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.DisplayObject;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class ToolTip extends Sprite {


    private var background_:uint;

    private var backgroundAlpha_:Number;

    private var outline_:uint;

    private var outlineAlpha_:Number;

    private var followMouse_:Boolean;

    public var contentWidth_:int;

    public var contentHeight_:int;

    private var targetObj:DisplayObject;

    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(0, 1);

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[lineStyle_, backgroundFill_, path_, GraphicsUtil.END_FILL, GraphicsUtil.END_STROKE];

    public function ToolTip(background:uint, backgroundAlpha:Number, outline:uint, outlineAlpha:Number, followMouse:Boolean = true) {
        super();
        this.background_ = background;
        this.backgroundAlpha_ = backgroundAlpha;
        this.outline_ = outline;
        this.outlineAlpha_ = outlineAlpha;
        this.followMouse_ = followMouse;
        mouseEnabled = false;
        mouseChildren = false;
        filters = [new DropShadowFilter(0, 0, 0, 1, 16, 16)];
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function attachToTarget(dObj:DisplayObject):void {
        if (dObj) {
            this.targetObj = dObj;
            this.targetObj.addEventListener(MouseEvent.ROLL_OUT, this.onLeaveTarget);
        }
    }

    public function detachFromTarget():void {
        if (this.targetObj) {
            this.targetObj.removeEventListener(MouseEvent.ROLL_OUT, this.onLeaveTarget);
            if (parent) {
                parent.removeChild(this);
            }
            this.targetObj = null;
        }
    }

    private function onLeaveTarget(e:MouseEvent):void {
        this.detachFromTarget();
    }

    private function onAddedToStage(event:Event):void {
        this.draw();
        if (this.followMouse_) {
            this.position();
            addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
    }

    private function onRemovedFromStage(event:Event):void {
        if (this.followMouse_) {
            removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
    }

    private function onEnterFrame(event:Event):void {
        this.position();
    }

    private function position():void {
        if (stage == null) {
            return;
        }
        if (stage.mouseX < stage.stageWidth / 2) {
            x = stage.mouseX + 12;
        } else {
            x = stage.mouseX - width - 1;
        }
        if (x < 12) {
            x = 12;
        }
        if (stage.mouseY < stage.stageHeight / 3) {
            y = stage.mouseY + 12;
        } else {
            y = stage.mouseY - height - 1;
        }
        if (y < 12) {
            y = 12;
        }
    }

    public function draw():void {
        this.backgroundFill_.color = this.background_;
        this.backgroundFill_.alpha = this.backgroundAlpha_;
        this.outlineFill_.color = this.outline_;
        this.outlineFill_.alpha = this.outlineAlpha_;
        graphics.clear();
        this.contentWidth_ = width;
        this.contentHeight_ = height;
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(-6, -6, this.contentWidth_ + 12, this.contentHeight_ + 12, 4, [1, 1, 1, 1], this.path_);
        graphics.drawGraphicsData(this.graphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/TradePanel.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.game.GameSprite;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

import svera.untiered.messaging.impl.incoming.TradeStart;

public class TradePanel extends Sprite {

    public static const WIDTH:int = 200;

    public static const HEIGHT:int = 400;


    public var gs_:GameSprite;

    private var myInv_:TradeInventory;

    private var yourInv_:TradeInventory;

    private var cancelButton_:TextButton;

    private var tradeButton_:TradeButton;

    public function TradePanel(gs:GameSprite, tradeStart:TradeStart) {
        super();
        this.gs_ = gs;
        var playerName:String = this.gs_.map.player_.name_;
        this.myInv_ = new TradeInventory(gs, playerName, tradeStart.myItems_, true);
        this.myInv_.x = 14;
        this.myInv_.y = 0;
        this.myInv_.addEventListener(Event.CHANGE, this.onMyInvChange);
        addChild(this.myInv_);
        this.yourInv_ = new TradeInventory(gs, tradeStart.theirName_, tradeStart.theirItems_, false);
        this.yourInv_.x = 14;
        this.yourInv_.y = 174;
        addChild(this.yourInv_);
        this.cancelButton_ = new TextButton(16, "Cancel", 80);
        this.cancelButton_.addEventListener(MouseEvent.CLICK, this.onCancelClick);
        this.cancelButton_.x = WIDTH / 4 - this.cancelButton_.width / 2;
        this.cancelButton_.y = HEIGHT - this.cancelButton_.height - 10;
        addChild(this.cancelButton_);
        this.tradeButton_ = new TradeButton(16, 80);
        this.tradeButton_.addEventListener(MouseEvent.CLICK, this.onTradeClick);
        this.tradeButton_.x = 3 * WIDTH / 4 - this.tradeButton_.width / 2;
        this.tradeButton_.y = this.cancelButton_.y;
        addChild(this.tradeButton_);
        this.checkTrade();
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function setYourOffer(offer:Vector.<Boolean>):void {
        this.yourInv_.setOffer(offer);
        this.checkTrade();
    }

    public function youAccepted(myOffer:Vector.<Boolean>, yourOffer:Vector.<Boolean>):void {
        if (this.myInv_.isOffer(myOffer) && this.yourInv_.isOffer(yourOffer)) {
            this.yourInv_.setMessage(TradeInventory.TRADEACCEPTED_MESSAGE);
        }
    }

    private function onAddedToStage(event:Event):void {
        stage.addEventListener(Event.ACTIVATE, this.onActivate);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(Event.ACTIVATE, this.onActivate);
    }

    private function onActivate(event:Event):void {
        this.tradeButton_.reset();
    }

    private function onMyInvChange(event:Event):void {
        this.gs_.gsc_.changeTrade(this.myInv_.getOffer());
        this.checkTrade();
    }

    private function onCancelClick(event:MouseEvent):void {
        this.gs_.gsc_.cancelTrade();
        dispatchEvent(new Event(Event.CANCEL));
    }

    private function onTradeClick(event:MouseEvent):void {
        this.gs_.gsc_.acceptTrade(this.myInv_.getOffer(), this.yourInv_.getOffer());
        this.myInv_.setMessage(TradeInventory.TRADEACCEPTED_MESSAGE);
    }

    public function checkTrade():void {
        var myTrading:int = this.myInv_.numIncluded();
        var myEmpty:int = this.myInv_.numEmpty();
        var yourTrading:int = this.yourInv_.numIncluded();
        var yourEmpty:int = this.yourInv_.numEmpty();
        var valid:Boolean = true;
        if (yourTrading - myTrading - myEmpty > 0) {
            this.myInv_.setMessage(TradeInventory.NOTENOUGHSPACE_MESSAGE);
            valid = false;
        } else {
            this.myInv_.setMessage(TradeInventory.CLICKITEMS_MESSAGE);
        }
        if (myTrading - yourTrading - yourEmpty > 0) {
            this.yourInv_.setMessage(TradeInventory.NOTENOUGHSPACE_MESSAGE);
            valid = false;
        } else {
            this.yourInv_.setMessage(TradeInventory.TRADEWAITING_MESSAGE);
        }
        if (valid) {
            this.tradeButton_.reset();
        } else {
            this.tradeButton_.disable();
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/AnimatedChars.as">
package com.company.assembleegameclient.util {
import flash.display.BitmapData;
import flash.utils.Dictionary;

public class AnimatedChars {

    private static var nameMap_:Dictionary = new Dictionary();


    public function AnimatedChars() {
        super();
    }

    public static function getAnimatedChar(name:String, id:int):AnimatedChar {
        var chars:Vector.<AnimatedChar> = nameMap_[name];
        if (chars == null || id >= chars.length) {
            return null;
        }
        return chars[id];
    }

    public static function add(name:String, images:BitmapData, masks:BitmapData, charWidth:int, charHeight:int, sheetWidth:int, sheetHeight:int, firstDir:int):void {
        var image:MaskedImage = null;
        var chars:Vector.<AnimatedChar> = new Vector.<AnimatedChar>();
        var charImages:MaskedImageSet = new MaskedImageSet();
        charImages.addFromBitmapData(images, masks, sheetWidth, sheetHeight);
        for each(image in charImages.images_) {
            chars.push(new AnimatedChar(image, charWidth, charHeight, firstDir));
        }
        nameMap_[name] = chars;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/BloodComposition.as">
package com.company.assembleegameclient.util {
import flash.display.BitmapData;
import flash.utils.Dictionary;

public class BloodComposition {

    private static var idDict_:Dictionary = new Dictionary();

    private static var imageDict_:Dictionary = new Dictionary();


    public function BloodComposition() {
        super();
    }

    public static function getBloodComposition(id:int, image:BitmapData, bloodProb:Number, bloodColor:uint):Vector.<uint> {
        var comp:Vector.<uint> = idDict_[id];
        if (comp != null) {
            return comp;
        }
        comp = new Vector.<uint>();
        var colors:Vector.<uint> = getColors(image);
        for (var i:int = 0; i < colors.length; i++) {
            if (Math.random() < bloodProb) {
                comp.push(bloodColor);
            } else {
                comp.push(colors[int(colors.length * Math.random())]);
            }
        }
        return comp;
    }

    public static function getColors(image:BitmapData):Vector.<uint> {
        var colors:Vector.<uint> = imageDict_[image];
        if (colors == null) {
            colors = buildColors(image);
            imageDict_[image] = colors;
        }
        return colors;
    }

    private static function buildColors(image:BitmapData):Vector.<uint> {
        var y:int = 0;
        var color:uint = 0;
        var colors:Vector.<uint> = new Vector.<uint>();
        for (var x:int = 0; x < image.width; x++) {
            for (y = 0; y < image.height; y++) {
                color = image.getPixel32(x, y);
                if ((color & 4278190080) != 0) {
                    colors.push(color);
                }
            }
        }
        return colors;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/Currency.as">
package com.company.assembleegameclient.util {
public class Currency {

    public static const INVALID:int = -1;

    public static const TSAVORITE:int = 0;
    public static const MEDALLIONS:int = 1;
    public static const HONOR:int = 2;

    public static const GUILD_FAME:int = 4;


    public function Currency() {
        super();
    }

    public static function typeToName(type:int):String {
        switch (type) {
            case TSAVORITE:
                return "Tsavorite";
            case MEDALLIONS:
                return "Medallions";
            case HONOR:
                return "Honor";
            case GUILD_FAME:
                return "Guild Honor";
            default:
                return "";
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/DisplayHierarchy.as">
package com.company.assembleegameclient.util {
import flash.display.DisplayObject;

public class DisplayHierarchy {


    public function DisplayHierarchy() {
        super();
    }

    public static function getParentWithType(dObj:DisplayObject, c:Class):DisplayObject {
        while (dObj && !(dObj is c)) {
            dObj = dObj.parent;
        }
        return dObj;
    }

    public static function getParentWithTypeArray(dObj:DisplayObject, ...classes):DisplayObject {
        var c:Class = null;
        while (dObj) {
            for each(c in classes) {
                if (dObj is c) {
                    return dObj;
                }
            }
            dObj = dObj.parent;
        }
        return dObj;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/FreeList.as">
package com.company.assembleegameclient.util {
import flash.utils.Dictionary;

public class FreeList {

    private static var dict_:Dictionary = new Dictionary();


    public function FreeList() {
        super();
    }

    public static function newObject(c:Class):Object {
        var vec:Vector.<Object> = dict_[c];
        if (vec == null) {
            vec = new Vector.<Object>();
            dict_[c] = vec;
        } else if (vec.length > 0) {
            return vec.pop();
        }
        return new c();
    }

    public static function storeObject(id:*, o:Object):void {
        var vec:Vector.<Object> = dict_[id];
        if (vec == null) {
            vec = new Vector.<Object>();
            dict_[id] = vec;
        }
        vec.push(o);
    }

    public static function getObject(id:*):Object {
        var vec:Vector.<Object> = dict_[id];
        if (vec != null && vec.length > 0) {
            trace("vec size: " + vec.length);
            return vec.pop();
        }
        return null;
    }

    public static function dump(id:*):void {
        delete dict_[id];
    }

    public static function deleteObject(o:Object):void {
        var c:Class = Object(o).constructor;
        var vec:Vector.<Object> = dict_[c];
        if (vec == null) {
            vec = new Vector.<Object>();
            dict_[c] = vec;
        }
        vec.push(o);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/HonorUtil.as">
package com.company.assembleegameclient.util {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.untiered.graphics.StarGraphic;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

public class HonorUtil {

    public static const STARS:Vector.<int> = new <int>[20, 150, 400, 800, 2000];

    private static const lightBlueCT:ColorTransform = new ColorTransform(138 / 255, 152 / 255, 222 / 255);

    private static const darkBlueCT:ColorTransform = new ColorTransform(49 / 255, 77 / 255, 219 / 255);

    private static const redCT:ColorTransform = new ColorTransform(193 / 255, 39 / 255, 45 / 255);

    private static const orangeCT:ColorTransform = new ColorTransform(247 / 255, 147 / 255, 30 / 255);

    private static const yellowCT:ColorTransform = new ColorTransform(255 / 255, 255 / 255, 0 / 255);

    public static const COLORS:Vector.<ColorTransform> = new <ColorTransform>[lightBlueCT, darkBlueCT, redCT, orangeCT, yellowCT];


    public function HonorUtil() {
        super();
    }

    public static function maxStars():int {
        return ObjectLibrary.playerChars_.length * STARS.length;
    }

    public static function numStars(honor:int):int {
        var num:int = 0;
        while (num < STARS.length && honor >= STARS[num]) {
            num++;
        }
        return num;
    }

    public static function nextStarHonor(bestHonor:int, currHonor:int):int {
        var curr:int = Math.max(bestHonor, currHonor);
        for (var i:int = 0; i < STARS.length; i++) {
            if (STARS[i] > curr) {
                return STARS[i];
            }
        }
        return -1;
    }

    public static function numStarsToBigImage(numStars:int):Sprite {
        var star:Sprite = numStarsToImage(numStars);
        star.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        star.scaleX = 1.4;
        star.scaleY = 1.4;
        return star;
    }

    public static function numStarsToImage(numStars:int):Sprite {
        var star:Sprite = new StarGraphic();
        if (numStars < ObjectLibrary.playerChars_.length) {
            star.transform.colorTransform = lightBlueCT;
        } else if (numStars < ObjectLibrary.playerChars_.length * 2) {
            star.transform.colorTransform = darkBlueCT;
        } else if (numStars < ObjectLibrary.playerChars_.length * 3) {
            star.transform.colorTransform = redCT;
        } else if (numStars < ObjectLibrary.playerChars_.length * 4) {
            star.transform.colorTransform = orangeCT;
        } else if (numStars < ObjectLibrary.playerChars_.length * 5) {
            star.transform.colorTransform = yellowCT;
        }
        return star;
    }

    public static function numStarsToIcon(numStars:int):Sprite {
        var star:Sprite;
        star = numStarsToImage(numStars);
        var sprite:Sprite = new Sprite();
        sprite.graphics.beginFill(0, 0.4);
        var w:int = star.width / 2 + 2;
        var h:int = star.height / 2 + 2;
        sprite.graphics.drawCircle(w, h, w);
        star.x = 2;
        star.y = 1;
        sprite.addChild(star);
        sprite.filters = [new DropShadowFilter(0, 0, 0, 0.5, 6, 6, 1)];
        return sprite;
    }

    public static function getHonorIcon():BitmapData {
        var honor:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 0);
        return TextureRedrawer.redraw(honor, 40, true, 0);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/MaskedImage.as">
package com.company.assembleegameclient.util {
import com.company.util.BitmapUtil;

import flash.display.BitmapData;

public class MaskedImage {


    public var image_:BitmapData;

    public var mask_:BitmapData;

    public function MaskedImage(image:BitmapData, mask:BitmapData) {
        super();
        this.image_ = image;
        this.mask_ = mask;
    }

    public function width():int {
        return this.image_.width;
    }

    public function height():int {
        return this.image_.height;
    }

    public function mirror(width:int = 0):MaskedImage {
        var mirroredImage:BitmapData = BitmapUtil.mirror(this.image_, width);
        var mirroredMask:BitmapData = this.mask_ == null ? null : BitmapUtil.mirror(this.mask_, width);
        return new MaskedImage(mirroredImage, mirroredMask);
    }

    public function amountTransparent():Number {
        return BitmapUtil.amountTransparent(this.image_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/MaskedImageSet.as">
package com.company.assembleegameclient.util {
import com.company.util.ImageSet;

import flash.display.BitmapData;

public class MaskedImageSet {


    public var images_:Vector.<MaskedImage>;

    public function MaskedImageSet() {
        this.images_ = new Vector.<MaskedImage>();
        super();
    }

    public function addFromBitmapData(images:BitmapData, masks:BitmapData, width:int, height:int):void {
        var imagesSet:ImageSet = new ImageSet();
        imagesSet.addFromBitmapData(images, width, height);
        var masksSet:ImageSet = null;
        if (masks != null) {
            masksSet = new ImageSet();
            masksSet.addFromBitmapData(masks, width, height);
        }
        for (var i:int = 0; i < imagesSet.images_.length; i++) {
            this.images_.push(new MaskedImage(imagesSet.images_[i], masksSet == null ? null : masksSet.images_[i]));
        }
    }

    public function addFromMaskedImage(maskedImage:MaskedImage, width:int, height:int):void {
        this.addFromBitmapData(maskedImage.image_, maskedImage.mask_, width, height);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/redrawers/GlowRedrawer.as">
package com.company.assembleegameclient.util.redrawers {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.PointUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BlendMode;
import flash.display.GradientType;
import flash.display.Shape;
import flash.filters.BitmapFilterQuality;
import flash.filters.GlowFilter;
import flash.geom.Matrix;
import flash.utils.Dictionary;

public class GlowRedrawer {

    private static const GRADIENT_MAX_SUB:uint = 2631720;

    private static const GLOW_FILTER:GlowFilter = new GlowFilter(0, 0.3, 12, 12, 2, BitmapFilterQuality.LOW, false, false);

    private static const GLOW_FILTER_ALT:GlowFilter = new GlowFilter(0, 0.5, 16, 16, 3, BitmapFilterQuality.LOW, false, false);

    private static var tempMatrix_:Matrix = new Matrix();

    private static var gradient_:Shape = getGradient();

    private static var glowHashes:Dictionary = new Dictionary();


    public function GlowRedrawer() {
        super();
    }

    public static function outlineGlow(texture:BitmapData, glowColor:uint, outlineSize:Number = 1.4, caching:Boolean = true, outlineColor:int = 0):BitmapData {
        var hash:int = getHash(glowColor, outlineSize, outlineColor);
        if (caching && isCached(texture, hash)) {
            return glowHashes[texture][hash];
        }
        var newTexture:BitmapData = texture.clone();
        tempMatrix_.identity();
        tempMatrix_.scale(texture.width / 256, texture.height / 256);
        newTexture.draw(gradient_, tempMatrix_, null, BlendMode.SUBTRACT);
        var origBitmap:Bitmap = new Bitmap(texture);
        newTexture.draw(origBitmap, null, null, BlendMode.ALPHA);
        TextureRedrawer.OUTLINE_FILTER.blurX = outlineSize;
        TextureRedrawer.OUTLINE_FILTER.blurY = outlineSize;
        TextureRedrawer.OUTLINE_FILTER.color = outlineColor;
        newTexture.applyFilter(newTexture, newTexture.rect, PointUtil.ORIGIN, TextureRedrawer.OUTLINE_FILTER);
        if (glowColor != 4294967295) {
            if (Parameters.GPURenderFrame && glowColor != 0) {
                GLOW_FILTER_ALT.color = glowColor;
                newTexture.applyFilter(newTexture, newTexture.rect, PointUtil.ORIGIN, GLOW_FILTER_ALT);
            } else {
                GLOW_FILTER.color = glowColor;
                newTexture.applyFilter(newTexture, newTexture.rect, PointUtil.ORIGIN, GLOW_FILTER);
            }
        }
        if (caching) {
            cache(texture, glowColor, outlineSize, newTexture, outlineColor);
        }
        return newTexture;
    }

    private static function cache(texture:BitmapData, glowColor:uint, outlineSize:Number, newTexture:BitmapData, outlineColor:int):void {
        var glowHash:Object = null;
        var hash:int = getHash(glowColor, outlineSize, outlineColor);
        if (texture in glowHashes) {
            glowHashes[texture][hash] = newTexture;
        } else {
            glowHash = {};
            glowHash[hash] = newTexture;
            glowHashes[texture] = glowHash;
        }
    }

    private static function isCached(texture:BitmapData, hash:int):Boolean {
        var outlineHash:Object = null;
        if (texture in glowHashes) {
            outlineHash = glowHashes[texture];
            if (hash in outlineHash) {
                return true;
            }
        }
        return false;
    }

    private static function getHash(glowColor:uint, outlineSize:Number, outlineColor:int):int {
        return int(outlineSize * 10) + glowColor + outlineColor;
    }

    private static function getGradient():Shape {
        var gradient:Shape = new Shape();
        var gm:Matrix = new Matrix();
        gm.createGradientBox(256, 256, Math.PI / 2, 0, 0);
        gradient.graphics.beginGradientFill(GradientType.LINEAR, [0, GRADIENT_MAX_SUB], [1, 1], [127, 255], gm);
        gradient.graphics.drawRect(0, 0, 256, 256);
        gradient.graphics.endFill();
        return gradient;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/Stage3DProxy.as">
package com.company.assembleegameclient.util {
import flash.display.Stage3D;
import flash.events.Event;
import flash.events.IEventDispatcher;

import svera.untiered.stage3D.proxies.Context3DProxy;

public class Stage3DProxy implements IEventDispatcher {

    private static var context3D:Context3DProxy;


    private var stage3D:Stage3D;

    public function Stage3DProxy(stage3D:Stage3D) {
        super();
        this.stage3D = stage3D;
    }

    public function requestContext3D():void {
        this.stage3D.requestContext3D();
    }

    public function getContext3D():Context3DProxy {
        if (context3D == null) {
            context3D = new Context3DProxy(this.stage3D.context3D);
        }
        return context3D;
    }

    public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {
        this.stage3D.addEventListener(type, listener, useCapture, priority, useWeakReference);
    }

    public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void {
        this.stage3D.removeEventListener(type, listener, useCapture);
    }

    public function dispatchEvent(event:Event):Boolean {
        return this.stage3D.dispatchEvent(event);
    }

    public function hasEventListener(type:String):Boolean {
        return this.stage3D.hasEventListener(type);
    }

    public function willTrigger(type:String):Boolean {
        return this.stage3D.willTrigger(type);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/StageProxy.as">
package com.company.assembleegameclient.util {
import flash.display.DisplayObject;
import flash.display.DisplayObjectContainer;
import flash.display.InteractiveObject;
import flash.events.Event;
import flash.events.IEventDispatcher;

public class StageProxy implements IEventDispatcher {

    private static var stage3D:Stage3DProxy = null;


    protected var reference:DisplayObject;

    public function StageProxy(reference:DisplayObject) {
        super();
        this.reference = reference;
    }

    public function getStage():DisplayObjectContainer {
        return this.reference.stage;
    }


    public function getStageHeight():Number {
        if (this.reference.stage != null) {
            return this.reference.stage.stageHeight;
        }
        return 600;
    }

    public function getFocus():InteractiveObject {
        return this.reference.stage.focus;
    }

    public function setFocus(value:InteractiveObject):void {
        this.reference.stage.focus = value;
    }

    public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {
        this.reference.stage.addEventListener(type, listener, useCapture, priority, useWeakReference);
    }

    public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void {
        this.reference.stage.removeEventListener(type, listener, useCapture);
    }

    public function dispatchEvent(event:Event):Boolean {
        return this.reference.stage.dispatchEvent(event);
    }

    public function hasEventListener(type:String):Boolean {
        return this.reference.stage.hasEventListener(type);
    }

    public function willTrigger(type:String):Boolean {
        return this.reference.stage.willTrigger(type);
    }

    public function getQuality():String {
        return this.reference.stage.quality;
    }

    public function setQuality(quality:String):void {
        this.reference.stage.quality = quality;
    }

    public function getStage3Ds(i:int):Stage3DProxy {
        if (stage3D == null) {
            stage3D = new Stage3DProxy(this.reference.stage.stage3Ds[i]);
        }
        return stage3D;
    }
}
}
</file>

<file path="src/com/company/ui/fonts/MyriadPro.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.ui.fonts {
import mx.core.*;

[Embed(source="MyriadPro.otf", fontName="Myriad Pro", fontFamily="MyriadPro", fontStyle="Regular", embedAsCFF="false", mimeType="application/x-font")]
public class MyriadPro extends FontAsset {
    public function MyriadPro() {
        super();

    }
}
}//package svera.untiered.text.model
</file>

<file path="src/com/company/ui/fonts/MyriadProBold.as">
//Created by Action Script Viewer - http://www.buraks.com/asv
package com.company.ui.fonts {
import mx.core.*;

[Embed(source="MyriadProBold.otf", fontName="Myriad Pro", fontFamily="MyriadPro", fontStyle="Bold", fontWeight="bold", embedAsCFF="false", mimeType="application/x-font")]
public class MyriadProBold extends FontAsset {
    public function MyriadProBold() {
        super();

    }
}
}//package svera.untiered.text.model
</file>

<file path="src/com/company/util/Base64Decoder.as">
package com.company.util {
////////////////////////////////////////////////////////////////////////////////
//
//  Licensed to the Apache Software Foundation (ASF) under one or more
//  contributor license agreements.  See the NOTICE file distributed with
//  this work for additional information regarding copyright ownership.
//  The ASF licenses this file to You under the Apache License, Version 2.0
//  (the "License"); you may not use this file except in compliance with
//  the License.  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

//package mx.utils
//{

import flash.utils.ByteArray;
import mx.resources.IResourceManager;
import mx.resources.ResourceManager;

//[ResourceBundle("utils")]

/**
 * A utility class to decode a Base64 encoded String to a ByteArray.
 *
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 */
public class Base64Decoder
{
    //--------------------------------------------------------------------------
    //
    //  Constructor
    //
    //--------------------------------------------------------------------------

    /**
     * Constructor.
     *
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function Base64Decoder()
    {
        super();
        data = new ByteArray();
    }

    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------

    /**
     * Decodes a Base64 encoded String and adds the result to an internal
     * buffer. Strings must be in ASCII format.
     *
     * <p>Subsequent calls to this method add on to the internal
     * buffer. After all data have been encoded, call <code>toByteArray()</code>
     * to obtain a decoded <code>flash.utils.ByteArray</code>.</p>
     *
     * @param encoded The Base64 encoded String to decode.
     *
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function decode(encoded:String):void
    {
        for (var i:uint = 0; i < encoded.length; ++i)
        {
            var c:Number = encoded.charCodeAt(i);

            if (c == ESCAPE_CHAR_CODE)
                work[count++] = -1;
            else if (inverse[c] != 64)
                work[count++] = inverse[c];
            else
                continue;

            if (count == 4)
            {
                count = 0;
                data.writeByte(work[0] << 2 | (work[1] & 0xFF) >> 4);
                filled++;

                if (work[2] == -1)
                    break;

                data.writeByte(work[1] << 4 | (work[2] & 0xFF) >> 2);
                filled++;

                if (work[3] == -1)
                    break;

                data.writeByte(work[2] << 6 | work[3]);
                filled++;
            }
        }
    }

    /**
     * @private
     */
    public function drain():ByteArray
    {
        var result:ByteArray = new ByteArray();

        var oldPosition:uint = data.position;
        data.position = 0;  // technically, shouldn't need to set this, but carrying over from previous implementation
        result.writeBytes(data, 0, data.length);
        data.position = oldPosition;
        result.position = 0;

        filled = 0;
        return result;
    }

    /**
     * @private
     */
    public function flush():ByteArray
    {
        if (count > 0)
        {
            //var message:String = resourceManager.getString("utils", "partialBlockDropped", [ count ]);
            var message:String = "partialBlockDropped: " + count;
            throw new Error(message);
        }
        return drain();
    }

    /**
     * Clears all buffers and resets the decoder to its initial state.
     *
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function reset():void
    {
        data = new ByteArray();
        count = 0;
        filled = 0;
    }

    /**
     * Returns the current buffer as a decoded <code>flash.utils.ByteArray</code>.
     * Note that calling this method also clears the buffer and resets the
     * decoder to its initial state.
     *
     * @return The decoded <code>flash.utils.ByteArray</code>.
     *
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    public function toByteArray():ByteArray
    {
        var result:ByteArray = flush();
        reset();
        return result;
    }

    //--------------------------------------------------------------------------
    //
    //  Private Variables
    //
    //--------------------------------------------------------------------------

    private var count:int = 0;
    private var data:ByteArray;
    private var filled:int = 0;
    private var work:Array = [0, 0, 0, 0];

    /**
     *  @private
     *  Used for accessing localized Error messages.
     */
    private var resourceManager:IResourceManager = ResourceManager.getInstance();

    private static const ESCAPE_CHAR_CODE:Number = 61; // The '=' char

    private static const inverse:Array =
            [
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
                52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
                64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
                64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
                64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
            ];
}

}
</file>

<file path="src/com/company/util/BitmapUtil.as">
package com.company.util {
import flash.display.BitmapData;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Dictionary;

public class BitmapUtil {


    public function BitmapUtil(se:StaticEnforcer) {
        super();
    }

    public static function mirror(bitmapData:BitmapData, width:int = 0):BitmapData {
        var y:int = 0;
        if (width == 0) {
            width = bitmapData.width;
        }
        var mirrored:BitmapData = new BitmapData(bitmapData.width, bitmapData.height, true, 0);
        for (var x:int = 0; x < width; x++) {
            for (y = 0; y < bitmapData.height; y++) {
                mirrored.setPixel32(width - x - 1, y, bitmapData.getPixel32(x, y));
            }
        }
        return mirrored;
    }

    public static function rotateBitmapData(bitmapData:BitmapData, clockwiseTurns:int):BitmapData {
        var matrix:Matrix = new Matrix();
        matrix.translate(-bitmapData.width / 2, -bitmapData.height / 2);
        matrix.rotate(clockwiseTurns * Math.PI / 2);
        matrix.translate(bitmapData.height / 2, bitmapData.width / 2);
        var rotated:BitmapData = new BitmapData(bitmapData.height, bitmapData.width, true, 0);
        rotated.draw(bitmapData, matrix);
        return rotated;
    }

    public static function cropToBitmapData(bitmapData:BitmapData, x:int, y:int, width:int, height:int):BitmapData {
        var cropped:BitmapData = new BitmapData(width, height);
        cropped.copyPixels(bitmapData, new Rectangle(x, y, width, height), new Point(0, 0));
        return cropped;
    }

    public static function amountTransparent(bitmapData:BitmapData):Number {
        var y:int = 0;
        var alpha:int = 0;
        var trans:int = 0;
        for (var x:int = 0; x < bitmapData.width; x++) {
            for (y = 0; y < bitmapData.height; y++) {
                alpha = bitmapData.getPixel32(x, y) & 4278190080;
                if (alpha == 0) {
                    trans++;
                }
            }
        }
        return trans / (bitmapData.width * bitmapData.height);
    }

    public static function mostCommonColor(bitmapData:BitmapData):uint {
        var color:uint = 0;
        var colorStr:* = null;
        var y:int = 0;
        var count:int = 0;
        var colors_:Dictionary = new Dictionary();
        for (var x:int = 0; x < bitmapData.width; x++) {
            for (y = 0; y < bitmapData.width; y++) {
                color = bitmapData.getPixel32(x, y);
                if ((color & 4278190080) != 0) {
                    if (!colors_.hasOwnProperty(color)) {
                        colors_[color] = 1;
                    } else {
                        colors_[color]++;
                    }
                }
            }
        }
        var bestColor:uint = 0;
        var bestCount:uint = 0;
        for (colorStr in colors_) {
            color = uint(colorStr);
            count = colors_[colorStr];
            if (count > bestCount || count == bestCount && color > bestColor) {
                bestColor = color;
                bestCount = count;
            }
        }
        return bestColor;
    }

    public static function lineOfSight(bitmapData:BitmapData, p1:IntPoint, p2:IntPoint):Boolean {
        var temp:int = 0;
        var numSteps:int = 0;
        var skipYSteps:int = 0;
        var skipXSteps:int = 0;
        var width:int = bitmapData.width;
        var height:int = bitmapData.height;
        var x0:int = p1.x();
        var y0:int = p1.y();
        var x1:int = p2.x();
        var y1:int = p2.y();
        var steep:Boolean = (y0 > y1 ? y0 - y1 : y1 - y0) > (x0 > x1 ? x0 - x1 : x1 - x0);
        if (steep) {
            temp = x0;
            x0 = y0;
            y0 = temp;
            temp = x1;
            x1 = y1;
            y1 = temp;
            temp = width;
            width = height;
            height = temp;
        }
        if (x0 > x1) {
            temp = x0;
            x0 = x1;
            x1 = temp;
            temp = y0;
            y0 = y1;
            y1 = temp;
        }
        var deltax:int = x1 - x0;
        var deltay:int = y0 > y1 ? int(y0 - y1) : int(y1 - y0);
        var error:int = -(deltax + 1) / 2;
        var ystep:int = y0 > y1 ? int(-1) : int(1);
        var xstop:int = x1 > width - 1 ? int(width - 1) : int(x1);
        var y:int = y0;
        var x:int = x0;
        if (x < 0) {
            error = error + deltay * -x;
            if (error >= 0) {
                numSteps = error / deltax + 1;
                y = y + ystep * numSteps;
                error = error - numSteps * deltax;
            }
            x = 0;
        }
        if (ystep > 0 && y < 0 || ystep < 0 && y >= height) {
            skipYSteps = ystep > 0 ? int(-y - 1) : int(y - height);
            error = error - deltax * skipYSteps;
            skipXSteps = -error / deltay;
            x = x + skipXSteps;
            error = error + skipXSteps * deltay;
            y = y + skipYSteps * ystep;
        }
        while (x <= xstop) {
            if (ystep > 0 && y >= height || ystep < 0 && y < 0) {
                break;
            }
            if (steep) {
                if (y >= 0 && y < height && bitmapData.getPixel(y, x) == 0) {
                    return false;
                }
            } else if (y >= 0 && y < height && bitmapData.getPixel(x, y) == 0) {
                return false;
            }
            error = error + deltay;
            if (error >= 0) {
                y = y + ystep;
                error = error - deltax;
            }
            x++;
        }
        return true;
    }
}
}

class StaticEnforcer {


    function StaticEnforcer() {
        super();
    }
}
</file>

<file path="src/com/company/util/CachingColorTransformer.as">
package com.company.util {
import flash.display.BitmapData;
import flash.filters.BitmapFilter;
import flash.geom.ColorTransform;
import flash.geom.Point;
import flash.utils.Dictionary;

public class CachingColorTransformer {

    private static var bds_:Dictionary = new Dictionary();
    private static var alphas_:Dictionary = new Dictionary();


    public function CachingColorTransformer() {
        super();
    }

    public static function transformBitmapData(bitmapData:BitmapData, ct:ColorTransform):BitmapData {
        var newBitmapData:BitmapData = null;
        var dict:Dictionary = bds_[bitmapData];
        if (dict != null) {
            newBitmapData = dict[ct];
        } else {
            dict = new Dictionary();
            bds_[bitmapData] = dict;
        }
        if (newBitmapData == null) {
            newBitmapData = bitmapData.clone();
            newBitmapData.colorTransform(newBitmapData.rect, ct);
            dict[ct] = newBitmapData;
        }
        return newBitmapData;
    }

    public static function filterBitmapData(bitmapData:BitmapData, filter:BitmapFilter):BitmapData {
        var newBitmapData:BitmapData = null;
        var dict:Dictionary = bds_[bitmapData];
        if (dict != null) {
            newBitmapData = dict[filter];
        } else {
            dict = new Dictionary();
            bds_[bitmapData] = dict;
        }
        if (newBitmapData == null) {
            newBitmapData = bitmapData.clone();
            newBitmapData.applyFilter(newBitmapData, newBitmapData.rect, new Point(), filter);
            dict[filter] = newBitmapData;
        }
        return newBitmapData;
    }

    public static function alphaBitmapData(bitmapData:BitmapData, alpha:int):BitmapData {
        var ct:ColorTransform = alphas_[alpha];
        if (ct == null) {
            ct = new ColorTransform(1, 1, 1, alpha / 100);
            alphas_[alpha] = ct;
        }
        return transformBitmapData(bitmapData, ct);
    }

    public static function clear():void {
        var dict:Dictionary = null;
        var bd:BitmapData = null;
        for each(dict in bds_) {
            for each(bd in dict) {
                bd.dispose();
            }
        }
        bds_ = new Dictionary();
        alphas_ = new Dictionary();
    }
}
}
</file>

<file path="src/com/company/util/CapabilitiesUtil.as">
package com.company.util {
import flash.system.Capabilities;

public class CapabilitiesUtil {


    public function CapabilitiesUtil() {
        super();
    }

    public static function getHumanReadable():String {
        return getHumanReadableLine("avHardwareDisable") + getHumanReadableLine("hasAccessibility") + getHumanReadableLine("hasAudio") + getHumanReadableLine("hasAudioEncoder") + getHumanReadableLine("hasEmbeddedVideo") + getHumanReadableLine("hasIME") + getHumanReadableLine("hasMP3") + getHumanReadableLine("hasPrinting") + getHumanReadableLine("hasScreenBroadcast") + getHumanReadableLine("hasScreenPlayback") + getHumanReadableLine("hasStreamingAudio") + getHumanReadableLine("hasStreamingVideo") + getHumanReadableLine("hasTLS") + getHumanReadableLine("hasVideoEncoder") + getHumanReadableLine("isDebugger") + getHumanReadableLine("language") + getHumanReadableLine("localFileReadDisable") + getHumanReadableLine("manufacturer") + getHumanReadableLine("os") + getHumanReadableLine("pixelAspectRatio") + getHumanReadableLine("playerType") + getHumanReadableLine("screenColor") + getHumanReadableLine("screenDPI") + getHumanReadableLine("screenResolutionX") + getHumanReadableLine("screenResolutionY") + getHumanReadableLine("version");
    }

    private static function getHumanReadableLine(name:String):String {
        return name + ": " + Capabilities[name] + "\n";
    }
}
}
</file>

<file path="src/com/company/util/ConversionUtil.as">
package com.company.util {
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.geom.Vector3D;

public class ConversionUtil {


    public function ConversionUtil(se:StaticEnforcer) {
        super();
    }

    public static function toIntArray(obj:Object, delim:String = ","):Array {
        if (obj == null) {
            return new Array();
        }
        var a:Array = obj.toString().split(delim).map(mapParseInt);
        return a;
    }

    public static function toNumberArray(obj:Object, delim:String = ","):Array {
        if (obj == null) {
            return new Array();
        }
        var a:Array = obj.toString().split(delim).map(mapParseFloat);
        return a;
    }

    public static function toIntVector(obj:Object, delim:String = ","):Vector.<int> {
        if (obj == null) {
            return new Vector.<int>();
        }
        var v:Vector.<int> = Vector.<int>(obj.toString().split(delim).map(mapParseInt));
        return v;
    }

    public static function toNumberVector(obj:Object, delim:String = ","):Vector.<Number> {
        if (obj == null) {
            return new Vector.<Number>();
        }
        var v:Vector.<Number> = Vector.<Number>(obj.toString().split(delim).map(mapParseFloat));
        return v;
    }

    public static function toStringArray(obj:Object, delim:String = ","):Array {
        if (obj == null) {
            return new Array();
        }
        var a:Array = obj.toString().split(delim);
        return a;
    }

    public static function toRectangle(obj:Object, delim:String = ","):Rectangle {
        if (obj == null) {
            return new Rectangle();
        }
        var a:Array = obj.toString().split(delim).map(mapParseFloat);
        return a == null || a.length < 4 ? new Rectangle() : new Rectangle(a[0], a[1], a[2], a[3]);
    }

    public static function toPoint(obj:Object, delim:String = ","):Point {
        if (obj == null) {
            return new Point();
        }
        var a:Array = obj.toString().split(delim).map(ConversionUtil.mapParseFloat);
        return a == null || a.length < 2 ? new Point() : new Point(a[0], a[1]);
    }

    public static function toPointPair(obj:Object, delim:String = ","):Array {
        var ret:Array = new Array();
        if (obj == null) {
            ret.push(new Point());
            ret.push(new Point());
            return ret;
        }
        var a:Array = obj.toString().split(delim).map(ConversionUtil.mapParseFloat);
        if (a == null || a.length < 4) {
            ret.push(new Point());
            ret.push(new Point());
            return ret;
        }
        ret.push(new Point(a[0], a[1]));
        ret.push(new Point(a[2], a[3]));
        return ret;
    }

    public static function toVector3D(obj:Object, delim:String = ","):Vector3D {
        if (obj == null) {
            return new Vector3D();
        }
        var a:Array = obj.toString().split(delim).map(ConversionUtil.mapParseFloat);
        return a == null || a.length < 3 ? new Vector3D() : new Vector3D(a[0], a[1], a[2]);
    }

    public static function toCharCodesVector(obj:Object, delim:String = ","):Vector.<int> {
        if (obj == null) {
            return new Vector.<int>();
        }
        var v:Vector.<int> = Vector.<int>(obj.toString().split(delim).map(mapParseCharCode));
        return v;
    }

    public static function addToNumberVector(obj:Object, vec:Vector.<Number>, delim:String = ","):void {
        var f:Number = NaN;
        if (obj == null) {
            return;
        }
        var a:Array = obj.toString().split(delim).map(mapParseFloat);
        for each(f in a) {
            vec.push(f);
        }
    }

    public static function addToIntVector(obj:Object, vec:Vector.<int>, delim:String = ","):void {
        var i:int = 0;
        if (obj == null) {
            return;
        }
        var a:Array = obj.toString().split(delim).map(mapParseFloat);
        for each(i in a) {
            vec.push(i);
        }
    }

    public static function mapParseFloat(str:*, ...args):Number {
        return parseFloat(str);
    }

    public static function mapParseInt(str:*, ...args):Number {
        return parseInt(str);
    }

    public static function mapParseCharCode(str:*, ...args):Number {
        return String(str).charCodeAt();
    }

    public static function vector3DToShaderParameter(v:Vector3D):Array {
        return [v.x, v.y, v.z];
    }
}
}

class StaticEnforcer {


    function StaticEnforcer() {
        super();
    }
}
</file>

<file path="src/com/company/util/Guid.as">
package com.company.util {
import flash.utils.IDataInput;

public class Guid {

    public static const Empty:String = "00000000-0000-0000-0000-000000000000";

    private static var tempData:Vector.<int> = new Vector.<int>(16, true);

    public static function guidDataToString(data:IDataInput): String {
        for (var i:int = 0; i < 16; i++) {
            tempData[i] = data.readUnsignedByte();
        }

        var part1:String = toHex(tempData[3]) + toHex(tempData[2]) + toHex(tempData[1]) + toHex(tempData[0]);
        var part2:String = toHex(tempData[5]) + toHex(tempData[4]);
        var part3:String = toHex(tempData[7]) + toHex(tempData[6]);
        var part4:String = toHex(tempData[8]) + toHex(tempData[9]);
        var part5:String = toHex(tempData[10]) + toHex(tempData[11]) + toHex(tempData[12]) + toHex(tempData[13]) + toHex(tempData[14]) + toHex(tempData[15]);

        return part1 + "-" + part2 + "-" + part3 + "-" + part4 + "-" + part5;
    }

    private static function toHex(n:int):String {
        return ("0" + n.toString(16)).substr(-2);
    }
}
}
</file>

<file path="src/com/company/util/HTMLUtil.as">
package com.company.util {
import flash.xml.XMLDocument;
import flash.xml.XMLNode;
import flash.xml.XMLNodeType;

public class HTMLUtil {


    public function HTMLUtil() {
        super();
    }

    public static function unescape(str:String):String {
        return new XMLDocument(str).firstChild.nodeValue;
    }

    public static function escape(str:String):String {
        return XML(new XMLNode(XMLNodeType.TEXT_NODE, str)).toXMLString();
    }
}
}
</file>

<file path="src/com/company/util/ImageSet.as">
package com.company.util {
import flash.display.BitmapData;

public class ImageSet {


    public var images_:Vector.<BitmapData>;

    public function ImageSet() {
        super();
        this.images_ = new Vector.<BitmapData>();
    }

    public function add(bitmapData:BitmapData):void {
        this.images_.push(bitmapData);
    }

    public function random():BitmapData {
        return this.images_[int(Math.random() * this.images_.length)];
    }

    public function addFromBitmapData(bitmapData:BitmapData, width:int, height:int):void {
        var x:int = 0;
        var maxX:int = bitmapData.width / width;
        var maxY:int = bitmapData.height / height;
        for (var y:int = 0; y < maxY; y++) {
            for (x = 0; x < maxX; x++) {
                this.images_.push(BitmapUtil.cropToBitmapData(bitmapData, x * width, y * height, width, height));
            }
        }
    }
}
}
</file>

<file path="src/com/company/util/MoreColorUtil.as">
package com.company.util {
import flash.geom.ColorTransform;

public class MoreColorUtil {

    public static const greyscaleFilterMatrix:Array = [0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0, 0, 0, 1, 0];

    public static const redFilterMatrix:Array = [0.3, 0.59, 0.11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0];

    public static const identity:ColorTransform = new ColorTransform();

    public static const invisible:ColorTransform = new ColorTransform(1, 1, 1, 0, 0, 0, 0, 0);

    public static const transparentCT:ColorTransform = new ColorTransform(1, 1, 1, 0.3, 0, 0, 0, 0);

    public static const slightlyTransparentCT:ColorTransform = new ColorTransform(1, 1, 1, 0.7, 0, 0, 0, 0);

    public static const greenCT:ColorTransform = new ColorTransform(0.6, 1, 0.6, 1, 0, 0, 0, 0);

    public static const lightGreenCT:ColorTransform = new ColorTransform(0.8, 1, 0.8, 1, 0, 0, 0, 0);

    public static const veryGreenCT:ColorTransform = new ColorTransform(0.2, 1, 0.2, 1, 0, 100, 0, 0);

    public static const transparentGreenCT:ColorTransform = new ColorTransform(0.5, 1, 0.5, 0.3, 0, 0, 0, 0);

    public static const transparentVeryGreenCT:ColorTransform = new ColorTransform(0.3, 1, 0.3, 0.5, 0, 0, 0, 0);

    public static const redCT:ColorTransform = new ColorTransform(1, 0.5, 0.5, 1, 0, 0, 0, 0);

    public static const lightRedCT:ColorTransform = new ColorTransform(1, 0.7, 0.7, 1, 0, 0, 0, 0);

    public static const veryRedCT:ColorTransform = new ColorTransform(1, 0.2, 0.2, 1, 100, 0, 0, 0);

    public static const transparentRedCT:ColorTransform = new ColorTransform(1, 0.5, 0.5, 0.3, 0, 0, 0, 0);

    public static const transparentVeryRedCT:ColorTransform = new ColorTransform(1, 0.3, 0.3, 0.5, 0, 0, 0, 0);

    public static const blueCT:ColorTransform = new ColorTransform(0.5, 0.5, 1, 1, 0, 0, 0, 0);

    public static const lightBlueCT:ColorTransform = new ColorTransform(0.7, 0.7, 1, 1, 0, 0, 100, 0);

    public static const veryBlueCT:ColorTransform = new ColorTransform(0.3, 0.3, 1, 1, 0, 0, 100, 0);

    public static const transparentBlueCT:ColorTransform = new ColorTransform(0.5, 0.5, 1, 0.3, 0, 0, 0, 0);

    public static const transparentVeryBlueCT:ColorTransform = new ColorTransform(0.3, 0.3, 1, 0.5, 0, 0, 0, 0);

    public static const purpleCT:ColorTransform = new ColorTransform(1, 0.5, 1, 1, 0, 0, 0, 0);

    public static const veryPurpleCT:ColorTransform = new ColorTransform(1, 0.2, 1, 1, 100, 0, 100, 0);

    public static const darkCT:ColorTransform = new ColorTransform(0.6, 0.6, 0.6, 1, 0, 0, 0, 0);

    public static const veryDarkCT:ColorTransform = new ColorTransform(0.4, 0.4, 0.4, 1, 0, 0, 0, 0);

    public static const makeWhiteCT:ColorTransform = new ColorTransform(1, 1, 1, 1, 255, 255, 255, 0);


    public function MoreColorUtil(se:StaticEnforcer) {
        super();
    }

    public static function hsvToRgb(h:Number, s:Number, v:Number):int {
        var r:Number = NaN;
        var g:Number = NaN;
        var b:Number = NaN;
        var hi:int = int(h / 60) % 6;
        var f:Number = h / 60 - Math.floor(h / 60);
        var p:Number = v * (1 - s);
        var q:Number = v * (1 - f * s);
        var t:Number = v * (1 - (1 - f) * s);
        switch (hi) {
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
        }
        return int(Math.min(255, Math.floor(r * 255))) << 16 | int(Math.min(255, Math.floor(g * 255))) << 8 | int(Math.min(255, Math.floor(b * 255)));
    }

    public static function randomColor():uint {
        return uint(16777215 * Math.random());
    }

    public static function randomColor32():uint {
        return uint(16777215 * Math.random()) | 4278190080;
    }

    public static function transformColor(ct:ColorTransform, color:uint):uint {
        var r:int = ((color & 16711680) >> 16) * ct.redMultiplier + ct.redOffset;
        r = r < 0 ? int(0) : r > 255 ? int(255) : int(r);
        var g:int = ((color & 65280) >> 8) * ct.greenMultiplier + ct.greenOffset;
        g = g < 0 ? int(0) : g > 255 ? int(255) : int(g);
        var b:int = (color & 255) * ct.blueMultiplier + ct.blueOffset;
        b = b < 0 ? int(0) : b > 255 ? int(255) : int(b);
        return r << 16 | g << 8 | b;
    }

    public static function copyColorTransform(ct:ColorTransform):ColorTransform {
        return new ColorTransform(ct.redMultiplier, ct.greenMultiplier, ct.blueMultiplier, ct.alphaMultiplier, ct.redOffset, ct.greenOffset, ct.blueOffset, ct.alphaOffset);
    }

    public static function lerpColorTransform(startCT:ColorTransform, endCT:ColorTransform, val:Number):ColorTransform {
        if (startCT == null) {
            startCT = identity;
        }
        if (endCT == null) {
            endCT = identity;
        }
        var ival:Number = 1 - val;
        var ct:ColorTransform = new ColorTransform(startCT.redMultiplier * ival + endCT.redMultiplier * val, startCT.greenMultiplier * ival + endCT.greenMultiplier * val, startCT.blueMultiplier * ival + endCT.blueMultiplier * val, startCT.alphaMultiplier * ival + endCT.alphaMultiplier * val, startCT.redOffset * ival + endCT.redOffset * val, startCT.greenOffset * ival + endCT.greenOffset * val, startCT.blueOffset * ival + endCT.blueOffset * val, startCT.alphaOffset * ival + endCT.alphaOffset * val);
        return ct;
    }

    public static function lerpColor(fromColor:uint, toColor:uint, progress:Number):uint {
        var q:Number = 1 - progress;
        var fromA:uint = fromColor >> 24 & 255;
        var fromR:uint = fromColor >> 16 & 255;
        var fromG:uint = fromColor >> 8 & 255;
        var fromB:uint = fromColor & 255;
        var toA:uint = toColor >> 24 & 255;
        var toR:uint = toColor >> 16 & 255;
        var toG:uint = toColor >> 8 & 255;
        var toB:uint = toColor & 255;
        var resultA:uint = fromA * q + toA * progress;
        var resultR:uint = fromR * q + toR * progress;
        var resultG:uint = fromG * q + toG * progress;
        var resultB:uint = fromB * q + toB * progress;
        var resultColor:uint = resultA << 24 | resultR << 16 | resultG << 8 | resultB;
        return resultColor;
    }

    public static function transformAlpha(ct:ColorTransform, alpha:Number):Number {
        var da:uint = alpha * 255;
        var a:uint = da * ct.alphaMultiplier + ct.alphaOffset;
        a = a < 0 ? uint(0) : a > 255 ? uint(255) : uint(a);
        return a / 255;
    }

    public static function multiplyColor(color:uint, multiply:Number):uint {
        var r:int = ((color & 16711680) >> 16) * multiply;
        r = r < 0 ? int(0) : r > 255 ? int(255) : int(r);
        var g:int = ((color & 65280) >> 8) * multiply;
        g = g < 0 ? int(0) : g > 255 ? int(255) : int(g);
        var b:int = (color & 255) * multiply;
        b = b < 0 ? int(0) : b > 255 ? int(255) : int(b);
        return r << 16 | g << 8 | b;
    }

    public static function adjustBrightness(color:uint, num:Number):uint {
        var a:uint = color & 4278190080;
        var r:int = ((color & 16711680) >> 16) + num * 255;
        r = r < 0 ? int(0) : r > 255 ? int(255) : int(r);
        var g:int = ((color & 65280) >> 8) + num * 255;
        g = g < 0 ? int(0) : g > 255 ? int(255) : int(g);
        var b:int = (color & 255) + num * 255;
        b = b < 0 ? int(0) : b > 255 ? int(255) : int(b);
        return a | r << 16 | g << 8 | b;
    }

    public static function colorToShaderParameter(color:uint):Array {
        var alpha:Number = (color >> 24 & 255) / 256;
        return [alpha * ((color >> 16 & 255) / 256), alpha * ((color >> 8 & 255) / 256), alpha * ((color & 255) / 256), alpha];
    }

    public static function rgbToGreyscale(color:uint):uint {
        var val:uint = ((color & 16711680) >> 16) * 0.3 + ((color & 65280) >> 8) * 0.59 + (color & 255) * 0.11;
        return (color && 4278190080) | val << 16 | val << 8 | val;
    }

    public static function singleColorFilterMatrix(color:uint):Array {
        return [0, 0, 0, 0, (color & 16711680) >> 16, 0, 0, 0, 0, (color & 65280) >> 8, 0, 0, 0, 0, color & 255, 0, 0, 0, 1, 0];
    }
}
}

class StaticEnforcer {


    function StaticEnforcer() {
        super();
    }
}
</file>

<file path="src/com/company/util/MoreStringUtil.as">
package com.company.util {
import flash.utils.ByteArray;

public class MoreStringUtil {


    public function MoreStringUtil() {
        super();
    }

    public static function hexStringToByteArray(hexString:String):ByteArray {
        var byteArray:ByteArray = new ByteArray();
        for (var i:int = 0; i < hexString.length; i = i + 2) {
            byteArray.writeByte(parseInt(hexString.substr(i, 2), 16));
        }
        return byteArray;
    }

    public static function cmp(s1:String, s2:String):Number {
        return s1.localeCompare(s2);
    }
}
}
</file>

<file path="src/com/company/util/Random.as">
package com.company.util {
public class Random {


    public var seed:uint;

    public function Random(seed:uint) {
        this.seed = seed;
    }

    public function drop(count:int):void {
        for (var i:int = 0; i < count; i++)
            gen();
    }

    public function nextIntRange(min:uint, max:uint):uint {
        return min == max ? min : min + this.gen() % (max - min);
    }

    private function gen():uint {
        var lb:uint = 16807 * (this.seed & 0xFFFF);
        var hb:uint = 16807 * (this.seed >> 16);
        lb = lb + ((hb & 32767) << 16);
        lb = lb + (hb >> 15);
        if (lb > 2147483647) {
            lb = lb - 2147483647;
        }
        return this.seed = lb;
    }
}
}
</file>

<file path="src/com/company/util/RectangleUtil.as">
package com.company.util {
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Rectangle;

public class RectangleUtil {


    public function RectangleUtil() {
        super();
    }

    public static function pointDist(rect:Rectangle, x:Number, y:Number):Number {
        var cX:Number = x;
        var cY:Number = y;
        if (cX < rect.x) {
            cX = rect.x;
        } else if (cX > rect.right) {
            cX = rect.right;
        }
        if (cY < rect.y) {
            cY = rect.y;
        } else if (cY > rect.bottom) {
            cY = rect.bottom;
        }
        if (cX == x && cY == y) {
            return 0;
        }
        return PointUtil.distanceXY(cX, cY, x, y);
    }

    public static function closestPoint(rect:Rectangle, x:Number, y:Number):Point {
        var cX:Number = x;
        var cY:Number = y;
        if (cX < rect.x) {
            cX = rect.x;
        } else if (cX > rect.right) {
            cX = rect.right;
        }
        if (cY < rect.y) {
            cY = rect.y;
        } else if (cY > rect.bottom) {
            cY = rect.bottom;
        }
        return new Point(cX, cY);
    }

    public static function lineSegmentIntersectsXY(rect:Rectangle, x0:Number, y0:Number, x1:Number, y1:Number):Boolean {
        var tint:Number = NaN;
        var bint:Number = NaN;
        var maxY:Number = NaN;
        var minY:Number = NaN;
        if (rect.left > x0 && rect.left > x1 || rect.right < x0 && rect.right < x1 || rect.top > y0 && rect.top > y1 || rect.bottom < y0 && rect.bottom < y1) {
            return false;
        }
        if (rect.left < x0 && x0 < rect.right && rect.top < y0 && y0 < rect.bottom || rect.left < x1 && x1 < rect.right && rect.top < y1 && y1 < rect.bottom) {
            return true;
        }
        var m:Number = (y1 - y0) / (x1 - x0);
        var c:Number = y0 - m * x0;
        if (m > 0) {
            tint = m * rect.left + c;
            bint = m * rect.right + c;
        } else {
            tint = m * rect.right + c;
            bint = m * rect.left + c;
        }
        if (y0 < y1) {
            minY = y0;
            maxY = y1;
        } else {
            minY = y1;
            maxY = y0;
        }
        var topoverlap:Number = tint > minY ? Number(tint) : Number(minY);
        var botoverlap:Number = bint < maxY ? Number(bint) : Number(maxY);
        return topoverlap < botoverlap && !(botoverlap < rect.top || topoverlap > rect.bottom);
    }

    public static function lineSegmentIntersectXY(rect:Rectangle, p1x:Number, p1y:Number, p2x:Number, p2y:Number, result:Point):Boolean {
        var slope:Number = NaN;
        var c:Number = NaN;
        var y:Number = NaN;
        var x:Number = NaN;
        if (p2x <= rect.x) {
            slope = (p2y - p1y) / (p2x - p1x);
            c = p1y - p1x * slope;
            y = slope * rect.x + c;
            if (y >= rect.y && y <= rect.y + rect.height) {
                result.x = rect.x;
                result.y = y;
                return true;
            }
        } else if (p2x >= rect.x + rect.width) {
            slope = (p2y - p1y) / (p2x - p1x);
            c = p1y - p1x * slope;
            y = slope * (rect.x + rect.width) + c;
            if (y >= rect.y && y <= rect.y + rect.height) {
                result.x = rect.x + rect.width;
                result.y = y;
                return true;
            }
        }
        if (p2y <= rect.y) {
            slope = (p2x - p1x) / (p2y - p1y);
            c = p1x - p1y * slope;
            x = slope * rect.y + c;
            if (x >= rect.x && x <= rect.x + rect.width) {
                result.x = x;
                result.y = rect.y;
                return true;
            }
        } else if (p2y >= rect.y + rect.height) {
            slope = (p2x - p1x) / (p2y - p1y);
            c = p1x - p1y * slope;
            x = slope * (rect.y + rect.height) + c;
            if (x >= rect.x && x <= rect.x + rect.width) {
                result.x = x;
                result.y = rect.y + rect.height;
                return true;
            }
        }
        return false;
    }

    public static function lineSegmentIntersect(rect:Rectangle, p1:IntPoint, p2:IntPoint):Point {
        var slope:Number = NaN;
        var c:Number = NaN;
        var y:Number = NaN;
        var x:Number = NaN;
        if (p2.x() <= rect.x) {
            slope = (p2.y() - p1.y()) / (p2.x() - p1.x());
            c = p1.y() - p1.x() * slope;
            y = slope * rect.x + c;
            if (y >= rect.y && y <= rect.y + rect.height) {
                return new Point(rect.x, y);
            }
        } else if (p2.x() >= rect.x + rect.width) {
            slope = (p2.y() - p1.y()) / (p2.x() - p1.x());
            c = p1.y() - p1.x() * slope;
            y = slope * (rect.x + rect.width) + c;
            if (y >= rect.y && y <= rect.y + rect.height) {
                return new Point(rect.x + rect.width, y);
            }
        }
        if (p2.y() <= rect.y) {
            slope = (p2.x() - p1.x()) / (p2.y() - p1.y());
            c = p1.x() - p1.y() * slope;
            x = slope * rect.y + c;
            if (x >= rect.x && x <= rect.x + rect.width) {
                return new Point(x, rect.y);
            }
        } else if (p2.y() >= rect.y + rect.height) {
            slope = (p2.x() - p1.x()) / (p2.y() - p1.y());
            c = p1.x() - p1.y() * slope;
            x = slope * (rect.y + rect.height) + c;
            if (x >= rect.x && x <= rect.x + rect.width) {
                return new Point(x, rect.y + rect.height);
            }
        }
        return null;
    }

    public static function getRotatedRectExtents2D(centerX:Number, centerY:Number, angle:Number, w:Number, h:Number):Extents2D {
        var pout:Point = null;
        var y:int = 0;
        var m:Matrix = new Matrix();
        m.translate(-w / 2, -h / 2);
        m.rotate(angle);
        m.translate(centerX, centerY);
        var extents:Extents2D = new Extents2D();
        var pin:Point = new Point();
        for (var x:int = 0; x <= 1; x++) {
            for (y = 0; y <= 1; y++) {
                pin.x = x * w;
                pin.y = y * h;
                pout = m.transformPoint(pin);
                extents.add(pout.x, pout.y);
            }
        }
        return extents;
    }
}
}
</file>

<file path="src/com/company/util/SpriteUtil.as">
package com.company.util {
import flash.display.DisplayObject;
import flash.display.DisplayObjectContainer;

public class SpriteUtil {


    public function SpriteUtil() {
        super();
    }

    public static function safeAddChild(sprite:DisplayObjectContainer, displayObject:DisplayObject):void {
        if (sprite != null && displayObject != null && !sprite.contains(displayObject)) {
            sprite.addChild(displayObject);
        }
    }

    public static function safeRemoveChild(sprite:DisplayObjectContainer, displayObject:DisplayObject):void {
        if (sprite != null && displayObject != null && sprite.contains(displayObject)) {
            sprite.removeChild(displayObject);
        }
    }
}
}
</file>

<file path="src/com/company/util/Trig.as">
package com.company.util {
public class Trig {

    public static const toDegrees:Number = 180 / Math.PI;

    public static const toRadians:Number = Math.PI / 180;


    public function Trig(se:StaticEnforcer) {
        super();
    }

    public static function slerp(fromAngle:Number, toAngle:Number, f:Number):Number {
        var angle:Number;
        if (fromAngle > toAngle) {
            if (fromAngle - toAngle > Math.PI) {
                angle = fromAngle * (1 - f) + (toAngle + 2 * Math.PI) * f;
            } else {
                angle = fromAngle * (1 - f) + toAngle * f;
            }
        } else if (toAngle - fromAngle > Math.PI) {
            angle = (fromAngle + 2 * Math.PI) * (1 - f) + toAngle * f;
        } else {
            angle = fromAngle * (1 - f) + toAngle * f;
        }
        if (angle < -Math.PI || angle > Math.PI) {
            angle = boundToPI(angle);
        }
        return angle;
    }

    public static function angleDiff(fromAngle:Number, toAngle:Number):Number {
        if (fromAngle > toAngle) {
            if (fromAngle - toAngle > Math.PI) {
                return toAngle + 2 * Math.PI - fromAngle;
            }
            return fromAngle - toAngle;
        }
        if (toAngle - fromAngle > Math.PI) {
            return fromAngle + 2 * Math.PI - toAngle;
        }
        return toAngle - fromAngle;
    }

    public static function sin(x:Number):Number {
        var sin:Number;
        if (x < -Math.PI || x > Math.PI) {
            x = boundToPI(x);
        }
        if (x < 0) {
            sin = 1.27323954 * x + 0.405284735 * x * x;
            if (sin < 0) {
                sin = 0.225 * (sin * -sin - sin) + sin;
            } else {
                sin = 0.225 * (sin * sin - sin) + sin;
            }
        } else {
            sin = 1.27323954 * x - 0.405284735 * x * x;
            if (sin < 0) {
                sin = 0.225 * (sin * -sin - sin) + sin;
            } else {
                sin = 0.225 * (sin * sin - sin) + sin;
            }
        }
        return sin;
    }

    public static function cos(x:Number):Number {
        return sin(x + Math.PI / 2);
    }

    public static function atan2(y:Number, x:Number):Number {
        var atan:Number = NaN;
        if (x == 0) {
            if (y < 0) {
                return -Math.PI / 2;
            }
            if (y > 0) {
                return Math.PI / 2;
            }
            return undefined;
        }
        if (y == 0) {
            if (x < 0) {
                return Math.PI;
            }
            return 0;
        }
        if ((x > 0 ? x : -x) > (y > 0 ? y : -y)) {
            atan = (x < 0 ? -Math.PI : 0) + atan2Helper(y, x);
        } else {
            atan = (y > 0 ? Math.PI / 2 : -Math.PI / 2) - atan2Helper(x, y);
        }
        if (atan < -Math.PI || atan > Math.PI) {
            atan = boundToPI(atan);
        }
        return atan;
    }

    public static function atan2Helper(y:Number, x:Number):Number {
        var v:Number = y / x;
        var total:Number = v;
        var nom:Number = v;
        var i:Number = 1;
        var sign:int = 1;
        do {
            i = i + 2;
            sign = sign > 0 ? int(-1) : int(1);
            nom = nom * v * v;
            total = total + sign * nom / i;
        }
        while ((nom > 0.01 || nom < -0.01) && i <= 11);

        return total;
    }

    public static function boundToPI(x:Number):Number {
        var v:int = 0;
        if (x < -Math.PI) {
            v = (int(x / -Math.PI) + 1) / 2;
            x = x + v * 2 * Math.PI;
        } else if (x > Math.PI) {
            v = (int(x / Math.PI) + 1) / 2;
            x = x - v * 2 * Math.PI;
        }
        return x;
    }

    public static function boundTo180(x:Number):Number {
        var v:int = 0;
        if (x < -180) {
            v = (int(x / -180) + 1) / 2;
            x = x + v * 360;
        } else if (x > 180) {
            v = (int(x / 180) + 1) / 2;
            x = x - v * 360;
        }
        return x;
    }
}
}

class StaticEnforcer {


    function StaticEnforcer() {
        super();
    }
}
</file>

<file path="src/svera/display/Loader/LoaderProxy.as">
package svera.display.Loader {
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.net.URLRequest;
import flash.system.LoaderContext;

import svera.display.LoaderInfo.LoaderInfoProxy;

public class LoaderProxy extends Sprite {


    public function LoaderProxy() {
        super();
    }

    public function get content():DisplayObject {
        return null;
    }

    public function get contentLoaderInfo():LoaderInfoProxy {
        return null;
    }

    public function load(request:URLRequest, context:LoaderContext = null):void {
    }

    public function unload():void {
    }
}
}
</file>

<file path="src/svera/display/Loader/LoaderProxyConcrete.as">
package svera.display.Loader {
import flash.display.DisplayObject;
import flash.display.Loader;
import flash.net.URLRequest;
import flash.system.LoaderContext;

import svera.display.LoaderInfo.LoaderInfoProxy;
import svera.display.LoaderInfo.LoaderInfoProxyConcrete;

public class LoaderProxyConcrete extends LoaderProxy {


    private var loader:Loader;

    private var _contentLoaderInfo:LoaderInfoProxy;

    public function LoaderProxyConcrete() {
        this.loader = addChild(new Loader()) as Loader;
        super();
    }

    override public function get content():DisplayObject {
        return this.loader.content;
    }

    override public function get contentLoaderInfo():LoaderInfoProxy {
        if (this._contentLoaderInfo == null) {
            this._contentLoaderInfo = new LoaderInfoProxyConcrete();
            this._contentLoaderInfo.loaderInfo = this.loader.contentLoaderInfo;
        }
        return this._contentLoaderInfo;
    }

    override public function load(request:URLRequest, context:LoaderContext = null):void {
        this.loader.load(request, context);
    }

    override public function unload():void {
        this.loader.unload();
    }
}
}
</file>

<file path="src/svera/display/LoaderInfo/LoaderInfoProxy.as">
package svera.display.LoaderInfo {
import flash.display.LoaderInfo;
import flash.events.IEventDispatcher;

public interface LoaderInfoProxy extends IEventDispatcher {


    function set loaderInfo(param1:LoaderInfo):void;
}
}
</file>

<file path="src/svera/display/LoaderInfo/LoaderInfoProxyConcrete.as">
package svera.display.LoaderInfo {
import flash.display.LoaderInfo;
import flash.events.Event;
import flash.events.EventDispatcher;

public class LoaderInfoProxyConcrete extends EventDispatcher implements LoaderInfoProxy {


    private var _loaderInfo:LoaderInfo;

    public function LoaderInfoProxyConcrete() {
        super();
    }

    override public function toString():String {
        return this._loaderInfo.toString();
    }

    override public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false):void {
        this._loaderInfo.addEventListener(type, listener, useCapture, priority, useWeakReference);
    }

    override public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void {
        this._loaderInfo.removeEventListener(type, listener, useCapture);
    }

    override public function dispatchEvent(event:Event):Boolean {
        return this._loaderInfo.dispatchEvent(event);
    }

    override public function hasEventListener(type:String):Boolean {
        return this._loaderInfo.hasEventListener(type);
    }

    override public function willTrigger(type:String):Boolean {
        return this._loaderInfo.willTrigger(type);
    }

    public function set loaderInfo(value:LoaderInfo):void {
        this._loaderInfo = value;
    }
}
}
</file>

<file path="src/svera/lib/json/SoftwareJsonParser.as">
package svera.lib.json {
import com.adobe.serialization.json.JSON;

public class SoftwareJsonParser implements JsonParser {


    public function SoftwareJsonParser() {
        super();
    }

    public function stringify(value:Object):String {
        return com.adobe.serialization.json.JSON.encode(value);
    }

    public function parse(text:String):Object {
        return com.adobe.serialization.json.JSON.decode(text);
    }
}
}
</file>

<file path="src/svera/lib/loopedprocs/LoopedProcess.as">
package svera.lib.loopedprocs {
import flash.utils.Dictionary;
import flash.utils.getTimer;

public class LoopedProcess {

    private static var maxId:uint;

    private static var loopProcs:Dictionary = new Dictionary();


    public var id:uint;

    public var paused:Boolean;

    public var interval:uint;

    public var lastRun:int;

    public function LoopedProcess(runInterval:uint) {
        super();
        this.interval = runInterval;
    }

    public static function addProcess(proc:LoopedProcess):uint {
        if (loopProcs[proc.id] == proc) {
            return proc.id;
        }
        var _loc2_:* = ++maxId;
        loopProcs[_loc2_] = proc;
        proc.lastRun = getTimer();
        return maxId;
    }

    public static function runProcesses(curTime:int):void {
        var proc:LoopedProcess = null;
        var timeSinceRun:int = 0;
        for each(proc in loopProcs) {
            if (!proc.paused) {
                timeSinceRun = curTime - proc.lastRun;
                if (timeSinceRun >= proc.interval) {
                    proc.lastRun = curTime;
                    proc.run();
                }
            }
        }
    }

    public static function destroyProcess(proc:LoopedProcess):void {
        delete loopProcs[proc.id];
        proc.onDestroyed();
    }

    public static function destroyAll():void {
        var proc:LoopedProcess = null;
        for each(proc in loopProcs) {
            proc.destroy();
        }
        loopProcs = new Dictionary();
    }

    public final function add():void {
        addProcess(this);
    }

    public final function destroy():void {
        destroyProcess(this);
    }

    protected function run():void {
    }

    protected function onDestroyed():void {
    }
}
}
</file>

<file path="src/svera/lib/net/api/MessageMapping.as">
package svera.lib.net.api {
import svera.lib.net.impl.MessagePool;

public interface MessageMapping {


    function setID(param1:int):MessageMapping;

    function toMessage(param1:Class):MessageMapping;

    function toHandler(param1:Class):MessageMapping;

    function toMethod(param1:Function):MessageMapping;

    function setPopulation(param1:int):MessageMapping;

    function makePool():MessagePool;
}
}
</file>

<file path="src/svera/lib/net/api/MessageProvider.as">
package svera.lib.net.api {
import svera.lib.net.impl.Message;

public interface MessageProvider {


    function require(param1:int):Message;
}
}
</file>

<file path="src/svera/lib/net/impl/ClassHandlerProxy.as">
package svera.lib.net.impl {
import org.swiftsuspenders.Injector;

import svera.lib.net.api.MessageHandlerProxy;

public class ClassHandlerProxy implements MessageHandlerProxy {


    private var injector:Injector;

    private var handlerType:Class;

    private var handler:Object;

    public function ClassHandlerProxy() {
        super();
    }

    public function setType(handlerType:Class):ClassHandlerProxy {
        this.handlerType = handlerType;
        return this;
    }

    public function setInjector(injector:Injector):ClassHandlerProxy {
        this.injector = injector;
        return this;
    }

    public function getMethod():Function {
        return Boolean(this.handler) ? this.handler.execute : this.makeHandlerAndReturnExecute();
    }

    private function makeHandlerAndReturnExecute():Function {
        if (!this.handlerType) {
            return null;
        }
        this.handler = this.injector.getInstance(this.handlerType);
        return this.handler.execute;
    }
}
}
</file>

<file path="src/svera/lib/net/impl/Message.as">
package svera.lib.net.impl {
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

public class Message {


    public var pool:MessagePool;

    public var prev:Message;

    public var next:Message;

    private var isCallback:Boolean;

    public var id:uint;

    public var callback:Function;

    public function Message(id:uint, callback:Function = null) {
        super();
        this.id = id;
        this.isCallback = callback != null;
        this.callback = callback;
    }

    public function parseFromInput(data:IDataInput):void {
    }

    public function writeToOutput(data:IDataOutput):void {
    }

    public function toString():String {
        return this.formatToString("MESSAGE", "id");
    }

    protected function formatToString(name:String, ...args):String {
        var str:String = "[" + name;
        for (var i:int = 0; i < args.length; i++) {
            str = str + (" " + args[i] + "=\"" + this[args[i]] + "\"");
        }
        str = str + "]";
        return str;
    }

    public function consume():void {
        this.isCallback && this.callback(this);
        this.prev = null;
        this.next = null;
        this.pool.append(this);
    }
}
}
</file>

<file path="src/svera/lib/net/impl/MessageCenterMapping.as">
package svera.lib.net.impl {
import org.swiftsuspenders.Injector;

import svera.lib.net.api.MessageHandlerProxy;
import svera.lib.net.api.MessageMapping;

public class MessageCenterMapping implements MessageMapping {


    private const nullHandler:NullHandlerProxy = new NullHandlerProxy();

    private var id:int;

    private var injector:Injector;

    private var messageType:Class;

    private var population:int = 1;

    private var handler:MessageHandlerProxy;

    public function MessageCenterMapping() {
        this.handler = this.nullHandler;
        super();
    }

    public function setID(id:int):MessageMapping {
        this.id = id;
        return this;
    }

    public function setInjector(injector:Injector):MessageCenterMapping {
        this.injector = injector;
        return this;
    }

    public function toMessage(messageType:Class):MessageMapping {
        this.messageType = messageType;
        return this;
    }

    public function toHandler(handlerType:Class):MessageMapping {
        this.handler = new ClassHandlerProxy().setType(handlerType).setInjector(this.injector);
        return this;
    }

    public function toMethod(method:Function):MessageMapping {
        this.handler = new MethodHandlerProxy().setMethod(method);
        return this;
    }

    public function setPopulation(population:int):MessageMapping {
        this.population = population;
        return this;
    }

    public function makePool():MessagePool {
        var pool:MessagePool = new MessagePool(this.id, this.messageType, this.handler.getMethod());
        pool.populate(this.population);
        return pool;
    }
}
}

import svera.lib.net.api.MessageHandlerProxy;

class NullHandlerProxy implements MessageHandlerProxy {


    function NullHandlerProxy() {
        super();
    }

    public function getMethod():Function {
        return null;
    }
}
</file>

<file path="src/svera/lib/net/impl/MethodHandlerProxy.as">
package svera.lib.net.impl {
import svera.lib.net.api.MessageHandlerProxy;

public class MethodHandlerProxy implements MessageHandlerProxy {


    private var method:Function;

    public function MethodHandlerProxy() {
        super();
    }

    public function setMethod(method:Function):MethodHandlerProxy {
        this.method = method;
        return this;
    }

    public function getMethod():Function {
        return this.method;
    }
}
}
</file>

<file path="src/svera/lib/net/impl/SocketServer.as">
package svera.lib.net.impl {
import flash.events.Event;
import flash.events.IOErrorEvent;
import flash.events.ProgressEvent;
import flash.events.SecurityErrorEvent;
import flash.net.Socket;
import flash.utils.ByteArray;

import org.osflash.signals.Signal;

import svera.lib.net.api.MessageProvider;

public class SocketServer {
    [Inject]
    public var messages:MessageProvider;

    [Inject]
    public var socket:Socket;

    public const connected:Signal = new Signal();
    public const closed:Signal = new Signal();
    public const error:Signal = new Signal(String);
    private const unsentPlaceholder:Message = new Message(0);
    private const data:ByteArray = new ByteArray();

    private var head:Message;
    private var tail:Message;
    private var messageLen:int = -1;

    public function SocketServer() {
        this.head = this.unsentPlaceholder;
        this.tail = this.unsentPlaceholder;
        super();
    }

    public function connect(server:String, port:int):void {
        this.addListeners();
        this.messageLen = -1;
        this.socket.connect(server, port);
    }

    private function addListeners():void {
        this.socket.addEventListener(Event.CONNECT, this.onConnect);
        this.socket.addEventListener(Event.CLOSE, this.onClose);
        this.socket.addEventListener(ProgressEvent.SOCKET_DATA, this.onSocketData);
        this.socket.addEventListener(IOErrorEvent.IO_ERROR, this.onIOError);
        this.socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onSecurityError);
    }

    public function disconnect():void {
        try {
            this.socket.close();
        } catch (error:Error) {
        }
        this.removeListeners();
        this.closed.dispatch();
    }

    private function removeListeners():void {
        this.socket.removeEventListener(Event.CONNECT, this.onConnect);
        this.socket.removeEventListener(Event.CLOSE, this.onClose);
        this.socket.removeEventListener(ProgressEvent.SOCKET_DATA, this.onSocketData);
        this.socket.removeEventListener(IOErrorEvent.IO_ERROR, this.onIOError);
        this.socket.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onSecurityError);
    }

    public function sendMessage(msg:Message):void {
        this.tail.next = msg;
        this.tail = msg;
        this.socket.connected && this.sendPendingMessages();
    }

    private function sendPendingMessages():void {
        var temp:Message = this.head.next;
        var msg:Message = temp;

        if (!this.socket.connected) {
            return;
        }

        var i:int = 0;
        while (msg) {
            this.data.position = 0;
            this.data.length = 0;
            msg.writeToOutput(this.data);
            this.data.position = 0;
            this.socket.writeInt(this.data.bytesAvailable + 5);
            this.socket.writeByte(msg.id);
            this.socket.writeBytes(this.data);
            temp = msg;
            msg = msg.next;
            temp.consume();
            i++;
        }
        if (i > 0) {
            this.socket.flush();
        }
        this.unsentPlaceholder.next = null;
        this.unsentPlaceholder.prev = null;
        this.head = (this.tail = this.unsentPlaceholder);
    }

    private function onConnect(event:Event):void {
        this.sendPendingMessages();
        this.connected.dispatch();
    }

    private function onClose(event:Event):void {
        this.closed.dispatch();
    }

    private function onIOError(event:IOErrorEvent):void {
        var message:String = this.parseString("Socket-Server IO Error: {0}", [event.text]);
        this.error.dispatch(message);
        this.closed.dispatch();
    }

    private function onSecurityError(event:SecurityErrorEvent):void {
        var message:String = this.parseString("Socket-Server Security Error: {0}", [event.text]);
        this.error.dispatch(message);
        this.closed.dispatch();
    }

    private function onSocketData(_:ProgressEvent = null):void {
        var messageId:uint;
        var message:Message;
        var errorMessage:String;
        while (true) {
            if (this.socket == null || !this.socket.connected) break;
            if (this.messageLen == -1) {
                if (this.socket.bytesAvailable < 4) break;
                try {
                    this.messageLen = this.socket.readInt();
                } catch (e:Error) {
                    errorMessage = parseString("Socket-Server Data Error: {0}: {1}", [e.name, e.message]);
                    error.dispatch(errorMessage);
                    messageLen = -1;
                    return;
                }
            }
            if (this.socket.bytesAvailable < this.messageLen - 4) break;
            messageId = this.socket.readUnsignedByte();
            message = this.messages.require(messageId);
            data.position = 0;
            data.length = 0;
            if (this.messageLen - 5 > 0) {
                this.socket.readBytes(data, 0, this.messageLen - 5);
            }
            data.position = 0;
            this.messageLen = -1;
            if (message == null) {
                this.logErrorAndClose("Socket-Server Protocol Error: Unknown message");
                return;
            }
            try {
                message.parseFromInput(data);
            } catch (error:Error) {
                logErrorAndClose("Socket-Server Protocol Error: {0}", [error.toString()]);
                return;
            }
            message.consume();
        }
    }

    private function logErrorAndClose(message:String, arguments:Array = null):void {
        this.error.dispatch(this.parseString(message, arguments));
        this.disconnect();
    }

    private function parseString(error:String, arguments:Array):String {
        var count:int = arguments.length;
        for (var i:int = 0; i < count; i++) {
            error = error.replace("{" + i + "}", arguments[i]);
        }
        return error;
    }
}
}
</file>

<file path="src/svera/lib/resizing/signals/Resize.as">
package svera.lib.resizing.signals {
import flash.geom.Rectangle;

import org.osflash.signals.Signal;

public class Resize extends Signal {


    public function Resize() {
        super(Rectangle);
    }
}
}
</file>

<file path="src/svera/lib/resizing/view/Resizable.as">
package svera.lib.resizing.view {
import flash.geom.Rectangle;

public interface Resizable {


    function resize(param1:Rectangle):void;
}
}
</file>

<file path="src/svera/lib/resizing/view/ResizableMediator.as">
package svera.lib.resizing.view {
import flash.display.DisplayObject;
import flash.display.Stage;
import flash.geom.Rectangle;

import svera.lib.framework.Mediator;
import svera.lib.resizing.signals.Resize;

public class ResizableMediator extends Mediator {

    [Inject]
    public var resize:Resize;

    // Type-safe view accessor
    private function get resizableView():Resizable {
        return view as Resizable;
    }

    override protected function onInitialize():void {
        var stage:Stage = (view as DisplayObject).stage;
        var rectangle:Rectangle = new Rectangle(0, 0, stage.stageWidth, stage.stageHeight);
        resize.add(onResize);
        resizableView.resize(rectangle);
    }

    override protected function onDestroy():void {
        resize.remove(onResize);
    }

    private function onResize(rectangle:Rectangle):void {
        resizableView.resize(rectangle);
    }
}
}
</file>

<file path="src/svera/lib/signals/DeferredQueueSignal.as">
package svera.lib.signals {
import org.osflash.signals.ISlot;
import org.osflash.signals.Signal;

public class DeferredQueueSignal extends Signal {


    private var data:Array;

    private var log:Boolean = true;

    public function DeferredQueueSignal(...valueClasses) {
        this.data = [];
        super(valueClasses);
    }

    override public function dispatch(...valueObjects):void {
        if (this.log) {
            this.data.push(valueObjects);
        }
        super.dispatch.apply(this, valueObjects);
    }

    override public function add(listener:Function):ISlot {
        var slot:ISlot = super.add(listener);
        while (this.data.length > 0) {
            listener.apply(this, this.data.shift());
        }
        this.log = false;
        return slot;
    }

    override public function addOnce(listener:Function):ISlot {
        var slot:ISlot = null;
        if (this.data.length > 0) {
            listener.apply(this, this.data.shift());
        } else {
            slot = super.addOnce(listener);
            this.log = false;
        }
        while (this.data.length > 0) {
            this.data.shift();
        }
        return slot;
    }

    public function getNumData():int {
        return this.data.length;
    }
}
}
</file>

<file path="src/svera/lib/tasks/BaseTask.as">
package svera.lib.tasks {
import flash.errors.IllegalOperationError;

import org.osflash.signals.Signal;

public class BaseTask implements Task {


    private var _started:TaskStartedSignal;

    private var _finished:TaskResultSignal;

    private var _lastly:TaskResultSignal;

    private var _isStarted:Boolean;

    private var _isFinished:Boolean;

    private var _isOK:Boolean;

    private var _error:String;

    public function BaseTask() {
        super();
    }

    public final function start():void {
        if (!this._isStarted) {
            this._isStarted = true;
            this._started && this._started.dispatch(this);
            this.startTask();
        }
    }

    public final function reset():void {
        if (this._isStarted) {
            this._isStarted = false;
            if (!this._isFinished) {
                throw new IllegalOperationError("Unable to Task.reset() when a task is ongoing");
            }
        }
        this._started && this._started.removeAll();
        this._finished && this._finished.removeAll();
        this._lastly && this._lastly.removeAll();
        this.onReset();
    }

    protected function startTask():void {
    }

    protected function onReset():void {
    }

    protected final function completeTask(isOK:Boolean, error:String = ""):void {
        this._isOK = isOK;
        this._error = error;
        this._isFinished = true;
        this._finished && this._finished.dispatch(this, isOK, error);
        this._lastly && this._lastly.dispatch(this, isOK, error);
    }

    public final function get started():Signal {
        return this._started = this._started || new TaskStartedSignal();
    }

    public final function get finished():TaskResultSignal {
        return this._finished = this._finished || new TaskResultSignal();
    }

    public final function get lastly():TaskResultSignal {
        return this._lastly = this._lastly || new TaskResultSignal();
    }

    public function get isStarted():Boolean {
        return this._isStarted;
    }

    public function get isFinished():Boolean {
        return this._isFinished;
    }

    public function get isOK():Boolean {
        return this._isOK;
    }

    public function get error():String {
        return this._error;
    }
}
}
</file>

<file path="src/svera/lib/tasks/DispatchSignalTask.as">
package svera.lib.tasks {
import org.osflash.signals.Signal;

public class DispatchSignalTask extends BaseTask {


    private var signal:Signal;

    private var params:Array;

    public function DispatchSignalTask(signal:Signal, ...params) {
        super();
        this.signal = signal;
        this.params = params;
    }

    override protected function startTask():void {
        this.signal.dispatch.apply(null, this.params);
        completeTask(true);
    }
}
}
</file>

<file path="src/svera/lib/tasks/Task.as">
package svera.lib.tasks {
import org.osflash.signals.Signal;

public interface Task {


    function start():void;

    function reset():void;

    function get started():Signal;

    function get finished():TaskResultSignal;

    function get lastly():TaskResultSignal;

    function get isStarted():Boolean;

    function get isFinished():Boolean;

    function get isOK():Boolean;

    function get error():String;
}
}
</file>

<file path="src/svera/lib/tasks/TaskResultSignal.as">
package svera.lib.tasks {
import org.osflash.signals.Signal;

public class TaskResultSignal extends Signal {


    public function TaskResultSignal() {
        super(BaseTask, Boolean, String);
    }
}
}
</file>

<file path="src/svera/lib/tasks/TaskStartedSignal.as">
package svera.lib.tasks {
import org.osflash.signals.Signal;

public class TaskStartedSignal extends Signal {


    public function TaskStartedSignal() {
        super(BaseTask);
    }
}
}
</file>

<file path="src/svera/lib/ui/api/Layout.as">
package svera.lib.ui.api {
import flash.display.DisplayObject;

public interface Layout {


    function getPadding():int;

    function setPadding(param1:int):void;

    function layout(param1:Vector.<DisplayObject>, param2:int = 0):void;
}
}
</file>

<file path="src/svera/lib/ui/api/List.as">
package svera.lib.ui.api {
import flash.display.DisplayObject;

public interface List {


    function addItem(param1:DisplayObject):void;

    function setItems(param1:Vector.<DisplayObject>):void;

    function getItemAt(param1:int):DisplayObject;

    function getItemCount():int;
}
}
</file>

<file path="src/svera/lib/ui/api/Scrollbar.as">
package svera.lib.ui.api {
import org.osflash.signals.Signal;

public interface Scrollbar {


    function get positionChanged():Signal;

    function setSize(param1:int, param2:int):void;

    function getBarSize():int;

    function getGrooveSize():int;

    function getPosition():Number;

    function setPosition(param1:Number):void;
}
}
</file>

<file path="src/svera/lib/ui/GroupMappedSignal.as">
package svera.lib.ui {
import flash.events.Event;
import flash.events.IEventDispatcher;
import flash.utils.Dictionary;

import org.osflash.signals.Signal;

public class GroupMappedSignal extends Signal {


    private var eventType:String;

    private var mappedTargets:Dictionary;

    public function GroupMappedSignal(eventType:String, ...valueClasses) {
        this.eventType = eventType;
        this.mappedTargets = new Dictionary(true);
        super(valueClasses);
    }

    public function map(target:IEventDispatcher, value:*):void {
        this.mappedTargets[target] = value;
        target.addEventListener(this.eventType, this.onTarget, false, 0, true);
    }

    private function onTarget(event:Event):void {
        dispatch(this.mappedTargets[event.target]);
    }
}
}
</file>

<file path="src/svera/lib/ui/impl/HorizontalLayout.as">
package svera.lib.ui.impl {
import flash.display.DisplayObject;

import svera.lib.ui.api.Layout;

public class HorizontalLayout implements Layout {


    private var padding:int = 0;

    public function HorizontalLayout() {
        super();
    }

    public function getPadding():int {
        return this.padding;
    }

    public function setPadding(value:int):void {
        this.padding = value;
    }

    public function layout(elements:Vector.<DisplayObject>, offset:int = 0):void {
        var element:DisplayObject = null;
        var x:int = offset;
        var length:int = elements.length;
        for (var i:int = 0; i < length; i++) {
            element = elements[i];
            element.x = x;
            x = x + (element.width + this.padding);
        }
    }
}
}
</file>

<file path="src/svera/lib/ui/impl/LayoutList.as">
package svera.lib.ui.impl {
import flash.display.DisplayObject;
import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.geom.Rectangle;

import org.osflash.signals.Signal;

import svera.lib.ui.api.Layout;
import svera.lib.ui.api.List;
import svera.lib.ui.api.Size;

public class LayoutList extends Sprite implements List {

    private static const NULL_LAYOUT:Layout = new NullLayout();

    private static const ZERO_SIZE:Size = new Size(0, 0);


    public const itemsChanged:Signal = new Signal();

    private const list:Vector.<DisplayObject> = new Vector.<DisplayObject>(0);

    private const container:Sprite = new Sprite();

    private const containerMask:Shape = new Shape();

    private var layout:Layout;

    private var size:Size;

    private var offset:int = 0;

    public function LayoutList() {
        this.layout = NULL_LAYOUT;
        this.size = ZERO_SIZE;
        super();
        addChild(this.container);
        addChild(this.containerMask);
    }

    public function getLayout():Layout {
        return this.layout;
    }

    public function setLayout(layout:Layout):void {
        this.layout = layout || NULL_LAYOUT;
        layout.layout(this.list, -this.offset);
    }

    public function getSize():Size {
        return this.size;
    }

    public function setSize(size:Size):void {
        this.size = size || ZERO_SIZE;
        this.applySizeToMask();
    }

    public function getSizeOfItems():Size {
        var rect:Rectangle = this.container.getRect(this.container);
        return new Size(rect.width, rect.height);
    }

    private function applySizeToMask():void {
        var g:Graphics = this.containerMask.graphics;
        g.clear();
        g.beginFill(10027263);
        g.drawRect(0, 0, this.size.width, this.size.height);
        g.endFill();
        this.container.mask = this.containerMask;
    }

    public function addItem(item:DisplayObject):void {
        this.addToListAndContainer(item);
        this.updateLayout();
        this.itemsChanged.dispatch();
    }

    public function getItemAt(index:int):DisplayObject {
        return this.list[index];
    }

    public function setItems(items:Vector.<DisplayObject>):void {
        this.clearList();
        this.addItemsToListAndContainer(items);
        this.offset = 0;
        this.updateLayout();
        this.itemsChanged.dispatch();
    }

    public function getItemCount():int {
        return this.list.length;
    }

    private function clearList():void {
        var i:int = this.list.length;
        while (i--) {
            this.container.removeChild(this.list[i]);
        }
        this.list.length = 0;
    }

    private function addItemsToListAndContainer(items:Vector.<DisplayObject>):void {
        var item:DisplayObject = null;
        for each(item in items) {
            this.addToListAndContainer(item);
        }
    }

    private function addToListAndContainer(item:DisplayObject):void {
        this.list.push(item);
        this.container.addChild(item);
    }

    public function setOffset(value:int):void {
        this.offset = value;
        this.updateLayout();
    }

    public function getOffset():int {
        return this.offset;
    }

    public function updateLayout():void {
        this.layout.layout(this.list, -this.offset);
    }
}
}
</file>

<file path="src/svera/lib/ui/impl/NullLayout.as">
package svera.lib.ui.impl {
import flash.display.DisplayObject;

import svera.lib.ui.api.Layout;

public class NullLayout implements Layout {


    public function NullLayout() {
        super();
    }

    public function getPadding():int {
        return 0;
    }

    public function setPadding(value:int):void {
    }

    public function layout(elements:Vector.<DisplayObject>, offset:int = 0):void {
    }
}
}
</file>

<file path="src/svera/lib/ui/impl/VerticalLayout.as">
package svera.lib.ui.impl {
import flash.display.DisplayObject;

import svera.lib.ui.api.Layout;

public class VerticalLayout implements Layout {


    private var padding:int = 0;

    public function VerticalLayout() {
        super();
    }

    public function getPadding():int {
        return this.padding;
    }

    public function setPadding(value:int):void {
        this.padding = value;
    }

    public function layout(elements:Vector.<DisplayObject>, offset:int = 0):void {
        var element:DisplayObject = null;
        var y:int = offset;
        var length:int = elements.length;
        for (var i:int = 0; i < length; i++) {
            element = elements[i];
            element.y = y;
            y = y + (element.height + this.padding);
        }
    }
}
}
</file>

<file path="src/svera/lib/util/StageLifecycleUtil.as">
package svera.lib.util {
import flash.display.DisplayObject;
import flash.events.Event;

import org.osflash.signals.Signal;

public class StageLifecycleUtil {


    private var target:DisplayObject;

    private var _addedToStage:Signal;

    private var _removedFromStage:Signal;

    public function StageLifecycleUtil(target:DisplayObject) {
        super();
        this.target = target;
        target.addEventListener(Event.ADDED_TO_STAGE, this.handleAddedToStage);
    }

    private function handleAddedToStage(event:Event):void {
        this.target.removeEventListener(Event.ADDED_TO_STAGE, this.handleAddedToStage);
        this.target.addEventListener(Event.REMOVED_FROM_STAGE, this.handleRemovedFromStage);
        this._addedToStage && this._addedToStage.dispatch();
    }

    private function handleRemovedFromStage(event:Event):void {
        this.target.addEventListener(Event.ADDED_TO_STAGE, this.handleAddedToStage);
        this.target.removeEventListener(Event.REMOVED_FROM_STAGE, this.handleRemovedFromStage);
        this._removedFromStage && this._removedFromStage.dispatch();
    }

    public function get addedToStage():Signal {
        return this._addedToStage = this._addedToStage || new Signal();
    }

    public function get removedFromStage():Signal {
        return this._removedFromStage = this._removedFromStage || new Signal();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/control/IsAccountRegisteredGuard.as">
package svera.untiered.account.core.control {
import svera.lib.framework.IGuard;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.view.RegisterPromptDialog;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class IsAccountRegisteredGuard implements IGuard {

    private static const REGISTER_TO_PURCHASE:String = "In order to make purchase requests you must be a registered user.";


    [Inject]
    public var account:Account;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function IsAccountRegisteredGuard() {
        super();
    }

    public function approve():Boolean {
        var isApproved:Boolean = this.account.isRegistered();
        isApproved || this.enterRegisterFlow();
        return isApproved;
    }

    private function enterRegisterFlow():void {
        this.openDialog.dispatch(new RegisterPromptDialog(REGISTER_TO_PURCHASE));
    }
}
}
</file>

<file path="src/svera/untiered/account/core/services/ChangePasswordTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface ChangePasswordTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/LinkAccountsTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface LinkAccountsTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/LoadAccountTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface LoadAccountTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/LoadApiTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface LoadApiTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/LoginTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface LoginTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/RegisterAccountTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface RegisterAccountTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/RelayLoginTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface RelayLoginTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/services/SendPasswordReminderTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.Task;

public interface SendPasswordReminderTask extends Task {

}
}
</file>

<file path="src/svera/untiered/account/core/signals/CharListDataSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

public class CharListDataSignal extends Signal {


    public function CharListDataSignal() {
        super(XML);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/LinkWebAccountSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

import svera.untiered.account.web.model.AccountData;

public class LinkWebAccountSignal extends Signal {


    public function LinkWebAccountSignal() {
        super(AccountData);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/LoginSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

import svera.untiered.account.web.model.AccountData;

public class LoginSignal extends Signal {


    public function LoginSignal() {
        super(AccountData);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/LogoutSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

public class LogoutSignal extends Signal {


    public function LogoutSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/OpenAccountInfoSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

public class OpenAccountInfoSignal extends Signal {


    public function OpenAccountInfoSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/RegisterSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

import svera.untiered.account.web.model.AccountData;

public class RegisterSignal extends Signal {


    public function RegisterSignal() {
        super(AccountData);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/SendPasswordReminderSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

public class SendPasswordReminderSignal extends Signal {


    public function SendPasswordReminderSignal() {
        super(String);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/UpdateAccountInfoSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

public class UpdateAccountInfoSignal extends Signal {


    public function UpdateAccountInfoSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/view/AccountInfoMediator.as">
package svera.untiered.account.core.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.signals.UpdateAccountInfoSignal;

public class AccountInfoMediator extends Mediator {


    [Inject]
    public var account:Account;

    [Inject]
    public var view:AccountInfoView;

    [Inject]
    public var update:UpdateAccountInfoSignal;

    public function AccountInfoMediator() {
        super();
    }

    override public function initialize():void {
        this.view.setInfo(this.account.getUserName(), this.account.isRegistered());
        this.update.add(this.updateLogin);
    }

    override public function destroy():void {
        this.update.remove(this.updateLogin);
    }

    private function updateLogin():void {
        this.view.setInfo(this.account.getUserName(), this.account.isRegistered());
    }
}
}
</file>

<file path="src/svera/untiered/account/core/view/BuyingDialog.as">
package svera.untiered.account.core.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

public class BuyingDialog extends Dialog {


    public function BuyingDialog() {
        super("Buying Character Slot...", null, null, null);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/view/RegisterPromptDialogMediator.as">
package svera.untiered.account.core.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.signals.OpenAccountInfoSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class RegisterPromptDialogMediator extends Mediator {


    [Inject]
    public var view:RegisterPromptDialog;

    [Inject]
    public var openAccountManagement:OpenAccountInfoSignal;

    [Inject]
    public var close:CloseDialogsSignal;

    public function RegisterPromptDialogMediator() {
        super();
    }

    override public function initialize():void {
        this.view.cancel.add(this.onCancel);
        this.view.register.add(this.onRegister);
    }

    override public function destroy():void {
        this.view.cancel.remove(this.onCancel);
        this.view.register.remove(this.onRegister);
    }

    private function onRegister():void {
        this.onCancel();
        this.openAccountManagement.dispatch();
    }

    private function onCancel():void {
        this.close.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/view/RegisterWebAccountDialog.as">
package svera.untiered.account.core.view {
import com.company.assembleegameclient.account.ui.CheckBoxField;
import com.company.assembleegameclient.account.ui.Frame;
import com.company.assembleegameclient.account.ui.TextInputField;
import com.company.assembleegameclient.parameters.Parameters;

import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.account.web.model.AccountData;

public class RegisterWebAccountDialog extends Frame {


    public var register:Signal;

    public var cancel:Signal;

    private var emailInput:TextInputField;

    private var passwordInput:TextInputField;

    private var retypePasswordInput:TextInputField;

    private var checkbox:CheckBoxField;

    public function RegisterWebAccountDialog() {
        this.register = new Signal(AccountData);
        this.cancel = new Signal();
        super("Register a web account in order to play anywhere", "Cancel", "Register");
        this.emailInput = new TextInputField("Email", false, "");
        addTextInputField(this.emailInput);
        this.passwordInput = new TextInputField("Password", true, "");
        addTextInputField(this.passwordInput);
        this.retypePasswordInput = new TextInputField("Retype Password", true, "");
        addTextInputField(this.retypePasswordInput);
        this.checkbox = new CheckBoxField("I agree to the <font color=\"#7777EE\"><a href=\"" + Parameters.TERMS_OF_USE_URL + "\" target=\"_blank\">Terms of Use</a></font>.", false, "");
        addCheckBox(this.checkbox);
        leftButton_.addEventListener(MouseEvent.CLICK, this.onCancel);
        rightButton_.addEventListener(MouseEvent.CLICK, this.onRegister);
    }

    private function onCancel(event:MouseEvent):void {
        this.cancel.dispatch();
    }

    private function onRegister(event:MouseEvent):void {
        var data:AccountData = null;
        if (this.isEmailValid() && this.isPasswordValid() && this.isPasswordVerified() && this.isCheckboxChecked()) {
            data = new AccountData();
            data.username = this.emailInput.text();
            data.password = this.passwordInput.text();
            this.register.dispatch(data);
        }
    }

    private function isCheckboxChecked():Boolean {
        var isChecked:Boolean = this.checkbox.isChecked();
        if (!isChecked) {
            this.checkbox.setError("Must agree to register");
        }
        return isChecked;
    }

    private function isEmailValid():Boolean {
        var isValid:Boolean = EmailValidator.isValidEmail(this.emailInput.text());
        if (!isValid) {
            this.emailInput.setError("Not a valid email address");
        }
        return isValid;
    }

    private function isPasswordValid():Boolean {
        var isValid:Boolean = this.passwordInput.text().length >= 5;
        if (!isValid) {
            this.passwordInput.setError("Password too short");
        }
        return isValid;
    }

    private function isPasswordVerified():Boolean {
        var isValid:Boolean = this.passwordInput.text() == this.retypePasswordInput.text();
        if (!isValid) {
            this.retypePasswordInput.setError("Password does not match");
        }
        return isValid;
    }

    public function showError(error:String):void {
        this.emailInput.setError(error);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebChangePasswordCommand.as">
package svera.untiered.account.web.commands {
import svera.lib.framework.ICommand;
import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.account.core.services.ChangePasswordTask;
import svera.untiered.account.web.view.WebAccountDetailDialog;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebChangePasswordCommand implements ICommand {


    [Inject]
    public var task:ChangePasswordTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var close:CloseDialogsSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var loginError:TaskErrorSignal;

    public function WebChangePasswordCommand() {
        super();
    }

    public function execute():void {
        var branch:BranchingTask = new BranchingTask(this.task, this.makeSuccess(), this.makeFailure());
        this.monitor.add(branch);
        branch.start();
    }

    private function makeSuccess():Task {
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(new DispatchSignalTask(this.openDialog, new WebAccountDetailDialog()));
        return sequence;
    }

    private function makeFailure():Task {
        return new DispatchSignalTask(this.loginError, this.task);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebLoginCommand.as">
package svera.untiered.account.web.commands {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import flash.display.Sprite;

import svera.lib.framework.ICommand;

import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.account.core.services.LoginTask;
import svera.untiered.account.core.signals.UpdateAccountInfoSignal;
import svera.untiered.account.web.model.AccountData;
import svera.untiered.account.web.view.WebAccountDetailDialog;
import svera.untiered.core.model.ScreenModel;
import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebLoginCommand implements ICommand {


    [Inject]
    public var data:AccountData;

    [Inject]
    public var task:LoginTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var loginError:TaskErrorSignal;

    [Inject]
    public var updateLogin:UpdateAccountInfoSignal;

    [Inject]
    public var invalidate:InvalidateDataSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var screenModel:ScreenModel;

    public function WebLoginCommand() {
        super();
    }

    public function execute():void {
        var branch:BranchingTask = new BranchingTask(this.task, this.makeSuccessTask(), this.makeFailureTask());
        this.monitor.add(branch);
        branch.start();
    }

    private function makeSuccessTask():TaskSequence {
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(new DispatchSignalTask(this.openDialog, new WebAccountDetailDialog()));
        sequence.add(new DispatchSignalTask(this.updateLogin));
        sequence.add(new DispatchSignalTask(this.invalidate));
        sequence.add(new DispatchSignalTask(this.setScreenWithValidData, this.getTargetScreen()));
        return sequence;
    }

    private function makeFailureTask():Task {
        return new DispatchSignalTask(this.loginError, this.task);
    }

    private function getTargetScreen():Sprite {
        var type:Class = this.screenModel.currentType;
        if (type == null || type == GameSprite) {
            type = CharacterSelectionAndNewsScreen;
        }
        return new type();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebLogoutCommand.as">
package svera.untiered.account.web.commands {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import flash.display.Sprite;

import svera.lib.framework.ICommand;

import svera.untiered.account.core.Account;
import svera.untiered.core.model.ScreenModel;
import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;

public class WebLogoutCommand implements ICommand {


    [Inject]
    public var account:Account;

    [Inject]
    public var invalidate:InvalidateDataSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var model:ScreenModel;

    public function WebLogoutCommand() {
        super();
    }

    public function execute():void {
        this.account.clear();
        this.invalidate.dispatch();
        this.setScreenWithValidData.dispatch(this.makeScreen());
    }

    private function makeScreen():Sprite {
        return new (this.model.currentType || CharacterSelectionAndNewsScreen)();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebOpenAccountInfoCommand.as">
package svera.untiered.account.web.commands {
import svera.lib.framework.ICommand;
import svera.untiered.account.core.Account;
import svera.untiered.account.web.view.WebAccountDetailDialog;
import svera.untiered.account.web.view.WebRegisterDialog;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebOpenAccountInfoCommand implements ICommand {


    [Inject]
    public var account:Account;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function WebOpenAccountInfoCommand() {
        super();
    }

    public function execute():void {
        if (this.account.isRegistered()) {
            this.openDialog.dispatch(new WebAccountDetailDialog());
        } else {
            this.openDialog.dispatch(new WebRegisterDialog());
        }
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebRegisterAccountCommand.as">
package svera.untiered.account.web.commands {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import flash.display.Sprite;

import svera.lib.framework.ICommand;

import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.account.core.services.RegisterAccountTask;
import svera.untiered.account.core.signals.UpdateAccountInfoSignal;
import svera.untiered.account.web.view.WebAccountDetailDialog;
import svera.untiered.core.model.ScreenModel;
import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebRegisterAccountCommand implements ICommand {


    [Inject]
    public var task:RegisterAccountTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var taskError:TaskErrorSignal;

    [Inject]
    public var updateAccount:UpdateAccountInfoSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var invalidate:InvalidateDataSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var screenModel:ScreenModel;

    public function WebRegisterAccountCommand() {
        super();
    }

    public function execute():void {
        var branch:BranchingTask = new BranchingTask(this.task, this.makeSuccess(), this.makeFailure());
        this.monitor.add(branch);
        branch.start();
    }

    private function makeSuccess():Task {
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(new DispatchSignalTask(this.updateAccount));
        sequence.add(new DispatchSignalTask(this.openDialog, new WebAccountDetailDialog()));
        sequence.add(new DispatchSignalTask(this.invalidate));
        sequence.add(new DispatchSignalTask(this.setScreenWithValidData, this.getTargetScreen()));
        return sequence;
    }

    private function makeFailure():DispatchSignalTask {
        return new DispatchSignalTask(this.taskError, this.task);
    }

    private function getTargetScreen():Sprite {
        var type:Class = this.screenModel.currentType;
        if (type == null || type == GameSprite) {
            type = CharacterSelectionAndNewsScreen;
        }
        return new type();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebSendPasswordReminderCommand.as">
package svera.untiered.account.web.commands {
import svera.lib.framework.ICommand;
import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.TaskGroup;
import svera.lib.tasks.TaskMonitor;
import svera.untiered.account.core.services.SendPasswordReminderTask;
import svera.untiered.account.web.view.WebLoginDialog;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebSendPasswordReminderCommand implements ICommand {


    [Inject]
    public var email:String;

    [Inject]
    public var task:SendPasswordReminderTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var taskError:TaskErrorSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function WebSendPasswordReminderCommand() {
        super();
    }

    public function execute():void {
        var success:TaskGroup = new TaskGroup();
        success.add(new DispatchSignalTask(this.openDialog, new WebLoginDialog()));
        var failure:TaskGroup = new TaskGroup();
        failure.add(new DispatchSignalTask(this.taskError, this.task));
        var branch:BranchingTask = new BranchingTask(this.task, success, failure);
        this.monitor.add(branch);
        branch.start();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/model/AccountData.as">
package svera.untiered.account.web.model {
public class AccountData {


    public var username:String;

    public var password:String;



    public var error:String;

    public function AccountData() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/services/WebChangePasswordTask.as">
package svera.untiered.account.web.services {
import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.account.core.services.ChangePasswordTask;
import svera.untiered.account.web.model.ChangePasswordData;
import svera.untiered.appengine.api.AppEngineClient;

public class WebChangePasswordTask extends BaseTask implements ChangePasswordTask {


    [Inject]
    public var account:Account;

    [Inject]
    public var data:ChangePasswordData;

    [Inject]
    public var client:AppEngineClient;

    public function WebChangePasswordTask() {
        super();
    }

    override protected function startTask():void {
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/account/changePassword", this.makeDataPacket());
    }

    private function onComplete(isOK:Boolean, data:*):void {
        isOK && this.onChangeDone();
        completeTask(isOK, data);
    }

    private function makeDataPacket():Object {
        var obj:Object = {};
        obj.username = this.account.getUsername();
        obj.password = this.data.currentPassword;
        obj.newPassword = this.data.newPassword;
        return obj;
    }

    private function onChangeDone():void {
        this.account.updateUser(this.account.getUsername(), this.data.newPassword);
        completeTask(true);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/services/WebLoadAccountTask.as">
package svera.untiered.account.web.services {
import flash.net.SharedObject;

import svera.lib.tasks.BaseTask;
import svera.lib.tasks.Task;
import svera.untiered.account.core.Account;
import svera.untiered.account.core.services.LoadAccountTask;
import svera.untiered.account.web.model.AccountData;
import svera.untiered.appengine.api.AppEngineClient;

public class WebLoadAccountTask extends BaseTask implements LoadAccountTask {


    [Inject]
    public var account:Account;

    [Inject]
    public var client:AppEngineClient;

    private var data:AccountData;

    public function WebLoadAccountTask() {
        super();
    }

    override protected function startTask():void {
        this.getAccountData();
        if (this.data.username) {
            this.runLoginTaskThenComplete();
        } else {
            this.setGuestPasswordAndComplete();
        }
    }

    private function getAccountData():void {
        var rotmg:SharedObject = null;
        this.data = new AccountData();
        try {
            rotmg = SharedObject.getLocal("OWRotMG", "/");
            rotmg.data["Username"] && (this.data.username = rotmg.data["Username"]);
            rotmg.data["Password"] && (this.data.password = rotmg.data["Password"]);
        } catch (error:Error) {
            data.username = null;
            data.password = null;
        }
    }

    private function runLoginTaskThenComplete():void {
        var login:WebLoginTask = new WebLoginTask();
        login.account = this.account;
        login.client = this.client;
        login.data = this.data;
        login.finished.addOnce(this.onLoginVerified);
        login.start();
    }

    private function onLoginVerified(task:Task, isOK:Boolean, error:String = ""):void {
        completeTask(true);
    }

    private function setGuestPasswordAndComplete():void {
        this.account.updateUser(null, null);
        completeTask(true);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/services/WebLoginTask.as">
package svera.untiered.account.web.services {
import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.account.core.services.LoginTask;
import svera.untiered.account.web.model.AccountData;
import svera.untiered.appengine.api.AppEngineClient;

public class WebLoginTask extends BaseTask implements LoginTask {


    [Inject]
    public var account:Account;

    [Inject]
    public var data:AccountData;

    [Inject]
    public var client:AppEngineClient;

    public function WebLoginTask() {
        super();
    }

    override protected function startTask():void {
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/account/verify", {
            "username": this.data.username,
            "password": this.data.password
        });
    }

    private function onComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.updateUser(data);
        }
        completeTask(isOK, data);
    }

    private function updateUser(response:String):void {
        this.account.updateUser(this.data.username, this.data.password);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/services/WebRegisterAccountTask.as">
package svera.untiered.account.web.services {
import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.account.core.services.RegisterAccountTask;
import svera.untiered.account.web.model.AccountData;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.core.model.PlayerModel;

public class WebRegisterAccountTask extends BaseTask implements RegisterAccountTask {


    [Inject]
    public var data:AccountData;

    [Inject]
    public var account:Account;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var client:AppEngineClient;

    public function WebRegisterAccountTask() {
        super();
    }

    override protected function startTask():void {
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/account/register", this.makeDataPacket());
    }

    private function makeDataPacket():Object {
        var obj:Object = {};
        obj.newUsername = this.data.username;
        obj.newPassword = this.data.password;
        return obj;
    }

    private function onComplete(isOK:Boolean, data:*):void {
        isOK && this.onRegisterDone();
        completeTask(isOK, data);
    }

    private function onRegisterDone():void {
        this.account.updateUser(this.data.username, this.data.password);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/services/WebSendPasswordReminderTask.as">
package svera.untiered.account.web.services {
import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.services.SendPasswordReminderTask;
import svera.untiered.appengine.api.AppEngineClient;

public class WebSendPasswordReminderTask extends BaseTask implements SendPasswordReminderTask {


    [Inject]
    public var email:String;

    [Inject]
    public var client:AppEngineClient;

    public function WebSendPasswordReminderTask() {
        super();
    }

    override protected function startTask():void {
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/account/forgotPassword", {"guid": this.email});
    }

    private function onComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.onForgotDone();
        } else {
            this.onForgotError(data);
        }
    }

    private function onForgotDone():void {
        completeTask(true);
    }

    private function onForgotError(error:String):void {
        completeTask(false, error);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/signals/WebChangePasswordSignal.as">
package svera.untiered.account.web.signals {
import org.osflash.signals.Signal;

import svera.untiered.account.web.model.ChangePasswordData;

public class WebChangePasswordSignal extends Signal {


    public function WebChangePasswordSignal() {
        super(ChangePasswordData);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/DateFieldValidator.as">
package svera.untiered.account.web.view {
import svera.untiered.account.ui.components.DateField;

public class DateFieldValidator {


    public function DateFieldValidator() {
        super();
    }

    public static function getPlayerAge(dateField:DateField):uint {
        var dob:Date = new Date(getBirthDate(dateField));
        var now:Date = new Date();
        var age:uint = Number(now.fullYear) - Number(dob.fullYear);
        if (dob.month > now.month || dob.month == now.month && dob.date > now.date) {
            age--;
        }
        return age;
    }

    public static function getBirthDate(dateField:DateField):uint {
        var birthDateString:String = dateField.months.text + "/" + dateField.days.text + "/" + dateField.years.text;
        return Date.parse(birthDateString);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/LabeledField.as">
package svera.untiered.account.web.view {
import com.company.ui.SimpleText;

import flash.filters.DropShadowFilter;

public class LabeledField extends FormField {


    public var nameText_:SimpleText;

    public var inputText_:SimpleText;

    public var isHighlighted:Boolean;

    public function LabeledField(name:String, isPassword:Boolean, w:uint = 238, h:uint = 30) {
        super();
        this.nameText_ = new SimpleText(18, TEXT_COLOR, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.text = name;
        this.nameText_.updateMetrics();
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.nameText_);
        this.inputText_ = new SimpleText(20, TEXT_COLOR, true, w, h);
        this.inputText_.y = 30;
        this.inputText_.x = 6;
        this.inputText_.border = false;
        this.inputText_.displayAsPassword = isPassword;
        this.inputText_.updateMetrics();
        addChild(this.inputText_);
        this.setErrorHighlight(false);
    }

    public function text():String {
        return this.inputText_.text;
    }

    override public function getHeight():Number {
        return 68;
    }

    public function setErrorHighlight(hasError:Boolean):void {
        this.isHighlighted = hasError;
        drawSimpleTextBackground(this.inputText_, 0, 0, hasError);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebAccountDetailDialog.as">
package svera.untiered.account.web.view {
import com.company.assembleegameclient.account.ui.Frame;
import com.company.assembleegameclient.ui.ClickableText;
import com.company.ui.SimpleText;

import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class WebAccountDetailDialog extends Frame {
    public var cancel:Signal;

    public var change:Signal;

    public var logout:Signal;

    private var loginText:SimpleText;

    private var emailText:SimpleText;

    private var changeText:ClickableText;

    private var logoutText:ClickableText;

    public function WebAccountDetailDialog() {
        super("Current account", "", "Continue");
        this.makeLoginText();
        this.makeEmailText();
        h_ = h_ + 88;
        this.cancel = new NativeMappedSignal(rightButton_, MouseEvent.CLICK);
        this.change = new Signal();
        this.logout = new Signal();
    }

    public function setUserInfo(email:String):void {
        this.emailText.text = email;
        this.makeChangeText();
        this.makeLogoutText();
    }

    private function makeChangeText():void {
        this.changeText = new ClickableText(12, false, "Click here to change password");
        this.changeText.addEventListener(MouseEvent.CLICK, this.onChange);
        addNavigationText(this.changeText);
    }

    private function onChange(event:MouseEvent):void {
        this.change.dispatch();
    }

    private function makeLogoutText():void {
        this.logoutText = new ClickableText(12, false, "Not you?  Click here");
        this.logoutText.addEventListener(MouseEvent.CLICK, this.onLogout);
        addNavigationText(this.logoutText);
    }

    private function onLogout(event:MouseEvent):void {
        this.logout.dispatch();
    }

    private function makeLoginText():void {
        this.loginText = new SimpleText(18, 11776947, false, 0, 0);
        this.loginText.setBold(true);
        this.loginText.text = "Currently logged in as:";
        this.loginText.updateMetrics();
        this.loginText.filters = [new DropShadowFilter(0, 0, 0)];
        this.loginText.y = h_ - 60;
        this.loginText.x = 17;
        addChild(this.loginText);
    }

    private function makeEmailText():void {
        this.emailText = new SimpleText(16, 11776947, false, 238, 30);
        this.emailText.updateMetrics();
        this.emailText.y = h_ - 30;
        this.emailText.x = 17;
        addChild(this.emailText);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebAccountDetailMediator.as">
package svera.untiered.account.web.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebAccountDetailMediator extends Mediator {


    [Inject]
    public var view:WebAccountDetailDialog;

    [Inject]
    public var account:Account;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var closeDialog:CloseDialogsSignal;

    public function WebAccountDetailMediator() {
        super();
    }

    override public function initialize():void {
        this.view.setUserInfo(this.account.getUserName());
        this.view.change.add(this.onChange);
        this.view.logout.add(this.onLogout);
        this.view.cancel.add(this.onDone);
    }

    override public function destroy():void {
        this.view.change.remove(this.onChange);
        this.view.logout.remove(this.onLogout);
        this.view.cancel.remove(this.onDone);
    }

    private function onChange():void {
        this.openDialog.dispatch(new WebChangePasswordDialog());
    }

    private function onLogout():void {
        this.account.clear();
        this.openDialog.dispatch(new WebLoginDialog());
    }

    private function onDone():void {
        this.closeDialog.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebAccountInfoMediator.as">
package svera.untiered.account.web.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.signals.LogoutSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebAccountInfoMediator extends Mediator {


    [Inject]
    public var view:WebAccountInfoView;

    [Inject]
    public var account:Account;

    [Inject]
    public var logout:LogoutSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function WebAccountInfoMediator() {
        super();
    }

    override public function initialize():void {
        this.view.login.add(this.onLoginToggle);
        this.view.register.add(this.onRegister);
    }

    override public function destroy():void {
        this.view.login.remove(this.onLoginToggle);
        this.view.register.remove(this.onRegister);
    }

    private function onRegister():void {
        this.openDialog.dispatch(new WebRegisterDialog());
    }

    private function onLoginToggle():void {
        if (this.account.isRegistered()) {
            this.onLogOut();
        } else {
            this.openDialog.dispatch(new WebLoginDialog());
        }
    }

    private function onLogOut():void {
        this.logout.dispatch();
        this.view.setInfo("", false);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebChangePasswordDialog.as">
package svera.untiered.account.web.view {
import com.company.assembleegameclient.account.ui.Frame;
import com.company.assembleegameclient.account.ui.TextInputField;

import flash.events.MouseEvent;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.account.web.model.ChangePasswordData;

public class WebChangePasswordDialog extends Frame {


    public var cancel:Signal;

    public var change:Signal;

    public var password_:TextInputField;

    public var newPassword_:TextInputField;

    public var retypeNewPassword_:TextInputField;

    public function WebChangePasswordDialog() {
        super("Change your password", "Cancel", "Submit");
        this.password_ = new TextInputField("Password", true, "");
        addTextInputField(this.password_);
        this.newPassword_ = new TextInputField("New Password", true, "");
        addTextInputField(this.newPassword_);
        this.retypeNewPassword_ = new TextInputField("Retype New Password", true, "");
        addTextInputField(this.retypeNewPassword_);
        this.cancel = new NativeMappedSignal(leftButton_, MouseEvent.CLICK);
        this.change = new NativeMappedSignal(rightButton_, MouseEvent.CLICK);
    }

    private function onChange(event:MouseEvent):void {
        var data:ChangePasswordData = null;
        if (this.isCurrentPasswordValid() && this.isNewPasswordValid() && this.isNewPasswordVerified()) {
            disable();
            data = new ChangePasswordData();
            data.currentPassword = this.password_.text();
            data.newPassword = this.newPassword_.text();
            this.change.dispatch(data);
        }
    }

    private function isCurrentPasswordValid():Boolean {
        var isValid:Boolean = this.password_.text().length >= 5;
        if (!isValid) {
            this.password_.setError("Incorrect password");
        }
        return isValid;
    }

    private function isNewPasswordValid():Boolean {
        var isValid:Boolean = this.newPassword_.text().length >= 5;
        if (!isValid) {
            this.newPassword_.setError("Password too short");
        }
        return isValid;
    }

    private function isNewPasswordVerified():Boolean {
        var isValid:Boolean = this.newPassword_.text() == this.retypeNewPassword_.text();
        if (!isValid) {
            this.retypeNewPassword_.setError("Password does not match");
        }
        return isValid;
    }

    public function setError(error:String):void {
        this.password_.setError(error);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebChangePasswordMediator.as">
package svera.untiered.account.web.view {
import svera.lib.framework.Mediator;

import svera.lib.tasks.Task;
import svera.untiered.account.web.model.ChangePasswordData;
import svera.untiered.account.web.signals.WebChangePasswordSignal;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebChangePasswordMediator extends Mediator {


    [Inject]
    public var view:WebChangePasswordDialog;

    [Inject]
    public var change:WebChangePasswordSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var loginError:TaskErrorSignal;

    public function WebChangePasswordMediator() {
        super();
    }

    override public function initialize():void {
        this.view.change.add(this.onChange);
        this.view.cancel.add(this.onCancel);
        this.loginError.add(this.onError);
    }

    override public function destroy():void {
        this.view.change.remove(this.onChange);
        this.view.cancel.remove(this.onCancel);
        this.loginError.remove(this.onError);
    }

    private function onCancel():void {
        this.openDialog.dispatch(new WebAccountDetailDialog());
    }

    private function onChange():void {
        var data:ChangePasswordData = null;
        if (this.isCurrentPasswordValid() && this.isNewPasswordValid() && this.isNewPasswordVerified()) {
            this.view.disable();
            data = new ChangePasswordData();
            data.currentPassword = this.view.password_.text();
            data.newPassword = this.view.newPassword_.text();
            this.change.dispatch(data);
        }
    }

    private function isCurrentPasswordValid():Boolean {
        var isValid:Boolean = this.view.password_.text().length >= 5;
        if (!isValid) {
            this.view.password_.setError("Incorrect password");
        }
        return isValid;
    }

    private function isNewPasswordValid():Boolean {
        var isValid:Boolean = this.view.newPassword_.text().length >= 5;
        if (!isValid) {
            this.view.newPassword_.setError("New password too short");
        }
        return isValid;
    }

    private function isNewPasswordVerified():Boolean {
        var isValid:Boolean = this.view.newPassword_.text() == this.view.retypeNewPassword_.text();
        if (!isValid) {
            this.view.retypeNewPassword_.setError("Password does not match");
        }
        return isValid;
    }

    private function onError(task:Task):void {
        this.view.setError(task.error);
        this.view.enable();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebLoginDialog.as">
package svera.untiered.account.web.view {
import com.company.assembleegameclient.account.ui.Frame;
import com.company.assembleegameclient.account.ui.TextInputField;
import com.company.assembleegameclient.ui.ClickableText;

import flash.events.MouseEvent;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.account.web.model.AccountData;

public class WebLoginDialog extends Frame {


    public var cancel:Signal;

    public var signIn:Signal;

    public var register:Signal;

    private var usernameInput:TextInputField;

    private var passwordInput:TextInputField;

    private var registerText:ClickableText;

    public function WebLoginDialog() {
        super("Sign in", "Cancel", "Sign in");
        this.makeUI();
        this.register = new NativeMappedSignal(this.registerText, MouseEvent.CLICK);
        this.cancel = new NativeMappedSignal(leftButton_, MouseEvent.CLICK);
        this.signIn = new Signal(AccountData);
    }

    private function makeUI():void {
        this.usernameInput = new TextInputField("Username", false, "");
        addTextInputField(this.usernameInput);
        this.passwordInput = new TextInputField("Password", true, "");
        addTextInputField(this.passwordInput);
        this.registerText = new ClickableText(12, false, "New user?  Click here to Register");
        addNavigationText(this.registerText);
        rightButton_.addEventListener(MouseEvent.CLICK, this.onSignIn);
    }

    private function onCancel(event:MouseEvent):void {
        this.cancel.dispatch();
    }

    private function onSignIn(event:MouseEvent):void {
        var data:AccountData = null;
        if (this.isUsernameValid() && this.isPasswordValid()) {
            data = new AccountData();
            data.username = this.usernameInput.text();
            data.password = this.passwordInput.text();
            this.signIn.dispatch(data);
        }
    }

    private function isUsernameValid():Boolean {
        var isValid:Boolean = Boolean(usernameInput.text().match(/^[a-zA-Z0-9]+$/i)) && this.usernameInput.text().length > 0 && this.usernameInput.text().length <= 12;
        if (!isValid) {
            this.usernameInput.setError("Invalid username");
        }
        return isValid;
    }

    private function isPasswordValid():Boolean {
        var isValid:Boolean = this.passwordInput.text().length >= 9;
        if (!isValid) {
            this.passwordInput.setError("Invalid password");
        }
        return isValid;
    }

    public function setError(error:String):void {
        this.passwordInput.setError(error);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebLoginMediator.as">
package svera.untiered.account.web.view {
import svera.lib.framework.Mediator;

import svera.lib.tasks.Task;
import svera.untiered.account.core.signals.LoginSignal;
import svera.untiered.account.web.model.AccountData;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebLoginMediator extends Mediator {


    [Inject]
    public var view:WebLoginDialog;

    [Inject]
    public var login:LoginSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var closeDialog:CloseDialogsSignal;

    [Inject]
    public var loginError:TaskErrorSignal;

    public function WebLoginMediator() {
        super();
    }

    override public function initialize():void {
        this.view.signIn.add(this.onSignIn);
        this.view.register.add(this.onRegister);
        this.view.cancel.add(this.onCancel);
        this.loginError.add(this.onLoginError);
    }

    override public function destroy():void {
        this.view.signIn.remove(this.onSignIn);
        this.view.register.remove(this.onRegister);
        this.view.cancel.remove(this.onCancel);
        this.loginError.remove(this.onLoginError);
    }

    private function onSignIn(data:AccountData):void {
        this.view.disable();
        this.login.dispatch(data);
    }

    private function onRegister():void {
        this.openDialog.dispatch(new WebRegisterDialog());
    }

    private function onCancel():void {
        this.closeDialog.dispatch();
    }

    private function onLoginError(task:Task):void {
        this.view.setError(task.error);
        this.view.enable();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebRegisterMediator.as">
package svera.untiered.account.web.view {
import svera.lib.framework.Mediator;

import svera.lib.tasks.Task;
import svera.untiered.account.core.signals.RegisterSignal;
import svera.untiered.account.web.model.AccountData;
import svera.untiered.core.signals.TaskErrorSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.signals.SetWorldInteractionSignal;

public class WebRegisterMediator extends Mediator {


    [Inject]
    public var view:WebRegisterDialog;

    [Inject]
    public var closeDialog:CloseDialogsSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var register:RegisterSignal;

    [Inject]
    public var registrationError:TaskErrorSignal;

    [Inject]
    public var setWorldInteraction:SetWorldInteractionSignal;

    public function WebRegisterMediator() {
        super();
    }

    override public function initialize():void {
        this.view.register.add(this.onRegister);
        this.view.signIn.add(this.onSignIn);
        this.view.cancel.add(this.onCancel);
        this.registrationError.add(this.onRegistrationError);
        this.setWorldInteraction.dispatch(false);
    }

    override public function destroy():void {
        this.view.register.remove(this.onRegister);
        this.view.signIn.remove(this.onSignIn);
        this.view.cancel.remove(this.onCancel);
        this.registrationError.remove(this.onRegistrationError);
        this.setWorldInteraction.dispatch(true);
    }

    private function onRegister(data:AccountData):void {
        this.view.disable();
        this.register.dispatch(data);
    }

    private function onCancel():void {
        this.closeDialog.dispatch();
    }

    private function onSignIn():void {
        this.openDialog.dispatch(new WebLoginDialog());
    }

    private function onRegistrationError(task:Task):void {
        this.view.displayServerError(task.error);
        this.view.enable();
    }
}
}
</file>

<file path="src/svera/untiered/appengine/api/AppEngineClient.as">
package svera.untiered.appengine.api {
import org.osflash.signals.OnceSignal;

public interface AppEngineClient {


    function get complete():OnceSignal;

    function setDataFormat(param1:String):void;

    function setSendEncrypted(param1:Boolean):void;

    function setMaxRetries(param1:int):void;

    function sendRequest(param1:String, param2:Object):void;
}
}
</file>

<file path="src/svera/untiered/appengine/api/RetryLoader.as">
package svera.untiered.appengine.api {
import org.osflash.signals.OnceSignal;

public interface RetryLoader {


    function get complete():OnceSignal;

    function setMaxRetries(param1:int):void;

    function setDataFormat(param1:String):void;

    function sendRequest(param1:String, param2:Object):void;
}
}
</file>

<file path="src/svera/untiered/appengine/impl/AppEngineRetryLoader.as">
package svera.untiered.appengine.impl {
import flash.events.Event;
import flash.events.IOErrorEvent;
import flash.events.SecurityErrorEvent;
import flash.net.URLLoader;
import flash.net.URLLoaderDataFormat;
import flash.net.URLRequest;
import flash.net.URLRequestMethod;
import flash.net.URLVariables;
import flash.utils.ByteArray;
import flash.utils.getTimer;

import org.osflash.signals.OnceSignal;

import svera.untiered.appengine.api.RetryLoader;

public class AppEngineRetryLoader implements RetryLoader {


    private const _complete:OnceSignal = new OnceSignal(Boolean);

    private var maxRetries:int;

    private var dataFormat:String;

    private var url:String;

    private var params:Object;

    private var urlRequest:URLRequest;

    private var urlLoader:URLLoader;

    private var retriesLeft:int;

    public function AppEngineRetryLoader() {
        super();
        this.maxRetries = 0;
        this.dataFormat = URLLoaderDataFormat.TEXT;
    }

    public function get complete():OnceSignal {
        return this._complete;
    }

    public function setDataFormat(dataFormat:String):void {
        this.dataFormat = dataFormat;
    }

    public function setMaxRetries(maxRetries:int):void {
        this.maxRetries = maxRetries;
    }

    public function sendRequest(url:String, params:Object):void {
        this.url = url;
        this.params = params;
        this.retriesLeft = this.maxRetries;
        this.internalSendRequest();
    }

    private function internalSendRequest():void {
        this.cancelPendingRequest();
        this.urlRequest = this.makeUrlRequest();
        this.urlLoader = this.makeUrlLoader();
        this.urlLoader.load(this.urlRequest);
    }

    private function makeUrlRequest():URLRequest {
        var urlRequest:URLRequest = new URLRequest(this.url);
        urlRequest.method = URLRequestMethod.POST;
        urlRequest.data = this.makeUrlVariables();
        return urlRequest;
    }

    private function makeUrlVariables():URLVariables {
        var key:* = null;
        var vars:URLVariables = new URLVariables();
        vars.ignore = getTimer();
        for (key in this.params) {
            vars[key] = this.params[key];
        }
        return vars;
    }

    private function makeUrlLoader():URLLoader {
        var urlLoader:URLLoader = new URLLoader();
        urlLoader.dataFormat = this.dataFormat;
        urlLoader.addEventListener(IOErrorEvent.IO_ERROR, this.onIOError);
        urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onSecurityError);
        urlLoader.addEventListener(Event.COMPLETE, this.onComplete);
        return urlLoader;
    }

    private function onIOError(event:IOErrorEvent):void {
        var text:String = this.urlLoader.data;
        if (text.length == 0) {
            text = "Unable to contact server";
        }
        this.retryOrReportError(text);
    }

    private function onSecurityError(event:SecurityErrorEvent):void {
        this.cleanUpAndComplete(false, "Security Error");
    }

    private function retryOrReportError(error:String):void {
        if (this.retriesLeft-- > 0) {
            this.internalSendRequest();
        } else {
            this.cleanUpAndComplete(false, error);
        }
    }

    private function onComplete(event:Event):void {
        if (this.dataFormat == URLLoaderDataFormat.TEXT) {
            this.handleTextResponse(this.urlLoader.data);
        } else {
            this.cleanUpAndComplete(true, ByteArray(this.urlLoader.data));
        }
    }

    private function handleTextResponse(response:String):void {
        if (response.substring(0, 7) == "<Error>") {
            this.retryOrReportError(response);
        } else if (response.substring(0, 12) == "<FatalError>") {
            this.cleanUpAndComplete(false, response);
        } else {
            this.cleanUpAndComplete(true, response);
        }
    }

    private function cleanUpAndComplete(isOK:Boolean, data:*):void {
        if (!isOK && data is String) {
            data = this.parseXML(data);
        }
        this.cancelPendingRequest();
        this._complete.dispatch(isOK, data);
    }

    private function parseXML(data:String):String {
        var match:Array = data.match("<.*>(.*)</.*>");
        return match && match.length > 1 ? match[1] : data;
    }

    private function cancelPendingRequest():void {
        if (this.urlLoader) {
            this.urlLoader.removeEventListener(IOErrorEvent.IO_ERROR, this.onIOError);
            this.urlLoader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onSecurityError);
            this.urlLoader.removeEventListener(Event.COMPLETE, this.onComplete);
            this.closeLoader();
            this.urlLoader = null;
        }
    }

    private function closeLoader():void {
        try {
            this.urlLoader.close();
        } catch (e:Error) {
        }
    }
}
}
</file>

<file path="src/svera/untiered/appengine/impl/SimpleAppEngineClient.as">
package svera.untiered.appengine.impl {
import com.company.assembleegameclient.parameters.Parameters;

import flash.net.URLLoaderDataFormat;

import org.osflash.signals.OnceSignal;

import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.appengine.api.RetryLoader;

public class SimpleAppEngineClient implements AppEngineClient {


    [Inject]
    public var loader:RetryLoader;

    private var isEncrypted:Boolean;

    private var maxRetries:int;

    private var dataFormat:String;

    public function SimpleAppEngineClient() {
        super();
        this.isEncrypted = true;
        this.maxRetries = 0;
        this.dataFormat = URLLoaderDataFormat.TEXT;
    }

    public function get complete():OnceSignal {
        return this.loader.complete;
    }

    public function setDataFormat(dataFormat:String):void {
        this.loader.setDataFormat(dataFormat);
    }

    public function setSendEncrypted(value:Boolean):void {
        this.isEncrypted = value;
    }

    public function setMaxRetries(maxRetries:int):void {
        this.loader.setMaxRetries(maxRetries);
    }

    public function sendRequest(target:String, params:Object):void {
        this.loader.sendRequest(this.makeURL(target), params);
    }

    private function makeURL(target:String):String {
        if (target.charAt(0) != "/") {
            target = "/" + target;
        }
        return Parameters.appServerAddress() + target;
    }
}
}
</file>

<file path="src/svera/untiered/assets/model/Animation.as">
package svera.untiered.assets.model {
import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.TimerEvent;
import flash.utils.Timer;

public class Animation extends Sprite {


    private const DEFAULT_SPEED:int = 200;

    private const bitmap:Bitmap = makeBitmap();

    private const frames:Vector.<BitmapData> = new Vector.<BitmapData>(0);

    private const timer:Timer = makeTimer();

    private var isStarted:Boolean;

    private var index:int;

    private var count:uint;

    public function Animation() {
        super();
    }

    private function makeBitmap():Bitmap {
        var bitmap:Bitmap = new Bitmap();
        addChild(bitmap);
        return bitmap;
    }

    private function makeTimer():Timer {
        var timer:Timer = new Timer(this.DEFAULT_SPEED);
        timer.addEventListener(TimerEvent.TIMER, this.iterate);
        return timer;
    }

    public function getSpeed():int {
        return this.timer.delay;
    }

    public function setSpeed(speed:int):void {
        this.timer.delay = speed;
    }

    public function setFrames(...newFrames):void {
        var frame:BitmapData = null;
        this.frames.length = 0;
        this.index = 0;
        for each(frame in newFrames) {
            this.count = this.frames.push(frame);
        }
        if (this.isStarted) {
            this.start();
        } else {
            this.iterate();
        }
    }

    public function addFrame(frame:BitmapData):void {
        this.count = this.frames.push(frame);
        this.isStarted && this.start();
    }

    public function start():void {
        if (!this.isStarted && this.count > 0) {
            this.timer.start();
            this.iterate();
        }
        this.isStarted = true;
    }

    public function stop():void {
        this.isStarted && this.timer.stop();
        this.isStarted = false;
    }

    private function iterate(event:TimerEvent = null):void {
        this.index = ++this.index % this.count;
        this.bitmap.bitmapData = this.frames[this.index];
    }

    public function dispose():void {
        var frame:BitmapData = null;
        this.stop();
        this.index = 0;
        this.count = 0;
        this.frames.length = 0;
        for each(frame in this.frames) {
            frame.dispose();
        }
    }
}
}
</file>

<file path="src/svera/untiered/assets/services/CharacterFactory.as">
package svera.untiered.assets.services {
import com.company.assembleegameclient.util.AnimatedChar;
import com.company.assembleegameclient.util.AnimatedChars;
import com.company.assembleegameclient.util.MaskedImage;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.assembleegameclient.util.redrawers.GlowRedrawer;
import com.company.util.BitmapUtil;

import flash.display.BitmapData;

import svera.untiered.assets.model.Animation;
import svera.untiered.assets.model.CharacterTemplate;

public class CharacterFactory {


    private var texture1:int;

    private var texture2:int;

    private var size:int;

    public function CharacterFactory() {
        super();
    }

    public function makeCharacter(template:CharacterTemplate):AnimatedChar {
        return AnimatedChars.getAnimatedChar(template.file, template.index);
    }

    public function makeIcon(template:CharacterTemplate, size:int = 100, texture1:int = 0, texture2:int = 0):BitmapData {
        this.texture1 = texture1;
        this.texture2 = texture2;
        this.size = size;
        var character:AnimatedChar = this.makeCharacter(template);
        var data:BitmapData = this.makeFrame(character, AnimatedChar.STAND, 0);
        data = GlowRedrawer.outlineGlow(data, 0);
        data = BitmapUtil.cropToBitmapData(data, 6, 6, data.width - 12, data.height - 6);
        return data;
    }

    public function makeWalkingIcon(template:CharacterTemplate, size:int = 100, texture1:int = 0, texture2:int = 0):Animation {
        this.texture1 = texture1;
        this.texture2 = texture2;
        this.size = size;
        var character:AnimatedChar = this.makeCharacter(template);
        var first:BitmapData = this.makeFrame(character, AnimatedChar.WALK, 0.5);
        first = GlowRedrawer.outlineGlow(first, 0);
        var second:BitmapData = this.makeFrame(character, AnimatedChar.WALK, 0);
        second = GlowRedrawer.outlineGlow(second, 0);
        var animation:Animation = new Animation();
        animation.setFrames(first, second);
        return animation;
    }

    private function makeFrame(character:AnimatedChar, action:int, offset:Number):BitmapData {
        var data:MaskedImage = character.imageFromDir(AnimatedChar.RIGHT, action, offset);
        return TextureRedrawer.resize(data.image_, data.mask_, this.size, false, this.texture1, this.texture2);
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/control/DeleteCharacterCommand.as">
package svera.untiered.characters.deletion.control {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import svera.lib.framework.ICommand;

import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.characters.deletion.service.DeleteCharacterTask;
import svera.untiered.characters.deletion.view.DeletingCharacterView;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class DeleteCharacterCommand implements ICommand {


    [Inject]
    public var task:DeleteCharacterTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    [Inject]
    public var setScreen:SetScreenSignal;

    public function DeleteCharacterCommand() {
        super();
    }

    public function execute():void {
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(new DispatchSignalTask(this.openDialog, new DeletingCharacterView()));
        sequence.add(new BranchingTask(this.task, this.onSuccess(), this.onFailure()));
        this.monitor.add(sequence);
        sequence.start();
    }

    private function onSuccess():Task {
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(new DispatchSignalTask(this.setScreen, new CharacterSelectionAndNewsScreen()));
        sequence.add(new DispatchSignalTask(this.closeDialogs));
        return sequence;
    }

    private function onFailure():Task {
        return new DispatchSignalTask(this.openDialog, "Unable to delete character");
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/control/DeleteCharacterSignal.as">
package svera.untiered.characters.deletion.control {
import com.company.assembleegameclient.appengine.SavedCharacter;

import org.osflash.signals.Signal;

public class DeleteCharacterSignal extends Signal {


    public function DeleteCharacterSignal() {
        super(SavedCharacter);
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/service/DeleteCharacterTask.as">
package svera.untiered.characters.deletion.service {
import com.company.assembleegameclient.appengine.SavedCharacter;

import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.characters.model.CharacterModel;

public class DeleteCharacterTask extends BaseTask {


    [Inject]
    public var character:SavedCharacter;

    [Inject]
    public var client:AppEngineClient;

    [Inject]
    public var account:Account;

    [Inject]
    public var model:CharacterModel;

    public function DeleteCharacterTask() {
        super();
    }

    override protected function startTask():void {
        this.client.setMaxRetries(2);
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/char/delete", this.getRequestPacket());
    }

    private function getRequestPacket():Object {
        var params:Object = this.account.getCredentials();
        params.charId = this.character.charId();
        return params;
    }

    private function onComplete(isOK:Boolean, data:*):void {
        isOK && this.updateUserData();
        completeTask(isOK, data);
    }

    private function updateUserData():void {
        this.model.deleteCharacter(this.character.charId());
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/view/ConfirmDeleteCharacterMediator.as">
package svera.untiered.characters.deletion.view {
import com.company.assembleegameclient.appengine.SavedCharacter;

import svera.lib.framework.Mediator;

import svera.untiered.characters.deletion.control.DeleteCharacterSignal;
import svera.untiered.characters.model.CharacterModel;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class ConfirmDeleteCharacterMediator extends Mediator {


    [Inject]
    public var view:ConfirmDeleteCharacterDialog;

    [Inject]
    public var model:CharacterModel;

    [Inject]
    public var deleteCharacter:DeleteCharacterSignal;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    private var character:SavedCharacter;

    public function ConfirmDeleteCharacterMediator() {
        super();
    }

    override public function initialize():void {
        this.view.deleteCharacter.add(this.onDeleteCharacter);
        this.view.cancel.add(this.closeDialog);
        this.character = this.model.getSelected();
        this.view.setText(this.character.name(), this.character.displayId());
    }

    override public function destroy():void {
        this.view.deleteCharacter.remove(this.onDeleteCharacter);
        this.view.cancel.remove(this.closeDialog);
    }

    private function onDeleteCharacter():void {
        this.deleteCharacter.dispatch(this.character);
    }

    private function closeDialog():void {
        this.closeDialogs.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/view/DeletingCharacterView.as">
package svera.untiered.characters.deletion.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

public class DeletingCharacterView extends Dialog {


    public function DeletingCharacterView() {
        super("Deleting Character...", null, null, null);
    }
}
}
</file>

<file path="src/svera/untiered/characters/model/CharacterModel.as">
package svera.untiered.characters.model {
import com.company.assembleegameclient.appengine.SavedCharacter;

public interface CharacterModel {


    function getCharacterCount():int;

    function getCharacter(param1:int):SavedCharacter;

    function deleteCharacter(param1:int):void;

    function select(param1:SavedCharacter):void;

    function getSelected():SavedCharacter;
}
}
</file>

<file path="src/svera/untiered/characters/model/LegacyCharacterModel.as">
package svera.untiered.characters.model {
import com.company.assembleegameclient.appengine.SavedCharacter;

import svera.untiered.core.model.PlayerModel;

public class LegacyCharacterModel implements CharacterModel {


    [Inject]
    public var wrapped:PlayerModel;

    private var selected:SavedCharacter;

    public function LegacyCharacterModel() {
        super();
    }

    public function getCharacterCount():int {
        return this.wrapped.getCharacterCount();
    }

    public function getCharacter(characterId:int):SavedCharacter {
        return this.wrapped.getCharById(characterId);
    }

    public function deleteCharacter(characterId:int):void {
        this.wrapped.deleteCharacter(characterId);
        if (this.selected.charId() == characterId) {
            this.selected = null;
        }
    }

    public function select(character:SavedCharacter):void {
        this.selected = character;
    }

    public function getSelected():SavedCharacter {
        return this.selected;
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/control/OpenReskinDialogSignal.as">
package svera.untiered.characters.reskin.control {
import org.osflash.signals.Signal;

public class OpenReskinDialogSignal extends Signal {


    public function OpenReskinDialogSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/control/ReskinCharacterCommand.as">
package svera.untiered.characters.reskin.control {
import svera.lib.framework.ICommand;
import svera.lib.net.api.MessageProvider;
import svera.lib.net.impl.SocketServer;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.messaging.impl.outgoing.Reskin;

public class ReskinCharacterCommand implements ICommand {


    [Inject]
    public var skin:CharacterSkin;

    [Inject]
    public var messages:MessageProvider;

    [Inject]
    public var server:SocketServer;

    public function ReskinCharacterCommand() {
        super();
    }

    public function execute():void {
        var reskin:Reskin = this.messages.require(GameServerConnection.RESKIN) as Reskin;
        reskin.skinID = this.skin.id;
        this.server.sendMessage(reskin);
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/control/ReskinCharacterSignal.as">
package svera.untiered.characters.reskin.control {
import org.osflash.signals.Signal;

import svera.untiered.classes.model.CharacterSkin;

public class ReskinCharacterSignal extends Signal {


    public function ReskinCharacterSignal() {
        super(CharacterSkin);
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/view/ReskinCharacterMediator.as">
package svera.untiered.characters.reskin.view {
import svera.lib.framework.Mediator;

import svera.untiered.characters.reskin.control.ReskinCharacterSignal;
import svera.untiered.classes.model.CharacterSkins;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class ReskinCharacterMediator extends Mediator {


    [Inject]
    public var view:ReskinCharacterView;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var model:ClassesModel;

    [Inject]
    public var reskinCharacter:ReskinCharacterSignal;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    private var skins:CharacterSkins;

    public function ReskinCharacterMediator() {
        super();
    }

    override public function initialize():void {
        this.skins = this.getCharacterSkins();
        this.view.selected.add(this.onSelected);
        this.view.cancelled.add(this.onCancelled);
    }

    private function getCharacterSkins():CharacterSkins {
        return this.model.getSelected().skins;
    }

    override public function destroy():void {
        this.view.selected.remove(this.onSelected);
        this.view.cancelled.remove(this.onCancelled);
    }

    private function onSelected():void {
        this.closeDialogs.dispatch();
        this.reskinCharacter.dispatch(this.skins.getSelectedSkin());
    }

    private function onCancelled():void {
        this.closeDialogs.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/view/ReskinPanelMediator.as">
package svera.untiered.characters.reskin.view {
import svera.lib.framework.Mediator;

import svera.untiered.characters.reskin.control.OpenReskinDialogSignal;

public class ReskinPanelMediator extends Mediator {


    [Inject]
    public var view:ReskinPanel;

    [Inject]
    public var openReskinDialog:OpenReskinDialogSignal;

    public function ReskinPanelMediator() {
        super();
    }

    override public function initialize():void {
        this.view.reskin.add(this.onReskin);
    }

    override public function destroy():void {
        this.view.reskin.remove(this.onReskin);
    }

    private function onReskin():void {
        this.openReskinDialog.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/BuyCharacterSkinCommand.as">
package svera.untiered.classes.control {
import svera.lib.framework.ICommand;
import svera.lib.tasks.TaskMonitor;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;
import svera.untiered.classes.services.BuySkinTask;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.ui.view.NotEnoughTsavoriteDialog;

public class BuyCharacterSkinCommand implements ICommand {


    [Inject]
    public var skin:CharacterSkin;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var task:BuySkinTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function BuyCharacterSkinCommand() {
        super();
    }

    public function execute():void {
        if (this.isSkinPurchasable()) {
            this.enterPurchaseFlow();
        }
    }

    private function enterPurchaseFlow():void {
        if (this.isSkinAffordable()) {
            this.purchaseSkin();
        } else {
            this.enterGetTsavoriteFlow();
        }
    }

    private function isSkinPurchasable():Boolean {
        return this.skin.getState() == CharacterSkinState.PURCHASABLE;
    }

    private function isSkinAffordable():Boolean {
        return this.model.getTsavorite() >= this.skin.cost;
    }

    private function purchaseSkin():void {
        this.monitor.add(this.task);
        this.task.start();
    }

    private function enterGetTsavoriteFlow():void {
        this.openDialog.dispatch(new NotEnoughTsavoriteDialog());
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/ParseCharListXmlCommand.as">
package svera.untiered.classes.control {

import svera.lib.framework.ICommand;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;
import svera.untiered.classes.model.ClassesModel;

public class ParseCharListXmlCommand implements ICommand {
    [Inject]
    public var data:XML;

    [Inject]
    public var model:ClassesModel;

    public function ParseCharListXmlCommand() {
        super();
    }

    public function execute():void {
        this.parseOwnership();
    }

    private function parseOwnership():void {
        var owned:int = 0;
        var skin:CharacterSkin = null;
        var ownership:Array = Boolean(this.data.OwnedSkins.length()) ? this.data.OwnedSkins.split(",") : [];
        for each(owned in ownership) {
            skin = this.model.getCharacterSkin(owned);
            if (skin) {
                skin.setState(CharacterSkinState.OWNED);
            }
        }
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/ResetClassDataCommand.as">
package svera.untiered.classes.control {
import svera.lib.framework.ICommand;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;
import svera.untiered.classes.model.ClassesModel;

public class ResetClassDataCommand implements ICommand {


    [Inject]
    public var classes:ClassesModel;

    public function ResetClassDataCommand() {
        super();
    }

    public function execute():void {
        var count:int = this.classes.getCount();
        for (var i:int = 0; i < count; i++) {
            this.resetClass(this.classes.getClassAtIndex(i));
        }
    }

    private function resetClass(charClass:CharacterClass):void {
        charClass.setIsSelected(charClass.id == ClassesModel.WIZARD_ID);
        this.resetClassSkins(charClass);
    }

    private function resetClassSkins(charClass:CharacterClass):void {
        var skin:CharacterSkin = null;
        var defaultSkin:CharacterSkin = charClass.skins.getDefaultSkin();
        var count:int = charClass.skins.getCount();
        for (var i:int = 0; i < count; i++) {
            skin = charClass.skins.getSkinAt(i);
            if (skin != defaultSkin) {
                this.resetSkin(charClass.skins.getSkinAt(i));
            }
        }
    }

    private function resetSkin(charSkin:CharacterSkin):void {
        charSkin.setState(CharacterSkinState.NULL);
    }
}
}
</file>

<file path="src/svera/untiered/classes/model/CharacterSkins.as">
package svera.untiered.classes.model {
public class CharacterSkins {
    private const skins:Vector.<CharacterSkin> = new Vector.<CharacterSkin>(0);

    private const map:Object = {};

    private var defaultSkin:CharacterSkin;

    private var selectedSkin:CharacterSkin;

    public function CharacterSkins() {
        super();
    }

    public function getCount():int {
        return this.skins.length;
    }

    public function getDefaultSkin():CharacterSkin {
        return this.defaultSkin;
    }

    public function getSelectedSkin():CharacterSkin {
        return this.selectedSkin;
    }

    public function getSkinAt(index:int):CharacterSkin {
        return this.skins[index];
    }

    public function addSkin(skin:CharacterSkin, isDefault:Boolean = false):void {
        skin.changed.add(onSkinChanged);
        this.skins.push(skin);
        this.map[skin.id] = skin;
        this.updateSkinState(skin);
        if (isDefault) {
            this.defaultSkin = skin;
            if (!this.selectedSkin) {
                this.selectedSkin = skin;
                skin.setIsSelected(true);
            }
        } else if (skin.getIsSelected()) {
            this.selectedSkin = skin;
        }
    }

    private function onSkinChanged(skin:CharacterSkin):void {
        if (skin.getIsSelected() && this.selectedSkin != skin) {
            this.selectedSkin && this.selectedSkin.setIsSelected(false);
            this.selectedSkin = skin;
        }
    }

    public function updateSkins():void {
        var skin:CharacterSkin = null;
        for each(skin in this.skins) {
            this.updateSkinState(skin);
        }
    }

    private function updateSkinState(skin:CharacterSkin):void {
        if (skin.getState() != CharacterSkinState.OWNED) {
            skin.setState(CharacterSkinState.PURCHASABLE);
        }
    }

    public function getSkin(id:int):CharacterSkin {
        return this.map[id] || this.defaultSkin;
    }
}
}
</file>

<file path="src/svera/untiered/classes/model/ClassesModel.as">
package svera.untiered.classes.model {
import org.osflash.signals.Signal;

public class ClassesModel {
    public static const WIZARD_ID:int = 782;

    public const selected:Signal = new Signal(CharacterClass);
    private const map:Object = {};
    private const classes:Vector.<CharacterClass> = new Vector.<CharacterClass>(0);

    private var count:uint = 0;
    private var selectedChar:CharacterClass;

    public function ClassesModel() {
        super();
    }

    public function getCount():uint {
        return this.count;
    }

    public function getClassAtIndex(index:int):CharacterClass {
        return this.classes[index];
    }

    public function getCharacterClass(id:int):CharacterClass {
        return this.map[id] = this.map[id] || this.makeCharacterClass();
    }

    private function makeCharacterClass():CharacterClass {
        var character:CharacterClass = new CharacterClass();
        character.selected.add(this.onClassSelected);
        this.count = this.classes.push(character);
        return character;
    }

    private function onClassSelected(charClass:CharacterClass):void {
        if (this.selectedChar != charClass) {
            this.selectedChar && this.selectedChar.setIsSelected(false);
            this.selectedChar = charClass;
            this.selected.dispatch(charClass);
        }
    }

    public function getSelected():CharacterClass {
        return this.selectedChar || this.getCharacterClass(WIZARD_ID);
    }

    public function getCharacterSkin(type:int):CharacterSkin {
        var skin:CharacterSkin;
        var character:CharacterClass;
        for each(character in this.classes) {
            skin = character.skins.getSkin(type);
            if (skin != character.skins.getDefaultSkin()) {
                break;
            }
        }
        return skin;
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/Orbiter.as">
package svera.untiered.classes.view {
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.geom.Point;
import flash.utils.getTimer;

public class Orbiter extends Sprite
{
    // Pixels.
    public static const radius:Number = 100;

    // Degrees per second.
    public var speed:Number = 60;

    public var items:Vector.<CharacterSkinListItem>;
    public var lastTime:int;
    public var rot:Number;

    public function start()
    {
        stop();

        rot = 0;
        lastTime = getTimer();

        addEventListener(Event.ENTER_FRAME, onFrame);
    }

    public function stop():void
    {
        removeEventListener(Event.ENTER_FRAME, onFrame);
    }

    public function onFrame(e:Event = null):void
    {
        var aTime:int = getTimer();

        rot += speed * (aTime - lastTime) / 1000;
        lastTime = aTime;

        var angle:Number = (Math.PI * 2) / items.length ;
        var accumulatedAngle:Number = -(Math.PI * 3) / 2 + rot;
        for (var i:int = 0; i < items.length; i++) {
            var item:DisplayObject = items[i];

            var x:Number = 0 + Math.cos(accumulatedAngle) * radius;
            var y:Number = 0 + Math.sin(accumulatedAngle) * radius * 0.38; // 0.38 for ellipse look

            item.scaleX = item.scaleY = Math.max((y / 19 + 2) / 2, 1); //min scale 1, max scale 2
            item.x = -item.width / 2;
            item.y = -item.height / 2;
            var container:Sprite = item.parent as Sprite;
            container.x = x;
            container.y = y;
            accumulatedAngle += angle;
        }
    }

    private function getPosition(index:int):Point
    {
        // Calculate the angle with regard to the present items amount.
        var anAngle:Number = (Math.PI * 2) / items.length + rot;
        var result:Point = new Point;

        // Figure the position with regard to (x,y) offset.
        result.x = x + radius * Math.cos(anAngle);
        result.y = y + radius * Math.sin(anAngle);

        return result;
    }
}
}
</file>

<file path="src/svera/untiered/core/commands/InvalidateDataCommand.as">
package svera.untiered.core.commands {
import svera.lib.framework.ICommand;
import svera.untiered.account.core.model.JSInitializedModel;
import svera.untiered.core.model.PlayerModel;

public class InvalidateDataCommand implements ICommand {


    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var jsInitialized:JSInitializedModel;

    public function InvalidateDataCommand() {
        super();
    }

    public function execute():void {
        this.model.isInvalidated = true;
        this.jsInitialized.isInitialized = false;
    }
}
}
</file>

<file path="src/svera/untiered/core/commands/SetScreenWithValidDataCommand.as">
package svera.untiered.core.commands {
import com.company.assembleegameclient.screens.LoadingScreen;

import flash.display.Sprite;

import svera.lib.framework.ICommand;

import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.account.core.services.GetCharListTask;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenSignal;

public class SetScreenWithValidDataCommand implements ICommand {


    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var view:Sprite;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var task:GetCharListTask;

    public function SetScreenWithValidDataCommand() {
        super();
    }

    public function execute():void {
        if (this.model.isInvalidated) {
            this.reloadDataThenSetScreen();
        } else {
            this.setScreen.dispatch(this.view);
        }
    }

    private function reloadDataThenSetScreen():void {
        this.setScreen.dispatch(new LoadingScreen());
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(this.task);
        sequence.add(new DispatchSignalTask(this.setScreen, this.view));
        this.monitor.add(sequence);
        sequence.start();
    }
}
}
</file>

<file path="src/svera/untiered/core/commands/UpdatePlayerModelCommand.as">
package svera.untiered.core.commands {
import com.company.assembleegameclient.appengine.SavedCharactersList;
import com.company.assembleegameclient.editor.Command;
import com.company.assembleegameclient.sound.Music;

import svera.untiered.core.model.PlayerModel;

public class UpdatePlayerModelCommand extends Command {


    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var data:XML;

    public function UpdatePlayerModelCommand() {
        super();
    }

    override public function execute():void {
        this.model.setCharacterList(new SavedCharactersList(this.data));
        this.model.isInvalidated = false;
        Music.load(Music.MENU_MUSIC);
    }
}
}
</file>

<file path="src/svera/untiered/core/model/MapModel.as">
package svera.untiered.core.model {
import com.company.assembleegameclient.objects.IInteractiveObject;

public class MapModel {


    public var currentInteractiveTarget:IInteractiveObject;

    public function MapModel() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/GotoPreviousScreenSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

public class GotoPreviousScreenSignal extends Signal {


    public function GotoPreviousScreenSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/HideTooltipsSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

public class HideTooltipsSignal extends Signal {


    public function HideTooltipsSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/InvalidateDataSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

public class InvalidateDataSignal extends Signal {


    public function InvalidateDataSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/LaunchGameSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

public class LaunchGameSignal extends Signal {


    public function LaunchGameSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/SetLoadingMessageSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

public class SetLoadingMessageSignal extends Signal {


    public function SetLoadingMessageSignal() {
        super(String);
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/SetScreenWithValidDataSignal.as">
package svera.untiered.core.signals {
import flash.display.Sprite;

import org.osflash.signals.Signal;

public class SetScreenWithValidDataSignal extends Signal {


    public function SetScreenWithValidDataSignal() {
        super(Sprite);
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/ShowTooltipSignal.as">
package svera.untiered.core.signals {
import com.company.assembleegameclient.ui.tooltip.ToolTip;

import org.osflash.signals.Signal;

public class ShowTooltipSignal extends Signal {


    public function ShowTooltipSignal() {
        super(ToolTip);
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/TaskErrorSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

import svera.lib.tasks.Task;

public class TaskErrorSignal extends Signal {


    public function TaskErrorSignal() {
        super(Task);
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/UpdateNewCharacterScreenSignal.as">
package svera.untiered.core.signals {
import org.osflash.signals.Signal;

public class UpdateNewCharacterScreenSignal extends Signal {


    public function UpdateNewCharacterScreenSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/core/StaticInjectorContext.as">
package svera.untiered.core {
import org.swiftsuspenders.Injector;

import svera.lib.framework.AppContext;

public class StaticInjectorContext extends AppContext {

    public static var injector:Injector;


    public function StaticInjectorContext() {
        super();
        if (!StaticInjectorContext.injector) {
            StaticInjectorContext.injector = this.injector;
        }
    }

    public static function getInjector():Injector {
        return injector;
    }
}
}
</file>

<file path="src/svera/untiered/core/view/Layers.as">
package svera.untiered.core.view {
import flash.display.DisplayObjectContainer;
import flash.display.Sprite;

import svera.untiered.dialogs.view.DialogsView;
import svera.untiered.tooltips.view.TooltipsView;

public class Layers extends Sprite {
    private var menu:ScreensView;

    public var overlay:DisplayObjectContainer;

    private var tooltips:TooltipsView;

    public var top:DisplayObjectContainer;

    private var dialogs:DialogsView;

    public var api:DisplayObjectContainer;


    public function Layers() {
        super();
        addChild(this.menu = new ScreensView());
        addChild(this.overlay = new Sprite());
        addChild(this.top = new Sprite());
        addChild(this.tooltips = new TooltipsView());
        addChild(this.dialogs = new DialogsView());
        addChild(this.api = new Sprite());
    }
}
}
</file>

<file path="src/svera/untiered/death/control/HandleDeathSignal.as">
package svera.untiered.death.control {
import org.osflash.signals.Signal;

import svera.untiered.messaging.impl.incoming.Death;

public class HandleDeathSignal extends Signal {


    public function HandleDeathSignal() {
        super(Death);
    }
}
}
</file>

<file path="src/svera/untiered/death/control/HandleNormalDeathSignal.as">
package svera.untiered.death.control {
import org.osflash.signals.Signal;

import svera.untiered.messaging.impl.incoming.Death;

public class HandleNormalDeathSignal extends Signal {


    public function HandleNormalDeathSignal() {
        super(Death);
    }
}
}
</file>

<file path="src/svera/untiered/dialogs/control/CloseDialogsSignal.as">
package svera.untiered.dialogs.control {
import org.osflash.signals.Signal;

public class CloseDialogsSignal extends Signal {


    public function CloseDialogsSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/dialogs/view/DialogsMediator.as">
package svera.untiered.dialogs.view {
import flash.display.Sprite;

import svera.lib.framework.Mediator;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class DialogsMediator extends Mediator {
    // Remove [Inject] for view - it's automatic now
    [Inject]
    public var openDialog:OpenDialogSignal;

    // Type-safe view accessor
    private function get dialogsView():DialogsView {
        return view as DialogsView;
    }

    // Use onInitialize instead of initialize
    override protected function onInitialize():void {
        openDialog.add(onOpenDialog);
    }

    // Use onDestroy instead of destroy
    override protected function onDestroy():void {
        openDialog.remove(onOpenDialog);
    }

    private function onOpenDialog(dialog:Sprite):void {
        dialogsView.show(dialog);
    }
}
}
</file>

<file path="src/svera/untiered/game/commands/UsePotionCommand.as">
package svera.untiered.game.commands {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.sound.SoundEffectLibrary;

import svera.lib.framework.ICommand;

import svera.untiered.game.model.PotionInventoryModel;
import svera.untiered.game.model.UsePotionVO;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.model.PotionModel;

public class UsePotionCommand implements ICommand {


    [Inject]
    public var vo:UsePotionVO;

    [Inject]
    public var potInventoryModel:PotionInventoryModel;

    [Inject]
    public var hudModel:HUDModel;

    private var gsc:GameServerConnection;

    private var player:Player;

    private var potionId:int;

    private var count:int;

    private var potion:PotionModel;

    public function UsePotionCommand() {
        this.gsc = GameServerConnection.instance;
        super();
    }

    public function execute():void {
        this.player = this.hudModel.gameSprite.map.player_;
        this.potionId = this.vo.objectId;
        this.count = this.player.getPotionCount(this.potionId);
        this.potion = this.potInventoryModel.getPotionModel(this.potionId);
        if (this.count > 0) {
            this.usePotionIfEffective();
        }
    }

    private function usePotionIfEffective():void {
        if (this.isPlayerStatMaxed()) {
            //this.logger.info("UsePotionCommand.execute: User has MAX of that attribute, not requesting a use from server.");
        } else {
            this.sendServerRequest();
        }
    }

    private function isPlayerStatMaxed():Boolean {
        if (this.potionId == PotionInventoryModel.HEALTH_POTION_ID) {
            return this.player.hp_ >= this.player.maxHP_;
        }
        if (this.potionId == PotionInventoryModel.MAGIC_POTION_ID) {
            return this.player.rp_ >= this.player.maxRP_;
        }
        return false;
    }

    private function sendServerRequest():void {
        var slot:int = PotionInventoryModel.getPotionSlot(this.vo.objectId);
        this.gsc.useItem(this.gsc.gs_.lastUpdate_, this.player.objectId_, slot, this.player.x_, this.player.y_);
        SoundEffectLibrary.play("use_potion");
    }
}
}
</file>

<file path="src/svera/untiered/game/focus/control/SetGameFocusSignal.as">
package svera.untiered.game.focus.control {
import org.osflash.signals.Signal;

public class SetGameFocusSignal extends Signal {


    public function SetGameFocusSignal() {
        super(String);
    }
}
}
</file>

<file path="src/svera/untiered/game/focus/view/GameFocusMediator.as">
package svera.untiered.game.focus.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.GameObject;

import flash.utils.Dictionary;

import svera.lib.framework.Mediator;

import svera.untiered.game.focus.control.SetGameFocusSignal;

public class GameFocusMediator extends Mediator {


    [Inject]
    public var signal:SetGameFocusSignal;

    [Inject]
    public var view:GameSprite;

    public function GameFocusMediator() {
        super();
    }

    override public function initialize():void {
        this.signal.add(this.onSetGameFocus);
    }

    override public function destroy():void {
        this.signal.remove(this.onSetGameFocus);
    }

    private function onSetGameFocus(id:String = ""):void {
        this.view.setFocus(this.getFocusById(id));
    }

    private function getFocusById(id:String):GameObject {
        var object:GameObject = null;
        if (id == "") {
            return this.view.map.player_;
        }
        var objects:Dictionary = this.view.map.goDict_;
        for each(object in objects) {
            if (object.name_ == id) {
                return object;
            }
        }
        return this.view.map.player_;
    }
}
}
</file>

<file path="src/svera/untiered/game/model/AddSpeechBalloonVO.as">
package svera.untiered.game.model {
import com.company.assembleegameclient.objects.GameObject;

public class AddSpeechBalloonVO {


    public var go:GameObject;

    public var text:String;

    public var background:uint;

    public var backgroundAlpha:Number;

    public var outline:uint;

    public var outlineAlpha:uint;

    public var textColor:uint;

    public var lifetime:int;

    public var bold:Boolean;

    public var hideable:Boolean;

    public function AddSpeechBalloonVO(go:GameObject, text:String, background:uint, backgroundAlpha:Number, outline:uint, outlineAlpha:Number, textColor:uint, lifetime:int, bold:Boolean, hideable:Boolean) {
        super();
        this.go = go;
        this.text = text;
        this.background = background;
        this.backgroundAlpha = backgroundAlpha;
        this.outline = outline;
        this.outlineAlpha = outlineAlpha;
        this.textColor = textColor;
        this.lifetime = lifetime;
        this.bold = bold;
        this.hideable = hideable;
    }
}
}
</file>

<file path="src/svera/untiered/game/model/ChatFilter.as">
package svera.untiered.game.model {
import com.company.assembleegameclient.parameters.Parameters;

public class ChatFilter {


    public function ChatFilter() {
        super();
    }

    public function guestChatFilter(name:String):Boolean {
        var show:Boolean = false;
        if (name == null) {
            return true;
        }
        if (name == Parameters.SERVER_CHAT_NAME || name == Parameters.HELP_CHAT_NAME || name == Parameters.ERROR_CHAT_NAME || name == Parameters.CLIENT_CHAT_NAME) {
            show = true;
        }
        if (name.charAt(0) == "#") {
            show = true;
        }
        if (name.charAt(0) == "@") {
            show = true;
        }
        return show;
    }
}
}
</file>

<file path="src/svera/untiered/game/model/GameInitData.as">
package svera.untiered.game.model {
public class GameInitData {
    public var gameId:int;
    public var createCharacter:Boolean;
    public var charId:int;
    public var isNewGame:Boolean;
    public var traits:Array = [-1, -1, -1];

    public function GameInitData() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/game/model/GameModel.as">
package svera.untiered.game.model {
import com.company.assembleegameclient.objects.Player;

public class GameModel {


    public var player:Player;

    public function GameModel() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/game/model/StatModel.as">
package svera.untiered.game.model {
public class StatModel {


    public var name:String;

    public var abbreviation:String;

    public var description:String;

    public var redOnZero:Boolean;

    public function StatModel(name:String, abbreviation:String, description:String, redOnZero:Boolean = true) {
        super();
        this.name = name;
        this.abbreviation = abbreviation;
        this.description = description;
        this.redOnZero = redOnZero;
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/AddSpeechBalloonSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

import svera.untiered.game.model.AddSpeechBalloonVO;

public class AddSpeechBalloonSignal extends Signal {


    public function AddSpeechBalloonSignal() {
        super(AddSpeechBalloonVO);
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/AddTextLineSignal.as">
package svera.untiered.game.signals {
import svera.lib.signals.DeferredQueueSignal;
import svera.untiered.game.model.AddTextLineVO;

public class AddTextLineSignal extends DeferredQueueSignal {


    public function AddTextLineSignal() {
        super(AddTextLineVO);
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/DisconnectGameSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class DisconnectGameSignal extends Signal {


    public function DisconnectGameSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/ExitGameSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class ExitGameSignal extends Signal {


    public function ExitGameSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/GameClosedSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class GameClosedSignal extends Signal {


    public function GameClosedSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/PlayGameSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

import svera.untiered.game.model.GameInitData;

public class PlayGameSignal extends Signal {


    public function PlayGameSignal() {
        super(GameInitData);
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/SetTextBoxVisibilitySignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class SetTextBoxVisibilitySignal extends Signal {


    public function SetTextBoxVisibilitySignal() {
        super(Boolean);
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/SetWorldInteractionSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class SetWorldInteractionSignal extends Signal {


    public function SetWorldInteractionSignal() {
        super(Boolean);
    }
}
}
</file>

<file path="src/svera/untiered/game/signals/UpdateLootboxButtonSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

public class UpdateLootboxButtonSignal extends Signal {


}
}//package svera.untiered.game.signals
</file>

<file path="src/svera/untiered/game/signals/UsePotionSignal.as">
package svera.untiered.game.signals {
import org.osflash.signals.Signal;

import svera.untiered.game.model.UsePotionVO;

public class UsePotionSignal extends Signal {


    public function UsePotionSignal() {
        super(UsePotionVO);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/components/StatMediator.as">
package svera.untiered.game.view.components {
import svera.lib.framework.Mediator;

public class StatMediator extends Mediator {


    [Inject]
    public var view:StatView;

    public function StatMediator() {
        super();
    }

    override public function initialize():void {
    }

    override public function destroy():void {
    }
}
}
</file>

<file path="src/svera/untiered/game/view/components/StatsMediator.as">
package svera.untiered.game.view.components {
import com.company.assembleegameclient.objects.Player;

import svera.lib.framework.Mediator;

import svera.untiered.ui.signals.UpdateHUDSignal;

public class StatsMediator extends Mediator {


    [Inject]
    public var view:StatsView;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    public function StatsMediator() {
        super();
    }

    override public function initialize():void {
        this.updateHUD.add(this.onUpdateHUD);
    }

    override public function destroy():void {
        this.updateHUD.remove(this.onUpdateHUD);
    }

    private function onUpdateHUD(player:Player):void {
        this.view.draw(player);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/MapOverlayMediator.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.map.mapoverlay.MapOverlay;
import com.company.assembleegameclient.map.mapoverlay.SpeechBalloon;

import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.game.model.AddSpeechBalloonVO;
import svera.untiered.game.model.ChatFilter;
import svera.untiered.game.signals.AddSpeechBalloonSignal;

public class MapOverlayMediator extends Mediator {


    [Inject]
    public var view:MapOverlay;

    [Inject]
    public var addSpeechBalloon:AddSpeechBalloonSignal;

    [Inject]
    public var chatFilter:ChatFilter;

    [Inject]
    public var account:Account;

    public function MapOverlayMediator() {
        super();
    }

    override public function initialize():void {
        this.addSpeechBalloon.add(this.onAddSpeechBalloon);
    }

    override public function destroy():void {
        this.addSpeechBalloon.remove(this.onAddSpeechBalloon);
    }

    private function onAddSpeechBalloon(vo:AddSpeechBalloonVO):void {
        var text:String = this.account.isRegistered() || this.chatFilter.guestChatFilter(vo.go.name_) ? vo.text : ". . .";
        this.view.addSpeechBalloon(new SpeechBalloon(vo.go, text, vo.background, vo.backgroundAlpha, vo.outline, vo.outlineAlpha, vo.textColor, vo.lifetime, vo.bold, vo.hideable));
    }
}
}
</file>

<file path="src/svera/untiered/game/view/PortalPanelMediator.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.ui.panels.PortalPanel;

import svera.lib.framework.Mediator;

import svera.untiered.game.signals.ExitGameSignal;

public class PortalPanelMediator extends Mediator {


    [Inject]
    public var view:PortalPanel;

    [Inject]
    public var exitGameSignal:ExitGameSignal;

    public function PortalPanelMediator() {
        super();
    }

    override public function initialize():void {
        this.view.exitGameSignal.add(this.onExitGame);
    }

    private function onExitGame():void {
        this.exitGameSignal.dispatch();
    }

    override public function destroy():void {
        this.view.exitGameSignal.remove(this.onExitGame);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/SellableObjectPanelMediator.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.objects.SellableObject;
import com.company.assembleegameclient.util.Currency;

import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.view.RegisterPromptDialog;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class SellableObjectPanelMediator extends Mediator {

    public static const TEXT:String = "In order to use ${type} you must be a registered user.";


    [Inject]
    public var account:Account;

    [Inject]
    public var view:SellableObjectPanel;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var playerModel:PlayerModel;

    public function SellableObjectPanelMediator() {
        super();
    }

    override public function initialize():void {
        this.view.buyItem.add(this.onBuyItem);
    }

    override public function destroy():void {
        this.view.buyItem.remove(this.onBuyItem);
    }

    private function onBuyItem(item:SellableObject, currencyType:int):void {
        if (this.account.isRegistered()) {
            this.view.gs_.gsc_.buy(item.objectId_, currencyType);
        } else {
            this.openDialog.dispatch(this.makeRegisterDialog(item));
        }
    }

    private function makeRegisterDialog(item:SellableObject):RegisterPromptDialog {
        var text:String = TEXT.replace("${type}", Currency.typeToName(item.currency_));
        return new RegisterPromptDialog(text);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/TextBoxMediator.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.ui.TextBox;

import flash.events.Event;

import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.signals.UpdateAccountInfoSignal;
import svera.untiered.account.web.view.WebRegisterDialog;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.model.AddTextLineVO;
import svera.untiered.game.model.ChatFilter;
import svera.untiered.game.signals.AddTextLineSignal;
import svera.untiered.game.signals.SetTextBoxVisibilitySignal;
import svera.untiered.game.signals.ShowChatInputSignal;

public class TextBoxMediator extends Mediator {


    [Inject]
    public var chatFilter:ChatFilter;

    [Inject]
    public var addTextLine:AddTextLineSignal;

    [Inject]
    public var setTextBoxVisibility:SetTextBoxVisibilitySignal;

    [Inject]
    public var showChatInput:ShowChatInputSignal;

    [Inject]
    public var view:TextBox;

    [Inject]
    public var account:Account;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var updateAccount:UpdateAccountInfoSignal;

    public function TextBoxMediator() {
        super();
    }

    override public function initialize():void {
        this.addTextLine.add(this.onAddTextLine);
        this.setTextBoxVisibility.add(this.onSetTextBoxVisibility);
        this.updateAccount.add(this.onUpdateAccount);
        this.view.setInputTextAllowed(this.account.isRegistered());
        this.view.inputTextClicked.add(this.onInputTextClicked);
        this.view.speechBubbleClicked.add(this.onInputTextClicked);
        this.showChatInput.add(this.view.onShowChatInput);
    }

    override public function destroy():void {
        this.addTextLine.remove(this.onAddTextLine);
        this.setTextBoxVisibility.remove(this.onSetTextBoxVisibility);
        this.updateAccount.remove(this.onUpdateAccount);
        this.view.inputTextClicked.remove(this.onInputTextClicked);
        this.view.speechBubbleClicked.remove(this.onInputTextClicked);
        this.showChatInput.remove(this.view.onShowChatInput);
    }

    private function onAddTextLine(vo:AddTextLineVO):void {
        if (this.account.isRegistered() || this.chatFilter.guestChatFilter(vo.name)) {
            this.view.addTextFull(vo.name, vo.objectId, vo.numStars, vo.recipient, vo.text);
        }
    }

    private function onSetTextBoxVisibility(visible:Boolean):void {
        this.view.textSprite_.visible = visible;
    }

    private function onInputTextClicked(e:Event):void {
        if (!this.account.isRegistered()) {
            this.openDialog.dispatch(new WebRegisterDialog());
        } else {
            this.view.stage.focus = null;
        }
    }

    private function onUpdateAccount():void {
        this.view.setInputTextAllowed(this.account.isRegistered());
    }
}
}
</file>

<file path="src/svera/untiered/honor/service/RequestCharacterHonorTask.as">
package svera.untiered.honor.service {
import com.company.assembleegameclient.ui.dialogs.ErrorDialog;
import com.company.util.DateFormatterReplacement;

import svera.lib.tasks.BaseTask;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.assets.model.CharacterTemplate;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class RequestCharacterHonorTask extends BaseTask {


    [Inject]
    public var client:AppEngineClient;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var classes:ClassesModel;

    public var accountId:int;

    public var charId:int;

    public var xml:XML;

    public var name:String;

    public var level:int;

    public var type:int;

    public var deathDate:String;

    public var killer:String;

    public var totalHonor:int;

    public var template:CharacterTemplate;

    public var texture1:int;

    public var texture2:int;

    public function RequestCharacterHonorTask() {
        super();
    }

    override protected function startTask():void {
        this.sendHonorRequest();
    }

    private function sendHonorRequest():void {
        this.client.setMaxRetries(3);
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("char/honor", this.getDataPacket());
    }

    private function getDataPacket():Object {
        var data:Object = {};
        data.accountId = this.accountId;
        data.charId = this.accountId == -1 ? -1 : this.charId;
        return data;
    }

    private function onComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.parseHonorData(data);
        } else {
            this.onHonorError(data);
        }
    }

    private function parseHonorData(data:String):void {
        this.xml = new XML(data);
        this.parseXML();
        completeTask(true);
    }

    private function parseXML():void {
        var charXml:XML;
        var char:CharacterClass;
        var skin:CharacterSkin;
        charXml = this.xml.Char.(@id == charId)[0];
        this.name = charXml.Account.Name;
        this.level = charXml.Level;
        this.type = charXml.ObjectType;
        this.deathDate = this.getDeathDate();
        this.killer = this.xml.KilledBy || "";
        this.totalHonor = this.xml.TotalHonor;
        char = this.classes.getCharacterClass(charXml.ObjectType);
        skin = Boolean(charXml.hasOwnProperty("Texture")) ? char.skins.getSkin(charXml.Texture) : char.skins.getDefaultSkin();
        this.template = skin.template;
        this.texture1 = Boolean(charXml.hasOwnProperty("Tex1")) ? int(charXml.Tex1) : int(0);
        this.texture2 = Boolean(charXml.hasOwnProperty("Tex2")) ? int(charXml.Tex2) : int(0);
    }

    private function getDeathDate():String {
        var time:Number = Number(this.xml.KilledOn) * 1000;
        var date:Date = new Date(time);
        var df:DateFormatterReplacement = new DateFormatterReplacement();
        df.formatString = "MMMM D, YYYY";
        return df.format(date);
    }

    private function onHonorError(data:String):void {
        this.openDialog.dispatch(new ErrorDialog(data));
    }
}
}
</file>

<file path="src/svera/untiered/honor/view/HonorView.as">
package svera.untiered.honor.view {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.screens.ScoreTextLine;
import com.company.assembleegameclient.screens.ScoringBox;
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.HonorIconBackgroundDesign;
import com.company.untiered.graphics.ScreenGraphic;
import com.company.util.BitmapUtil;
import com.gskinner.motion.GTween;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.DisplayObjectContainer;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.Rectangle;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.ui.view.components.ScreenBase;

public class HonorView extends Sprite {
    private static const CHARACTER_INFO:String = "${NAME}, Level ${LEVEL} ${TYPE}";
    private static const DEATH_INFO_LONG:String = "killed on ${DATE} by ${KILLER}";
    private static const DEATH_INFO_SHORT:String = "died ${DATE}";

    public var closed:Signal;
    private var infoContainer:DisplayObjectContainer;
    private var overlayContainer:Bitmap;
    private var title:SimpleText;
    private var date:SimpleText;
    private var scoringBox:ScoringBox;
    private var finalLine:ScoreTextLine;
    private var continueBtn:TitleMenuOption;
    private var isAnimation:Boolean;
    private var isFadeComplete:Boolean;
    private var isDataPopulated:Boolean;

    public function HonorView() {
        super();
        addChild(new ScreenBase());
        addChild(this.infoContainer = new Sprite());
        addChild(this.overlayContainer = new Bitmap());
        this.continueBtn = new TitleMenuOption("continue", 36, false);
        this.closed = new NativeMappedSignal(this.continueBtn, MouseEvent.CLICK);
    }

    public function setIsAnimation(isAnimation:Boolean):void {
        this.isAnimation = isAnimation;
    }

    public function setBackground(background:BitmapData):void {
        this.overlayContainer.bitmapData = background;
        var tween:GTween = new GTween(this.overlayContainer, 2, {"alpha": 0});
        tween.onComplete = this.onFadeComplete;
    }

    public function clearBackground():void {
        this.overlayContainer.bitmapData = null;
    }

    private function onFadeComplete(tween:GTween):void {
        removeChild(this.overlayContainer);
        this.isFadeComplete = true;
        if (this.isDataPopulated) {
            this.makeContinueButton();
        }
    }

    public function setCharacterInfo(name:String, level:int, type:int):void {
        this.title = new SimpleText(38, 13421772, false, 0, 0);
        this.title.setBold(true);
        this.title.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.title.text = CHARACTER_INFO.replace("${NAME}", name).replace("${LEVEL}", level).replace("${TYPE}", ObjectLibrary.typeToDisplayId_[type]);
        this.title.updateMetrics();
        this.title.x = stage.stageWidth / 2 - this.title.width / 2;
        this.title.y = 225;
        this.infoContainer.addChild(this.title);
    }

    public function setDeathInfo(dateStr:String, killer:String):void {
        this.date = new SimpleText(24, 13421772, false, 0, 0);
        this.date.setBold(true);
        this.date.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.date.text = (Boolean(killer) ? DEATH_INFO_LONG : DEATH_INFO_SHORT).replace("${DATE}", dateStr).replace("${KILLER}", killer);
        this.date.updateMetrics();
        this.date.x = stage.stageWidth / 2 - this.date.width / 2;
        this.date.y = 272;
        this.infoContainer.addChild(this.date);
    }

    public function setIcon(icon:BitmapData):void {
        var backgroundDesign:Sprite;
        var container:Sprite = new Sprite();
        backgroundDesign = new HonorIconBackgroundDesign();
        backgroundDesign.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        container.addChild(backgroundDesign);
        var bitmap:Bitmap = new Bitmap(icon);
        bitmap.x = container.width / 2 - bitmap.width / 2;
        bitmap.y = container.height / 2 - bitmap.height / 2;
        container.addChild(bitmap);
        container.y = 20;
        container.x = stage.stageWidth / 2 - container.width / 2;
        this.infoContainer.addChild(container);
    }

    public function setScore(score:int, xml:XML):void {
        this.scoringBox = new ScoringBox(new Rectangle(0, 0, 784, 150), xml);
        this.scoringBox.x = 8;
        this.scoringBox.y = 316;
        addChild(this.scoringBox);
        this.infoContainer.addChild(this.scoringBox);
        var honorBD:BitmapData = HonorUtil.getHonorIcon();
        honorBD = BitmapUtil.cropToBitmapData(honorBD, 6, 6, honorBD.width - 12, honorBD.height - 12);
        this.finalLine = new ScoreTextLine(24, 13421772, 16762880, "Total Honor Earned", null, score, "", "", new Bitmap(honorBD));
        this.finalLine.x = 10;
        this.finalLine.y = 470;
        this.infoContainer.addChild(this.finalLine);
        this.isDataPopulated = true;
        if (!this.isAnimation || this.isFadeComplete) {
            this.makeContinueButton();
        }
    }

    private function makeContinueButton():void {
        this.infoContainer.addChild(new ScreenGraphic());
        this.continueBtn.x = stage.stageWidth / 2 - this.continueBtn.width / 2;
        this.continueBtn.y = 520;
        this.infoContainer.addChild(this.continueBtn);
        if (this.isAnimation) {
            this.scoringBox.animateScore();
        } else {
            this.scoringBox.showScore();
        }
    }
}
}
</file>

<file path="src/svera/untiered/itemdata/Item.as">
package svera.untiered.itemdata {


public class Item {

    private var _objectType:int;
    public final function get ObjectType():int { return _objectType; }

    private var _id:String = "NO ITEM";
    public final function get Id():String { return _id; }

    private var _displayId:String;
    public final function get DisplayId():String { return _displayId; }

    private var _slotType:int;
    public final function get SlotType():int { return _slotType; }

    private var _tier:int;
    public final function get Tier():int { return _tier; }

    private var _description:String;
    public final function get Description():String { return _description; }

    private var _rateOfFire:Number;
    public final function get RateOfFire():Number { return _rateOfFire; }

    private var _usable:Boolean;
    public final function get Usable():Boolean { return _usable; }

    private var _mpCost:int;
    public final function get MpCost():int { return _mpCost; }

    private var _hpCost:int;
    public final function get HpCost():int { return _hpCost; }

    private var _fabled:Boolean;
    public final function get Fabled():Boolean { return _fabled; }

    private var _legendary:Boolean;
    public final function get Legendary():Boolean { return _legendary; }

    private var _godly:Boolean;
    public final function get Godly():Boolean { return _godly; }

    private var _godSlayer:Boolean;
    public final function get GodSlayer():Boolean { return _godSlayer; }

    private var _tierType:String;
    public final function get TierType():String { return _tierType; }

    private var _containerType:String;
    public final function get ContainerType():String { return _containerType; }

    private var _valuable:Boolean;
    public final function get Valuable():Boolean { return _valuable; }

    private var _tarnished:Boolean;
    public final function get Tarnished():Boolean { return _tarnished; }

    private var _artifact:Boolean;
    public final function get Artifact():Boolean { return _artifact; }

    private var _ancestral:Boolean;
    public final function get Ancestral():Boolean { return _ancestral; }

    private var _valiant:Boolean;
    public final function get Valiant():Boolean { return _valiant; }

    private var _relic:Boolean;
    public final function get Relic():Boolean { return _relic; }

    private var _exiled:Boolean;
    public final function get Exiled():Boolean { return _exiled; }

    private var _celestial:Boolean;
    public final function get Celestial():Boolean { return _celestial; }

    private var _shard:Boolean;
    public final function get Shard():Boolean { return _shard; }

    private var _fragment:Boolean;
    public final function get Fragment():Boolean { return _fragment; }

    private var _ascended:Boolean;
    public final function get Ascended():Boolean { return _ascended; }

    private var _multiPhase:Boolean;
    public final function get MultiPhase():Boolean { return _multiPhase; }

    private var _honorBonus:int;
    public final function get HonorBonus():int { return _honorBonus; }

    private var _numProjectiles:int;
    public final function get NumProjectiles():int { return _numProjectiles; }

    private var _halfHPArmored:Boolean;
    public final function get HalfHPArmored():Boolean { return _halfHPArmored; }

    private var _arcGap:Number;
    public final function get ArcGap():Number { return _arcGap; }

    private var _arcGap1:Number;
    public final function get ArcGap1():Number { return _arcGap1; }

    private var _arcGap2:Number;
    public final function get ArcGap2():Number { return _arcGap2; }

    private var _numProjectiles1:int;
    public final function get NumProjectiles1():int { return _numProjectiles1; }

    private var _numProjectiles2:int;
    public final function get NumProjectiles2():int { return _numProjectiles2; }

    private var _dualShooting:Boolean;
    public final function get DualShooting():Boolean { return _dualShooting; }

    private var _consumable:Boolean;
    public final function get Consumable():Boolean { return _consumable; }

    private var _invUse:Boolean;
    public final function get InvUse():Boolean { return _invUse; }

    private var _reUse:Boolean;
    public final function get ReUse():Boolean { return _reUse; }

    private var _potion:Boolean;
    public final function get Potion():Boolean { return _potion; }

    private var _doses:int;
    public final function get Doses():int { return _doses; }

    private var _successorId:String;
    public final function get SuccessorId():String { return _successorId; }

    private var _soulbound:Boolean;
    public function get Soulbound():Boolean { return _soulbound; }

    private var _undead:Boolean;
    public final function get Undead():Boolean { return _undead; }

    private var _pUndead:Boolean;
    public final function get PUndead():Boolean { return _pUndead; }

    private var _sUndead:Boolean;
    public final function get SUndead():Boolean { return _sUndead; }

    private var _secret:Boolean;
    public final function get Secret():Boolean { return _secret; }

    private var _cooldown:Number;
    public final function get Cooldown():Number { return _cooldown; }

    private var _resurrects:Boolean;
    public final function get Resurrects():Boolean { return _resurrects; }

    private var _texture1:int;
    public final function get Texture1():int { return _texture1; }

    private var _texture2:int;
    public final function get Texture2():int { return _texture2; }

    private var _statBoosts:Array;
    public final function get StatBoosts():Array { return _statBoosts; }

    private var _statBoostsPerc:Array;
    public final function get StatBoostsPerc():Array { return _statBoostsPerc; }

    private var _projectiles:Array;
    public final function get Projectiles():Array { return _projectiles; }

    private var _activateEffects:Array;
    public final function get ActivateEffects():Array { return _activateEffects; }

    private var _steal:Array;
    public final function get Steal():Array { return _steal; }

    private var _effectEquip:Array;
    public final function get EffectEquip():Array { return _effectEquip; }

    private var _exiledEffect:String;
    public final function get ExiledEffect():String { return _exiledEffect; }

    private var _valiantEffect:String;
    public final function get ValiantEffect():String { return _valiantEffect; }

    private var _scale:int;
    public final function get Scale():int { return _scale; }

    private var _setName:String;
    public final function get SetName():String { return _setName; }

    private var _rt:Boolean;
    public final function get RT():Boolean { return _rt; }

    private var _fabledToken:Boolean;
    public final function get FabledToken():Boolean { return _fabledToken; }

    private var _origin:String;
    public final function get Origin():String { return _origin; }

    private var _questItem:Boolean;
    public final function get QuestItem():Boolean { return _questItem; }

    private var _extraToolTipData:Array;
    public final function get ExtraToolTipData():Array { return _extraToolTipData; }

    private var _transmogData:Object;
    public final function get TransmogData():Object { return _transmogData; }

    public function Item(item:Item) {
        if (item == null) return;

        _objectType = item._objectType;
        _id = item._id;
        _displayId = item._displayId;
        _slotType = item._slotType;
        _tier = item._tier;
        _description = item._description;
        _rateOfFire = item._rateOfFire;
        _usable = item._usable;
        _mpCost = item._mpCost;
        _hpCost = item._hpCost;
        _fabled = item._fabled;
        _legendary = item._legendary;
        _godly = item._godly;
        _godSlayer = item._godSlayer;
        _tierType = item._tierType;
        _containerType = item._containerType;
        _valuable = item._valuable;
        _tarnished = item._tarnished;
        _artifact = item._artifact;
        _ancestral = item._ancestral;
        _valiant = item._valiant;
        _relic = item._relic;
        _exiled = item._exiled;
        _celestial = item._celestial;
        _shard = item._shard;
        _fragment = item._fragment;
        _ascended = item._ascended;
        _multiPhase = item._multiPhase;
        _honorBonus = item._honorBonus;
        _numProjectiles = item._numProjectiles;
        _halfHPArmored = item._halfHPArmored;
        _arcGap = item._arcGap;
        _arcGap1 = item._arcGap1;
        _arcGap2 = item._arcGap2;
        _numProjectiles1 = item._numProjectiles1;
        _numProjectiles2 = item._numProjectiles2;
        _dualShooting = item._dualShooting;
        _consumable = item._consumable;
        _invUse = item._invUse;
        _reUse = item._reUse;
        _potion = item._potion;
        _doses = item._doses;
        _successorId = item._successorId;
        _soulbound = item._soulbound;
        _undead = item._undead;
        _pUndead = item._pUndead;
        _sUndead = item._sUndead;
        _secret = item._secret;
        _cooldown = item._cooldown;
        _resurrects = item._resurrects;
        _texture1 = item._texture1;
        _texture2 = item._texture2;

        _statBoosts = item._statBoosts;
        _statBoostsPerc = item._statBoostsPerc;

        _projectiles = item._projectiles;
        _activateEffects = item._activateEffects;
        _steal = item._steal;
        _effectEquip = item._effectEquip;

        _exiledEffect = item._exiledEffect;
        _valiantEffect = item._valiantEffect;

        _scale = item._scale;
        _setName = item._setName;
        _rt = item._rt;
        _fabledToken = item._fabledToken;
        _origin = item._origin;
        _questItem = item._questItem;

        _extraToolTipData = item._extraToolTipData;

        _transmogData = item._transmogData;
    }

    public static function parseFromXml(xml:XML):Item {
        var item:Item = new Item(null);
        var elem:XML;
        item._objectType = int(xml.@type);
        item._id = String(xml.@id);
        item._displayId = LinkUtils.parseElementString(xml, "DisplayId", item._id);
        item._slotType = LinkUtils.parseElementInt(xml, "SlotType", -1);
        item._tier = LinkUtils.parseElementInt(xml, "Tier", -1);
        item._description = LinkUtils.parseElementString(xml, "Description");
        item._rateOfFire = LinkUtils.parseElementFloat(xml, "RateOfFire", 1.0);
        item._usable = LinkUtils.parseElementBool(xml, "Usable");
        item._mpCost = LinkUtils.parseElementInt(xml, "MpCost");
        item._hpCost = LinkUtils.parseElementInt(xml, "HpCost");
        item._fabled = LinkUtils.parseElementBool(xml, "Fabled");
        item._legendary = LinkUtils.parseElementBool(xml, "Legendary");
        item._godly = LinkUtils.parseElementBool(xml, "Godly");
        item._godSlayer = LinkUtils.parseElementBool(xml, "GodSlayer");
        item._tierType = LinkUtils.parseElementString(xml, "TierType");
        item._containerType = LinkUtils.parseElementString(xml, "ContainerType");
        item._valuable = LinkUtils.parseElementBool(xml, "Valuable");
        item._tarnished = LinkUtils.parseElementBool(xml, "Tarnished");
        item._artifact = LinkUtils.parseElementBool(xml, "Artifact");
        item._ancestral = LinkUtils.parseElementBool(xml, "Ancestral");
        item._valiant = LinkUtils.parseElementBool(xml, "Valiant");
        item._relic = LinkUtils.parseElementBool(xml, "Relic");
        item._exiled = LinkUtils.parseElementBool(xml, "Exiled");
        item._celestial = LinkUtils.parseElementBool(xml, "Celestial");
        item._shard = LinkUtils.parseElementBool(xml, "Shard");
        item._fragment = LinkUtils.parseElementBool(xml, "Fragment");
        item._ascended = LinkUtils.parseElementBool(xml, "Ascended");
        item._multiPhase = LinkUtils.parseElementBool(xml, "MultiPhase");
        item._honorBonus = LinkUtils.parseElementInt(xml, "HonorBonus");
        item._numProjectiles = LinkUtils.parseElementInt(xml, "NumProjectiles", 1);
        item._halfHPArmored = LinkUtils.parseElementBool(xml, "HalfHPArmored");
        item._arcGap = LinkUtils.parseElementFloat(xml, "ArcGap", 11.25);
        item._arcGap1 = LinkUtils.parseElementFloat(xml, "ArcGap1", 11.25);
        item. _arcGap2 = LinkUtils.parseElementFloat(xml, "ArcGap2", 11.25);
        item._numProjectiles1 = LinkUtils.parseElementInt(xml, "NumProjectiles1", 1);
        item._numProjectiles2 = LinkUtils.parseElementInt(xml, "NumProjectiles2", 1);
        item._dualShooting = LinkUtils.parseElementBool(xml, "DualShooting");
        item._consumable = LinkUtils.parseElementBool(xml, "Consumable");
        item._invUse = LinkUtils.parseElementBool(xml, "InvUse");
        item._reUse = LinkUtils.parseElementBool(xml, "ReUse");
        item._potion = LinkUtils.parseElementBool(xml, "Potion");
        item._doses = LinkUtils.parseElementInt(xml, "Doses");
        item._successorId = LinkUtils.parseElementString(xml, "SuccessorId");
        item._soulbound = LinkUtils.parseElementBool(xml, "Soulbound");
        item._undead = LinkUtils.parseElementBool(xml, "Undead");
        item._pUndead = LinkUtils.parseElementBool(xml, "PUndead");
        item._sUndead = LinkUtils.parseElementBool(xml, "SUndead");
        item._secret = LinkUtils.parseElementBool(xml, "Secret");
        item._cooldown = LinkUtils.parseElementFloat(xml, "Cooldown", 0.5) * 1000;
        item._resurrects = LinkUtils.parseElementBool(xml, "Resurrects");
        item._texture1 = LinkUtils.parseElementInt(xml, "Tex1", 0, 16);
        item._texture2 = LinkUtils.parseElementInt(xml, "Tex2", 0, 16);

        item._statBoosts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        item._statBoostsPerc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for each (elem in xml.elements("ActivateOnEquip")) {
            var statIndex:int = LinkUtils.getStatIndex(LinkUtils.parseAttributeInt(elem, "@stat"));
            var amount:int = LinkUtils.parseAttributeInt(elem, "@amount");
            if (LinkUtils.parseAttributeBool(elem, "@isPerc")) {
                item._statBoostsPerc[statIndex] = amount;
            } else {
                item._statBoosts[statIndex] = amount;
            }
        }

        item._projectiles = [];
        for each (elem in xml.elements("Projectile")) {
            var proj:ProjectileData = ProjectileData.parseFromXml(elem);
            item._projectiles[proj.BulletType] = proj;
        }

        item._activateEffects = [];
        var index:int = 0;
        for each (elem in xml.elements("Activate")) {
            item._activateEffects[index] = ActivateEffectsData.parseFromXml(elem, index);
            index++;
        }

        item._steal = [0, 0];
        for each (elem in xml.elements("Steal")) {
            var idx:int = LinkUtils.parseAttributeString(elem, "@type") == "life" ? 0 : 1;
            item._steal[idx] = LinkUtils.parseAttributeInt(elem, "@amount");
        }

        item._effectEquip = [];
        for each (elem in xml.elements("EffectEquip")) {
            item._effectEquip.push({
                "Effect": LinkUtils.parseAttributeString(elem, "@effect"),
                "Delay": LinkUtils.parseAttributeInt(elem, "@delay")
            });
        }

        item._exiledEffect = LinkUtils.parseAttributeFromElementString(xml, "Exiled", "@id");
        item._valiantEffect = LinkUtils.parseAttributeFromElementString(xml, "Valiant", "@id");

        // Client specific
        item._scale = LinkUtils.parseElementInt(xml, "ScaleValue", 5);
        item._setName = LinkUtils.parseAttributeString(xml, "@setName");
        item._rt = LinkUtils.parseElementBool(xml, "RT");
        item. _fabledToken = LinkUtils.parseElementBool(xml, "FabledToken");
        item._origin = LinkUtils.parseElementString(xml, "Origin");
        item._questItem = LinkUtils.parseElementBool(xml, "QuestItem");

        item._extraToolTipData = [];
        if (xml.hasOwnProperty("ExtraTooltipData")) {
            var subXml:XMLList = xml.child("ExtraTooltipData");
            for each (elem in subXml.elements("EffectInfo")) {
                item._extraToolTipData.push({
                    "Name": LinkUtils.parseAttributeString(elem, "@name"),
                    "Description": LinkUtils.parseAttributeString(elem, "@description")
                });
            }
        }

        if (xml.hasOwnProperty("TransmogData")) {
            var mog:XML = xml.elements("TransmogData")[0];
            item._transmogData = {
                "Id": LinkUtils.parseAttributeInt(mog, "@id", -1, 16),
                "Slot": LinkUtils.parseAttributeInt(mog, "@slot", -1),
                "ObjType": LinkUtils.parseAttributeInt(mog, "@type", -1, 16),
                "Tier": LinkUtils.parseAttributeString(mog, "@tier")
            };
        }

        return item;
    }
}
}
</file>

<file path="src/svera/untiered/legends/control/ExitLegendsCommand.as">
package svera.untiered.legends.control {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import svera.lib.framework.ICommand;

import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.death.model.DeathModel;
import svera.untiered.ui.view.TitleView;

public class ExitLegendsCommand implements ICommand {


    [Inject]
    public var model:DeathModel;

    [Inject]
    public var invalidate:InvalidateDataSignal;

    [Inject]
    public var setScreen:SetScreenWithValidDataSignal;

    public function ExitLegendsCommand() {
        super();
    }

    public function execute():void {
        if (this.model.getIsDeathViewPending()) {
            this.clearRecentlyDeceasedAndGotoCharacterView();
        } else {
            this.gotoTitleView();
        }
    }

    private function clearRecentlyDeceasedAndGotoCharacterView():void {
        this.model.clearPendingDeathView();
        this.invalidate.dispatch();
        this.setScreen.dispatch(new CharacterSelectionAndNewsScreen());
    }

    private function gotoTitleView():void {
        this.setScreen.dispatch(new TitleView());
    }
}
}
</file>

<file path="src/svera/untiered/legends/control/ExitLegendsSignal.as">
package svera.untiered.legends.control {
import org.osflash.signals.Signal;

public class ExitLegendsSignal extends Signal {


    public function ExitLegendsSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/legends/view/LegendsTab.as">
package svera.untiered.legends.view {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.legends.model.Timespan;

public class LegendsTab extends Sprite {

    private static const OVER_COLOR:int = 16567065;

    private static const DOWN_COLOR:int = 16777215;

    private static const OUT_COLOR:int = 11711154;


    public const selected:Signal = new Signal(LegendsTab);

    private var timespan:Timespan;

    private var label:SimpleText;

    private var isOver:Boolean;

    private var isDown:Boolean;

    private var isSelected:Boolean;

    public function LegendsTab(timespan:Timespan) {
        super();
        this.timespan = timespan;
        this.makeLabel(timespan);
        this.addMouseListeners();
        this.redraw();
    }

    public function getTimespan():Timespan {
        return this.timespan;
    }

    private function makeLabel(timespan:Timespan):void {
        this.label = new SimpleText(20, 16777215, false, 0, 0);
        this.label.setBold(true);
        this.label.text = timespan.getName();
        this.label.updateMetrics();
        this.label.x = 2;
        addChild(this.label);
    }

    private function addMouseListeners():void {
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    private function onClick(event:MouseEvent):void {
        this.selected.dispatch(this);
    }

    private function redraw():void {
        if (this.isOver) {
            this.label.setColor(OVER_COLOR);
        } else if (this.isSelected || this.isDown) {
            this.label.setColor(DOWN_COLOR);
        } else {
            this.label.setColor(OUT_COLOR);
        }
    }

    public function setIsSelected(isSelected:Boolean):void {
        this.isSelected = isSelected;
        this.redraw();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.isOver = true;
        this.redraw();
    }

    private function onMouseOut(event:MouseEvent):void {
        this.isOver = false;
        this.isDown = false;
        this.redraw();
    }

    private function onMouseDown(event:MouseEvent):void {
        this.isDown = true;
        this.redraw();
    }

    private function onMouseUp(event:MouseEvent):void {
        this.isDown = false;
        this.redraw();
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/content/MemMarketSellItem.as">
package svera.untiered.memMarket.content {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.util.Currency;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.text.TextFieldAutoSize;

import svera.untiered.assets.services.IconFactory;

import svera.untiered.memMarket.utils.DialogUtils;

import svera.untiered.memMarket.utils.IconUtils;

import svera.untiered.messaging.impl.data.MarketData;

public class MemMarketSellItem extends MemMarketItem
{
    private var removeButton_:TextButton;
    private var priceText_:SimpleText;
    private var timeText_:SimpleText;
    private var currency_:Bitmap;

    public function MemMarketSellItem(gameSprite:GameSprite, data:MarketData)
    {
        super(gameSprite, OFFER_WIDTH, OFFER_HEIGHT, 80, data.itemType_, data);
        this.icon_.x = 22;
        this.icon_.y = -8;

        this.removeButton_ = new TextButton(10, "Remove", 96);
        this.removeButton_.x = 2;
        this.removeButton_.y = 62;
        this.removeButton_.addEventListener(MouseEvent.CLICK, this.onRemoveClick);
        addChild(this.removeButton_);

        this.priceText_ = new SimpleText(10, 0xFFFFFF, false, width, 0);
        this.priceText_.setBold(true);
        this.priceText_.htmlText = "<p align=\"center\">" + this.data_.price_ + "</p>";
        this.priceText_.wordWrap = true;
        this.priceText_.multiline = true;
        this.priceText_.autoSize = TextFieldAutoSize.CENTER;
        this.priceText_.y = 49;
        addChild(this.priceText_);

        var unix:Number = this.data_.timeLeft_ * 1000;
        var later:Date = new Date(unix);
        var now:Date = new Date();
        var ms:Number = Math.floor(later.time - now.time);
        var hours:Number = ms / 3600000;
        this.timeText_ = new SimpleText(10, 0xFFFFFF, false, width, 0);
        this.timeText_.setBold(true);
        this.timeText_.htmlText = "<p align=\"center\">" + hours.toFixed(1) + "h</p>";
        this.timeText_.wordWrap = true;
        this.timeText_.multiline = true;
        this.timeText_.autoSize = TextFieldAutoSize.CENTER;
        this.timeText_.y = 39;
        addChild(this.timeText_);

        this.currency_ = new Bitmap(IconFactory.makeHonor());
        this.currency_.x = 76;
        this.currency_.y = 38;
        addChild(this.currency_);
    }

    private function onRemoveClick(event:MouseEvent) : void
    {
        DialogUtils.makeCallbackDialog(this.gameSprite_, "Verification", "Are you sure you want to remove this item?", "Yes", "No", this.onVerified);
    }

    private function onVerified(event:Event) : void
    {
        this.gameSprite_.gsc_.marketRemove(this.id_);
    }

    /* Clear */
    public override function dispose() : void
    {
        this.removeButton_.removeEventListener(MouseEvent.CLICK, this.onRemoveClick);
        this.removeButton_ = null;
        this.priceText_ = null;
        this.timeText_ = null;
        this.currency_ = null;

        super.dispose();
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/signals/MemMarketAddSignal.as">
package svera.untiered.memMarket.signals {
import svera.untiered.messaging.impl.incoming.market.MarketAddResult;

import org.osflash.signals.Signal;

public class MemMarketAddSignal extends Signal
{
    public static var instance:MemMarketAddSignal;

    public function MemMarketAddSignal()
    {
        super(MarketAddResult);
        instance = this;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/signals/MemMarketBuySignal.as">
package svera.untiered.memMarket.signals {
import svera.untiered.messaging.impl.incoming.market.MarketBuyResult;

import org.osflash.signals.Signal;

public class MemMarketBuySignal extends Signal
{
    public static var instance:MemMarketBuySignal;

    public function MemMarketBuySignal()
    {
        super(MarketBuyResult);
        instance = this;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/signals/MemMarketMyOffersSignal.as">
package svera.untiered.memMarket.signals {
import svera.untiered.messaging.impl.incoming.market.MarketMyOffersResult;

import org.osflash.signals.Signal;

public class MemMarketMyOffersSignal extends Signal
{
    public static var instance:MemMarketMyOffersSignal;

    public function MemMarketMyOffersSignal()
    {
        super(MarketMyOffersResult);
        instance = this;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/signals/MemMarketRemoveSignal.as">
package svera.untiered.memMarket.signals {
import svera.untiered.messaging.impl.incoming.market.MarketRemoveResult;

import org.osflash.signals.Signal;

public class MemMarketRemoveSignal extends Signal
{
    public static var instance:MemMarketRemoveSignal;

    public function MemMarketRemoveSignal()
    {
        super(MarketRemoveResult);
        instance = this;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/signals/MemMarketSearchSignal.as">
package svera.untiered.memMarket.signals {
import svera.untiered.messaging.impl.incoming.market.MarketSearchResult;

import org.osflash.signals.Signal;

public class MemMarketSearchSignal extends Signal
{
    public static var instance:MemMarketSearchSignal;

    public function MemMarketSearchSignal()
    {
        super(MarketSearchResult);
        instance = this;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/utils/DialogUtils.as">
package svera.untiered.memMarket.utils {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.dialogs.Dialog;

import flash.events.Event;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class DialogUtils
{
    /* Creates and adds an error dialog to the overlay */
    public static function makeSimpleDialog(gameSprite:GameSprite, title:String, description:String) : void
    {
        var dialog:Dialog = new Dialog(title, description, "Close", null);
        dialog.addEventListener(Dialog.LEFT_BUTTON, onDialogClose);
        (StaticInjectorContext.injector.getInstance(OpenDialogSignal) as OpenDialogSignal).dispatch(dialog);

    }

    /* Creates and adds a confirm dialog to the overlay */
    public static function makeCallbackDialog(gameSprite:GameSprite, title:String, description:String, textOne:String, textTwo:String,  callback:Function) : void
    {
        var dialog:Dialog = new Dialog(title, description, textOne, textTwo);
        dialog.addEventListener(Dialog.LEFT_BUTTON, callback); /* Should probably remove this as it could potentially cause a memory leak if used often */
        dialog.addEventListener(Dialog.LEFT_BUTTON, onDialogClose); /* Add this so we dont have to provide closing callback */
        dialog.addEventListener(Dialog.RIGHT_BUTTON, onDialogClose);
        (StaticInjectorContext.injector.getInstance(OpenDialogSignal) as OpenDialogSignal).dispatch(dialog);

    }

    /* Removes the dialog made by the above two functions */
    private static function onDialogClose(event:Event) : void
    {
        var dialog:Dialog = event.currentTarget as Dialog;
        dialog.removeEventListener(Dialog.LEFT_BUTTON, onDialogClose);
        dialog.removeEventListener(Dialog.RIGHT_BUTTON, onDialogClose);
        dialog.parent.removeChild(dialog);
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/utils/IconUtils.as">
package svera.untiered.memMarket.utils
{
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;

public class IconUtils
{
    /* Draw the honor icon */
    public static function getHonorIcon(size:int = 40) : BitmapData
    {
        var honorBD:BitmapData = AssetLibrary.getImageFromSet("lofiObj3",224);
        return TextureRedrawer.redraw(honorBD,size,true,0);
    }

    /* Draw the gold icon */
    public static function getCoinIcon(size:int = 40) : BitmapData
    {
        var honorBD:BitmapData = AssetLibrary.getImageFromSet("lofiObj3",225);
        return TextureRedrawer.redraw(honorBD,size,true,0);
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/utils/SortUtils.as">
package svera.untiered.memMarket.utils {
import com.company.assembleegameclient.objects.ObjectLibrary;

import svera.untiered.memMarket.MemMarket;
import svera.untiered.memMarket.content.MemMarketItem;

public class SortUtils
{
    /* Sorting options */
    public static const LOWEST_TO_HIGHEST:String = "Lowest -> Highest";
    public static const HIGHEST_TO_LOWEST:String = "Highest -> Lowest";
    public static const JUST_ADDED:String = "Just added";
    public static const ENDING_SOON:String = "Ending soon";

    public static const ALLTIERS:String = "All Tiers";
    public static const TARNISHED:String = "Tarnished";
    public static const ARTIFACT:String = "Artifact";
    public static const VALIANT:String = "Valiant";
    public static const RELIC:String = "Relic";
    public static const EXILED:String = "Exiled";

    public static const ALLSTATS:String = "All Stats";
    public static const HP:String = "Health";
    public static const MP:String = "Mana";
    public static const ATK:String = "Attack";
    public static const DEF:String = "Dmg R";
    public static const SPD:String = "Speed";
    public static const VIT:String = "Vigor";
    public static const WIS:String = "Intellect";
    public static const DEX:String = "Dexterity";
    public static const FRT:String = "Fortune";
    public static const MGT:String = "Crit D";
    public static const LCK:String = "Crit C";
    public static const RES:String = "Restoration";
    public static const PRT:String = "Overshield";

    public static const ALLITEMTYPES:String = "All Types";
    public static const SWORD:String = "Sword";
    public static const DAGGER:String = "Dagger";
    public static const BOW:String = "Bow";
    public static const WAND:String = "Wand";
    public static const STAFF:String = "Staff";
    public static const KATANA:String = "Katana";
    public static const LANCE:String = "Lance";
    public static const BLADES:String = "Blades";
    public static const LIGHTARMOR:String = "L-Armor";
    public static const MEDIUMARMOR:String = "M-Armor";
    public static const HEAVYARMOR:String = "H-Armor";
    public static const TOME:String = "Tome";
    public static const SHIELD:String = "Shield";
    public static const SPELL:String = "Spell";
    public static const SEAL:String = "Seal";
    public static const CLOAK:String = "Cloak";
    public static const QUIVER:String = "Quiver";
    public static const HELMET:String = "Helmet";
    public static const POISON:String = "Poison";
    public static const SKULL:String = "Skull";
    public static const TRAP:String = "Trap";
    public static const ORB:String = "Orb";
    public static const PRISM:String = "Prism";
    public static const SCEPTER:String = "Scepter";
    public static const SHURIKEN:String = "Shuriken";
    public static const SHEATH:String = "Sheath";
    public static const BANNER:String = "Banner";
    public static const SIPHON:String = "Siphon";
    public static const CHARM:String = "Charm";
    public static const DICE:String = "Dice";
    public static const JACKET:String = "Jacket";
    public static const TALISMAN:String = "Talisman";
    public static const ACCESSORY:String = "Accessory";
    public static const INGREDIENT:String = "Ingredients";
    public static const UTILITY:String = "Utility";
    public static const CAPSULE:String = "Capsule";

    public static const SORT_CHOICES:Vector.<String> = new <String>
    [
        LOWEST_TO_HIGHEST,
        HIGHEST_TO_LOWEST,
        //FAME_TO_GOLD,
        //GOLD_TO_FAME,
        JUST_ADDED,
        ENDING_SOON
    ];
    public static const TIER_SORT_CHOICES:Vector.<String> = new <String>
    [
        ALLTIERS,
        TARNISHED,
        ARTIFACT,
        VALIANT,
        RELIC,
        EXILED
    ];
    public static const STAT_SORT_CHOICES:Vector.<String> = new <String>
    [
        ALLSTATS,
        HP,
        MP,
        ATK,
        DEF,
        SPD,
        VIT,
        WIS,
        DEX,
        FRT,
        MGT,
        LCK,
        RES,
        PRT
    ];
    public static const ITEMTYPE_SORT_CHOICES:Vector.<String> = new <String>
    [
        ALLITEMTYPES,
        SWORD,
        DAGGER,
        BOW,
        WAND,
        STAFF,
        KATANA,
        LANCE,
        BLADES,
        LIGHTARMOR,
        MEDIUMARMOR,
        HEAVYARMOR,
        TOME,
        SHIELD,
        SPELL,
        SEAL,
        CLOAK,
        QUIVER,
        HELMET,
        POISON,
        SKULL,
        TRAP,
        ORB,
        PRISM,
        SCEPTER,
        SHURIKEN,
        SHEATH,
        BANNER,
        SIPHON,
        CHARM,
        DICE,
        JACKET,
        TALISMAN,
        ACCESSORY,
        INGREDIENT,
        UTILITY,
        CAPSULE
    ];
    public static function lowestToHighest(itemA:MemMarketItem, itemB:MemMarketItem) : int
    {
        if (itemA.data_.price_ < itemB.data_.price_)
        {
            return -1;
        }
        else if (itemA.data_.price_ > itemB.data_.price_)
        {
            return 1;
        }
        else return 0;
    }

    public static function highestToLowest(itemA:MemMarketItem, itemB:MemMarketItem) : int
    {
        if (itemA.data_.price_ < itemB.data_.price_)
        {
            return 1;
        }
        else if (itemA.data_.price_ > itemB.data_.price_)
        {
            return -1;
        }
        else return 0;
    }

    /*public static function honorToGold(itemA:MemMarketItem, itemB:MemMarketItem) : int
    {
        if (itemA.data_.currency_ < itemB.data_.currency_)
        {
            return 1;
        }
        else if (itemA.data_.currency_ > itemB.data_.currency_)
        {
            return -1;
        }
        else return 0;
    }

    public static function goldToHonor(itemA:MemMarketItem, itemB:MemMarketItem) : int
    {
        if (itemA.data_.currency_ < itemB.data_.currency_)
        {
            return -1;
        }
        else if (itemA.data_.currency_ > itemB.data_.currency_)
        {
            return 1;
        }
        else return 0;
    } */

    public static function justAdded(itemA:MemMarketItem, itemB:MemMarketItem) : int
    {
        if (itemA.data_.startTime_ < itemB.data_.startTime_)
        {
            return 1;
        }
        else if (itemA.data_.startTime_ > itemB.data_.startTime_)
        {
            return -1;
        }
        else return 0;
    }

    public static function endingSoon(itemA:MemMarketItem, itemB:MemMarketItem) : int
    {
        if (itemA.data_.timeLeft_ < itemB.data_.timeLeft_)
        {
            return -1;
        }
        else if (itemA.data_.timeLeft_ > itemB.data_.timeLeft_)
        {
            return 1;
        }
        else return 0;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/GroundTileData.as">
package svera.untiered.messaging.impl.data {
import flash.utils.IDataInput;

public class GroundTileData {


    public var x_:int;

    public var y_:int;

    public var type_:uint;

    public function GroundTileData() {
        super();
    }

    public function parseFromInput(data:IDataInput):void {
        this.x_ = data.readShort();
        this.y_ = data.readShort();
        this.type_ = data.readUnsignedShort();
    }

    public function toString():String {
        return "x_: " + this.x_ + " y_: " + this.y_ + " type_:" + this.type_;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/ObjectData.as">
package svera.untiered.messaging.impl.data {
import flash.utils.IDataInput;

public class ObjectData {


    public var objectType_:int;

    public var status_:ObjectStatusData;

    public function ObjectData() {
        this.status_ = new ObjectStatusData();
        super();
    }

    public function parseFromInput(data:IDataInput):void {
        this.objectType_ = data.readUnsignedShort();
        this.status_.parseFromInput(data);
    }

    public function toString():String {
        return "objectType_: " + this.objectType_ + " status_: " + this.status_;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/SlotObjectData.as">
package svera.untiered.messaging.impl.data {
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

public class SlotObjectData {
    public var objectId_:int;

    public var slotId_:int;

    public function SlotObjectData() {
        super();
    }

    public function parseFromInput(data:IDataInput):void {
        this.objectId_ = data.readInt();
        this.slotId_ = data.readUnsignedByte();
    }

    public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.objectId_);
        data.writeByte(this.slotId_);
    }

    public function toString():String {
        return "objectId_: " + this.objectId_ + " slotId_: " + this.slotId_;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/WorldPosData.as">
package svera.untiered.messaging.impl.data {
import flash.geom.Point;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

public class WorldPosData {


    public var x_:Number;

    public var y_:Number;

    public function WorldPosData() {
        super();
    }

    public function toPoint():Point {
        return new Point(this.x_, this.y_);
    }

    public function parseFromInput(data:IDataInput):void {
        this.x_ = data.readFloat();
        this.y_ = data.readFloat();
    }

    public function writeToOutput(data:IDataOutput):void {
        data.writeFloat(this.x_);
        data.writeFloat(this.y_);
    }

    public function toString():String {
        return "x_: " + this.x_ + " y_: " + this.y_;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/AllyShoot.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class AllyShoot extends IncomingMessage {
    public var ownerId_:int;
    public var containerType_:int;
    public var angle_:Number;

    public function AllyShoot(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.ownerId_ = data.readInt();
        this.containerType_ = data.readShort();
        this.angle_ = data.readFloat();
    }

    override public function toString():String {
        return formatToString("ALLYSHOOT", "ownerId_", "containerType_", "angle_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Aoe.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class Aoe extends IncomingMessage {


    public var pos_:WorldPosData;

    public var radius_:Number;

    public var damage_:int;

    public var effect_:int;

    public var color_:int;

    public function Aoe(id:uint, callback:Function) {
        this.pos_ = new WorldPosData();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.pos_.parseFromInput(data);
        this.radius_ = data.readFloat();
        this.damage_ = data.readUnsignedShort();
        this.effect_ = data.readUnsignedByte();
        this.color_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("AOE", "pos_", "radius_", "damage_", "effect_", "color_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/BuyResult.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class BuyResult extends IncomingMessage {
    public static const SUCCESS_BRID:int = 0;

    public static const DIALOG_BRID:int = 1;

    private static const resultStrings:Object = {
        0: "Purchase successful",
        1: "Cannot purchase items as a guest",
        2: "Insufficient rank",
        3: "Insufficient funds",
        4: "Can't buy items on a test map",
        5: "Uninitialized",
        6: "Transaction failed",
        7: "Item is currently being purchased",
        8: "Admins can't buy player sold items"
    }


    public var result_:int;

    public var resultString_:String;

    public function BuyResult(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.result_ = data.readByte();
        this.resultString_ = resultStrings[data.readByte()];
    }

    override public function toString():String {
        return formatToString("BUYRESULT", "result_", "resultString_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/CreateSuccess.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class CreateSuccess extends IncomingMessage {


    public var objectId_:int;

    public var charId_:int;

    public function CreateSuccess(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.objectId_ = data.readInt();
        this.charId_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("CREATE_SUCCESS", "objectId_", "charId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Damage.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class Damage extends IncomingMessage {
    public var targetId_:int;
    public var effects_:Vector.<uint>;
    public var damageAmount_:int;

    public function Damage(id:uint, callback:Function) {
        this.effects_ = new Vector.<uint>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.targetId_ = data.readInt();
        this.effects_.length = 0;
        var len:int = data.readUnsignedByte();
        for (var i:uint = 0; i < len; i++) {
            this.effects_.push(data.readUnsignedByte());
        }
        this.damageAmount_ = data.readUnsignedShort();
    }

    override public function toString():String {
        return formatToString("DAMAGE", "targetId_", "effects_", "damageAmount_", "bulletId_", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Death.as">
package svera.untiered.messaging.impl.incoming {
import flash.display.BitmapData;
import flash.utils.IDataInput;

public class Death extends IncomingMessage {


    public var accountId_:int;

    public var charId_:int;

    public var killedBy_:String;

    public var background:BitmapData;

    public function Death(id:uint, callback:Function) {
        super(id, callback);
    }

    public function disposeBackground():void {
        this.background && this.background.dispose();
        this.background = null;
    }

    override public function parseFromInput(data:IDataInput):void {
        this.accountId_ = data.readInt();
        this.charId_ = data.readInt();
        this.killedBy_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("DEATH", "accountId_", "charId_", "killedBy_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/EnemyShoot.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class EnemyShoot extends IncomingMessage {


    public var bulletId_:uint;

    public var ownerId_:int;

    public var bulletType_:int;

    public var startingPos_:WorldPosData;

    public var angle_:Number;

    public var damage_:int;

    public var numShots_:int;

    public var angleInc_:Number;

    public function EnemyShoot(id:uint, callback:Function) {
        this.startingPos_ = new WorldPosData();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.bulletId_ = data.readInt();
        this.ownerId_ = data.readInt();
        this.bulletType_ = data.readUnsignedByte();
        this.startingPos_.parseFromInput(data);
        this.angle_ = data.readFloat();
        this.damage_ = data.readShort();
        if (data.bytesAvailable > 0) {
            this.numShots_ = data.readUnsignedByte();
            this.angleInc_ = data.readFloat();
        } else {
            this.numShots_ = 1;
            this.angleInc_ = 0;
        }
    }

    override public function toString():String {
        return formatToString("SHOOT", "bulletId_", "ownerId_", "bulletType_", "startingPos_", "angle_", "damage_", "numShots_", "angleInc_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Failure.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class Failure extends IncomingMessage {
    public static const INCORRECT_VERSION:int = 1;
    public static const FORCE_CLOSE_GAME:int = 2;
    public static const INVALID_TELEPORT_TARGET:int = 3;


    public var errorId_:int;

    public var errorDescription_:String;

    public function Failure(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.errorId_ = data.readInt();
        this.errorDescription_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("FAILURE", "errorId_", "errorDescription_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/GlobalNotification.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

public class GlobalNotification extends IncomingMessage
{
    //   public var type:int;

    public var text:String;

    public function GlobalNotification(param1:uint, param2:Function)
    {
        super(param1,param2);
    }

    override public function parseFromInput(param1:IDataInput) : void
    {
        this.text = param1.readUTF();
    }

    override public function toString() : String
    {
        return formatToString("GLOBAL_NOTIFICATION", "text");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Goto.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class Goto extends IncomingMessage {


    public var objectId_:int;

    public var pos_:WorldPosData;

    public function Goto(id:uint, callback:Function) {
        this.pos_ = new WorldPosData();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.objectId_ = data.readInt();
        this.pos_.parseFromInput(data);
    }

    override public function toString():String {
        return formatToString("GOTO", "objectId_", "pos_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/GuildResult.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class GuildResult extends IncomingMessage {


    public var success_:Boolean;

    public var errorText_:String;

    public function GuildResult(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.success_ = data.readBoolean();
        this.errorText_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("CREATEGUILDRESULT", "success_", "errorText_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/IncomingMessage.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataOutput;

import svera.lib.net.impl.Message;

public class IncomingMessage extends Message {


    public function IncomingMessage(id:uint, callback:Function) {
        super(id, callback);
    }

    override public final function writeToOutput(data:IDataOutput):void {
        throw new Error("Client should not send " + id + " messages");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/InvitedToGuild.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class InvitedToGuild extends IncomingMessage {


    public var name_:String;

    public var guildName_:String;

    public function InvitedToGuild(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.name_ = data.readUTF();
        this.guildName_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("INVITEDTOGUILD", "name_", "guildName_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/InvResult.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class InvResult extends IncomingMessage {


    public var result_:int;

    public function InvResult(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.result_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("INVRESULT", "result_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/MapInfo.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class MapInfo extends IncomingMessage {


    public var width_:int;

    public var height_:int;

    public var name_:String;

    public var displayName_:String;

    public var fp_:uint;

    public var background_:int;

    public var allowPlayerTeleport_:Boolean;

    public var showDisplays_:Boolean;

    public var music_:String;

    public function MapInfo(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.width_ = data.readInt();
        this.height_ = data.readInt();
        this.name_ = data.readUTF();
        this.displayName_ = data.readUTF();
        this.fp_ = data.readUnsignedInt();
        this.background_ = data.readInt();
        this.showDisplays_ = data.readBoolean();
        this.allowPlayerTeleport_ = data.readBoolean();
        this.music_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("MAPINFO", "width_", "height_", "name_", "fp_", "background_", "allowPlayerTeleport_", "showDisplays_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/market/MarketMyOffersResult.as">
package svera.untiered.messaging.impl.incoming.market
{

import com.company.assembleegameclient.util.FreeList;

import flash.utils.ByteArray;
import flash.utils.IDataInput;


import svera.untiered.messaging.impl.data.MarketData;

import svera.untiered.messaging.impl.incoming.IncomingMessage;

public class MarketMyOffersResult  extends IncomingMessage
{
    public var results_:Vector.<MarketData>;

    public function MarketMyOffersResult(id:uint, callback:Function)
    {
        this.results_ = new Vector.<MarketData>();
        super(id,callback);
    }

    override public function parseFromInput(data:IDataInput) : void
    {
        var i:int;
        var len:int = data.readShort();
        for(i = len; i < this.results_.length; i++)
        {
            FreeList.deleteObject(this.results_[i]);
        }
        this.results_.length = Math.min(len,this.results_.length);
        while(this.results_.length < len)
        {
            this.results_.push(FreeList.newObject(MarketData) as MarketData);
        }
        for(i = 0; i < len; i++)
        {
            this.results_[i].parseFromInput(data);
        }
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/market/MarketSearchResult.as">
package svera.untiered.messaging.impl.incoming.market
{

import com.company.assembleegameclient.util.FreeList;

import flash.utils.ByteArray;
import flash.utils.IDataInput;


import svera.untiered.messaging.impl.data.MarketData;

import svera.untiered.messaging.impl.incoming.IncomingMessage;

public class MarketSearchResult  extends IncomingMessage
{
    public var results_:Vector.<MarketData>;
    public var description_:String;

    public function MarketSearchResult(id:uint, callback:Function)
    {
        this.results_ = new Vector.<MarketData>();
        super(id,callback);
    }

    override public function parseFromInput(data:IDataInput) : void
    {
        var i:int;
        var len:int = data.readShort();
        for(i = len; i < this.results_.length; i++)
        {
            FreeList.deleteObject(this.results_[i]);
        }
        this.results_.length = Math.min(len,this.results_.length);
        while(this.results_.length < len)
        {
            this.results_.push(FreeList.newObject(MarketData) as MarketData);
        }
        for(i = 0; i < len; i++)
        {
            this.results_[i].parseFromInput(data);
        }
        this.description_ = data.readUTF();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Notification.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class Notification extends IncomingMessage {
    public var objectId_:int;
    public var text_:String;
    public var color_:int;

    public function Notification(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.objectId_ = data.readInt();
        this.text_ = data.readUTF();
        this.color_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("NOTIFICATION", "objectId_", "text_", "color_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/PlaySound.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class PlaySound extends IncomingMessage {
    public var sound_:String;

    public function PlaySound(id:uint, callback:Function) {
        sound_ = new String();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.sound_ = data.readUTF();
    }

    override public function toString():String {
        return formatToString("PLAYSOUND", "sound_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/QuestObjId.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class QuestObjId extends IncomingMessage {


    public var objectId_:int;

    public function QuestObjId(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.objectId_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("QUESTOBJID", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Reconnect.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class Reconnect extends IncomingMessage {
    public var gameId_:int;

    public function Reconnect(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.gameId_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("RECONNECT", "gameId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/ServerPlayerShoot.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class ServerPlayerShoot extends IncomingMessage {


    public var bulletId_:uint;

    public var ownerId_:int;

    public var containerType_:int;

    public var startingPos_:WorldPosData;

    public var angle_:Number;

    public var angleInc_:Number;

    public var damageList_:Vector.<uint>;

    public function ServerPlayerShoot(id:uint, callback:Function) {
        this.startingPos_ = new WorldPosData();
        this.damageList_ = new Vector.<uint>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.bulletId_ = data.readInt();
        this.ownerId_ = data.readInt();
        this.containerType_ = data.readShort();
        this.startingPos_.parseFromInput(data);
        this.angle_ = data.readFloat();
        this.angleInc_ = data.readFloat();
        this.damageList_.length = 0;
        var len:int = data.readUnsignedByte();
        for (var i:int = 0; i < len; i++) {
            this.damageList_.push(data.readShort());
        }
    }

    override public function toString():String {
        return formatToString("SHOOT", "bulletId_", "ownerId_", "containerType_", "startingPos_", "angle_", "damage_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/ShowEffect.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class ShowEffect extends IncomingMessage {

    public static const UNKNOWN_EFFECT_TYPE:int = 0;

    public static const HEAL_EFFECT_TYPE:int = 1;

    public static const TELEPORT_EFFECT_TYPE:int = 2;

    public static const STREAM_EFFECT_TYPE:int = 3;

    public static const THROW_EFFECT_TYPE:int = 4;

    public static const NOVA_EFFECT_TYPE:int = 5;

    public static const POISON_EFFECT_TYPE:int = 6;

    public static const LINE_EFFECT_TYPE:int = 7;

    public static const BURST_EFFECT_TYPE:int = 8;

    public static const FLOW_EFFECT_TYPE:int = 9;

    public static const RING_EFFECT_TYPE:int = 10;

    public static const LIGHTNING_EFFECT_TYPE:int = 11;

    public static const COLLAPSE_EFFECT_TYPE:int = 12;

    public static const CONEBLAST_EFFECT_TYPE:int = 13;

    public static const JITTER_EFFECT_TYPE:int = 14;

    public static const FLASH_EFFECT_TYPE:int = 15;

    public static const THROW_PROJECTILE_EFFECT_TYPE:int = 16;


    public var effectType_:uint;

    public var targetObjectId_:int;

    public var color_:int;

    public var pos1_:WorldPosData;

    public var pos2_:WorldPosData;


    public function ShowEffect(id:uint, callback:Function) {
        this.pos1_ = new WorldPosData();
        this.pos2_ = new WorldPosData();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.effectType_ = data.readUnsignedByte();
        this.targetObjectId_ = data.readInt();
        this.color_ = data.readInt();
        this.pos1_.parseFromInput(data);

        if (data.bytesAvailable > 0) {
            this.pos2_.parseFromInput(data);
        } else {
            this.pos2_.x_ = 0;
            this.pos2_.y_ = 0;
        }
    }

    override public function toString():String {
        return formatToString("SHOW_EFFECT", "effectType_", "targetObjectId_", "pos1_", "pos2_", "color_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/StorageSlotUpdate.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class StorageSlotUpdate extends IncomingMessage {

    public var type_:int;
    public var slot_:int;
    public var inventory_:int;
    public var itemData_:int;

    public function StorageSlotUpdate(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.type_ = data.readByte();
        this.slot_ = data.readShort();
        this.inventory_ = data.readInt();
        this.itemData_ = data.readInt();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Text.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class Text extends IncomingMessage {


    public var name_:String;

    public var objectId_:int;

    public var numStars_:int; // Change to NumClassMastery
    // Add Icon Prefix

    public var bubbleTime_:uint;

    public var recipient_:String;

    public var text_:String;

    public var nameColor_:uint;

    public var chatColor_:uint;

    public var senderId_:int;

    public function Text(id:uint, callback:Function) {
        this.name_ = new String();
        this.text_ = new String();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.name_ = data.readUTF();
        this.objectId_ = data.readInt();
        this.numStars_ = data.readInt();
        this.bubbleTime_ = data.readUnsignedByte();
        this.recipient_ = data.readUTF();
        this.text_ = data.readUTF();
        this.nameColor_ = data.readUnsignedInt();
        this.chatColor_ = data.readUnsignedInt();
        this.senderId_ = data.readInt();
    }

    override public function toString():String {
        return formatToString("TEXT", "name_", "objectId_", "numStars_", "bubbleTime_", "recipient_", "text_", "nameColor_", "chatColor_", "senderId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/TradeAccepted.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class TradeAccepted extends IncomingMessage {


    public var myOffer_:Vector.<Boolean>;

    public var yourOffer_:Vector.<Boolean>;

    public function TradeAccepted(id:uint, callback:Function) {
        this.myOffer_ = new Vector.<Boolean>();
        this.yourOffer_ = new Vector.<Boolean>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        var i:int;
        this.myOffer_.length = 0;
        var num:int = data.readByte();
        for (i = 0; i < num; i++) {
            this.myOffer_.push(data.readBoolean());
        }
        this.yourOffer_.length = 0;
        num = data.readByte();
        for (i = 0; i < num; i++) {
            this.yourOffer_.push(data.readBoolean());
        }
    }

    override public function toString():String {
        return formatToString("TRADEACCEPTED", "myOffer_", "yourOffer_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/UnboxResultPacket.as">
package svera.untiered.messaging.impl.incoming{

import flash.utils.IDataInput;

public class UnboxResultPacket extends IncomingMessage
{

    public function UnboxResultPacket(_arg_1:uint, _arg_2:Function)
    {
        this.items_ = new Vector.<int>();
        super(_arg_1, _arg_2);
    }

    public var items_:Vector.<int>;

    override public function parseFromInput(_arg1:IDataInput):void
    {
        this.items_.length = 0;
        var _local1:int;
        var _local2:int = _arg1.readShort();
        this.items_.length = _local2;
        for(_local1 = 0; _local1 < _local2; _local1++)
        {
            this.items_[_local1] = _arg1.readInt();
        }

    }

    override public function toString():String
    {
        return formatToString("UNBOXRESULT", "items_");
    }

}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/Update.as">
package svera.untiered.messaging.impl.incoming {
import com.company.assembleegameclient.util.FreeList;

import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.GroundTileData;
import svera.untiered.messaging.impl.data.ObjectData;
import svera.untiered.messaging.impl.data.ObjectDropData;

public class Update extends IncomingMessage {


    public var tiles_:Vector.<GroundTileData>;

    public var newObjs_:Vector.<ObjectData>;

    public var drops_:Vector.<ObjectDropData>;

    public function Update(id:uint, callback:Function) {
        this.tiles_ = new Vector.<GroundTileData>();
        this.newObjs_ = new Vector.<ObjectData>();
        this.drops_ = new Vector.<ObjectDropData>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        var o:Object = null;
        var i:int;

        var len:int = data.readShort();
        for (i = 0; i < this.tiles_.length; i++) {
            FreeList.deleteObject(this.tiles_[i]);
        }
        this.tiles_.length = 0;
        while (this.tiles_.length < len) {
            this.tiles_.push(FreeList.newObject(GroundTileData) as GroundTileData);
            this.tiles_[this.tiles_.length - 1].parseFromInput(data);
        }

        len = data.readShort();
        for (i = 0; i < this.newObjs_.length; i++) {
            FreeList.deleteObject(this.newObjs_[i]);
        }
        this.newObjs_.length = 0;
        while (this.newObjs_.length < len) {
            this.newObjs_.push(FreeList.newObject(ObjectData) as ObjectData);
            this.newObjs_[this.newObjs_.length - 1].parseFromInput(data);
        }

        len = data.readShort();
        for (i = 0; i < this.drops_.length; i++) {
            FreeList.deleteObject(this.drops_[i]);
        }
        this.drops_.length = 0;
        while (this.drops_.length < len) {
            this.drops_.push(FreeList.newObject(ObjectDropData) as ObjectDropData);
            this.drops_[this.drops_.length - 1].parseFromInput(data);
        }
    }

    override public function toString():String {
        return formatToString("UPDATE", "tiles_", "newObjs_", "drops_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/JitterWatcher.as">
package svera.untiered.messaging.impl {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;
import flash.utils.getTimer;

public class JitterWatcher extends Sprite {


    private var text_:SimpleText = null;

    private var lastRecord_:int = -1;

    private var ticks_:Vector.<int>;

    private var sum_:int;

    public function JitterWatcher() {
        this.ticks_ = new Vector.<int>();
        super();
        this.text_ = new SimpleText(14, 16777215, false, 0, 0);
        this.text_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.text_);
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function record():void {
        var oldDT:int = 0;
        var t:int = getTimer();
        if (this.lastRecord_ == -1) {
            this.lastRecord_ = t;
            return;
        }
        var dt:int = t - this.lastRecord_;
        this.ticks_.push(dt);
        this.sum_ = this.sum_ + dt;
        if (this.ticks_.length > 50) {
            oldDT = this.ticks_.shift();
            this.sum_ = this.sum_ - oldDT;
        }
        this.lastRecord_ = t;
    }

    private function onAddedToStage(event:Event):void {
        stage.addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
    }

    private function onEnterFrame(event:Event):void {
        this.text_.text = "net jitter: " + int(this.jitter());
        this.text_.useTextDimensions();
    }

    private function jitter():Number {
        var t:int = 0;
        var len:int = this.ticks_.length;
        if (len == 0) {
            return 0;
        }
        var mean:Number = this.sum_ / len;
        var variance:Number = 0;
        for each(t in this.ticks_) {
            variance = variance + (t - mean) * (t - mean);
        }
        return int(Math.sqrt(variance / len) * 10) / 10;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/AcceptTrade.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class AcceptTrade extends OutgoingMessage {


    public var myOffer_:Vector.<Boolean>;

    public var yourOffer_:Vector.<Boolean>;

    public function AcceptTrade(id:uint, callback:Function) {
        this.myOffer_ = new Vector.<Boolean>();
        this.yourOffer_ = new Vector.<Boolean>();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        var i:int;
        data.writeByte(this.myOffer_.length);
        for (i = 0; i < this.myOffer_.length; i++) {
            data.writeBoolean(this.myOffer_[i]);
        }
        data.writeByte(this.yourOffer_.length);
        for (i = 0; i < this.yourOffer_.length; i++) {
            data.writeBoolean(this.yourOffer_[i]);
        }
    }

    override public function toString():String {
        return formatToString("ACCEPTTRADE", "myOffer_", "yourOffer_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/AoeAck.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class AoeAck extends OutgoingMessage {


    public var time_:int;

    public var position_:WorldPosData;

    public function AoeAck(id:uint, callback:Function) {
        this.position_ = new WorldPosData();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        this.position_.writeToOutput(data);
    }

    override public function toString():String {
        return formatToString("AOEACK", "time_", "position_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Buy.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class Buy extends OutgoingMessage {
    public var objectId_:int;

    public function Buy(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.objectId_);
    }

    override public function toString():String {
        return formatToString("BUY", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/ChangeGuildRank.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class ChangeGuildRank extends OutgoingMessage {


    public var name_:String;

    public var guildRank_:int;

    public function ChangeGuildRank(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.name_);
        data.writeByte(this.guildRank_);
    }

    override public function toString():String {
        return formatToString("CHANGEGUILDRANK", "name_", "guildRank_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Create.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class Create extends OutgoingMessage {


    public var classType:int;

    public var skinType:int;

    public var traitOne:int;
    public var traitTwo:int;
    public var traitThree:int;

    public function Create(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeShort(this.classType);
        data.writeShort(this.skinType);

        data.writeInt(this.traitOne);
        data.writeInt(this.traitTwo);
        data.writeInt(this.traitThree);
    }

    override public function toString():String {
        return formatToString("CREATE", "classType");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/CreateGuild.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class CreateGuild extends OutgoingMessage {


    public var name_:String;

    public function CreateGuild(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.name_);
    }

    override public function toString():String {
        return formatToString("CREATEGUILD", "name_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/EditAccountList.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class EditAccountList extends OutgoingMessage {


    public var accountListId_:int;

    public var add_:Boolean;

    public var objectId_:int;

    public function EditAccountList(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.accountListId_);
        data.writeBoolean(this.add_);
        data.writeInt(this.objectId_);
    }

    override public function toString():String {
        return formatToString("EDITACCOUNTLIST", "accountListId_", "add_", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/EnemyHit.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class EnemyHit extends OutgoingMessage {


    public var time_:int;

    public var bulletId_:int;

    public var targetId_:int;

    public function EnemyHit(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        data.writeInt(this.bulletId_);
        data.writeInt(this.targetId_);
    }

    override public function toString():String {
        return formatToString("ENEMYHIT", "time_", "bulletId_", "targetId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Escape.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class Escape extends OutgoingMessage {


    public function Escape(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
    }

    override public function toString():String {
        return formatToString("ESCAPE");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/GotoAck.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class GotoAck extends OutgoingMessage {


    public var time_:int;

    public function GotoAck(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
    }

    override public function toString():String {
        return formatToString("GOTOACK", "time_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/GuildInvite.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class GuildInvite extends OutgoingMessage {


    public var name_:String;

    public function GuildInvite(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.name_);
    }

    override public function toString():String {
        return formatToString("GUILDINVITE", "name_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/GuildRemove.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class GuildRemove extends OutgoingMessage {


    public var name_:String;

    public function GuildRemove(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.name_);
    }

    override public function toString():String {
        return formatToString("GUILDREMOVE", "name_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Hello.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class Hello extends OutgoingMessage {
    public var buildVersion_:String;
    public var gameId_:int = 0;
    public var username_:String;
    public var password_:String;
    public var mapJSON_:String;

    public function Hello(id:uint, callback:Function) {
        this.buildVersion_ = new String();
        this.username_ = new String();
        this.password_ = new String();
        this.mapJSON_ = new String();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.buildVersion_);
        data.writeInt(this.gameId_);
        data.writeUTF(this.username_);
        data.writeUTF(this.password_);
        data.writeInt(this.mapJSON_.length);
        data.writeUTFBytes(this.mapJSON_);
    }

    override public function toString():String {
        return formatToString("HELLO", "buildVersion_", "gameId_", "username_", "password_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/InvDrop.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class InvDrop extends OutgoingMessage {


    public var slotId_:uint;

    public function InvDrop(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeByte(slotId_);
    }

    override public function toString():String {
        return formatToString("INVDROP", "slotObject_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/InvSwap.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.data.SlotObjectData;

public class InvSwap extends OutgoingMessage {

    public var slotObject1_:SlotObjectData;

    public var slotObject2_:SlotObjectData;

    public function InvSwap(id:uint, callback:Function) {
        this.slotObject1_ = new SlotObjectData();
        this.slotObject2_ = new SlotObjectData();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        this.slotObject1_.writeToOutput(data);
        this.slotObject2_.writeToOutput(data);
    }

    override public function toString():String {
        return formatToString("INVSWAP", "time_", "position_", "slotObject1_", "slotObject2_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/JoinGuild.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class JoinGuild extends OutgoingMessage {


    public var guildName_:String;

    public function JoinGuild(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.guildName_);
    }

    override public function toString():String {
        return formatToString("JOINGUILD", "guildName_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Load.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class Load extends OutgoingMessage {


    public var charId_:int;

    public function Load(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.charId_);
    }

    override public function toString():String {
        return formatToString("LOAD", "charId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Move.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class Move extends OutgoingMessage {
    public var time_:int;

    public var newPosition_:WorldPosData;

    public function Move(id:uint, callback:Function) {
        this.newPosition_ = new WorldPosData();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        this.newPosition_.writeToOutput(data);
    }

    override public function toString():String {
        return formatToString("MOVE", "tickId_", "time_", "newPosition_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/OutgoingMessage.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataInput;

import svera.lib.net.impl.Message;

public class OutgoingMessage extends Message {


    public function OutgoingMessage(id:uint, callback:Function) {
        super(id, callback);
    }

    override public final function parseFromInput(data:IDataInput):void {
        throw new Error("Client should not receive " + id + " messages");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/PlayerHit.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class PlayerHit extends OutgoingMessage {
    public var bulletId_:int;

    public function PlayerHit(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.bulletId_);
    }

    override public function toString():String {
        return formatToString("PLAYERHIT", "bulletId_", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/PlayerShoot.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.data.WorldPosData;

public class PlayerShoot extends OutgoingMessage {
    public var time_:int;
    public var startingPos_:WorldPosData;
    public var angle_:Number;
    public var ability_:Boolean;
    public var numShots_:int;

    public function PlayerShoot(id:uint, callback:Function) {
        this.startingPos_ = new WorldPosData();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        this.startingPos_.writeToOutput(data);
        data.writeFloat(this.angle_);
        data.writeBoolean(ability_);
        if (numShots_ != 1) {
            data.writeByte(numShots_);
        }
    }

    override public function toString():String {
        return formatToString("PLAYERSHOOT", "time_", "startingPos_", "angle_", "ability_", "numShots_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/PlayerText.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class PlayerText extends OutgoingMessage {


    public var text_:String;

    public function PlayerText(id:uint, callback:Function) {
        this.text_ = new String();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeUTF(this.text_);
    }

    override public function toString():String {
        return formatToString("PLAYERTEXT", "text_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Reskin.as">
package svera.untiered.messaging.impl.outgoing {
import com.company.assembleegameclient.objects.Player;

import flash.utils.IDataOutput;

public class Reskin extends OutgoingMessage {


    public var skinID:int;

    public var player:Player;

    public function Reskin(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.skinID);
    }

    override public function consume():void {
        super.consume();
        this.player = null;
    }

    override public function toString():String {
        return formatToString("RESKIN", "skinID");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/ShootAck.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class ShootAck extends OutgoingMessage {


    public var time_:int;

    public function ShootAck(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
    }

    override public function toString():String {
        return formatToString("SHOOTACK", "time_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/SquareHit.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class SquareHit extends OutgoingMessage {


    public var time_:int;

    public var bulletId_:int;

    public function SquareHit(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        data.writeInt(this.bulletId_);
    }

    override public function toString():String {
        return formatToString("SQUAREHIT", "time_", "bulletId_", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/StorageRequest.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class StorageRequest extends OutgoingMessage {
    public var objectId_:int;

    public function StorageRequest(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.objectId_);
    }

    override public function toString():String {
        return formatToString("VAULTREQUEST", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/StorageUpgrade.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class StorageUpgrade extends OutgoingMessage {

    public var objectId_:int;

    public function StorageUpgrade(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.objectId_);
    }

    override public function toString():String {
        return formatToString("VAULTREQUEST", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/Teleport.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class Teleport extends OutgoingMessage {

    public var time_:int;
    public var objectId_:int;

    public function Teleport(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        data.writeInt(this.objectId_);
    }

    override public function toString():String {
        return formatToString("TELEPORT", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/UseItem.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

import svera.untiered.messaging.impl.data.SlotObjectData;
import svera.untiered.messaging.impl.data.WorldPosData;

public class UseItem extends OutgoingMessage {
    public var time_:int;

    public var slotObject_:SlotObjectData;

    public var itemUsePos_:WorldPosData;

    public function UseItem(id:uint, callback:Function) {
        this.slotObject_ = new SlotObjectData();
        this.itemUsePos_ = new WorldPosData();
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.time_);
        this.slotObject_.writeToOutput(data);
        this.itemUsePos_.writeToOutput(data);
    }

    override public function toString():String {
        return formatToString("USEITEM", "slotObject_", "itemUsePos_", "useType_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/UsePortal.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class UsePortal extends OutgoingMessage {


    public var objectId_:int;

    public function UsePortal(id:uint, callback:Function) {
        super(id, callback);
    }

    override public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.objectId_);
    }

    override public function toString():String {
        return formatToString("USEPORTAL", "objectId_");
    }
}
}
</file>

<file path="src/svera/untiered/minimap/control/MiniMapZoomSignal.as">
package svera.untiered.minimap.control {
import org.osflash.signals.Signal;

public class MiniMapZoomSignal extends Signal {

    public static const OUT:String = "OUT";

    public static const IN:String = "IN";


    public function MiniMapZoomSignal() {
        super(String);
    }
}
}
</file>

<file path="src/svera/untiered/minimap/control/SetMiniMapMapSignal.as">
package svera.untiered.minimap.control {
import com.company.assembleegameclient.map.Map;

import org.osflash.signals.Signal;

public class SetMiniMapMapSignal extends Signal {


    public function SetMiniMapMapSignal() {
        super(Map);
    }
}
}
</file>

<file path="src/svera/untiered/minimap/control/UpdateGameObjectTileSignal.as">
package svera.untiered.minimap.control {
import org.osflash.signals.Signal;

import svera.untiered.ui.model.UpdateGameObjectTileVO;

public class UpdateGameObjectTileSignal extends Signal {


    public function UpdateGameObjectTileSignal() {
        super(UpdateGameObjectTileVO);
    }
}
}
</file>

<file path="src/svera/untiered/minimap/control/UpdateGroundTileSignal.as">
package svera.untiered.minimap.control {
import org.osflash.signals.Signal;

import svera.untiered.minimap.model.UpdateGroundTileVO;

public class UpdateGroundTileSignal extends Signal {


    public function UpdateGroundTileSignal() {
        super(UpdateGroundTileVO);
    }
}
}
</file>

<file path="src/svera/untiered/minimap/view/MiniMap.as">
package svera.untiered.minimap.view {
import com.company.assembleegameclient.map.GroundLibrary;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.objects.Character;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.GuildHallPortal;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.objects.Portal;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.menu.PlayerGroupMenu;
import com.company.assembleegameclient.ui.tooltip.PlayerGroupToolTip;
import com.company.util.AssetLibrary;
import com.company.util.PointUtil;
import com.company.util.RectangleUtil;

import flash.display.BitmapData;
import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Dictionary;

public class MiniMap extends Sprite {

    public static const MOUSE_DIST_SQ:int = 5 * 5;

    private static var objectTypeColorDict_:Dictionary = new Dictionary();


    public var map:Map;

    public var _width:int;

    public var _height:int;

    public var zoomIndex:int = 0;

    public var windowRect_:Rectangle;

    private var focus:GameObject;

    public var maxWH_:Point;

    public var miniMapData_:BitmapData;

    public var zoomLevels:Vector.<Number>;

    public var blueArrow_:BitmapData;

    public var groundLayer_:Shape;

    public var characterLayer_:Shape;

    private var zoomButtons:MiniMapZoomButtons;

    private var isMouseOver:Boolean = false;

    private var tooltip:PlayerGroupToolTip = null;

    private var menu:PlayerGroupMenu = null;

    private var mapMatrix_:Matrix;

    private var arrowMatrix_:Matrix;

    private var players_:Vector.<Player>;

    private var tempPoint:Point;

    public var active:Boolean = true;

    public function MiniMap(width:int, height:int) {
        this.zoomLevels = new Vector.<Number>();
        this.mapMatrix_ = new Matrix();
        this.arrowMatrix_ = new Matrix();
        this.players_ = new Vector.<Player>();
        this.tempPoint = new Point();
        super();
        this._width = width;
        this._height = height;
        this.makeVisualLayers();
        this.addMouseListeners();
    }

    public static function gameObjectToColor(go:GameObject):uint {
        var objectType:* = go.objectType_;
        if (!objectTypeColorDict_.hasOwnProperty(objectType)) {
            objectTypeColorDict_[objectType] = go.getColor();
        }
        return objectTypeColorDict_[objectType];
    }

    public function setMap(map:Map):void {
        this.map = map;
        this.makeViewModel();
    }

    public function setFocus(focus:GameObject):void {
        this.focus = focus;
    }

    private function makeViewModel():void {
        this.windowRect_ = new Rectangle(-this._width / 2, -this._height / 2, this._width, this._height);
        this.maxWH_ = new Point(this.map.width_, this.map.height_);
        this.miniMapData_ = new BitmapData(this.maxWH_.x, this.maxWH_.y, false, 0);
        var minZoom:Number = Math.max(this._width / this.maxWH_.x, this._height / this.maxWH_.y);
        for (var z:Number = 4; z > minZoom; z = z / 2) {
            this.zoomLevels.push(z);
        }
        this.zoomLevels.push(minZoom);
        this.zoomButtons && this.zoomButtons.setZoomLevels(this.zoomLevels.length);
    }

    private function makeVisualLayers():void {
        this.blueArrow_ = AssetLibrary.getImageFromSet("lofiInterface", 54).clone();
        this.blueArrow_.colorTransform(this.blueArrow_.rect, new ColorTransform(0, 0, 1));
        graphics.clear();
        graphics.beginFill(1776411);
        graphics.drawRect(0, 0, this._width, this._height);
        graphics.endFill();
        this.groundLayer_ = new Shape();
        this.groundLayer_.x = this._width / 2;
        this.groundLayer_.y = this._height / 2;
        addChild(this.groundLayer_);
        this.characterLayer_ = new Shape();
        this.characterLayer_.x = this._width / 2;
        this.characterLayer_.y = this._height / 2;
        addChild(this.characterLayer_);
        this.zoomButtons = new MiniMapZoomButtons();
        this.zoomButtons.x = this._width - 20;
        this.zoomButtons.zoom.add(this.onZoomChanged);
        this.zoomButtons.setZoomLevels(this.zoomLevels.length);
        addChild(this.zoomButtons);
    }

    private function addMouseListeners():void {
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        addEventListener(MouseEvent.CLICK, this.onMapClick);
    }

    public function dispose():void {
        this.miniMapData_.dispose();
        this.miniMapData_ = null;
        this.removeDecorations();
    }

    private function onZoomChanged(zoomLevel:int):void {
        this.zoomIndex = zoomLevel;
    }

    private function onMouseOver(event:MouseEvent):void {
        this.isMouseOver = true;
    }

    private function onMouseOut(event:MouseEvent):void {
        this.isMouseOver = false;
    }

    private function onMapClick(event:MouseEvent):void {
        if (this.tooltip == null || this.tooltip.parent == null || this.tooltip.players_ == null || this.tooltip.players_.length == 0) {
            return;
        }
        this.removeMenu();
        this.addMenu();
        this.removeTooltip();
    }

    private function addMenu():void {
        this.menu = new PlayerGroupMenu(this.map, this.tooltip.players_);
        this.menu.x = this.tooltip.x + 12;
        this.menu.y = this.tooltip.y;
        stage.addChild(this.menu);
    }

    public function setGroundTile(x:int, y:int, tileType:uint):void {
        var color:uint = GroundLibrary.getColor(tileType);
        this.miniMapData_.setPixel(x, y, color);
    }

    public function setGameObjectTile(x:int, y:int, go:GameObject):void {
        var color:uint = gameObjectToColor(go);
        this.miniMapData_.setPixel(x, y, color);
    }

    private function removeDecorations():void {
        this.removeTooltip();
        this.removeMenu();
    }

    private function removeTooltip():void {
        if (this.tooltip != null) {
            if (this.tooltip.parent != null) {
                this.tooltip.parent.removeChild(this.tooltip);
            }
            this.tooltip = null;
        }
    }

    private function removeMenu():void {
        if (this.menu != null) {
            if (this.menu.parent != null) {
                this.menu.parent.removeChild(this.menu);
            }
            this.menu = null;
        }
    }

    public function draw():void {
        var g:Graphics = null;
        var go:GameObject = null;
        var fillColor:uint = 0;
        var player:Player = null;
        var mmx:Number = NaN;
        var mmy:Number = NaN;
        var dx:Number = NaN;
        var dy:Number = NaN;
        var distSq:Number = NaN;
        this.groundLayer_.graphics.clear();
        this.characterLayer_.graphics.clear();
        if (!this.focus) {
            return;
        }
        if (!this.active) {
            return;
        }
        var zoom:Number = this.zoomLevels[this.zoomIndex];
        this.mapMatrix_.identity();
        this.mapMatrix_.translate(-this.focus.x_, -this.focus.y_);
        this.mapMatrix_.scale(zoom, zoom);
        var upLeft:Point = this.mapMatrix_.transformPoint(PointUtil.ORIGIN);
        var bottomRight:Point = this.mapMatrix_.transformPoint(this.maxWH_);
        var tx:Number = 0;
        if (upLeft.x > this.windowRect_.left) {
            tx = this.windowRect_.left - upLeft.x;
        } else if (bottomRight.x < this.windowRect_.right) {
            tx = this.windowRect_.right - bottomRight.x;
        }
        var ty:Number = 0;
        if (upLeft.y > this.windowRect_.top) {
            ty = this.windowRect_.top - upLeft.y;
        } else if (bottomRight.y < this.windowRect_.bottom) {
            ty = this.windowRect_.bottom - bottomRight.y;
        }
        this.mapMatrix_.translate(tx, ty);
        upLeft = this.mapMatrix_.transformPoint(PointUtil.ORIGIN);
        var drawRect:Rectangle = new Rectangle();
        drawRect.x = Math.max(this.windowRect_.x, upLeft.x);
        drawRect.y = Math.max(this.windowRect_.y, upLeft.y);
        drawRect.right = Math.min(this.windowRect_.right, upLeft.x + this.maxWH_.x * zoom);
        drawRect.bottom = Math.min(this.windowRect_.bottom, upLeft.y + this.maxWH_.y * zoom);
        g = this.groundLayer_.graphics;
        g.beginBitmapFill(this.miniMapData_, this.mapMatrix_, false);
        g.drawRect(drawRect.x, drawRect.y, drawRect.width, drawRect.height);
        g.endFill();
        g = this.characterLayer_.graphics;
        var mX:Number = mouseX - this._width / 2;
        var mY:Number = mouseY - this._height / 2;
        this.players_.length = 0;
        for each(go in this.map.goDict_) {
            if (!(go.props_.noMiniMap_ || go == this.focus)) {
                player = go as Player;
                if (player != null) {
                    if (player.isFellowGuild_) {
                        fillColor = 65280;
                    } else {
                        fillColor = 16776960;
                    }
                } else if (go is Character) {
                    if (go.props_.isEnemy_) {
                        fillColor = 16711680;
                    } else {
                        fillColor = gameObjectToColor(go);
                    }
                } else if (go is Portal || go is GuildHallPortal) {
                    fillColor = 255;
                } else {
                    continue;
                }
                mmx = this.mapMatrix_.a * go.x_ + this.mapMatrix_.c * go.y_ + this.mapMatrix_.tx;
                mmy = this.mapMatrix_.b * go.x_ + this.mapMatrix_.d * go.y_ + this.mapMatrix_.ty;
                if (mmx <= -this._width / 2 || mmx >= this._width / 2 || mmy <= -this._height / 2 || mmy >= this._height / 2) {
                    RectangleUtil.lineSegmentIntersectXY(this.windowRect_, 0, 0, mmx, mmy, this.tempPoint);
                    mmx = this.tempPoint.x;
                    mmy = this.tempPoint.y;
                }
                if (player != null && this.isMouseOver && (this.menu == null || this.menu.parent == null)) {
                    dx = mX - mmx;
                    dy = mY - mmy;
                    distSq = dx * dx + dy * dy;
                    if (distSq < MOUSE_DIST_SQ) {
                        this.players_.push(player);
                    }
                }
                g.beginFill(fillColor);
                g.drawRect(mmx - 2, mmy - 2, 4, 4);
                g.endFill();
            }
        }
        if (this.players_.length != 0) {
            if (this.tooltip == null) {
                this.tooltip = new PlayerGroupToolTip(this.players_);
                stage.addChild(this.tooltip);
            } else if (!this.areSamePlayers(this.tooltip.players_, this.players_)) {
                this.tooltip.setPlayers(this.players_);
            }
        } else if (this.tooltip != null) {
            if (this.tooltip.parent != null) {
                this.tooltip.parent.removeChild(this.tooltip);
            }
            this.tooltip = null;
        }
        var px:Number = this.focus.x_;
        var py:Number = this.focus.y_;
        var ppx:Number = this.mapMatrix_.a * px + this.mapMatrix_.c * py + this.mapMatrix_.tx;
        var ppy:Number = this.mapMatrix_.b * px + this.mapMatrix_.d * py + this.mapMatrix_.ty;
        this.arrowMatrix_.identity();
        this.arrowMatrix_.translate(-4, -5);
        this.arrowMatrix_.scale(8 / this.blueArrow_.width, 32 / this.blueArrow_.height);
        this.arrowMatrix_.rotate(Parameters.data_.cameraAngle);
        this.arrowMatrix_.translate(ppx, ppy);
        g.beginBitmapFill(this.blueArrow_, this.arrowMatrix_, false);
        g.drawRect(ppx - 16, ppy - 16, 32, 32);
        g.endFill();
    }

    private function areSamePlayers(players0:Vector.<Player>, players1:Vector.<Player>):Boolean {
        var count:int = players0.length;
        if (count != players1.length) {
            return false;
        }
        for (var i:int = 0; i < count; i++) {
            if (players0[i] != players1[i]) {
                return false;
            }
        }
        return true;
    }

    public function zoomIn():void {
        this.zoomIndex = this.zoomButtons.setZoomLevel(this.zoomIndex - 1);
    }

    public function zoomOut():void {
        this.zoomIndex = this.zoomButtons.setZoomLevel(this.zoomIndex + 1);
    }

    public function deactivate():void {
        this.active = false;
        this.removeDecorations();
    }
}
}
</file>

<file path="src/svera/untiered/minimap/view/MiniMapMediator.as">
package svera.untiered.minimap.view {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;

import flash.utils.Dictionary;

import svera.lib.framework.Mediator;

import svera.untiered.game.focus.control.SetGameFocusSignal;
import svera.untiered.game.signals.ExitGameSignal;
import svera.untiered.minimap.control.MiniMapZoomSignal;
import svera.untiered.minimap.control.UpdateGameObjectTileSignal;
import svera.untiered.minimap.control.UpdateGroundTileSignal;
import svera.untiered.minimap.model.UpdateGroundTileVO;
import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.model.UpdateGameObjectTileVO;
import svera.untiered.ui.signals.UpdateHUDSignal;

public class MiniMapMediator extends Mediator {


    [Inject]
    public var model:HUDModel;

    [Inject]
    public var setFocus:SetGameFocusSignal;

    [Inject]
    public var updateGroundTileSignal:UpdateGroundTileSignal;

    [Inject]
    public var updateGameObjectTileSignal:UpdateGameObjectTileSignal;

    [Inject]
    public var miniMapZoomSignal:MiniMapZoomSignal;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    [Inject]
    public var exitGameSignal:ExitGameSignal;


    private function get miniMapView():MiniMap {
        return view as MiniMap;
    }

    override protected function onInitialize():void {

        miniMapView.setMap(this.model.gameSprite.map);
        this.setFocus.add(this.onSetFocus);
        this.updateHUD.add(this.onUpdateHUD);
        this.updateGameObjectTileSignal.add(this.onUpdateGameObjectTile);
        this.updateGroundTileSignal.add(this.onUpdateGroundTile);
        this.miniMapZoomSignal.add(this.onMiniMapZoom);
        this.exitGameSignal.add(this.onExitGame);
    }

    private function onExitGame():void {
        miniMapView.deactivate();
    }

    override protected function onDestroy():void {
        this.setFocus.remove(this.onSetFocus);
        this.updateHUD.remove(this.onUpdateHUD);
        this.updateGameObjectTileSignal.remove(this.onUpdateGameObjectTile);
        this.updateGroundTileSignal.remove(this.onUpdateGroundTile);
        this.miniMapZoomSignal.remove(this.onMiniMapZoom);
        this.exitGameSignal.remove(this.onExitGame);
    }

    private function onSetFocus(id:String):void {
        var object:GameObject = this.getFocusById(id);
        miniMapView.setFocus(object);
    }

    private function getFocusById(id:String):GameObject {
        var object:GameObject = null;
        if (id == "") {
            return miniMapView.map.player_;
        }
        var objects:Dictionary = miniMapView.map.goDict_;
        for each(object in objects) {
            if (object.name_ == id) {
                return object;
            }
        }
        return miniMapView.map.player_;
    }

    private function onUpdateGroundTile(vo:UpdateGroundTileVO):void {
        miniMapView.setGroundTile(vo.tileX, vo.tileY, vo.tileType);
    }

    private function onUpdateGameObjectTile(vo:UpdateGameObjectTileVO):void {
        miniMapView.setGameObjectTile(vo.tileX, vo.tileY, vo.gameObject);
    }

    private function onMiniMapZoom(direction:String):void {
        if (direction == MiniMapZoomSignal.IN) {
            miniMapView.zoomIn();
        } else if (direction == MiniMapZoomSignal.OUT) {
            miniMapView.zoomOut();
        }
    }

    private function onUpdateHUD(_:Player):void {
        miniMapView.draw();
    }
}
}
</file>

<file path="src/svera/untiered/raidLauncher/RaidLauncherMediator.as">
package svera.untiered.raidLauncher {

import flash.events.MouseEvent;

import org.swiftsuspenders.Injector;

import svera.lib.framework.Mediator;

import svera.lib.net.api.MessageProvider;
import svera.lib.net.impl.SocketServer;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.signals.AddTextLineSignal;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.messaging.impl.outgoing.LaunchRaid;

public class RaidLauncherMediator extends Mediator {


    [Inject]
    public var injector:Injector;
    [Inject]
    public var closeDialogs:CloseDialogsSignal;
    [Inject]
    public var socketServer:SocketServer;
    [Inject]
    public var messages:MessageProvider;
    [Inject]
    public var view:RaidLauncherModal;
    [Inject]
    public var openNoModalDialog:OpenDialogSignal;
    [Inject]
    public var addTextLine:AddTextLineSignal;


    override public function initialize():void {
        this.view.launchButton.addEventListener(MouseEvent.CLICK, this.onButtonLaunch);
        this.view.launchButton2.addEventListener(MouseEvent.CLICK, this.onButtonLaunch2);
        this.view.launchButton3.addEventListener(MouseEvent.CLICK, this.onButtonLaunch3);
    }

    override public function destroy():void {
        super.destroy();
    }

    protected function onButtonLaunch(_arg_1:MouseEvent):void {
        var _local_1:LaunchRaid;
        _local_1 = (this.messages.require(GameServerConnection.LAUNCH_RAID) as LaunchRaid);
        _local_1.raidId_ = 1;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch()
    }

    protected function onButtonLaunch2(_arg_1:MouseEvent):void {
        var _local_1:LaunchRaid;
        _local_1 = (this.messages.require(GameServerConnection.LAUNCH_RAID) as LaunchRaid);
        _local_1.raidId_ = 2;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch()
    }

    protected function onButtonLaunch3(_arg_1:MouseEvent):void {
        var _local_1:LaunchRaid;
        _local_1 = (this.messages.require(GameServerConnection.LAUNCH_RAID) as LaunchRaid);
        _local_1.raidId_ = 3;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch()
    }


}
}//package svera.untiered.pets.view.components
</file>

<file path="src/svera/untiered/stage3D/graphic3D/Graphic3D.as">
package svera.untiered.stage3D.graphic3D {
import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsGradientFill;
import flash.display3D.Context3D;
import flash.display3D.Context3DProgramType;
import flash.display3D.Context3DVertexBufferFormat;
import flash.display3D.IndexBuffer3D;
import flash.display3D.VertexBuffer3D;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Matrix3D;

import svera.untiered.stage3D.GraphicsFillExtra;
import svera.untiered.stage3D.proxies.Context3DProxy;
import svera.untiered.stage3D.proxies.IndexBuffer3DProxy;
import svera.untiered.stage3D.proxies.TextureProxy;
import svera.untiered.stage3D.proxies.VertexBuffer3DProxy;

public class Graphic3D {
    private static const gradientVertex:Vector.<Number> = Vector.<Number>(
            [-0.5, 0.5, 0, 0, 0, 0, 0.01, 0, 1, 0.5, 0.5, 0, 0, 0, 0, 0.3, 1, 1,
                -0.5, -0.5, 0, 0, 0, 0, 0.1, 0, 0, 0.5, -0.5, 0, 0, 0, 0, 0.2, 1, 0]);
    private static const indices:Vector.<uint> = Vector.<uint>([0, 1, 2, 2, 1, 3]);

    public var texture:TextureProxy;
    public var matrix3D:Matrix3D;
    public var context3D:Context3DProxy;

    [Inject]
    public var textureFactory:TextureFactory;

    [Inject]
    public var vertexBuffer:VertexBuffer3DProxy;

    [Inject]
    public var indexBuffer:IndexBuffer3DProxy;

    private var bitmapData:BitmapData;
    private var matrix2D:Matrix;
    private var shadowMatrix2D:Matrix;
    private var sinkLevel:Number = 0;
    private var offsetMatrix:Vector.<Number>;
    private var vertexBufferCustom:VertexBuffer3D;
    private var gradientVB:VertexBuffer3D;
    private var gradientIB:IndexBuffer3D;
    private var repeat:Boolean;

    private var sinkOffset:Vector.<Number>;
    private var ctMult:Vector.<Number>;
    private var ctOffset:Vector.<Number>;
    private var rawMatrix3D:Vector.<Number>;

    public function Graphic3D() {
        this.matrix3D = new Matrix3D();
        this.sinkOffset = new Vector.<Number>(4, true);
        this.ctMult = new Vector.<Number>(4, true);
        this.ctOffset = new Vector.<Number>(4, true);
        this.rawMatrix3D = new Vector.<Number>(16, true);
        super();
    }

    public function setGraphic(graphicsBitmapFill:GraphicsBitmapFill, context3D:Context3DProxy):void {
        this.bitmapData = graphicsBitmapFill.bitmapData;
        this.repeat = graphicsBitmapFill.repeat;
        this.matrix2D = graphicsBitmapFill.matrix;
        this.texture = this.textureFactory.make(graphicsBitmapFill.bitmapData);
        this.offsetMatrix = GraphicsFillExtra.getOffsetUV(graphicsBitmapFill);
        this.vertexBufferCustom = GraphicsFillExtra.getVertexBuffer(graphicsBitmapFill);
        this.sinkLevel = GraphicsFillExtra.getSinkLevel(graphicsBitmapFill);
        if (this.sinkLevel != 0) {
            this.sinkOffset[1] = -this.sinkLevel;
            this.offsetMatrix = sinkOffset;
        }
        this.transform();
        var ct:ColorTransform = GraphicsFillExtra.getColorTransform(this.bitmapData);
        ctMult[0] = ct.redMultiplier;
        ctMult[1] = ct.greenMultiplier;
        ctMult[2] = ct.blueMultiplier;
        ctMult[3] = ct.alphaMultiplier;
        ctOffset[0] = ct.redOffset / 0xFF;
        ctOffset[1] = ct.greenOffset / 0xFF;
        ctOffset[2] = ct.blueOffset / 0xFF;
        ctOffset[3] = ct.alphaOffset / 0xFF;
        var c3d:Context3D = context3D.GetContext3D();
        c3d.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 2, ctMult);
        c3d.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 3, ctOffset);
    }

    public function setGradientFill(gradientFill:GraphicsGradientFill, context3D:Context3DProxy, width:Number, height:Number):void {
        this.shadowMatrix2D = gradientFill.matrix;
        if (this.gradientVB == null || this.gradientIB == null) {
            this.gradientVB = context3D.GetContext3D().createVertexBuffer(4, 9);
            this.gradientVB.uploadFromVector(gradientVertex, 0, 4);
            this.gradientIB = context3D.GetContext3D().createIndexBuffer(6);
            this.gradientIB.uploadFromVector(indices, 0, 6);
        }
        this.shadowTransform(width, height);
    }

    private function shadowTransform(width:Number, height:Number):void {
        this.matrix3D.identity();
        var raw:Vector.<Number> = this.matrix3D.rawData;
        raw[4] = -this.shadowMatrix2D.c;
        raw[1] = -this.shadowMatrix2D.b;
        raw[0] = this.shadowMatrix2D.a * 4;
        raw[5] = this.shadowMatrix2D.d * 4;
        raw[12] = this.shadowMatrix2D.tx / width;
        raw[13] = -this.shadowMatrix2D.ty / height;
        this.matrix3D.rawData = raw;
    }

    private function transform():void {
        this.matrix3D.identity();
        this.matrix3D.copyRawDataTo(rawMatrix3D);
        rawMatrix3D[4] = -this.matrix2D.c;
        rawMatrix3D[1] = -this.matrix2D.b;
        rawMatrix3D[0] = this.matrix2D.a;
        rawMatrix3D[5] = this.matrix2D.d;
        rawMatrix3D[12] = this.matrix2D.tx;
        rawMatrix3D[13] = -this.matrix2D.ty;
        this.matrix3D.copyRawDataFrom(rawMatrix3D);
        this.matrix3D.prependScale(Math.ceil(this.texture.getWidth()), Math.ceil(this.texture.getHeight()), 1);
        this.matrix3D.prependTranslation(0.5, -0.5, 0);
    }

    public function render(c3dProxy:Context3DProxy):void {
        c3dProxy.setProgram(Program3DFactory.getInstance().getProgram(c3dProxy, this.repeat));
        c3dProxy.setTextureAt(0, this.texture);
        var c3d:Context3D = c3dProxy.GetContext3D();
        if (this.vertexBufferCustom != null) {
            c3d.setVertexBufferAt(0, this.vertexBufferCustom, 0, Context3DVertexBufferFormat.FLOAT_3);
            c3d.setVertexBufferAt(1, this.vertexBufferCustom, 3, Context3DVertexBufferFormat.FLOAT_2);
            c3d.setProgramConstantsFromVector(Context3DProgramType.VERTEX, 4, this.offsetMatrix);
            c3d.setVertexBufferAt(2, null, 6, Context3DVertexBufferFormat.FLOAT_2);
            c3dProxy.drawTriangles(this.indexBuffer);
        } else {
            c3dProxy.setVertexBufferAt(0, this.vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            c3dProxy.setVertexBufferAt(1, this.vertexBuffer, 3, Context3DVertexBufferFormat.FLOAT_2);
            c3d.setProgramConstantsFromVector(Context3DProgramType.VERTEX, 4, this.offsetMatrix);
            c3d.setVertexBufferAt(2, null, 6, Context3DVertexBufferFormat.FLOAT_2);
            c3dProxy.drawTriangles(this.indexBuffer);
        }
    }

    public function renderShadow(c3dProxy:Context3DProxy):void {
        var c3d:Context3D = c3dProxy.GetContext3D();
        c3d.setVertexBufferAt(0, this.gradientVB, 0, Context3DVertexBufferFormat.FLOAT_3);
        c3d.setVertexBufferAt(1, this.gradientVB, 3, Context3DVertexBufferFormat.FLOAT_4);
        c3d.setVertexBufferAt(2, this.gradientVB, 7, Context3DVertexBufferFormat.FLOAT_2);
        c3d.setTextureAt(0, null);
        c3d.drawTriangles(this.gradientIB);
    }

    public function getMatrix3D():Matrix3D {
        return this.matrix3D;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/graphic3D/Graphic3DHelper.as">
package svera.untiered.stage3D.graphic3D {
import org.swiftsuspenders.Injector;

import svera.untiered.stage3D.proxies.IndexBuffer3DProxy;
import svera.untiered.stage3D.proxies.VertexBuffer3DProxy;

public class Graphic3DHelper {


    public function Graphic3DHelper() {
        super();
    }

    public static function map(injector:Injector):void {
        injectSingletonIndexBuffer(injector);
        injectSingletonVertexBuffer(injector);
    }

    private static function injectSingletonIndexBuffer(injector:Injector):void {
        var factory:IndexBufferFactory = injector.getInstance(IndexBufferFactory);
        injector.map(IndexBuffer3DProxy).toProvider(factory);
    }

    private static function injectSingletonVertexBuffer(injector:Injector):void {
        var factory:VertexBufferFactory = injector.getInstance(VertexBufferFactory);
        injector.map(VertexBuffer3DProxy).toProvider(factory);
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/graphic3D/IndexBufferFactory.as">
package svera.untiered.stage3D.graphic3D {
import flash.utils.Dictionary;

import org.swiftsuspenders.Injector;
import org.swiftsuspenders.dependencyproviders.DependencyProvider;

import svera.untiered.stage3D.proxies.Context3DProxy;
import svera.untiered.stage3D.proxies.IndexBuffer3DProxy;

public class IndexBufferFactory implements DependencyProvider {

    private static const numVertices:int = 6;


    private var indexBuffer:IndexBuffer3DProxy;

    public function IndexBufferFactory(context3D:Context3DProxy) {
        super();
        var indices:Vector.<uint> = Vector.<uint>([0, 1, 2, 2, 1, 3]);
        if (context3D != null) {
            this.indexBuffer = context3D.createIndexBuffer(numVertices);
            this.indexBuffer.uploadFromVector(indices, 0, numVertices);
        }
    }

    public function apply(targetType:Class, activeInjector:Injector, injectParameters:Dictionary):Object {
        return this.indexBuffer;
    }

    public function destroy():void {
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/graphic3D/VertexBufferFactory.as">
package svera.untiered.stage3D.graphic3D {
import flash.utils.Dictionary;

import org.swiftsuspenders.Injector;
import org.swiftsuspenders.dependencyproviders.DependencyProvider;

import svera.untiered.stage3D.proxies.Context3DProxy;
import svera.untiered.stage3D.proxies.VertexBuffer3DProxy;

public class VertexBufferFactory implements DependencyProvider {


    private var vertexBuffer:VertexBuffer3DProxy;

    public function VertexBufferFactory(context3D:Context3DProxy) {
        super();
        var vertices:Vector.<Number> = Vector.<Number>([-0.5, 0.5, 0, 0, 0, 0.5, 0.5, 0, 1, 0, -0.5, -0.5, 0, 0, 1, 0.5, -0.5, 0, 1, 1]);
        this.vertexBuffer = context3D.createVertexBuffer(4, 5);
        this.vertexBuffer.uploadFromVector(vertices, 0, 4);
    }

    public function apply(targetType:Class, activeInjector:Injector, injectParameters:Dictionary):Object {
        return this.vertexBuffer;
    }

    public function destroy():void {
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Object3D/Model3D_stage3d.as">
package svera.untiered.stage3D.Object3D {
import flash.display3D.Context3D;
import flash.display3D.VertexBuffer3D;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

public class Model3D_stage3d {


    public var name:String;

    public var groups:Vector.<OBJGroup>;

    public var vertexBuffer:VertexBuffer3D;

    protected var _materials:Dictionary;

    protected var _tupleIndex:uint;

    protected var _tupleIndices:Dictionary;

    protected var _vertices:Vector.<Number>;

    public function Model3D_stage3d() {
        super();
        this.groups = new Vector.<OBJGroup>();
        this._materials = new Dictionary();
        this._vertices = new Vector.<Number>();
    }

    public function dispose():void {
        var group:OBJGroup = null;
        for each(group in this.groups) {
            group.dispose();
        }
        this.groups.length = 0;
        if (this.vertexBuffer !== null) {
            this.vertexBuffer.dispose();
            this.vertexBuffer = null;
        }
        this._vertices.length = 0;
        this._tupleIndex = 0;
        this._tupleIndices = new Dictionary();
    }

    public function CreatBuffer(context:Context3D):void {
        var group:OBJGroup = null;
        for each(group in this.groups) {
            if (group._indices.length > 0) {
                group.indexBuffer = context.createIndexBuffer(group._indices.length);
                group.indexBuffer.uploadFromVector(group._indices, 0, group._indices.length);
                group._faces = null;
            }
        }
        this.vertexBuffer = context.createVertexBuffer(this._vertices.length / 8, 8);
        this.vertexBuffer.uploadFromVector(this._vertices, 0, this._vertices.length / 8);
    }

    public function readBytes(bytes:ByteArray):void {
        var face:Vector.<String> = null;
        var group:OBJGroup = null;
        var line:String = null;
        var fields:Array = null;
        var tuple:String = null;
        var il:int = 0;
        var i:int = 0;
        this.dispose();
        var materialName:String = "";
        var positions:Vector.<Number> = new Vector.<Number>();
        var normals:Vector.<Number> = new Vector.<Number>();
        var uvs:Vector.<Number> = new Vector.<Number>();
        bytes.position = 0;
        var text:String = bytes.readUTFBytes(bytes.bytesAvailable);
        var lines:Array = text.split(/[\r\n]+/);
        for each(line in lines) {
            line = line.replace(/^\s*|\s*$/g, "");
            if (line == "" || line.charAt(0) === "#") {
                continue;
            }
            fields = line.split(/\s+/);
            switch (fields[0].toLowerCase()) {
                case "v":
                    positions.push(parseFloat(fields[1]), parseFloat(fields[2]), parseFloat(fields[3]));
                    continue;
                case "vn":
                    normals.push(parseFloat(fields[1]), parseFloat(fields[2]), parseFloat(fields[3]));
                    continue;
                case "vt":
                    uvs.push(parseFloat(fields[1]), 1 - parseFloat(fields[2]));
                    continue;
                case "f":
                    face = new Vector.<String>();
                    for each(tuple in fields.slice(1)) {
                        face.push(tuple);
                    }
                    if (group === null) {
                        group = new OBJGroup(null, materialName);
                        this.groups.push(group);
                    }
                    group._faces.push(face);
                    continue;
                case "g":
                    group = new OBJGroup(fields[1], materialName);
                    this.groups.push(group);
                    continue;
                case "o":
                    this.name = fields[1];
                    continue;
                case "mtllib":
                    continue;
                case "usemtl":
                    materialName = fields[1];
                    if (group !== null) {
                        group.materialName = materialName;
                    }
                    continue;
                default:
                    continue;
            }
        }
        for each(group in this.groups) {
            group._indices.length = 0;
            for each(face in group._faces) {
                il = face.length - 1;
                for (i = 1; i < il; i++) {
                    group._indices.push(this.mergeTuple(face[i], positions, normals, uvs));
                    group._indices.push(this.mergeTuple(face[0], positions, normals, uvs));
                    group._indices.push(this.mergeTuple(face[i + 1], positions, normals, uvs));
                }
            }
            group._faces = null;
        }
        this._tupleIndex = 0;
        this._tupleIndices = null;
    }

    protected function mergeTuple(tuple:String, positions:Vector.<Number>, normals:Vector.<Number>, uvs:Vector.<Number>):uint {
        var faceIndices:Array = null;
        var index:uint = 0;
        if (this._tupleIndices[tuple] !== undefined) {
            return this._tupleIndices[tuple];
        }
        faceIndices = tuple.split("/");
        index = parseInt(faceIndices[0], 10) - 1;
        this._vertices.push(positions[index * 3 + 0], positions[index * 3 + 1], positions[index * 3 + 2]);
        if (faceIndices.length > 2 && faceIndices[2].length > 0) {
            index = parseInt(faceIndices[2], 10) - 1;
            this._vertices.push(normals[index * 3 + 0], normals[index * 3 + 1], normals[index * 3 + 2]);
        } else {
            this._vertices.push(0, 0, 0);
        }
        if (faceIndices.length > 1 && faceIndices[1].length > 0) {
            index = parseInt(faceIndices[1], 10) - 1;
            this._vertices.push(uvs[index * 2 + 0], uvs[index * 2 + 1]);
        } else {
            this._vertices.push(0, 0);
        }
        return this._tupleIndices[tuple] = this._tupleIndex++;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Object3D/Object3DStage3D.as">
package svera.untiered.stage3D.Object3D {
import flash.display.BitmapData;
import flash.display3D.Context3D;
import flash.display3D.Context3DTextureFormat;
import flash.display3D.Context3DVertexBufferFormat;
import flash.display3D.textures.Texture;
import flash.geom.Matrix3D;
import flash.geom.Vector3D;

import svera.untiered.stage3D.graphic3D.TextureFactory;

public class Object3DStage3D {

    public static const missingTextureBitmap:BitmapData = new BitmapData(1, 1, true, 2290649343);


    public var model_:Model3D_stage3d = null;

    private var bitmapData:BitmapData;

    public var modelMatrix_:Matrix3D;

    public var modelView_:Matrix3D;

    public var modelViewProjection_:Matrix3D;

    public var position:Vector3D;

    private var zRotation_:Number;

    private var texture_:Texture;

    public function Object3DStage3D(model:Model3D_stage3d) {
        super();
        this.model_ = model;
        this.modelMatrix_ = new Matrix3D();
        this.modelView_ = new Matrix3D();
        this.modelViewProjection_ = new Matrix3D();
    }

    public function setBitMapData(bitmap:BitmapData):void {
        this.bitmapData = TextureFactory.GetFlippedBitmapData(bitmap);
    }

    public function setPosition(x:Number, y:Number, z:Number, angleDegrees:Number):void {
        this.position = new Vector3D(x, -y, z);
        this.zRotation_ = angleDegrees;
    }

    public function dispose():void {
        if (this.texture_ != null) {
            this.texture_.dispose();
            this.texture_ = null;
        }
        this.bitmapData = null;
        this.modelMatrix_ = null;
        this.modelView_ = null;
        this.modelViewProjection_ = null;
        this.position = null;
    }

    public function UpdateModelMatrix(widthOffset:Number, heightOffset:Number):void {
        this.modelMatrix_.identity();
        this.modelMatrix_.appendRotation(-90, Vector3D.Z_AXIS);
        this.modelMatrix_.appendRotation(-this.zRotation_, Vector3D.Z_AXIS);
        this.modelMatrix_.appendTranslation(this.position.x, this.position.y, 0);
        this.modelMatrix_.appendTranslation(widthOffset, heightOffset, 0);
    }

    public function GetModelMatrix():Matrix3D {
        return this.modelMatrix_;
    }

    public function draw(context:Context3D):void {
        var group:OBJGroup = null;
        context.setVertexBufferAt(0, this.model_.vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
        context.setVertexBufferAt(1, this.model_.vertexBuffer, 3, Context3DVertexBufferFormat.FLOAT_3);
        context.setVertexBufferAt(2, this.model_.vertexBuffer, 6, Context3DVertexBufferFormat.FLOAT_2);
        if (this.texture_ == null && this.bitmapData != null) {
            this.texture_ = context.createTexture(this.bitmapData.width, this.bitmapData.height, Context3DTextureFormat.BGRA, false);
            this.texture_.uploadFromBitmapData(this.bitmapData);
        } else if (this.texture_ == null) {
            this.bitmapData = missingTextureBitmap;
            this.texture_ = context.createTexture(this.bitmapData.width, this.bitmapData.height, Context3DTextureFormat.BGRA, false);
            this.texture_.uploadFromBitmapData(this.bitmapData);
        }
        context.setTextureAt(0, this.texture_);
        for each(group in this.model_.groups) {
            if (group.indexBuffer != null) {
                context.drawTriangles(group.indexBuffer);
            }
        }
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Object3D/OBJGroup.as">
package svera.untiered.stage3D.Object3D {
import flash.display3D.IndexBuffer3D;

public class OBJGroup {


    public var name:String;

    public var materialName:String;

    public var indexBuffer:IndexBuffer3D;

    public var _faces:Vector.<Vector.<String>>;

    public var _indices:Vector.<uint>;

    public function OBJGroup(name:String = null, materialName:String = null) {
        super();
        this.name = name;
        this.materialName = materialName;
        this._faces = new Vector.<Vector.<String>>();
        this._indices = new Vector.<uint>();
    }

    public function dispose():void {
        if (this.indexBuffer != null) {
            this.indexBuffer.dispose();
            this.indexBuffer = null;
        }
        this._faces.length = 0;
        this._indices.length = 0;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Object3D/Util.as">
package svera.untiered.stage3D.Object3D {
import flash.geom.Matrix3D;
import flash.utils.ByteArray;

public class Util {


    public function Util() {
        super();
    }

    public static function perspectiveProjection(fov:Number = 90, aspect:Number = 1, near:Number = 1, far:Number = 2048):Matrix3D {
        var y2:Number = near * Math.tan(fov * Math.PI / 360);
        var y1:Number = -y2;
        var x1:Number = y1 * aspect;
        var x2:Number = y2 * aspect;
        var a:Number = 2 * near / (x2 - x1);
        var b:Number = 2 * near / (y2 - y1);
        var c:Number = (x2 + x1) / (x2 - x1);
        var d:Number = (y2 + y1) / (y2 - y1);
        var q:Number = -(far + near) / (far - near);
        var qn:Number = -2 * (far * near) / (far - near);
        return new Matrix3D(Vector.<Number>([a, 0, 0, 0, 0, b, 0, 0, c, d, q, -1, 0, 0, qn, 0]));
    }

    public static function readString(bytes:ByteArray, length:int):String {
        var byte:uint = 0;
        var string:String = "";
        for (var i:int = 0; i < length; i++) {
            byte = bytes.readUnsignedByte();
            if (byte === 0) {
                bytes.position = bytes.position + Math.max(0, length - (i + 1));
                break;
            }
            string = string + String.fromCharCode(byte);
        }
        return string;
    }

    public static function upperPowerOfTwo(value:uint):uint {
        value--;
        value = value | value >> 1;
        value = value | value >> 2;
        value = value | value >> 4;
        value = value | value >> 8;
        value = value | value >> 16;
        value++;
        return value;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/proxies/Context3DProxy.as">
package svera.untiered.stage3D.proxies {
import flash.display3D.Context3D;
import flash.geom.Matrix3D;

public class Context3DProxy {


    private var context3D:Context3D;

    public function Context3DProxy(context3D:Context3D) {
        super();
        this.context3D = context3D;
    }

    public function GetContext3D():Context3D {
        return this.context3D;
    }

    public function configureBackBuffer(width:int, height:int, antiAlias:int, enableDepthAndStencil:Boolean = true):void {
        this.context3D.configureBackBuffer(width, height, antiAlias, enableDepthAndStencil);
    }

    public function createProgram():Program3DProxy {
        return new Program3DProxy(this.context3D.createProgram());
    }

    public function clear():void {
        this.context3D.clear();
    }

    public function present():void {
        this.context3D.present();
    }

    public function createIndexBuffer(numIndices:int):IndexBuffer3DProxy {
        return new IndexBuffer3DProxy(this.context3D.createIndexBuffer(numIndices));
    }

    public function createVertexBuffer(numVertices:int, data32PerVertex:int):VertexBuffer3DProxy {
        return new VertexBuffer3DProxy(this.context3D.createVertexBuffer(numVertices, data32PerVertex));
    }

    public function setVertexBufferAt(index:int, buffer:VertexBuffer3DProxy, bufferOffset:int, format:String = "float4"):void {
        this.context3D.setVertexBufferAt(index, buffer.getVertexBuffer3D(), bufferOffset, format);
    }

    public function setProgramConstantsFromMatrix(programType:String, firstRegister:int, matrix:Matrix3D, transposedMatrix:Boolean = false):void {
        this.context3D.setProgramConstantsFromMatrix(programType, firstRegister, matrix, transposedMatrix);
    }

    public function setProgramConstantsFromVector(programType:String, firstRegister:int, data:Vector.<Number>, numRegisters:int = -1):void {
        this.context3D.setProgramConstantsFromVector(programType, firstRegister, data, numRegisters);
    }

    public function createTexture(width:int, height:int, format:String, optimizeForRenderToTexture:Boolean):TextureProxy {
        return new TextureProxy(this.context3D.createTexture(width, height, format, optimizeForRenderToTexture));
    }

    public function setTextureAt(sampler:int, texture:TextureProxy):void {
        this.context3D.setTextureAt(sampler, texture.getTexture());
    }

    public function setProgram(program:Program3DProxy):void {
        this.context3D.setProgram(program.getProgram3D());
    }

    public function drawTriangles(indexBuffer:IndexBuffer3DProxy):void {
        this.context3D.drawTriangles(indexBuffer.getIndexBuffer3D());
    }

    public function setBlendFactors(sourceFactor:String, destinationFactory:String):void {
        this.context3D.setBlendFactors(sourceFactor, destinationFactory);
    }

    public function setDepthTest(depthMask:Boolean, passCompareMode:String):void {
        this.context3D.setDepthTest(depthMask, passCompareMode);
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/proxies/IndexBuffer3DProxy.as">
package svera.untiered.stage3D.proxies {
import flash.display3D.IndexBuffer3D;

public class IndexBuffer3DProxy {


    private var indexBuffer:IndexBuffer3D;

    public function IndexBuffer3DProxy(indexBuffer:IndexBuffer3D) {
        super();
        this.indexBuffer = indexBuffer;
    }

    public function uploadFromVector(data:Vector.<uint>, startOffset:int, count:int):void {
        this.indexBuffer.uploadFromVector(data, startOffset, count);
    }

    public function getIndexBuffer3D():IndexBuffer3D {
        return this.indexBuffer;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/proxies/Program3DProxy.as">
package svera.untiered.stage3D.proxies {
import flash.display3D.Program3D;
import flash.utils.ByteArray;

public class Program3DProxy {


    private var program3D:Program3D;

    public function Program3DProxy(program3D:Program3D) {
        super();
        this.program3D = program3D;
    }

    public function upload(vertexProgram:ByteArray, fragmentProgram:ByteArray):void {
        this.program3D.upload(vertexProgram, fragmentProgram);
    }

    public function getProgram3D():Program3D {
        return this.program3D;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/proxies/TextureProxy.as">
package svera.untiered.stage3D.proxies {
import flash.display.BitmapData;
import flash.display3D.textures.Texture;
import flash.display3D.textures.TextureBase;

public class TextureProxy {


    private var texture:Texture;

    protected var width:int;

    protected var height:int;

    public function TextureProxy(texture:Texture) {
        super();
        this.texture = texture;
    }

    public function uploadFromBitmapData(bitmapData:BitmapData):void {
        this.width = bitmapData.width;
        this.height = bitmapData.height;
        this.texture.uploadFromBitmapData(bitmapData);
    }

    public function getTexture():TextureBase {
        return this.texture;
    }

    public function getWidth():int {
        return this.width;
    }

    public function getHeight():int {
        return this.height;
    }

    public function dispose():void {
        this.texture.dispose();
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/proxies/VertexBuffer3DProxy.as">
package svera.untiered.stage3D.proxies {
import flash.display3D.VertexBuffer3D;

public class VertexBuffer3DProxy {


    private var vertexBuffer3D:VertexBuffer3D;

    protected var data:Vector.<Number>;

    public function VertexBuffer3DProxy(vertexBuffer3D:VertexBuffer3D) {
        super();
        this.vertexBuffer3D = vertexBuffer3D;
    }

    public function uploadFromVector(data:Vector.<Number>, startVertex:int, numVertices:int):void {
        this.data = data;
        this.vertexBuffer3D.uploadFromVector(data, startVertex, numVertices);
    }

    public function getVertexBuffer3D():VertexBuffer3D {
        return this.vertexBuffer3D;
    }

    public function getData():Vector.<Number> {
        return this.data;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Render3D.as">
package svera.untiered.stage3D {
import com.company.assembleegameclient.map.Camera;

import flash.display.IGraphicsData;

import org.osflash.signals.Signal;

import svera.untiered.stage3D.Object3D.Object3DStage3D;

public class Render3D extends Signal {


    public function Render3D() {
        super(Vector.<IGraphicsData>, Vector.<Object3DStage3D>, Number, Number, Camera, uint);
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/shaders/FragmentShader.as">
package svera.untiered.stage3D.shaders {
import com.adobe.utils.AGALMiniAssembler;

import flash.display3D.Context3DProgramType;
import flash.utils.ByteArray;

public class FragmentShader {


    private var vertexProgram:ByteArray;

    public function FragmentShader() {
        super();
        var fragmentShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
        fragmentShaderAssembler.assemble(Context3DProgramType.FRAGMENT, "tex ft1, v0, fs0 <2d>\n" + "mul ft1.x, ft1.x, fc2.x\n" + "mul ft1.y, ft1.y, fc2.y\n" + "mul ft1.z, ft1.z, fc2.z\n" + "mul ft1.w, ft1.w, fc2.w\n" + "add ft1, ft1, fc3\n" + "mov oc, ft1");
        this.vertexProgram = fragmentShaderAssembler.agalcode;
    }

    public function getVertexProgram():ByteArray {
        return this.vertexProgram;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/shaders/FragmentShaderRepeat.as">
package svera.untiered.stage3D.shaders {
import com.adobe.utils.AGALMiniAssembler;

import flash.display3D.Context3DProgramType;
import flash.utils.ByteArray;

public class FragmentShaderRepeat {


    private var vertexProgram:ByteArray;

    public function FragmentShaderRepeat() {
        super();
        var fragmentShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
        fragmentShaderAssembler.assemble(Context3DProgramType.FRAGMENT, "tex ft1, v0, fs0 <2d, repeat>\n" + "mul ft1.x, ft1.x, fc2.x\n" + "mul ft1.y, ft1.y, fc2.y\n" + "mul ft1.z, ft1.z, fc2.z\n" + "mul ft1.w, ft1.w, fc2.w\n" + "add ft1, ft1, fc3\n" + "mov oc, ft1");
        this.vertexProgram = fragmentShaderAssembler.agalcode;
    }

    public function getVertexProgram():ByteArray {
        return this.vertexProgram;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/shaders/VertextShader.as">
package svera.untiered.stage3D.shaders {
import com.adobe.utils.AGALMiniAssembler;

import flash.display3D.Context3DProgramType;
import flash.utils.ByteArray;

public class VertextShader extends AGALMiniAssembler {


    private var vertexProgram:ByteArray;

    public function VertextShader() {
        super();
        var vertexShaderAssembler:AGALMiniAssembler = new AGALMiniAssembler();
        vertexShaderAssembler.assemble(Context3DProgramType.VERTEX, "m44 op, va0, vc0\n" + "add vt1, va1, vc4\n" + "mov v0, vt1");
        this.vertexProgram = vertexShaderAssembler.agalcode;
    }

    public function getVertexProgram():ByteArray {
        return this.vertexProgram;
    }
}
}
</file>

<file path="src/svera/untiered/startup/control/StartupSequence.as">
package svera.untiered.startup.control {
import org.swiftsuspenders.Injector;

import svera.lib.tasks.BaseTask;
import svera.lib.tasks.Task;
import svera.untiered.startup.model.api.StartupDelegate;
import svera.untiered.startup.model.impl.SignalTaskDelegate;
import svera.untiered.startup.model.impl.TaskDelegate;

public class StartupSequence extends BaseTask {

    public static const LAST:int = int.MAX_VALUE;


    [Inject]
    public var injector:Injector;

    private const list:Vector.<StartupDelegate> = new Vector.<StartupDelegate>(0);

    private var index:int = 0;

    public function StartupSequence() {
        super();
    }

    public function addSignal(signalClass:Class, priority:int = 0):void {
        var delegate:SignalTaskDelegate = new SignalTaskDelegate();
        delegate.injector = this.injector;
        delegate.signalClass = signalClass;
        delegate.priority = priority;
        this.list.push(delegate);
    }

    public function addTask(taskClass:Class, priority:int = 0):void {
        var delegate:TaskDelegate = new TaskDelegate();
        delegate.injector = this.injector;
        delegate.taskClass = taskClass;
        delegate.priority = priority;
        this.list.push(delegate);
    }

    override protected function startTask():void {
        this.list.sort(this.priorityComparison);
        this.index = 0;
        this.doNextTaskOrComplete();
    }

    private function priorityComparison(a:StartupDelegate, b:StartupDelegate):int {
        return a.getPriority() - b.getPriority();
    }

    private function doNextTaskOrComplete():void {
        if (this.isAnotherTask()) {
            this.doNextTask();
        } else {
            completeTask(true);
        }
    }

    private function isAnotherTask():Boolean {
        return this.index < this.list.length;
    }

    private function doNextTask():void {
        var task:Task = this.list[this.index++].make();
        task.lastly.addOnce(this.onTaskFinished);
        task.start();
    }

    private function onTaskFinished(task:Task, isOK:Boolean, error:String):void {
        if (isOK) {
            this.doNextTaskOrComplete();
        } else {
            completeTask(false, error);
        }
    }
}
}
</file>

<file path="src/svera/untiered/startup/control/StartupSignal.as">
package svera.untiered.startup.control {
import org.osflash.signals.Signal;

public class StartupSignal extends Signal {


    public function StartupSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/startup/model/api/StartupDelegate.as">
package svera.untiered.startup.model.api {
import svera.lib.tasks.Task;

public interface StartupDelegate {


    function getPriority():int;

    function make():Task;
}
}
</file>

<file path="src/svera/untiered/startup/model/impl/SignalTaskDelegate.as">
package svera.untiered.startup.model.impl {
import org.osflash.signals.Signal;
import org.swiftsuspenders.Injector;

import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.untiered.startup.model.api.StartupDelegate;

public class SignalTaskDelegate implements StartupDelegate {


    public var injector:Injector;

    public var signalClass:Class;

    public var priority:int;

    public function SignalTaskDelegate() {
        super();
    }

    public function getPriority():int {
        return this.priority;
    }

    public function make():Task {
        var signal:Signal = this.injector.getInstance(this.signalClass);
        return new DispatchSignalTask(signal);
    }
}
}
</file>

<file path="src/svera/untiered/startup/model/impl/TaskDelegate.as">
package svera.untiered.startup.model.impl {
import org.swiftsuspenders.Injector;

import svera.lib.tasks.Task;
import svera.untiered.startup.model.api.StartupDelegate;

public class TaskDelegate implements StartupDelegate {


    public var injector:Injector;

    public var taskClass:Class;

    public var priority:int;

    public function TaskDelegate() {
        super();
    }

    public function getPriority():int {
        return this.priority;
    }

    public function make():Task {
        return this.injector.getInstance(this.taskClass);
    }
}
}
</file>

<file path="src/svera/untiered/storage/components/StorageSortTab.as">
package svera.untiered.storage.components {
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.util.MoreColorUtil;

import flash.display.Sprite;
import flash.events.MouseEvent;

public class StorageSortTab extends Sprite {

    public static const WEAPON:String = "WEAPON";
    public static const ABILITY:String = "ABILITY";
    public static const ARMOR:String = "ARMOR";
    public static const RING:String = "RING";
    public static const MISC:String = "MISC";
    public static const ALL:String = "ALL";

    private static const WEAPON_CATEGORY:Array = [1, 2, 17, 8, 24, 3, 26, 27, 28, 29, 30]; //slot types
    private static const ABILITY_CATEGORY:Array = [13, 11, 4, 16, 15, 12, 18, 19, 5, 20, 21, 25, 22, 23];
    private static const ARMOR_CATEGORY:Array = [6, 7, 14];
    private static const RING_CATEGORY:Array = [9];
    private static const OTHER_CATEGORY:Array = [10];

    public static const SIZE:int = 50;

    public static function getSortArray(sort:String):Array {
        switch (sort) {
            case WEAPON:
                return WEAPON_CATEGORY;
            case ABILITY:
                return ABILITY_CATEGORY;
            case ARMOR:
                return ARMOR_CATEGORY;
            case RING:
                return RING_CATEGORY;
            case MISC:
                return OTHER_CATEGORY;
        }
        return [];
    }

    public var filter_:String;

    private var selected_:Boolean;

    private var toolTip_:TextToolTip;

    public function StorageSortTab(filter:String) {
        this.filter_ = filter;

        this.toolTip_ = new TextToolTip(0x363636, 0xFFFFFF, filter, "", 100);

        graphics.clear();
        graphics.beginFill(0x161616);
        graphics.drawRect(0, 0, SIZE, SIZE);
        graphics.endFill();

        this.addEventListener(MouseEvent.ROLL_OVER, this.rollOver);
        this.addEventListener(MouseEvent.ROLL_OUT, this.rollOut);
    }

    public function select():void {
        this.selected_ = !this.selected_;
        if (this.selected_) {
            this.transform.colorTransform = MoreColorUtil.darkCT;
        } else {
            this.transform.colorTransform = MoreColorUtil.identity;
        }
    }

    public function unselect():void {
        this.selected_ = false;
        this.transform.colorTransform = MoreColorUtil.identity;
    }

    public function isSelected():Boolean {
        return this.selected_;
    }

    private function rollOver(e:MouseEvent):void {
        this.transform.colorTransform = MoreColorUtil.darkCT;

        this.toolTip_.attachToTarget(this);
        this.stage.addChild(this.toolTip_);
    }

    private function rollOut(e:MouseEvent):void {
        if (this.selected_) {
            return;
        }

        this.transform.colorTransform = MoreColorUtil.identity;

        this.toolTip_.attachToTarget(null);
        this.stage.removeChild(this.toolTip_);
    }
}
}
</file>

<file path="src/svera/untiered/storage/signals/VaultSlotUpdateSignal.as">
package svera.untiered.storage.signals {
import org.osflash.signals.Signal;

public class VaultSlotUpdateSignal extends Signal {
    public function VaultSlotUpdateSignal() {
        super(int, int, int);
    }
}
}
</file>

<file path="src/svera/untiered/storage/StorageUtil.as">
package svera.untiered.storage {
import svera.untiered.storage.components.StorageSortTab;

public class StorageUtil {

    public static const VAULT:int = 0;
    public static const GIFT:int = 1;

    public static const WINDOW_SIZE:int = 500;

    public static const CONTENT_WIDTH:int = 380;
    public static const CONTENT_HEIGHT:int = 400;
    public static const LEFT_PAD:int = 60;
    public static const TOP_PAD:int = 10;

    public static function makeStorageSortCategories():Vector.<StorageSortTab> {
        var categories:Vector.<StorageSortTab> = new Vector.<StorageSortTab>();

        categories[0] = new StorageSortTab(StorageSortTab.ALL);
        categories[1] = new StorageSortTab(StorageSortTab.WEAPON);
        categories[2] = new StorageSortTab(StorageSortTab.ABILITY);
        categories[3] = new StorageSortTab(StorageSortTab.ARMOR);
        categories[4] = new StorageSortTab(StorageSortTab.MISC);

        return categories;
    }
}
}
</file>

<file path="src/svera/untiered/tooltips/view/TooltipsMediator.as">
package svera.untiered.tooltips.view {
import com.company.assembleegameclient.ui.tooltip.ToolTip;

import svera.lib.framework.Mediator;

import svera.untiered.core.signals.HideTooltipsSignal;
import svera.untiered.core.signals.ShowTooltipSignal;

public class TooltipsMediator extends Mediator {


    [Inject]
    public var view:TooltipsView;

    [Inject]
    public var showTooltip:ShowTooltipSignal;

    [Inject]
    public var hideTooltips:HideTooltipsSignal;

    public function TooltipsMediator() {
        super();
    }

    override public function initialize():void {
        this.showTooltip.add(this.onShowTooltip);
        this.hideTooltips.add(this.onHideTooltips);
    }

    override public function destroy():void {
        this.showTooltip.remove(this.onShowTooltip);
        this.hideTooltips.remove(this.onHideTooltips);
    }

    private function onShowTooltip(tooltip:ToolTip):void {
        this.view.show(tooltip);
    }

    private function onHideTooltips():void {
        this.view.hide();
    }
}
}
</file>

<file path="src/svera/untiered/tooltips/view/TooltipsView.as">
package svera.untiered.tooltips.view {
import com.company.assembleegameclient.ui.tooltip.ToolTip;

import flash.display.Sprite;

public class TooltipsView extends Sprite {


    private var toolTip:ToolTip;

    public function TooltipsView() {
        super();
    }

    public function show(toolTip:ToolTip):void {
        this.hide();
        this.toolTip = toolTip;
        if (toolTip) {
            addChild(toolTip);
        }
    }

    public function hide():void {
        if (this.toolTip && this.toolTip.parent) {
            this.toolTip.parent.removeChild(this.toolTip);
        }
        this.toolTip = null;
    }
}
}
</file>

<file path="src/svera/untiered/ui/commands/EnterGameCommand.as">
package svera.untiered.ui.commands {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import svera.lib.framework.ICommand;

import svera.untiered.account.core.Account;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.model.GameInitData;
import svera.untiered.game.signals.PlayGameSignal;

public class EnterGameCommand implements ICommand {
    [Inject]
    public var account:Account;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var playGame:PlayGameSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    private const DEFAULT_CHARACTER:int = 782;

    public function EnterGameCommand() {
        super();
    }

    public function execute():void {
        this.showCurrentCharacterScreen();
    }

    private function showCurrentCharacterScreen():void {
        this.setScreenWithValidData.dispatch(new CharacterSelectionAndNewsScreen());
    }

    private function launchGame():void {
        this.playGame.dispatch(this.makeGameInitData());
    }

    private function makeGameInitData():GameInitData {
        var data:GameInitData = new GameInitData();
        data.createCharacter = true;
        data.charId = this.model.getNextCharId();
        data.isNewGame = true;
        return data;
    }
}
}
</file>

<file path="src/svera/untiered/ui/commands/HUDInitCommand.as">
package svera.untiered.ui.commands {
import com.company.assembleegameclient.editor.Command;
import com.company.assembleegameclient.game.GameSprite;

import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.signals.HUDModelInitialized;

public class HUDInitCommand extends Command {


    [Inject]
    public var gameSprite:GameSprite;

    [Inject]
    public var model:HUDModel;

    [Inject]
    public var hudModelInitialized:HUDModelInitialized;

    public function HUDInitCommand() {
        super();
    }

    override public function execute():void {
        this.model.gameSprite = this.gameSprite;
        this.hudModelInitialized.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/commands/ShowLoadingUICommand.as">
package svera.untiered.ui.commands {
import com.company.assembleegameclient.screens.AccountLoadingScreen;

import svera.lib.framework.ICommand;

import svera.untiered.core.signals.SetScreenSignal;

public class ShowLoadingUICommand implements ICommand {
    [Inject]
    public var setScreen:SetScreenSignal;

    public function ShowLoadingUICommand() {
        super();
    }

    public function execute():void {
        this.showLoadingScreen();
    }

    private function showLoadingScreen():void {
        this.setScreen.dispatch(new AccountLoadingScreen());
    }
}
}
</file>

<file path="src/svera/untiered/ui/model/HUDModel.as">
package svera.untiered.ui.model {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.parameters.Parameters;

public class HUDModel {


    public var gameSprite:GameSprite;

    public function HUDModel() {
        super();
    }

    public function getPlayerName():String {
        return this.gameSprite.model.getName() || "Undefined";
    }

    public function getButtonType():String {
        return this.gameSprite.gsc_.gameId_ == Parameters.NEXUS_GAMEID ? "OPTIONS_BUTTON" : "NEXUS_BUTTON";
    }
}
}
</file>

<file path="src/svera/untiered/ui/model/PotionModel.as">
package svera.untiered.ui.model {
import org.osflash.signals.Signal;

public class PotionModel {


    public var objectId:uint;

    public var maxPotionCount:int;

    public var position:int;

    public var available:Boolean;

    public var update:Signal;

    public function PotionModel() {
        super();
        this.update = new Signal(int);
        this.available = true;
    }
}
}
</file>

<file path="src/svera/untiered/ui/model/UpdateGameObjectTileVO.as">
package svera.untiered.ui.model {
import com.company.assembleegameclient.objects.GameObject;

public class UpdateGameObjectTileVO {


    public var tileX:int;

    public var tileY:int;

    public var gameObject:GameObject;

    public function UpdateGameObjectTileVO(tileX:int, tileY:int, gameObject:GameObject) {
        super();
        this.tileX = tileX;
        this.tileY = tileY;
        this.gameObject = gameObject;
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/BuyCharacterSlotSignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class BuyCharacterSlotSignal extends Signal {


    public function BuyCharacterSlotSignal() {
        super(int);
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/HUDModelInitialized.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class HUDModelInitialized extends Signal {


    public function HUDModelInitialized() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/HUDSetupStarted.as">
package svera.untiered.ui.signals {
import com.company.assembleegameclient.game.GameSprite;

import org.osflash.signals.Signal;

public class HUDSetupStarted extends Signal {


    public function HUDSetupStarted() {
        super(GameSprite);
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/NameChangedSignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class NameChangedSignal extends Signal {


    public function NameChangedSignal() {
        super(String);
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/ShowLoadingUISignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class ShowLoadingUISignal extends Signal {


    public function ShowLoadingUISignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/ShowTitleUISignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class ShowTitleUISignal extends Signal {


    public function ShowTitleUISignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/UpdateHUDSignal.as">
package svera.untiered.ui.signals {
import com.company.assembleegameclient.objects.Player;

import org.osflash.signals.Signal;

public class UpdateHUDSignal extends Signal {


    public function UpdateHUDSignal() {
        super(Player);
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/UpdatePotionInventorySignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class UpdatePotionInventorySignal extends Signal {


    public function UpdatePotionInventorySignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterDetailsMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.objects.Player;

import svera.lib.framework.Mediator;

import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.signals.HUDModelInitialized;
import svera.untiered.ui.signals.NameChangedSignal;
import svera.untiered.ui.signals.UpdateHUDSignal;

public class CharacterDetailsMediator extends Mediator {


    [Inject]
    public var view:CharacterDetailsView;

    [Inject]
    public var hudModel:HUDModel;

    [Inject]
    public var initHUDModelSignal:HUDModelInitialized;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    [Inject]
    public var nameChanged:NameChangedSignal;

    public function CharacterDetailsMediator() {
        super();
    }

    override public function initialize():void {
        this.view.init();
        this.updateHUD.addOnce(this.onUpdateHUD);
        this.updateHUD.add(this.onDraw);
        this.nameChanged.add(this.onNameChange);
    }

    override public function destroy():void {
        this.updateHUD.remove(this.onDraw);
        this.nameChanged.remove(this.onNameChange);
    }

    private function onUpdateHUD(player:Player):void {
        this.view.update(player);
    }

    private function onDraw(player:Player):void {
        this.view.draw(player);
    }

    private function onNameChange(name:String):void {
        this.view.setName(name);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterRectListMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.screens.NewCharacterScreen;
import com.company.assembleegameclient.screens.charrects.CharacterRectList;

import svera.lib.framework.Mediator;

import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.ui.signals.BuyCharacterSlotSignal;

public class CharacterRectListMediator extends Mediator {


    [Inject]
    public var view:CharacterRectList;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var buyCharacterSlotSignal:BuyCharacterSlotSignal;

    public function CharacterRectListMediator() {
        super();
    }

    override public function initialize():void {
        this.view.newCharacter.add(this.onNewCharacter);
        this.view.buyCharacterSlot.add(this.onBuyCharacterSlot);
    }

    override public function destroy():void {
        this.view.newCharacter.remove(this.onNewCharacter);
        this.view.buyCharacterSlot.remove(this.onBuyCharacterSlot);
    }

    private function onNewCharacter():void {
        this.setScreenWithValidData.dispatch(new NewCharacterScreen());
    }

    private function onBuyCharacterSlot(cost:int):void {
        this.buyCharacterSlotSignal.dispatch(cost);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterSlotNeedTsavoriteMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.parameters.Parameters;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class CharacterSlotNeedTsavoriteMediator extends Mediator {


    [Inject]
    public var view:CharacterSlotNeedTsavoriteDialog;

    [Inject]
    public var closeDialog:CloseDialogsSignal;

    [Inject]
    public var model:PlayerModel;

    public function CharacterSlotNeedTsavoriteMediator() {
        super();
    }

    override public function initialize():void {
        this.view.cancel.add(this.onCancel);
        this.view.setPrice(Parameters.CHARACTER_SLOT_PRICE);
    }

    override public function destroy():void {
        this.view.cancel.remove(this.onCancel);
    }

    public function onCancel():void {
        this.closeDialog.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterSlotRegisterMediator.as">
package svera.untiered.ui.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.signals.OpenAccountInfoSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class CharacterSlotRegisterMediator extends Mediator {


    [Inject]
    public var view:CharacterSlotRegisterDialog;

    [Inject]
    public var openAccountManagement:OpenAccountInfoSignal;

    [Inject]
    public var close:CloseDialogsSignal;

    public function CharacterSlotRegisterMediator() {
        super();
    }

    override public function initialize():void {
        this.view.cancel.add(this.onCancel);
        this.view.register.add(this.onRegister);
    }

    override public function destroy():void {
        this.view.cancel.remove(this.onCancel);
        this.view.register.remove(this.onRegister);
    }

    private function onRegister():void {
        this.openAccountManagement.dispatch();
    }

    private function onCancel():void {
        this.close.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterWindowBackground.as">
package svera.untiered.ui.view {
import flash.display.Sprite;

public class CharacterWindowBackground extends Sprite {


    public function CharacterWindowBackground() {
        super();
        var bg:Sprite = new Sprite();
        bg.graphics.beginFill(3552822);
        bg.graphics.drawRect(0, 0, 200, 600);
        addChild(bg);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/ChooseNameRegisterMediator.as">
package svera.untiered.ui.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.signals.OpenAccountInfoSignal;

public class ChooseNameRegisterMediator extends Mediator {


    [Inject]
    public var view:ChooseNameRegisterDialog;

    [Inject]
    public var openAccountManagement:OpenAccountInfoSignal;

    public function ChooseNameRegisterMediator() {
        super();
    }

    override public function initialize():void {
        this.view.register.add(this.onRegister);
        this.view.cancel.add(this.onCancel);
    }

    override public function destroy():void {
        this.view.register.remove(this.onRegister);
        this.view.cancel.remove(this.onCancel);
    }

    private function onRegister():void {
        this.onCancel();
        this.openAccountManagement.dispatch();
    }

    private function onCancel():void {
        this.view.parent.removeChild(this.view);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/components/PotionSlotMediator.as">
package svera.untiered.ui.view.components {
import com.company.assembleegameclient.objects.Player;

import svera.lib.framework.Mediator;

import svera.untiered.game.model.PotionInventoryModel;
import svera.untiered.game.model.UsePotionVO;
import svera.untiered.game.signals.UsePotionSignal;
import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.model.PotionModel;
import svera.untiered.ui.signals.UpdateHUDSignal;

public class PotionSlotMediator extends Mediator {


    [Inject]
    public var view:PotionSlotView;

    [Inject]
    public var hudModel:HUDModel;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    [Inject]
    public var potionInventoryModel:PotionInventoryModel;

    [Inject]
    public var usePotionSignal:UsePotionSignal;

    public function PotionSlotMediator() {
        super();
    }

    override public function initialize():void {
        this.updateHUD.addOnce(this.initializeData);
        //this.view.drop.add(this.onDrop);
        this.view.buyUse.add(this.onBuyUse);
        this.updateHUD.add(this.update);
    }

    override public function destroy():void {
        //this.view.drop.remove(this.onDrop);
        this.view.buyUse.remove(this.onBuyUse);
        this.updateHUD.remove(this.update);
    }

    private function initializeData(player:Player):void {
        var potionModel:PotionModel = this.potionInventoryModel.potionModels[this.view.position];
        var count:int = player.getPotionCount(potionModel.objectId);
        this.view.setData(count, potionModel.available, potionModel.objectId);
    }

    private function update(player:Player):void {
        var potModel:PotionModel = null;
        var count:int = 0;
        if (this.view.objectType == PotionInventoryModel.HEALTH_POTION_ID || this.view.objectType == PotionInventoryModel.MAGIC_POTION_ID) {
            potModel = this.potionInventoryModel.getPotionModel(this.view.objectType);
            count = player.getPotionCount(potModel.objectId);
            this.view.setData(count, potModel.available);
        }
    }

    /*private function onDrop(targetDO:DisplayObject) : void
    {
       var tile:InteractiveItemTile = null;
       var player:Player = this.hudModel.gameSprite.map.player_;
       var target:* = DisplayHierarchy.getParentWithTypeArray(targetDO,InteractiveItemTile,Map);
       if(target is Map || Parameters.GPURenderFrame && target == null)
       {
          GameServerConnection.instance.invDrop(player,PotionInventoryModel.getPotionSlot(this.view.objectType),this.view.objectType);
       }
       else if(target is InteractiveItemTile)
       {
          tile = target as InteractiveItemTile;
          if(tile.getItemId() == ItemConstants.NO_ITEM && tile.ownerGrid.owner != player)
          {
             GameServerConnection.instance.invSwapPotion(player,player,PotionInventoryModel.getPotionSlot(this.view.objectType),this.view.objectType,tile.ownerGrid.owner,tile.tileId,ItemConstants.NO_ITEM);
          }
       }
    }*/

    private function onBuyUse():void {
        var vo:UsePotionVO = null;
        var potModel:PotionModel = this.potionInventoryModel.potionModels[this.view.position];
        if (potModel.available) {
            vo = new UsePotionVO(potModel.objectId, UsePotionVO.SHIFTCLICK);
            this.usePotionSignal.dispatch(vo);
        }
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/components/PotionSlotView.as">
package svera.untiered.ui.view.components {
import com.company.ui.SimpleText;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.GraphicsSolidFill;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.TimerEvent;
import flash.filters.ColorMatrixFilter;
import flash.filters.DropShadowFilter;
import flash.utils.Timer;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeSignal;

public class PotionSlotView extends Sprite {
    private static var BUTTON_HEIGHT:int = 24;
    private static const DOUBLE_CLICK_PAUSE:uint = 250;
    //private static const DRAG_DIST:int = 3;

    public var position:int;
    public var objectType:int;
    public var click:NativeSignal;
    public var buyUse:Signal;
    //public var drop:Signal;
    private var lightGrayFill:GraphicsSolidFill;
    private var midGrayFill:GraphicsSolidFill;
    private var darkGrayFill:GraphicsSolidFill;
    private var text:SimpleText;
    //private var potionIconDraggableSprite:Sprite;
    private var potionIcon:Bitmap;
    private var grayscaleMatrix:ColorMatrixFilter;
    private var available:Boolean = false;
    private var doubleClickTimer:Timer;
    //private var dragStart:Point;
    private var pendingSecondClick:Boolean;
    //private var isDragging:Boolean;
    private var showPots:Boolean;

    public function PotionSlotView(position:int) {
        this.lightGrayFill = new GraphicsSolidFill(5526612, 1);
        this.midGrayFill = new GraphicsSolidFill(4078909, 1);
        this.darkGrayFill = new GraphicsSolidFill(2368034, 1);
        super();
        mouseChildren = false;
        this.position = position;
        this.grayscaleMatrix = new ColorMatrixFilter(MoreColorUtil.greyscaleFilterMatrix);
        this.text = new SimpleText(8, 16777215, false, BUTTON_HEIGHT, BUTTON_HEIGHT);
        this.text.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        this.text.y = 4;
        addChild(this.text);
        //this.potionIconDraggableSprite = new Sprite();
        this.doubleClickTimer = new Timer(DOUBLE_CLICK_PAUSE, 1);
        this.doubleClickTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onDoubleClickTimerComplete);
        //addEventListener(MouseEvent.MOUSE_DOWN,this.onMouseDown);
        addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        this.click = new NativeSignal(this, MouseEvent.CLICK, MouseEvent);
        this.buyUse = new Signal();
        //this.drop = new Signal(DisplayObject);
    }

    public function setData(potions:int, available:Boolean, objectType:int = -1):void {
        if (objectType != -1) {
            this.objectType = objectType;
        }
        this.available = available;
        filters = available ? [] : [this.grayscaleMatrix];
        showPots = potions > 0;
        if (showPots) {
            this.text.text = String(potions);
            this.text.textColor = 16777215;
            this.text.x = 5;
        } else {
            this.text.text = "0";
            this.text.textColor = 11184810;
            this.text.x = 5;
        }
    }

    private function onMouseOut(e:MouseEvent):void {
        this.setPendingDoubleClick(false);
    }

    private function onMouseUp(e:MouseEvent):void {
        //if(this.isDragging)
        //{
        //   return;
        //}
        if (e.shiftKey) {
            this.setPendingDoubleClick(false);
            this.buyUse.dispatch();
        } else if (!this.pendingSecondClick) {
            this.setPendingDoubleClick(true);
        } else {
            this.setPendingDoubleClick(false);
            this.buyUse.dispatch();
        }
    }

    //private function onMouseDown(e:MouseEvent) : void
    //{
    //   if(showPots)
    //   {
    //      this.beginDragCheck(e);
    //   }
    //}

    private function setPendingDoubleClick(isPending:Boolean):void {
        this.pendingSecondClick = isPending;
        if (this.pendingSecondClick) {
            this.doubleClickTimer.reset();
            this.doubleClickTimer.start();
        } else {
            this.doubleClickTimer.stop();
        }
    }

    //private function beginDragCheck(e:MouseEvent) : void
    //{
    //   this.dragStart = new Point(e.stageX,e.stageY);
    //   addEventListener(MouseEvent.MOUSE_MOVE,this.onMouseMoveCheckDrag);
    //   addEventListener(MouseEvent.MOUSE_OUT,this.cancelDragCheck);
    //   addEventListener(MouseEvent.MOUSE_UP,this.cancelDragCheck);
    //}

    //private function cancelDragCheck(e:MouseEvent) : void
    //{
    //   removeEventListener(MouseEvent.MOUSE_MOVE,this.onMouseMoveCheckDrag);
    //   removeEventListener(MouseEvent.MOUSE_OUT,this.cancelDragCheck);
    //   removeEventListener(MouseEvent.MOUSE_UP,this.cancelDragCheck);
    //}

    //private function onMouseMoveCheckDrag(e:MouseEvent) : void
    //{
    //   var dx:Number = e.stageX - this.dragStart.x;
    //   var dy:Number = e.stageY - this.dragStart.y;
    //   var distance:Number = Math.sqrt(dx * dx + dy * dy);
    //   if(distance > DRAG_DIST)
    //   {
    //      this.cancelDragCheck(null);
    //      this.setPendingDoubleClick(false);
    //      this.beginDrag();
    //   }
    //}

    private function onDoubleClickTimerComplete(e:TimerEvent):void {
        this.setPendingDoubleClick(false);
    }

    //private function beginDrag() : void
    //{
    //   this.isDragging = true;
    //   this.potionIconDraggableSprite.startDrag(true);
    //   stage.addChild(this.potionIconDraggableSprite);
    //   this.potionIconDraggableSprite.addEventListener(MouseEvent.MOUSE_UP,this.endDrag);
    //}

    //private function endDrag(e:MouseEvent) : void
    //{
    //   this.isDragging = false;
    //   this.potionIconDraggableSprite.stopDrag();
    //   this.potionIconDraggableSprite.x = this.dragStart.x;
    //   this.potionIconDraggableSprite.y = this.dragStart.y;
    //   stage.removeChild(this.potionIconDraggableSprite);
    //   this.potionIconDraggableSprite.removeEventListener(MouseEvent.MOUSE_UP,this.endDrag);
    //   this.drop.dispatch(this.potionIconDraggableSprite.dropTarget);
    //}

    private function onRemovedFromStage(e:Event):void {
        this.setPendingDoubleClick(false);
        //this.cancelDragCheck(null);
        //if(this.isDragging)
        //{
        //   this.potionIconDraggableSprite.stopDrag();
        //}
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CurrentCharacterMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;
import com.company.assembleegameclient.screens.NewCharacterScreen;

import svera.lib.framework.Mediator;

import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.game.model.GameInitData;
import svera.untiered.game.signals.PlayGameSignal;
import svera.untiered.ui.signals.NameChangedSignal;

public class CurrentCharacterMediator extends Mediator {


    [Inject]
    public var view:CharacterSelectionAndNewsScreen;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var classesModel:ClassesModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var playGame:PlayGameSignal;

    [Inject]
    public var nameChanged:NameChangedSignal;

    public function CurrentCharacterMediator() {
        super();
    }

    override public function initialize():void {
        this.view.close.add(this.onClose);
        this.view.newCharacter.add(this.onNewCharacter);
        this.view.showClasses.add(this.onNewCharacter);
        this.view.playGame.add(this.onPlayGame);
        this.view.initialize(this.playerModel);
        this.nameChanged.add(this.onNameChanged);
    }

    override public function destroy():void {
        this.nameChanged.remove(this.onNameChanged);
        this.view.close.remove(this.onClose);
        this.view.newCharacter.remove(this.onNewCharacter);
        this.view.showClasses.remove(this.onNewCharacter);
        this.view.playGame.remove(this.onPlayGame);
    }

    private function onNameChanged(name:String):void {
        this.view.setName(name);
    }

    private function onNewCharacter():void {
        this.setScreen.dispatch(new NewCharacterScreen());
    }

    private function onClose():void {
        this.setScreen.dispatch(new TitleView());
    }

    private function onPlayGame():void {
        var character:SavedCharacter = this.playerModel.getCharacterByIndex(0);
        this.playerModel.currentCharId = character.charId();
        var characterClass:CharacterClass = this.classesModel.getCharacterClass(character.objectType());
        characterClass.setIsSelected(true);
        characterClass.skins.getSkin(character.skinType()).setIsSelected(true);
        var game:GameInitData = new GameInitData();
        game.createCharacter = false;
        game.charId = character.charId();
        game.isNewGame = true;
        this.playGame.dispatch(game);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CurrentCharacterRectMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.screens.charrects.CurrentCharacterRect;

import svera.lib.framework.Mediator;

import svera.untiered.characters.deletion.view.ConfirmDeleteCharacterDialog;
import svera.untiered.characters.model.CharacterModel;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.model.GameInitData;
import svera.untiered.game.signals.PlayGameSignal;

public class CurrentCharacterRectMediator extends Mediator {


    [Inject]
    public var view:CurrentCharacterRect;

    [Inject]
    public var playGame:PlayGameSignal;

    [Inject]
    public var model:CharacterModel;

    [Inject]
    public var classesModel:ClassesModel;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function CurrentCharacterRectMediator() {
        super();
    }

    override public function initialize():void {
        this.view.selected.add(this.onSelected);
        this.view.deleteCharacter.add(this.onDeleteCharacter);
    }

    override public function destroy():void {
        this.view.selected.remove(this.onSelected);
        this.view.deleteCharacter.remove(this.onDeleteCharacter);
    }

    private function onSelected(character:SavedCharacter):void {
        var characterClass:CharacterClass = this.classesModel.getCharacterClass(character.objectType());
        characterClass.setIsSelected(true);
        characterClass.skins.getSkin(character.skinType()).setIsSelected(true);
        this.launchGame(character);
    }

    private function launchGame(character:SavedCharacter):void {
        var data:GameInitData = new GameInitData();
        data.createCharacter = false;
        data.charId = character.charId();
        data.isNewGame = true;
        this.playGame.dispatch(data);
    }

    private function onDeleteCharacter(character:SavedCharacter):void {
        this.model.select(character);
        this.openDialog.dispatch(new ConfirmDeleteCharacterDialog());
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/ErrorDialogMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;
import com.company.assembleegameclient.ui.dialogs.ErrorDialog;

import flash.events.Event;

import svera.lib.framework.Mediator;

import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class ErrorDialogMediator extends Mediator {

    [Inject]
    public var invalidateData:InvalidateDataSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var close:CloseDialogsSignal;
    // Type-safe view accessor
    private function get errorDialog():ErrorDialog {
        return view as ErrorDialog;
    }

    override protected function onInitialize():void {
        errorDialog.addEventListener(Event.COMPLETE, this.onComplete);
        errorDialog.ok.addOnce(this.onClose);
    }

    override public function destroy():void {
        errorDialog.removeEventListener(Event.COMPLETE, this.onComplete);
    }

    public function onClose():void {
        this.close.dispatch();
    }

    private function onComplete(event:Event):void {
        this.invalidateData.dispatch();
        this.setScreenWithValidData.dispatch(new CharacterSelectionAndNewsScreen());
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/HUDMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.objects.Player;

import svera.lib.framework.Mediator;

import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.signals.UpdateHUDSignal;

public class HUDMediator extends Mediator {


    [Inject]
    public var view:HUDView;

    [Inject]
    public var hudModel:HUDModel;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    public function HUDMediator() {
        super();
    }

    override public function initialize():void {
        this.updateHUD.addOnce(this.onInitializeHUD);
        this.updateHUD.add(this.onUpdateHUD);
    }

    override public function destroy():void {
        this.updateHUD.remove(this.onUpdateHUD);
    }

    private function onUpdateHUD(player:Player):void {
        this.view.draw();
    }

    private function onInitializeHUD(player:Player):void {
        this.view.setPlayerDependentAssets(this.hudModel.gameSprite);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/MapEditorMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.mapeditor.MapEditor;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.PlayerModel;

public class MapEditorMediator extends Mediator {


    [Inject]
    public var view:MapEditor;

    [Inject]
    public var model:PlayerModel;

    public function MapEditorMediator() {
        super();
    }

    override public function initialize():void {
        this.view.initialize(this.model);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/MessageCloseMediator.as">
package svera.untiered.ui.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class MessageCloseMediator extends Mediator {
    [Inject]
    public var account:Account;

    [Inject]
    public var view:MessageCloseDialog;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    public function MessageCloseMediator() {
        super();
    }

    override public function initialize():void {
        this.view.cancel.add(this.onCancel);
    }

    override public function destroy():void {
        this.view.cancel.remove(this.onCancel);
    }

    public function onCancel():void {
        this.closeDialogs.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/NotEnoughTsavoriteMediator.as">
package svera.untiered.ui.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.dialogs.control.CloseDialogsSignal;

public class NotEnoughTsavoriteMediator extends Mediator {
    [Inject]
    public var account:Account;

    [Inject]
    public var view:NotEnoughTsavoriteDialog;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    public function NotEnoughTsavoriteMediator() {
        super();
    }

    override public function initialize():void {
        this.view.cancel.add(this.onCancel);
    }

    override public function destroy():void {
        this.view.cancel.remove(this.onCancel);
    }

    public function onCancel():void {
        this.closeDialogs.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/SignalWaiter.as">
package svera.untiered.ui.view {
import com.adobe.utils.DictionaryUtil;

import flash.utils.Dictionary;

import org.osflash.signals.Signal;

public class SignalWaiter {

    public var complete:Signal;
    private var texts:Dictionary;

    public function SignalWaiter() {
        this.complete = new Signal();
        this.texts = new Dictionary();
        super();
    }

    public function push(_arg1:Signal):SignalWaiter {
        this.texts[_arg1] = true;
        this.listenTo(_arg1);
        return this;
    }

    public function pushArgs(..._args):SignalWaiter {
        var _local2:Signal;
        for each (_local2 in _args) {
            this.push(_local2);
        }
        return this;
    }

    private function listenTo(value:Signal):void {
        var onTextChanged:Function;
        onTextChanged = function ():void {
            delete texts[value];
            checkEmpty();
        };
        value.addOnce(onTextChanged);
    }

    private function checkEmpty():void {
        if (this.isEmpty()) {
            this.complete.dispatch();
        }
    }

    public function isEmpty():Boolean {
        return DictionaryUtil.getKeys(this.texts).length == 0;
    }


}
}
</file>

<file path="src/svera/untiered/ui/view/SplashView.as">
package svera.untiered.ui.view {
import flash.display.Bitmap;
import flash.display.Sprite;
import flash.events.Event;
import flash.utils.getDefinitionByName;
import flash.utils.getTimer;

import org.osflash.signals.Signal;

import svera.untiered.assets.EmbeddedAssets;
import svera.untiered.ui.view.components.ScreenBase;

public class SplashView extends Sprite {
    private static const FADE_DURATION:Number = 2.0;
    private static const DISPLAY_DELAY:Number = 1.0;
    private static const BASE_LOGO_SCALE:Number = 1.0; // Base scale at 800x600

    public var fadeCompleted:Signal;

    private var logo:Bitmap;
    private var isDestroyed:Boolean = false;
    private var fadeHandler:Function;
    private var originalLogoWidth:Number;
    private var originalLogoHeight:Number;

    public function SplashView() {
        super();
        this.fadeCompleted = new Signal();
        this.setupResizeListener();
        this.createEmbeddedLogo();
    }

    private function setupResizeListener():void {
        // Listen for stage resize events, same as ScreenBase
        GameClient.STAGE.addEventListener(Event.RESIZE, this.onResize, false, 0, true);
    }

    private function createEmbeddedLogo():void {
        if (this.isDestroyed) return;

        try {
            // Create logo from embedded asset
            this.logo = new EmbeddedAssets.SplashLogo() as Bitmap;

            if (this.logo) {
                // Store original dimensions before any scaling
                this.originalLogoWidth = this.logo.width;
                this.originalLogoHeight = this.logo.height;
                // Enable bitmap caching for smooth fade performance
                this.logo.cacheAsBitmap = true;

                addChild(this.logo);

                // Position and scale the logo based on current stage size
                this.updateLogoPosition();
            }
        } catch (error:Error) {
            // If embedded asset fails, continue without logo
            trace("SplashView: Failed to load embedded logo:", error.message);
        }

        // Start fade sequence regardless of logo success
        this.startFadeSequence();
    }

    private function onResize(event:Event):void {
        if (this.isDestroyed || !this.logo) return;

        // Update logo position and scale when stage resizes
        this.updateLogoPosition();
    }

    private function updateLogoPosition():void {
        if (!this.logo) return;

        // Calculate scale based on stage size (similar to how other UI elements scale)
        var stageWidth:Number = GameClient.StageWidth || 800;
        var stageHeight:Number = GameClient.StageHeight || 600;

        // Scale logo proportionally based on stage size
        // Use the smaller ratio to maintain aspect ratio
        var scaleX:Number = stageWidth / 800;
        var scaleY:Number = stageHeight / 600;
        var scale:Number = Math.min(scaleX, scaleY) * BASE_LOGO_SCALE;

        // Apply the scale
        this.logo.scaleX = scale;
        this.logo.scaleY = scale;

        // Center the scaled logo on stage
        this.logo.x = stageWidth / 2 - this.originalLogoWidth * scale / 2;
        this.logo.y = stageHeight / 2 - this.originalLogoHeight * scale / 2;
    }

    private function startFadeSequence():void {
        if (this.isDestroyed) return;

        // Use TweenLite if available, otherwise use simple timer-based fade
        if (this.isTweenLiteAvailable()) {
            this.startTweenLiteFade();
        } else {
            this.startManualFade();
        }
    }

    private function isTweenLiteAvailable():Boolean {
        try {
            // Try to access TweenLite class
            var tweenLiteClass:Class = getDefinitionByName("com.greensock.TweenLite") as Class;
            return tweenLiteClass != null;
        } catch (error:Error) {
            return false;
        }
    }

    private function startTweenLiteFade():void {
        if (this.isDestroyed) return;

        // Use TweenLite for smooth fade
        var tweenLiteClass:Class = getDefinitionByName("com.greensock.TweenLite") as Class;
        tweenLiteClass.to(this.logo, FADE_DURATION, {
            alpha: 0,
            delay: DISPLAY_DELAY,
            onComplete: this.onFadeComplete
        });
    }

    private function startManualFade():void {
        if (this.isDestroyed) return;

        // Fallback: Manual fade using ENTER_FRAME
        var fadeStartTime:Number = -1;
        var displayStartTime:Number = getTimer();
        var self:SplashView = this;

        this.fadeHandler = function(event:Event):void {
            if (self.isDestroyed) {
                self.removeEventListener(Event.ENTER_FRAME, self.fadeHandler);
                return;
            }

            var currentTime:Number = getTimer();

            // Wait for display delay
            if (currentTime - displayStartTime < DISPLAY_DELAY * 1000) {
                return;
            }

            // Initialize fade start time
            if (fadeStartTime == -1) {
                fadeStartTime = currentTime;
            }

            // Calculate fade progress
            var fadeElapsed:Number = (currentTime - fadeStartTime) / 1000;
            var fadeProgress:Number = Math.min(fadeElapsed / FADE_DURATION, 1.0);

            // Apply alpha
            if (self.logo) {
                self.logo.alpha = 1.0 - fadeProgress;
            }

            // Check if fade is complete
            if (fadeProgress >= 1.0) {
                self.removeEventListener(Event.ENTER_FRAME, self.fadeHandler);
                self.onFadeComplete();
            }
        };

        addEventListener(Event.ENTER_FRAME, this.fadeHandler);
    }

    private function onFadeComplete():void {
        if (this.isDestroyed) return;

        // Dispatch signal first, then cleanup
        if (this.fadeCompleted) {
            this.fadeCompleted.dispatch();
        }

        this.cleanupAssets();
    }

    private function cleanupAssets():void {
        // Remove logo from stage
        if (this.logo && this.logo.parent) {
            this.logo.parent.removeChild(this.logo);
        }

        // Remove manual fade event listener if it exists
        if (this.fadeHandler) {
            removeEventListener(Event.ENTER_FRAME, this.fadeHandler);
            this.fadeHandler = null;
        }

        // Nullify references for garbage collection
        this.logo = null;
    }

    public function destroy():void {
        this.isDestroyed = true;

        this.cleanupAssets();

        if (this.fadeCompleted) {
            this.fadeCompleted.removeAll();
            this.fadeCompleted = null;
        }
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/StatMetersMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.objects.Player;

import svera.lib.framework.Mediator;

import svera.untiered.ui.model.HUDModel;
import svera.untiered.ui.signals.UpdateHUDSignal;

public class StatMetersMediator extends Mediator {


    [Inject]
    public var view:StatMetersView;

    [Inject]
    public var hudModel:HUDModel;

    [Inject]
    public var updateHUD:UpdateHUDSignal;

    public function StatMetersMediator() {
        super();
    }

    override public function initialize():void {
        this.updateHUD.add(this.onUpdateHUD);
    }

    override public function destroy():void {
        this.updateHUD.add(this.onUpdateHUD);
    }

    private function onUpdateHUD(player:Player):void {
        this.view.update(player);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/api/BuyButton.as">
package svera.untiered.util.components.api {
import flash.display.Sprite;

public class BuyButton extends Sprite {


    public function BuyButton() {
        super();
    }

    public function setPrice(price:int, currency:int):void {
    }

    public function setEnabled(enabled:Boolean):void {
    }

    public function setWidth(w:int):void {
    }
}
}
</file>

<file path="src/svera/untiered/util/components/DialogBackground.as">
package svera.untiered.util.components {
import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;

import svera.untiered.util.graphics.BevelRect;
import svera.untiered.util.graphics.GraphicsHelper;

public class DialogBackground extends Sprite {

    private static const BEVEL:int = 4;


    public function DialogBackground() {
        super();
    }

    public function draw(width:int, height:int):void {
        var rect:BevelRect = new BevelRect(width, height, BEVEL);
        var helper:GraphicsHelper = new GraphicsHelper();
        graphics.lineStyle(1, 16777215, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3);
        graphics.beginFill(3552822);
        helper.drawBevelRect(0, 0, rect, graphics);
        graphics.endFill();
    }
}
}
</file>

<file path="src/svera/untiered/util/components/HorizontalScrollingList.as">
package svera.untiered.util.components {
import svera.lib.ui.impl.HorizontalLayout;
import svera.untiered.util.components.*;

import flash.display.DisplayObject;
import flash.display.Sprite;

import org.osflash.signals.Signal;

import svera.lib.ui.api.List;
import svera.lib.ui.api.Size;
import svera.lib.ui.impl.LayoutList;

public class HorizontalScrollingList extends Sprite implements List {
    public static const SCROLLBAR_PADDING:int = 2;
    public static const SCROLLBAR_GUTTER:int = HorizontalScrollbar.HEIGHT + SCROLLBAR_PADDING;

    public const scrollStateChanged:Signal = new Signal(Boolean);
    private var layout:HorizontalLayout;
    private var list:LayoutList;
    private var scrollbar:HorizontalScrollbar;
    private var isEnabled:Boolean = true;
    private var size:Size;

    public function HorizontalScrollingList() {
        super();
        this.makeLayout();
        this.makeVerticalList();
        this.makeScrollbar();
    }

    public function getIsEnabled():Boolean {
        return this.isEnabled;
    }

    public function setIsEnabled(value:Boolean):void {
        this.isEnabled = value;
        this.scrollbar.setIsEnabled(value);
    }

    public function setSize(size:Size):void {
        this.size = size;
        if (this.isScrollbarVisible()) {
            size = new Size(size.width - SCROLLBAR_GUTTER, size.height);
        }
        this.list.setSize(size);
        this.refreshScrollbar();
    }

    public function setPadding(padding:int):void {
        this.layout.setPadding(padding);
        this.list.updateLayout();
        this.refreshScrollbar();
    }

    public function addItem(item:DisplayObject):void {
        this.list.addItem(item);
    }

    public function setItems(items:Vector.<DisplayObject>):void {
        this.list.setItems(items);
    }

    public function getItemAt(index:int):DisplayObject {
        return this.list.getItemAt(index);
    }

    public function getItemCount():int {
        return this.list.getItemCount();
    }

    public function getListHeight():int {
        return this.list.getSizeOfItems().height;
    }

    private function makeLayout():void {
        this.layout = new HorizontalLayout();
    }

    public function isScrollbarVisible():Boolean {
        return this.scrollbar.visible;
    }

    private function makeVerticalList():void {
        this.list = new LayoutList();
        this.list.itemsChanged.add(this.refreshScrollbar);
        this.list.setLayout(this.layout);
        addChild(this.list);
    }

    private function refreshScrollbar():void {
        var isVisible:Boolean;
        var listSize:Size = this.list.getSize();
        var visibleSize:int = listSize.width;
        var itemsSize:int = this.list.getSizeOfItems().width;
        isVisible = itemsSize > visibleSize;
        var isChanged:Boolean = this.scrollbar.visible != isVisible;
        this.scrollbar.visible = isVisible;
        isVisible && this.updateScrollbarSize(visibleSize, itemsSize);
        isChanged && this.updateUiAndDispatchStateChange(isVisible);
    }

    private function updateUiAndDispatchStateChange(isVisible:Boolean):void {
        this.setSize(this.size);
        this.scrollStateChanged.dispatch(isVisible);
    }

    private function updateScrollbarSize(visibleSize:int, itemsSize:int):void {
        var barSize:int = visibleSize * (visibleSize / itemsSize);
        this.scrollbar.setSize(barSize, visibleSize);
        this.scrollbar.x = this.list.getSize().width + SCROLLBAR_PADDING;
    }

    private function makeScrollbar():void {
        this.scrollbar = new HorizontalScrollbar();
        this.scrollbar.positionChanged.add(this.onPositionChanged);
        this.scrollbar.visible = false;
        addChild(this.scrollbar);
    }

    private function onPositionChanged(value:Number):void {
        var maxOffset:int = this.list.getSizeOfItems().width - this.list.getSize().width;
        this.list.setOffset(maxOffset * value);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/StarsView.as">
package svera.untiered.util.components {
import com.company.untiered.graphics.StarGraphic;

import flash.display.Graphics;
import flash.display.Sprite;
import flash.geom.ColorTransform;

public class StarsView extends Sprite {

    private static const TOTAL:int = 5;

    private static const MARGIN:int = 4;

    private static const CORNER:int = 15;

    private static const BACKGROUND_COLOR:uint = 2434341;

    private static const EMPTY_STAR_COLOR:uint = 8618883;

    private static const FILLED_STAR_COLOR:uint = 16777215;


    private const stars:Vector.<StarGraphic> = makeStars();

    private const background:Sprite = makeBackground();

    public function StarsView() {
        super();
    }

    private function makeStars():Vector.<StarGraphic> {
        var list:Vector.<StarGraphic> = this.makeStarList();
        this.layoutStars(list);
        return list;
    }

    private function makeStarList():Vector.<StarGraphic> {
        var list:Vector.<StarGraphic> = new Vector.<StarGraphic>(TOTAL, true);
        for (var i:int = 0; i < TOTAL; i++) {
            list[i] = new StarGraphic();
            addChild(list[i]);
        }
        return list;
    }

    private function layoutStars(list:Vector.<StarGraphic>):void {
        for (var i:int = 0; i < TOTAL; i++) {
            list[i].x = MARGIN + list[0].width * i;
            list[i].y = MARGIN;
        }
    }

    private function makeBackground():Sprite {
        var sprite:Sprite = new Sprite();
        this.drawBackground(sprite.graphics);
        addChildAt(sprite, 0);
        return sprite;
    }

    private function drawBackground(graphics:Graphics):void {
        var star:StarGraphic = this.stars[0];
        var width:int = star.width * TOTAL + 2 * MARGIN;
        var height:int = star.height + 2 * MARGIN;
        graphics.clear();
        graphics.beginFill(BACKGROUND_COLOR);
        graphics.drawRoundRect(0, 0, width, height, CORNER, CORNER);
        graphics.endFill();
    }

    public function setStars(filled:int):void {
        for (var i:int = 0; i < TOTAL; i++) {
            this.updateStar(i, filled);
        }
    }

    private function updateStar(index:int, filled:int):void {
        var star:StarGraphic = this.stars[index];
        var ct:ColorTransform = star.transform.colorTransform;
        ct.color = index < filled ? uint(FILLED_STAR_COLOR) : uint(EMPTY_STAR_COLOR);
        star.transform.colorTransform = ct;
    }
}
}
</file>

<file path="src/svera/untiered/util/components/VerticalScrollbarBar.as">
package svera.untiered.util.components {
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.util.graphics.BevelRect;
import svera.untiered.util.graphics.GraphicsHelper;

public final class VerticalScrollbarBar extends Sprite {
    public static const WIDTH:int = VerticalScrollbar.WIDTH;
    public static const BEVEL:int = VerticalScrollbar.BEVEL;
    public static const PADDING:int = VerticalScrollbar.PADDING;

    public const dragging:Signal = new Signal(int);
    public const rect:BevelRect = new BevelRect(WIDTH - PADDING * 2, 0, BEVEL);
    private const helper:GraphicsHelper = new GraphicsHelper();
    private var downOffset:Number;
    private var isOver:Boolean;
    private var isDown:Boolean;

    function VerticalScrollbarBar() {
        super();
    }

    public function redraw():void {
        var color:int = this.isOver || this.isDown ? int(16767876) : int(13421772);
        graphics.clear();
        graphics.beginFill(color);
        this.helper.drawBevelRect(PADDING, 0, this.rect, graphics);
        graphics.endFill();
    }

    public function addMouseListeners():void {
        addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
    }

    public function removeMouseListeners():void {
        removeEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        removeEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        this.onMouseUp();
    }

    private function onMouseDown(event:MouseEvent = null):void {
        this.isDown = true;
        this.downOffset = parent.mouseY - y;
        stage.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        addEventListener(Event.ENTER_FRAME, this.iterate);
        this.redraw();
    }

    private function onMouseUp(event:MouseEvent = null):void {
        this.isDown = false;
        stage.removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        removeEventListener(Event.ENTER_FRAME, this.iterate);
        this.redraw();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.isOver = true;
        this.redraw();
    }

    private function onMouseOut(event:MouseEvent):void {
        this.isOver = false;
        this.redraw();
    }

    private function iterate(event:Event):void {
        this.dragging.dispatch(int(parent.mouseY - this.downOffset));
    }
}
}
</file>

<file path="src/svera/untiered/util/components/VerticalScrollbarGroove.as">
package svera.untiered.util.components {
import flash.display.Sprite;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.util.graphics.BevelRect;
import svera.untiered.util.graphics.GraphicsHelper;

public final class VerticalScrollbarGroove extends Sprite {

    public static const WIDTH:int = VerticalScrollbar.WIDTH;

    public static const BEVEL:int = VerticalScrollbar.BEVEL + VerticalScrollbar.PADDING * 0.5;


    public const clicked:Signal = new Signal(int);

    public const rect:BevelRect = new BevelRect(WIDTH, 0, BEVEL);

    private const helper:GraphicsHelper = new GraphicsHelper();

    function VerticalScrollbarGroove() {
        super();
    }

    public function redraw():void {
        graphics.clear();
        graphics.beginFill(5526612);
        this.helper.drawBevelRect(0, 0, this.rect, graphics);
        graphics.endFill();
    }

    public function addMouseListeners():void {
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function removeMouseListeners():void {
        removeEventListener(MouseEvent.CLICK, this.onClick);
    }

    private function onClick(event:MouseEvent):void {
        this.clicked.dispatch(int(mouseY));
    }
}
}
</file>

<file path="src/svera/untiered/util/graphics/ButtonLayoutHelper.as">
package svera.untiered.util.graphics {
import flash.display.DisplayObject;
import flash.errors.IllegalOperationError;

public class ButtonLayoutHelper {


    public function ButtonLayoutHelper() {
        super();
    }

    public function layout(width:int, ...buttons):void {
        var count:int = buttons.length;
        switch (count) {
            case 1:
                this.centerButton(width, buttons[0]);
                break;
            case 2:
                this.twoButtons(width, buttons[0], buttons[1]);
                break;
            default:
                throw new IllegalOperationError("Currently unable to layout more than 2 buttons");
        }
    }

    private function centerButton(width:int, button:DisplayObject):void {
        button.x = (width - button.width) * 0.5;
    }

    private function twoButtons(width:int, left:DisplayObject, right:DisplayObject):void {
        left.x = (width - 2 * left.width) * 0.25;
        right.x = (3 * width - 2 * right.width) * 0.25;
    }
}
}
</file>

<file path="src/svera/untiered/util/graphics/GraphicsHelper.as">
package svera.untiered.util.graphics {
import flash.display.Graphics;

public class GraphicsHelper {


    public function GraphicsHelper() {
        super();
    }

    public function drawBevelRect(x:int, y:int, rect:BevelRect, graphics:Graphics):void {
        var right:int = x + rect.width;
        var bottom:int = y + rect.height;
        var bevel:int = rect.bevel;
        if (rect.topLeftBevel) {
            graphics.moveTo(x, y + bevel);
            graphics.lineTo(x + bevel, y);
        } else {
            graphics.moveTo(x, y);
        }
        if (rect.topRightBevel) {
            graphics.lineTo(right - bevel, y);
            graphics.lineTo(right, y + bevel);
        } else {
            graphics.lineTo(right, y);
        }
        if (rect.bottomRightBevel) {
            graphics.lineTo(right, bottom - bevel);
            graphics.lineTo(right - bevel, bottom);
        } else {
            graphics.lineTo(right, bottom);
        }
        if (rect.bottomLeftBevel) {
            graphics.lineTo(x + bevel, bottom);
            graphics.lineTo(x, bottom - bevel);
        } else {
            graphics.lineTo(x, bottom);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/CheckBoxField.as">
package com.company.assembleegameclient.account.ui {
import com.company.ui.SimpleText;

import flash.display.CapsStyle;
import flash.display.Graphics;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class CheckBoxField extends Sprite {

    private static const BOX_SIZE:int = 20;


    public var checkBox_:Sprite;

    public var text_:SimpleText;

    public var errorText_:SimpleText;

    private var checked_:Boolean;

    private var hasError:Boolean;

    public function CheckBoxField(text:String, checked:Boolean, error:String, fontSize:uint = 16) {
        super();
        this.checked_ = checked;
        this.checkBox_ = new Sprite();
        this.checkBox_.x = 2;
        this.checkBox_.y = 2;
        this.redrawCheckBox();
        this.checkBox_.addEventListener(MouseEvent.CLICK, this.onClick);
        addChild(this.checkBox_);
        this.text_ = new SimpleText(fontSize, 11776947, false, 0, 0);
        this.text_.x = this.checkBox_.x + BOX_SIZE + 8;
        this.text_.setBold(true);
        this.text_.multiline = true;
        this.text_.htmlText = text;
        this.text_.mouseEnabled = true;
        this.text_.updateMetrics();
        this.text_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.text_);
        this.errorText_ = new SimpleText(12, 16549442, false, 0, 0);
        this.errorText_.x = this.text_.x;
        this.errorText_.y = this.text_.y + 20;
        this.errorText_.text = error;
        this.errorText_.updateMetrics();
        this.errorText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.errorText_);
    }

    public function isChecked():Boolean {
        return this.checked_;
    }

    public function setError(error:String):void {
        this.errorText_.text = error;
        this.errorText_.updateMetrics();
    }

    private function onClick(event:MouseEvent):void {
        this.setError("");
        this.checked_ = !this.checked_;
        this.redrawCheckBox();
    }

    public function setErrorHighlight(value:Boolean):void {
        this.hasError = value;
        this.redrawCheckBox();
    }

    private function redrawCheckBox():void {
        var color:Number;
        var g:Graphics = this.checkBox_.graphics;
        g.clear();
        g.beginFill(3355443, 1);
        g.drawRect(0, 0, BOX_SIZE, BOX_SIZE);
        g.endFill();
        if (this.checked_) {
            g.lineStyle(4, 11776947, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);
            g.moveTo(2, 2);
            g.lineTo(BOX_SIZE - 2, BOX_SIZE - 2);
            g.moveTo(2, BOX_SIZE - 2);
            g.lineTo(BOX_SIZE - 2, 2);
            g.lineStyle();
            this.hasError = false;
        }
        if (this.hasError) {
            color = 16549442;
        } else {
            color = 4539717;
        }
        g.lineStyle(2, color, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);
        g.drawRect(0, 0, BOX_SIZE, BOX_SIZE);
        g.lineStyle();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/CreateGuildFrame.as">
package com.company.assembleegameclient.account.ui {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.game.events.GuildResultEvent;

import flash.events.Event;
import flash.events.MouseEvent;

public class CreateGuildFrame extends Frame {


    private var name_:TextInputField;

    private var gs_:GameSprite;

    public function CreateGuildFrame(gs:GameSprite) {
        super("Create a new Guild", "Cancel", "Create");
        this.gs_ = gs;
        this.name_ = new TextInputField("Guild Name", false, "");
        this.name_.inputText_.restrict = "A-Za-z ";
        this.name_.inputText_.maxChars = 20;
        addTextInputField(this.name_);
        addPlainText("Maximum 20 characters");
        addPlainText("No numbers or punctuation");
        addPlainText("Racism or profanity gets your guild banned");
        leftButton_.addEventListener(MouseEvent.CLICK, this.onCancel);
        rightButton_.addEventListener(MouseEvent.CLICK, this.onCreate);
    }

    private function onCancel(event:MouseEvent):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }

    private function onCreate(event:MouseEvent):void {
        this.gs_.addEventListener(GuildResultEvent.EVENT, this.onResult);
        this.gs_.gsc_.createGuild(this.name_.text());
        disable();
    }

    private function onResult(event:GuildResultEvent):void {
        trace("onResult: " + event);
        this.gs_.removeEventListener(GuildResultEvent.EVENT, this.onResult);
        if (event.success_) {
            dispatchEvent(new Event(Event.COMPLETE));
            this.gs_.model.changeHonor(-1000);
        } else {
            this.name_.setError(event.errorText_);
            enable();
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/Frame.as">
package com.company.assembleegameclient.account.ui {
import com.company.assembleegameclient.ui.ClickableText;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.DisplayObject;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

import svera.untiered.account.web.view.LabeledField;

public class Frame extends Sprite {
    public var titleText_:SimpleText;

    public var leftButton_:ClickableText;

    public var rightButton_:ClickableText;

    public var textInputFields_:Vector.<TextInputField>;

    public var navigationLinks_:Vector.<ClickableText>;

    public var w_:int = 288;

    public var h_:int = 100;

    private var titleFill_:GraphicsSolidFill = new GraphicsSolidFill(5066061, 1);

    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(3552822, 1);

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private var path1_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private var path2_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[backgroundFill_, path2_, GraphicsUtil.END_FILL, titleFill_, path1_, GraphicsUtil.END_FILL, lineStyle_, path2_, GraphicsUtil.END_STROKE];

    public function Frame(title:String, leftButton:String, rightButton:String, w:int = 288) {
        this.textInputFields_ = new Vector.<TextInputField>();
        this.navigationLinks_ = new Vector.<ClickableText>();
        super();
        this.w_ = w;
        this.titleText_ = new SimpleText(12, 11776947, false, 0, 0);
        this.titleText_.text = title;
        this.titleText_.updateMetrics();
        this.titleText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.titleText_.x = 5;
        this.titleText_.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addChild(this.titleText_);
        this.leftButton_ = new ClickableText(18, true, leftButton);
        if (leftButton != "") {
            this.leftButton_.buttonMode = true;
            this.leftButton_.x = 109;
            addChild(this.leftButton_);
        }
        this.rightButton_ = new ClickableText(18, true, rightButton);
        this.rightButton_.buttonMode = true;
        this.rightButton_.x = this.w_ - this.rightButton_.width - 26;
        addChild(this.rightButton_);
        filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function addLabeledField(labeledField:LabeledField):void {
        addChild(labeledField);
        labeledField.y = this.h_ - 60;
        labeledField.x = 17;
        this.h_ = this.h_ + labeledField.getHeight();
    }

    public function addTextInputField(textInputField:TextInputField):void {
        this.textInputFields_.push(textInputField);
        addChild(textInputField);
        textInputField.y = this.h_ - 60;
        textInputField.x = 17;
        this.h_ = this.h_ + TextInputField.HEIGHT;
    }

    public function addNavigationText(navigationLink:ClickableText):void {
        this.navigationLinks_.push(navigationLink);
        addChild(navigationLink);
        navigationLink.y = this.h_ - 66;
        navigationLink.x = 17;
        this.h_ = this.h_ + 20;
    }

    public function addComponent(component:DisplayObject, offsetX:int = 8):void {
        addChild(component);
        component.y = this.h_ - 66;
        component.x = offsetX;
        this.h_ = this.h_ + component.height;
    }

    public function addPlainText(plainText:String):void {
        var text:SimpleText = new SimpleText(12, 16777215, false, 0, 0);
        text.text = plainText;
        text.updateMetrics();
        text.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(text);
        text.y = this.h_ - 66;
        text.x = 17;
        this.h_ = this.h_ + 20;
    }

    public function addCheckBox(checkBox:CheckBoxField):void {
        addChild(checkBox);
        checkBox.y = this.h_ - 66;
        checkBox.x = 17;
        this.h_ = this.h_ + 44;
    }

    public function addSpace(space:int):void {
        this.h_ = this.h_ + space;
    }

    public function disable():void {
        var navigationLink:ClickableText = null;
        mouseEnabled = false;
        mouseChildren = false;
        for each(navigationLink in this.navigationLinks_) {
            navigationLink.setDefaultColor(11776947);
        }
        this.leftButton_.setDefaultColor(11776947);
        this.rightButton_.setDefaultColor(11776947);
    }

    public function enable():void {
        var navigationLink:ClickableText = null;
        mouseEnabled = true;
        mouseChildren = true;
        for each(navigationLink in this.navigationLinks_) {
            navigationLink.setDefaultColor(16777215);
        }
        this.leftButton_.setDefaultColor(16777215);
        this.rightButton_.setDefaultColor(16777215);
    }

    protected function onAddedToStage(event:Event):void {
        this.draw();
        x = stage.stageWidth / 2 - (this.w_ - 6) / 2;
        y = stage.stageHeight / 2 - height / 2;
        if (this.textInputFields_.length > 0) {
            stage.focus = this.textInputFields_[0].inputText_;
        }
    }

    private function onRemovedFromStage(event:Event):void {
    }

    private function draw():void {
        graphics.clear();
        GraphicsUtil.clearPath(this.path1_);
        GraphicsUtil.drawCutEdgeRect(-6, -6, this.w_, 20 + 12, 4, [1, 1, 0, 0], this.path1_);
        GraphicsUtil.clearPath(this.path2_);
        GraphicsUtil.drawCutEdgeRect(-6, -6, this.w_, this.h_, 4, [1, 1, 1, 1], this.path2_);
        this.leftButton_.y = this.h_ - 52;
        this.rightButton_.y = this.h_ - 52;
        graphics.drawGraphicsData(this.graphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/appengine/CharacterStats.as">
package com.company.assembleegameclient.appengine {
import com.company.assembleegameclient.util.HonorUtil;

public class CharacterStats {


    public var charStatsXML_:XML;

    public function CharacterStats(charStatsXML:XML) {
        super();
        this.charStatsXML_ = charStatsXML;
    }

    public function bestLevel():int {
        return this.charStatsXML_.BestLevel;
    }

    public function bestHonor():int {
        return this.charStatsXML_.BestHonor;
    }

    public function numStars():int {
        return HonorUtil.numStars(int(this.charStatsXML_.BestHonor));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/CaveWall.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.engine3d.ObjectFace3D;
import com.company.assembleegameclient.parameters.Parameters;

import flash.display.BitmapData;
import flash.geom.Vector3D;

import svera.untiered.stage3D.GraphicsFillExtra;

public class CaveWall extends ConnectedObject {


    public function CaveWall(objectXML:XML) {
        super(objectXML);
    }

    override protected function buildDot():void {
        var face:ObjectFace3D = null;
        var v0:Vector3D = new Vector3D(-0.25 - Math.random() * 0.25, -0.25 - Math.random() * 0.25, 0);
        var v1:Vector3D = new Vector3D(0.25 + Math.random() * 0.25, -0.25 - Math.random() * 0.25, 0);
        var v2:Vector3D = new Vector3D(0.25 + Math.random() * 0.25, 0.25 + Math.random() * 0.25, 0);
        var v3:Vector3D = new Vector3D(-0.25 - Math.random() * 0.25, 0.25 + Math.random() * 0.25, 0);
        var v4:Vector3D = new Vector3D(-0.25 + Math.random() * 0.5, -0.25 + Math.random() * 0.5, 1);
        this.faceHelper(null, texture_, v4, v0, v1);
        this.faceHelper(null, texture_, v4, v1, v2);
        this.faceHelper(null, texture_, v4, v2, v3);
        this.faceHelper(null, texture_, v4, v3, v0);
        if (Parameters.GPURenderFrame) {
            for each(face in obj3D_.faces_) {
                GraphicsFillExtra.setSoftwareDraw(face.bitmapFill_, true);
            }
        }
    }

    override protected function buildShortLine():void {
        var face:ObjectFace3D = null;
        var v0:Vector3D = this.getVertex(0, 0);
        var v1:Vector3D = this.getVertex(0, 3);
        var v2:Vector3D = new Vector3D(0.25 + Math.random() * 0.25, 0.25 + Math.random() * 0.25, 0);
        var v3:Vector3D = new Vector3D(-0.25 - Math.random() * 0.25, 0.25 + Math.random() * 0.25, 0);
        var v4:Vector3D = this.getVertex(0, 1);
        var v5:Vector3D = this.getVertex(0, 2);
        var v6:Vector3D = new Vector3D(Math.random() * 0.25, Math.random() * 0.25, 0.5);
        var v7:Vector3D = new Vector3D(Math.random() * -0.25, Math.random() * 0.25, 0.5);
        this.faceHelper(null, texture_, v4, v7, v3, v0);
        this.faceHelper(null, texture_, v7, v6, v2, v3);
        this.faceHelper(null, texture_, v6, v5, v1, v2);
        this.faceHelper(null, texture_, v4, v5, v6, v7);
        if (Parameters.GPURenderFrame) {
            for each(face in obj3D_.faces_) {
                GraphicsFillExtra.setSoftwareDraw(face.bitmapFill_, true);
            }
        }
    }

    override protected function buildL():void {
        var face:ObjectFace3D = null;
        var v0:Vector3D = this.getVertex(0, 0);
        var v1:Vector3D = this.getVertex(0, 3);
        var v2:Vector3D = this.getVertex(1, 0);
        var v3:Vector3D = this.getVertex(1, 3);
        var v4:Vector3D = new Vector3D(-Math.random() * 0.25, Math.random() * 0.25, 0);
        var v5:Vector3D = this.getVertex(0, 1);
        var v6:Vector3D = this.getVertex(0, 2);
        var v7:Vector3D = this.getVertex(1, 1);
        var v8:Vector3D = this.getVertex(1, 2);
        var v9:Vector3D = new Vector3D(Math.random() * 0.25, -Math.random() * 0.25, 1);
        this.faceHelper(null, texture_, v5, v9, v4, v0);
        this.faceHelper(null, texture_, v9, v8, v3, v4);
        this.faceHelper(N2, texture_, v7, v6, v1, v2);
        this.faceHelper(null, texture_, v5, v6, v7, v8, v9);
        if (Parameters.GPURenderFrame) {
            for each(face in obj3D_.faces_) {
                GraphicsFillExtra.setSoftwareDraw(face.bitmapFill_, true);
            }
        }
    }

    override protected function buildLine():void {
        var face:ObjectFace3D = null;
        var v0:Vector3D = this.getVertex(0, 0);
        var v1:Vector3D = this.getVertex(0, 3);
        var v2:Vector3D = this.getVertex(2, 3);
        var v3:Vector3D = this.getVertex(2, 0);
        var v4:Vector3D = this.getVertex(0, 1);
        var v5:Vector3D = this.getVertex(0, 2);
        var v6:Vector3D = this.getVertex(2, 2);
        var v7:Vector3D = this.getVertex(2, 1);
        this.faceHelper(N7, texture_, v4, v7, v3, v0);
        this.faceHelper(N3, texture_, v6, v5, v1, v2);
        this.faceHelper(null, texture_, v4, v5, v6, v7);
        if (Parameters.GPURenderFrame) {
            for each(face in obj3D_.faces_) {
                GraphicsFillExtra.setSoftwareDraw(face.bitmapFill_, true);
            }
        }
    }

    override protected function buildT():void {
        var face:ObjectFace3D = null;
        var v0:Vector3D = this.getVertex(0, 0);
        var v1:Vector3D = this.getVertex(0, 3);
        var v2:Vector3D = this.getVertex(1, 0);
        var v3:Vector3D = this.getVertex(1, 3);
        var v4:Vector3D = this.getVertex(3, 3);
        var v5:Vector3D = this.getVertex(3, 0);
        var v6:Vector3D = this.getVertex(0, 1);
        var v7:Vector3D = this.getVertex(0, 2);
        var v8:Vector3D = this.getVertex(1, 1);
        var v9:Vector3D = this.getVertex(1, 2);
        var va:Vector3D = this.getVertex(3, 2);
        var vb:Vector3D = this.getVertex(3, 1);
        this.faceHelper(N2, texture_, v8, v7, v1, v2);
        this.faceHelper(null, texture_, va, v9, v3, v4);
        this.faceHelper(N0, texture_, v6, vb, v5, v0);
        this.faceHelper(null, texture_, v6, v7, v8, v9, va, vb);
        if (Parameters.GPURenderFrame) {
            for each(face in obj3D_.faces_) {
                GraphicsFillExtra.setSoftwareDraw(face.bitmapFill_, true);
            }
        }
    }

    override protected function buildCross():void {
        var face:ObjectFace3D = null;
        var v0:Vector3D = this.getVertex(0, 0);
        var v1:Vector3D = this.getVertex(0, 3);
        var v2:Vector3D = this.getVertex(1, 0);
        var v3:Vector3D = this.getVertex(1, 3);
        var v4:Vector3D = this.getVertex(2, 3);
        var v5:Vector3D = this.getVertex(2, 0);
        var v6:Vector3D = this.getVertex(3, 3);
        var v7:Vector3D = this.getVertex(3, 0);
        var v8:Vector3D = this.getVertex(0, 1);
        var v9:Vector3D = this.getVertex(0, 2);
        var va:Vector3D = this.getVertex(1, 1);
        var vb:Vector3D = this.getVertex(1, 2);
        var vc:Vector3D = this.getVertex(2, 2);
        var vd:Vector3D = this.getVertex(2, 1);
        var ve:Vector3D = this.getVertex(3, 2);
        var vf:Vector3D = this.getVertex(3, 1);
        this.faceHelper(N2, texture_, va, v9, v1, v2);
        this.faceHelper(N4, texture_, vc, vb, v3, v4);
        this.faceHelper(N6, texture_, ve, vd, v5, v6);
        this.faceHelper(N0, texture_, v8, vf, v7, v0);
        this.faceHelper(null, texture_, v8, v9, va, vb, vc, vd, ve, vf);
        if (Parameters.GPURenderFrame) {
            for each(face in obj3D_.faces_) {
                GraphicsFillExtra.setSoftwareDraw(face.bitmapFill_, true);
            }
        }
    }

    protected function getVertex(side:int, id:int):Vector3D {
        var r:int = 0;
        var v:Number = NaN;
        var h:Number = NaN;
        var x:int = x_;
        var y:int = y_;
        var rside:int = (side + rotation_) % 4;
        switch (rside) {
            case 1:
                x++;
                break;
            case 2:
                y++;
        }
        switch (id) {
            case 0:
            case 3:
                r = 15 + (x * 1259 ^ y * 2957) % 35;
                break;
            case 1:
            case 2:
                r = 3 + (x * 2179 ^ y * 1237) % 35;
        }
        switch (id) {
            case 0:
                v = -r / 100;
                h = 0;
                break;
            case 1:
                v = -r / 100;
                h = 1;
                break;
            case 2:
                v = r / 100;
                h = 1;
                break;
            case 3:
                v = r / 100;
                h = 0;
        }
        switch (side) {
            case 0:
                return new Vector3D(v, -0.5, h);
            case 1:
                return new Vector3D(0.5, v, h);
            case 2:
                return new Vector3D(v, 0.5, h);
            case 3:
                return new Vector3D(-0.5, v, h);
            default:
                return null;
        }
    }

    protected function faceHelper(normalL:Vector3D, texture:BitmapData, ...args):void {
        var v:Vector3D = null;
        var oldLen:int;
        var i:int = 0;
        var offset:int = obj3D_.vL_.length / 3;
        for each(v in args) {
            obj3D_.vL_.push(v.x, v.y, v.z);
        }
        oldLen = obj3D_.faces_.length;
        if (args.length == 4) {
            obj3D_.uvts_.push(0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0);
            if (Math.random() < 0.5) {
                obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 3]), new ObjectFace3D(obj3D_, new <int>[offset + 1, offset + 2, offset + 3]));
            } else {
                obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[offset, offset + 2, offset + 3]), new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2]));
            }
        } else if (args.length == 3) {
            obj3D_.uvts_.push(0, 0, 0, 0, 1, 0, 1, 1, 0);
            obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2]));
        } else if (args.length == 5) {
            obj3D_.uvts_.push(0.2, 0, 0, 0.8, 0, 0, 1, 0.2, 0, 1, 0.8, 0, 0, 0.8, 0);
            obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2, offset + 3, offset + 4]));
        } else if (args.length == 6) {
            obj3D_.uvts_.push(0, 0, 0, 0.2, 0, 0, 1, 0.2, 0, 1, 0.8, 0, 0, 0.8, 0, 0, 0.2, 0);
            obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2, offset + 3, offset + 4, offset + 5]));
        } else if (args.length == 8) {
            obj3D_.uvts_.push(0, 0, 0, 0.2, 0, 0, 1, 0.2, 0, 1, 0.8, 0, 0.8, 1, 0, 0.2, 1, 0, 0, 0.8, 0, 0, 0.2, 0);
            obj3D_.faces_.push(new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2, offset + 3, offset + 4, offset + 5, offset + 6, offset + 7]));
        }
        if (normalL != null || texture != null) {
            for (i = oldLen; i < obj3D_.faces_.length; i++) {
                obj3D_.faces_[i].normalL_ = normalL;
                obj3D_.faces_[i].texture_ = texture;
            }
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ConnectedWall.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.engine3d.ObjectFace3D;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;
import flash.geom.Vector3D;

import svera.untiered.stage3D.GraphicsFillExtra;

public class ConnectedWall extends ConnectedObject {


    protected var objectXML_:XML;

    protected var bI_:Number = 0.5;

    protected var tI_:Number = 0.25;

    protected var h_:Number = 1.0;

    protected var wallRepeat_:Boolean;

    protected var topRepeat_:Boolean;

    public function ConnectedWall(objectXML:XML) {
        super(objectXML);
        this.objectXML_ = objectXML;
        if (objectXML.hasOwnProperty("BaseIndent")) {
            this.bI_ = 0.5 - Number(objectXML.BaseIndent);
        }
        if (objectXML.hasOwnProperty("TopIndent")) {
            this.tI_ = 0.5 - Number(objectXML.TopIndent);
        }
        if (objectXML.hasOwnProperty("Height")) {
            this.h_ = Number(objectXML.Height);
        }
        this.wallRepeat_ = !objectXML.hasOwnProperty("NoWallTextureRepeat");
        this.topRepeat_ = !objectXML.hasOwnProperty("NoTopTextureRepeat");
    }

    override protected function buildDot():void {
        var v0:Vector3D = new Vector3D(-this.bI_, -this.bI_, 0);
        var v1:Vector3D = new Vector3D(this.bI_, -this.bI_, 0);
        var v2:Vector3D = new Vector3D(this.bI_, this.bI_, 0);
        var v3:Vector3D = new Vector3D(-this.bI_, this.bI_, 0);
        var v4:Vector3D = new Vector3D(-this.tI_, -this.tI_, this.h_);
        var v5:Vector3D = new Vector3D(this.tI_, -this.tI_, this.h_);
        var v6:Vector3D = new Vector3D(this.tI_, this.tI_, this.h_);
        var v7:Vector3D = new Vector3D(-this.tI_, this.tI_, this.h_);
        this.addQuad(v5, v4, v0, v1, texture_, true, true);
        this.addQuad(v6, v5, v1, v2, texture_, true, true);
        this.addQuad(v4, v7, v3, v0, texture_, true, true);
        this.addQuad(v7, v6, v2, v3, texture_, true, true);
        var texture:BitmapData = texture_;
        if (this.objectXML_.hasOwnProperty("DotTexture")) {
            texture = AssetLibrary.getImageFromSet(String(this.objectXML_.DotTexture.File), int(this.objectXML_.DotTexture.Index));
        }
        this.addTop([v4, v5, v6, v7], new <Number>[0.25, 0.25, 0.75, 0.25, 0.25, 0.75], texture);
    }

    override protected function buildShortLine():void {
        var v0:Vector3D = new Vector3D(-this.bI_, -0.5, 0);
        var v1:Vector3D = new Vector3D(this.bI_, -0.5, 0);
        var v2:Vector3D = new Vector3D(this.bI_, this.bI_, 0);
        var v3:Vector3D = new Vector3D(-this.bI_, this.bI_, 0);
        var v4:Vector3D = new Vector3D(-this.tI_, -0.5, this.h_);
        var v5:Vector3D = new Vector3D(this.tI_, -0.5, this.h_);
        var v6:Vector3D = new Vector3D(this.tI_, this.tI_, this.h_);
        var v7:Vector3D = new Vector3D(-this.tI_, this.tI_, this.h_);
        this.addQuad(v6, v5, v1, v2, texture_, true, false);
        this.addQuad(v4, v7, v3, v0, texture_, false, true);
        this.addQuad(v7, v6, v2, v3, texture_, true, true);
        var texture:BitmapData = texture_;
        if (this.objectXML_.hasOwnProperty("ShortLineTexture")) {
            texture = AssetLibrary.getImageFromSet(String(this.objectXML_.ShortLineTexture.File), int(this.objectXML_.ShortLineTexture.Index));
        }
        this.addTop([v4, v5, v6, v7], new <Number>[0.25, 0, 0.75, 0, 0.25, 0.75], texture);
    }

    override protected function buildL():void {
        var v0:Vector3D = new Vector3D(-this.bI_, -0.5, 0);
        var v1:Vector3D = new Vector3D(this.bI_, -0.5, 0);
        var v2:Vector3D = new Vector3D(this.bI_, -this.bI_, 0);
        var v3:Vector3D = new Vector3D(0.5, -this.bI_, 0);
        var v4:Vector3D = new Vector3D(0.5, this.bI_, 0);
        var v5:Vector3D = new Vector3D(-this.bI_, this.bI_, 0);
        var v6:Vector3D = new Vector3D(-this.tI_, -0.5, this.h_);
        var v7:Vector3D = new Vector3D(this.tI_, -0.5, this.h_);
        var v8:Vector3D = new Vector3D(this.tI_, -this.tI_, this.h_);
        var v9:Vector3D = new Vector3D(0.5, -this.tI_, this.h_);
        var va:Vector3D = new Vector3D(0.5, this.tI_, this.h_);
        var vb:Vector3D = new Vector3D(-this.tI_, this.tI_, this.h_);
        this.addBit(v8, v7, v1, v2, texture_, N2, true, true, true);
        this.addBit(v9, v8, v2, v3, texture_, N2, false, true, false);
        this.addQuad(vb, va, v4, v5, texture_, true, false);
        this.addQuad(v6, vb, v5, v0, texture_, false, true);
        var texture:BitmapData = texture_;
        if (this.objectXML_.hasOwnProperty("LTexture")) {
            texture = AssetLibrary.getImageFromSet(String(this.objectXML_.LTexture.File), int(this.objectXML_.LTexture.Index));
        }
        this.addTop([v6, v7, v8, v9, va, vb], new <Number>[0.25, 0, 0.75, 0, 0.25, 0.75], texture);
    }

    override protected function buildLine():void {
        var v0:Vector3D = new Vector3D(-this.bI_, -0.5, 0);
        var v1:Vector3D = new Vector3D(this.bI_, -0.5, 0);
        var v2:Vector3D = new Vector3D(this.bI_, 0.5, 0);
        var v3:Vector3D = new Vector3D(-this.bI_, 0.5, 0);
        var v4:Vector3D = new Vector3D(-this.tI_, -0.5, this.h_);
        var v5:Vector3D = new Vector3D(this.tI_, -0.5, this.h_);
        var v6:Vector3D = new Vector3D(this.tI_, 0.5, this.h_);
        var v7:Vector3D = new Vector3D(-this.tI_, 0.5, this.h_);
        this.addQuad(v6, v5, v1, v2, texture_, false, false);
        this.addQuad(v4, v7, v3, v0, texture_, false, false);
        var texture:BitmapData = texture_;
        if (this.objectXML_.hasOwnProperty("LineTexture")) {
            texture = AssetLibrary.getImageFromSet(String(this.objectXML_.LineTexture.File), int(this.objectXML_.LineTexture.Index));
        }
        this.addTop([v4, v5, v6, v7], new <Number>[0.25, 0, 0.75, 0, 0.25, 1], texture);
    }

    override protected function buildT():void {
        var v0:Vector3D = new Vector3D(-this.bI_, -0.5, 0);
        var v1:Vector3D = new Vector3D(this.bI_, -0.5, 0);
        var v2:Vector3D = new Vector3D(this.bI_, -this.bI_, 0);
        var v3:Vector3D = new Vector3D(0.5, -this.bI_, 0);
        var v4:Vector3D = new Vector3D(0.5, this.bI_, 0);
        var v5:Vector3D = new Vector3D(-0.5, this.bI_, 0);
        var v6:Vector3D = new Vector3D(-0.5, -this.bI_, 0);
        var v7:Vector3D = new Vector3D(-this.bI_, -this.bI_, 0);
        var v8:Vector3D = new Vector3D(-this.tI_, -0.5, this.h_);
        var v9:Vector3D = new Vector3D(this.tI_, -0.5, this.h_);
        var va:Vector3D = new Vector3D(this.tI_, -this.tI_, this.h_);
        var vb:Vector3D = new Vector3D(0.5, -this.tI_, this.h_);
        var vc:Vector3D = new Vector3D(0.5, this.tI_, this.h_);
        var vd:Vector3D = new Vector3D(-0.5, this.tI_, this.h_);
        var ve:Vector3D = new Vector3D(-0.5, -this.tI_, this.h_);
        var vf:Vector3D = new Vector3D(-this.tI_, -this.tI_, this.h_);
        this.addBit(va, v9, v1, v2, texture_, N2, true);
        this.addBit(vb, va, v2, v3, texture_, N2, false);
        this.addQuad(vd, vc, v4, v5, texture_, false, false);
        this.addBit(vf, ve, v6, v7, texture_, N0, true);
        this.addBit(v8, vf, v7, v0, texture_, N0, false);
        var texture:BitmapData = texture_;
        if (this.objectXML_.hasOwnProperty("TTexture")) {
            texture = AssetLibrary.getImageFromSet(String(this.objectXML_.TTexture.File), int(this.objectXML_.TTexture.Index));
        }
        this.addTop([v8, v9, va, vb, vc, vd, ve, vf], new <Number>[0.25, 0, 0.75, 0, 0.25, 0.25], texture);
    }

    override protected function buildCross():void {
        var vb0:Vector3D = new Vector3D(-this.bI_, -0.5, 0);
        var vb1:Vector3D = new Vector3D(this.bI_, -0.5, 0);
        var vb2:Vector3D = new Vector3D(this.bI_, -this.bI_, 0);
        var vb3:Vector3D = new Vector3D(0.5, -this.bI_, 0);
        var vb4:Vector3D = new Vector3D(0.5, this.bI_, 0);
        var vb5:Vector3D = new Vector3D(this.bI_, this.bI_, 0);
        var vb6:Vector3D = new Vector3D(this.bI_, 0.5, 0);
        var vb7:Vector3D = new Vector3D(-this.bI_, 0.5, 0);
        var vb8:Vector3D = new Vector3D(-this.bI_, this.bI_, 0);
        var vb9:Vector3D = new Vector3D(-0.5, this.bI_, 0);
        var vba:Vector3D = new Vector3D(-0.5, -this.bI_, 0);
        var vbb:Vector3D = new Vector3D(-this.bI_, -this.bI_, 0);
        var vt0:Vector3D = new Vector3D(-this.tI_, -0.5, this.h_);
        var vt1:Vector3D = new Vector3D(this.tI_, -0.5, this.h_);
        var vt2:Vector3D = new Vector3D(this.tI_, -this.tI_, this.h_);
        var vt3:Vector3D = new Vector3D(0.5, -this.tI_, this.h_);
        var vt4:Vector3D = new Vector3D(0.5, this.tI_, this.h_);
        var vt5:Vector3D = new Vector3D(this.tI_, this.tI_, this.h_);
        var vt6:Vector3D = new Vector3D(this.tI_, 0.5, this.h_);
        var vt7:Vector3D = new Vector3D(-this.tI_, 0.5, this.h_);
        var vt8:Vector3D = new Vector3D(-this.tI_, this.tI_, this.h_);
        var vt9:Vector3D = new Vector3D(-0.5, this.tI_, this.h_);
        var vta:Vector3D = new Vector3D(-0.5, -this.tI_, this.h_);
        var vtb:Vector3D = new Vector3D(-this.tI_, -this.tI_, this.h_);
        this.addBit(vt2, vt1, vb1, vb2, texture_, N2, true);
        this.addBit(vt3, vt2, vb2, vb3, texture_, N2, false);
        this.addBit(vt5, vt4, vb4, vb5, texture_, N4, true);
        this.addBit(vt6, vt5, vb5, vb6, texture_, N4, false);
        this.addBit(vt8, vt7, vb7, vb8, texture_, N6, true);
        this.addBit(vt9, vt8, vb8, vb9, texture_, N6, false);
        this.addBit(vtb, vta, vba, vbb, texture_, N0, true);
        this.addBit(vt0, vtb, vbb, vb0, texture_, N0, false);
        var texture:BitmapData = texture_;
        if (this.objectXML_.hasOwnProperty("CrossTexture")) {
            texture = AssetLibrary.getImageFromSet(String(this.objectXML_.CrossTexture.File), int(this.objectXML_.CrossTexture.Index));
        }
        this.addTop([vt0, vt1, vt2, vt3, vt4, vt5, vt6, vt7, vt8, vt9, vta, vtb], new <Number>[0.25, 0, 0.75, 0, 0.25, 0.25], texture);
    }

    protected function addQuad(v0:Vector3D, v1:Vector3D, v2:Vector3D, v3:Vector3D, texture:BitmapData, leftIndent:Boolean, rightIndent:Boolean):void {
        var n1:Number = NaN;
        var n2:Number = NaN;
        var vertexBuffer3D:Vector.<Number> = null;
        var offset:int = obj3D_.vL_.length / 3;
        obj3D_.vL_.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z);
        var n:Number = leftIndent ? Number(-(this.bI_ - this.tI_) / (1 - (this.bI_ - this.tI_) - (rightIndent ? this.bI_ - this.tI_ : 0))) : Number(0);
        obj3D_.uvts_.push(0, 0, 0, 1, 0, 0, 1, 1, 0, n, 1, 0);
        var face:ObjectFace3D = new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2, offset + 3]);
        face.texture_ = texture;
        face.bitmapFill_.repeat = this.wallRepeat_;
        obj3D_.faces_.push(face);
        if (GraphicsFillExtra.getVertexBuffer(face.bitmapFill_) == null && Parameters.GPURenderFrame) {
            n1 = 0;
            n2 = 0;
            if (leftIndent) {
                n1 = n;
            }
            if (rightIndent) {
                n2 = -n;
            }
            if (n2 == 0 && n1 == 0 && rightIndent && v3.x == -0.5) {
                n2 = 0.34;
            }
            vertexBuffer3D = Vector.<Number>([-0.5, 0.5, 0, 0, 0, 0.5, 0.5, 0, 1, 0, -0.5 + n1, -0.5, 0, 0, 1, 0.5 + n2, -0.5, 0, 1, 1]);
            GraphicsFillExtra.setVertexBuffer(face.bitmapFill_, vertexBuffer3D);
        }
    }

    protected function addBit(v0:Vector3D, v1:Vector3D, v2:Vector3D, v3:Vector3D, texture:BitmapData, normalL:Vector3D, indent:Boolean, forceStage3D:Boolean = false, leanLeft:Boolean = false):void {
        var vertexBuffer3D:Vector.<Number> = null;
        var offset:int = obj3D_.vL_.length / 3;
        obj3D_.vL_.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z);
        if (indent) {
            obj3D_.uvts_.push(-0.5 + this.tI_, 0, 0, 0, 0, 0, 0, 0, 0, -0.5 + this.bI_, 1, 0);
        } else {
            obj3D_.uvts_.push(1, 0, 0, 1.5 - this.tI_, 0, 0, 0, 0, 0, 1, 1, 0);
        }
        var face:ObjectFace3D = new ObjectFace3D(obj3D_, new <int>[offset, offset + 1, offset + 2, offset + 3]);
        face.texture_ = texture;
        face.bitmapFill_.repeat = this.wallRepeat_;
        face.normalL_ = normalL;
        if (!Parameters.GPURenderFrame && !forceStage3D) {
            obj3D_.faces_.push(face);
        } else if (forceStage3D) {
            if (leanLeft) {
                vertexBuffer3D = Vector.<Number>([-0.75, 0.5, 0, 0, 0, -0.5, 0.5, 0, 1, 0, -0.75, -0.5, 0, 0, 1, -0.5, -0.5, 0, 1, 1]);
            } else {
                vertexBuffer3D = Vector.<Number>([0.5, 0.5, 0, 0, 0, 0.75, 0.5, 0, 1, 0, 0.5, -0.5, 0, 0, 1, 0.75, -0.5, 0, 1, 1]);
            }
            GraphicsFillExtra.setVertexBuffer(face.bitmapFill_, vertexBuffer3D);
            obj3D_.faces_.push(face);
        }
    }

    protected function addTop(verts:Array, uvs:Vector.<Number>, texture:BitmapData):void {
        var face2:ObjectFace3D = null;
        var vertexBuffer3D:Vector.<Number> = null;
        var idxMod:int = 0;
        var processing:Array = null;
        var next:Array = null;
        var texSpecial:Array = null;
        var n:int = 0;
        var temp:int = 0;
        var texidx:int = 0;
        var offset:int = obj3D_.vL_.length / 3;
        var indices:Vector.<int> = new Vector.<int>();
        for (var i:uint = 0; i < verts.length; i++) {
            obj3D_.vL_.push(verts[i].x, verts[i].y, verts[i].z);
            indices.push(offset + i);
            if (i == 0) {
                obj3D_.uvts_.push(uvs[0], uvs[1], 0);
            } else if (i == 1) {
                obj3D_.uvts_.push(uvs[2], uvs[3], 0);
            } else if (i == verts.length - 1) {
                obj3D_.uvts_.push(uvs[4], uvs[5], 0);
            } else {
                obj3D_.uvts_.push(0, 0, 0);
            }
        }
        var face:ObjectFace3D = new ObjectFace3D(obj3D_, indices);
        face.texture_ = texture;
        face.bitmapFill_.repeat = this.topRepeat_;
        obj3D_.faces_.push(face);
        if (indices.length == 6 && Parameters.GPURenderFrame) {
            face2 = new ObjectFace3D(obj3D_, indices);
            face2.texture_ = texture;
            face2.bitmapFill_.repeat = this.topRepeat_;
            obj3D_.faces_.push(face2);
        }
        var idx:int = 0;
        if (indices.length == 4 && GraphicsFillExtra.getVertexBuffer(face.bitmapFill_) == null && Parameters.GPURenderFrame) {
            vertexBuffer3D = new Vector.<Number>();
            for (idx = 0; idx < indices.length; idx++) {
                if (idx == 3) {
                    idxMod = 2;
                } else if (idx == 2) {
                    idxMod = 3;
                } else {
                    idxMod = idx;
                }
                vertexBuffer3D.push(obj3D_.vL_[indices[idxMod] * 3], obj3D_.vL_[indices[idxMod] * 3 + 1] * -1, obj3D_.vL_[indices[idxMod] * 3 + 2], obj3D_.uvts_[indices[idxMod != 2 ? idxMod : idxMod - 1] * 3], obj3D_.uvts_[indices[idxMod != 2 ? idxMod : idxMod + 1] * 3 + 1]);
            }
            GraphicsFillExtra.setVertexBuffer(face.bitmapFill_, vertexBuffer3D);
        } else if (indices.length == 6 && GraphicsFillExtra.getVertexBuffer(face.bitmapFill_) == null && Parameters.GPURenderFrame) {
            processing = [0, 1, 5, 2];
            next = [2, 3, 5, 4];
            texSpecial = [5, 0, 2, 1];
            for (n = 0; n < 2; n++) {
                if (n == 1) {
                    processing = next;
                }
                vertexBuffer3D = new Vector.<Number>();
                temp = 0;
                texidx = 0;
                for each(idx in processing) {
                    if (n == 1) {
                        texidx = texSpecial[temp];
                    } else {
                        texidx = idx;
                    }
                    vertexBuffer3D.push(obj3D_.vL_[indices[idx] * 3], obj3D_.vL_[indices[idx] * 3 + 1] * -1, obj3D_.vL_[indices[idx] * 3 + 2], obj3D_.uvts_[indices[texidx != 2 ? texidx : texidx - 1] * 3], obj3D_.uvts_[indices[texidx != 2 ? texidx : texidx + 1] * 3 + 1]);
                    temp++;
                }
                if (n == 1) {
                    GraphicsFillExtra.setVertexBuffer(face2.bitmapFill_, vertexBuffer3D);
                } else {
                    GraphicsFillExtra.setVertexBuffer(face.bitmapFill_, vertexBuffer3D);
                }
            }
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/FountainEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.FreeList;

public class FountainEffect extends ParticleEffect {


    public var go_:GameObject;

    public var lastUpdate_:int = -1;

    public function FountainEffect(go:GameObject) {
        super();
        this.go_ = go;
    }

    override public function update(time:int, dt:int):Boolean {
        var t:int = 0;
        var part:FountainParticle = null;
        if (this.go_.map_ == null) {
            return false;
        }
        if (this.lastUpdate_ < 0) {
            this.lastUpdate_ = Math.max(0, time - 400);
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        for (var i:int = this.lastUpdate_ / 50; i < time / 50; i++) {
            t = i * 50;
            part = FreeList.newObject(FountainParticle) as FountainParticle;
            part.restart(t, time);
            map_.addObj(part, x_, y_);
        }
        this.lastUpdate_ = time;
        return true;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;
import com.company.assembleegameclient.util.FreeList;

import flash.geom.Vector3D;

class FountainParticle extends Particle {

    private static const G:Number = -4.9;

    private static const VI:Number = 6.5;

    private static const ZI:Number = 0.75;


    public var startTime_:int;

    protected var moveVec_:Vector3D;

    function FountainParticle() {
        this.moveVec_ = new Vector3D();
        super(4285909, ZI, 100);
    }

    public function restart(startTime:int, time:int):void {
        var dt:int;
        var angle:Number = 2 * Math.PI * Math.random();
        this.moveVec_.x = Math.cos(angle);
        this.moveVec_.y = Math.sin(angle);
        this.startTime_ = startTime;
        dt = time - this.startTime_;
        x_ = x_ + this.moveVec_.x * dt * 0.0008;
        y_ = y_ + this.moveVec_.y * dt * 0.0008;
        var t:Number = (time - this.startTime_) / 1000;
        z_ = 0.75 + VI * t + G * (t * t);
    }

    override public function removeFromMap():void {
        super.removeFromMap();
        FreeList.deleteObject(this);
    }

    override public function update(time:int, dt:int):Boolean {
        var t:Number = (time - this.startTime_) / 1000;
        moveTo(x_ + this.moveVec_.x * dt * 0.0008, y_ + this.moveVec_.y * dt * 0.0008);
        z_ = 0.75 + VI * t + G * (t * t);
        return z_ > 0;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/LevelUpEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;

public class LevelUpEffect extends ParticleEffect {

    private static const LIFETIME:int = 2000;


    public var go_:GameObject;

    public var parts1_:Vector.<LevelUpParticle>;

    public var parts2_:Vector.<LevelUpParticle>;

    public var startTime_:int = -1;

    public function LevelUpEffect(go:GameObject, color:uint, num:int) {
        var part:LevelUpParticle = null;
        this.parts1_ = new Vector.<LevelUpParticle>();
        this.parts2_ = new Vector.<LevelUpParticle>();
        super();
        this.go_ = go;
        for (var i:int = 0; i < num; i++) {
            part = new LevelUpParticle(color, 100);
            this.parts1_.push(part);
            part = new LevelUpParticle(color, 100);
            this.parts2_.push(part);
        }
    }

    override public function update(time:int, dt:int):Boolean {
        if (this.go_.map_ == null) {
            this.endEffect();
            return false;
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        if (this.startTime_ < 0) {
            this.startTime_ = time;
        }
        var t:Number = (time - this.startTime_) / LIFETIME;
        if (t >= 1) {
            this.endEffect();
            return false;
        }
        this.updateSwirl(this.parts1_, 1, 0, t);
        this.updateSwirl(this.parts2_, 1, Math.PI, t);
        return true;
    }

    private function endEffect():void {
        var part:LevelUpParticle = null;
        for each(part in this.parts1_) {
            part.alive_ = false;
        }
        for each(part in this.parts2_) {
            part.alive_ = false;
        }
    }

    public function updateSwirl(parts:Vector.<LevelUpParticle>, mult:Number, offset:Number, t:Number):void {
        var i:int;
        var part:LevelUpParticle = null;
        var angle:Number = NaN;
        var x:Number = NaN;
        var y:Number = NaN;
        for (i = 0; i < parts.length; i++) {
            part = parts[i];
            part.z_ = t * 2 - 1 + i / parts.length;
            if (part.z_ >= 0) {
                if (part.z_ > 1) {
                    part.alive_ = false;
                } else {
                    angle = mult * (2 * Math.PI * (i / parts.length) + 2 * Math.PI * t + offset);
                    x = this.go_.x_ + 0.5 * Math.cos(angle);
                    y = this.go_.y_ + 0.5 * Math.sin(angle);
                    if (part.map_ == null) {
                        map_.addObj(part, x, y);
                    } else {
                        part.moveTo(x, y);
                    }
                }
            }
        }
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;

class LevelUpParticle extends Particle {


    public var alive_:Boolean = true;

    function LevelUpParticle(color:uint, size:int) {
        super(color, 0, size);
    }

    override public function update(time:int, dt:int):Boolean {
        return this.alive_;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/Particle.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Square;
import com.company.assembleegameclient.objects.BasicObject;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.GraphicsUtil;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;

public class Particle extends BasicObject {
    protected var bitmapFill_:GraphicsBitmapFill = new GraphicsBitmapFill(null, null, false, false);
    protected var path_:GraphicsPath = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, null);
    protected var vS_:Vector.<Number> = new Vector.<Number>();
    protected var fillMatrix_:Matrix = new Matrix();

    public var size_:int;
    public var color_:uint;

    private var texture_:BitmapData;
    private var tW_:int;
    private var tH_:int;

    public function Particle(color:uint, z:Number, size:int) {
        super();
        objectId_ = getNextFakeObjectId();
        this.setZ(z);

        this.color_ = color; // So it doesn't call updateTexture() twice for no reason
        setSize(size);
    }

    public function moveTo(x:Number, y:Number):Boolean {
        var square:Square;
        square = map_.getSquare(x, y);
        if (square == null) {
            return false;
        }
        x_ = x;
        y_ = y;
        square_ = square;
        return true;
    }

    public function setColor(color:uint):void {
        this.color_ = color;
        updateTexture();
    }

    public function setZ(z:Number):void {
        z_ = z;
    }

    public function setSize(size:int):void {
        this.size_ = size / 100 * 5;
        updateTexture();
    }

    private function updateTexture():void {
        this.texture_ = TextureRedrawer.redrawSolidSquare(this.color_, this.size_);
        this.tW_ = this.texture_.width / 2;
        this.tH_ = this.texture_.height / 2;

    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        this.vS_.length = 0;
        this.vS_.push(
                posS_[3] - this.tW_,
                posS_[4] - this.tH_,
                posS_[3] + this.tW_,
                posS_[4] - this.tH_,
                posS_[3] + this.tW_,
                posS_[4] + this.tH_,
                posS_[3] - this.tW_,
                posS_[4] + this.tH_);
        this.path_.data = this.vS_;
        this.bitmapFill_.bitmapData = this.texture_;
        this.fillMatrix_.identity();
        this.fillMatrix_.translate(this.vS_[0], this.vS_[1]);
        this.bitmapFill_.matrix = this.fillMatrix_;
        graphicsData.push(this.bitmapFill_);
        graphicsData.push(this.path_);
        graphicsData.push(GraphicsUtil.END_FILL);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/ParticleGenerator.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;

public class ParticleGenerator extends ParticleEffect {


    private var particlePool:Vector.<BaseParticle>;

    private var liveParticles:Vector.<BaseParticle>;

    private var targetGO:GameObject;

    private var generatedParticles:Number = 0;

    private var totalTime:Number = 0;

    private var effectProps:EffectProperties;

    private var bitmapData:BitmapData;

    private var friction:Number;

    public function ParticleGenerator(effectProperties:EffectProperties, go:GameObject) {
        super();
        this.targetGO = go;
        this.particlePool = new Vector.<BaseParticle>();
        this.liveParticles = new Vector.<BaseParticle>();
        this.effectProps = effectProperties;
        if (this.effectProps.bitmapFile) {
            this.bitmapData = AssetLibrary.getImageFromSet(this.effectProps.bitmapFile, this.effectProps.bitmapIndex);
            this.bitmapData = TextureRedrawer.redraw(this.bitmapData, this.effectProps.size, true, 0);
        } else {
            this.bitmapData = TextureRedrawer.redrawSolidSquare(this.effectProps.color, this.effectProps.size);
        }
    }

    public static function attachParticleGenerator(effectProperties:EffectProperties, go:GameObject):ParticleGenerator {
        return new ParticleGenerator(effectProperties, go);
    }

    override public function update(time:int, dt:int):Boolean {
        var tDelta:Number;
        var newParticle:BaseParticle = null;
        var particle:BaseParticle = null;
        var t:Number = time / 1000;
        tDelta = dt / 1000;
        if (this.targetGO.map_ == null) {
            return false;
        }
        x_ = this.targetGO.x_;
        y_ = this.targetGO.y_;
        z_ = this.targetGO.z_ + this.effectProps.zOffset;
        this.totalTime = this.totalTime + tDelta;
        var projectedTotal:Number = this.effectProps.rate * this.totalTime;
        var particlesToGen:int = projectedTotal - this.generatedParticles;
        for (var i:int = 0; i < particlesToGen; i++) {
            if (this.particlePool.length) {
                newParticle = this.particlePool.pop();
            } else {
                newParticle = new BaseParticle(this.bitmapData);
            }
            newParticle.initialize(this.effectProps.life + this.effectProps.lifeVariance * (2 * Math.random() - 1), this.effectProps.speed + this.effectProps.speedVariance * (2 * Math.random() - 1), this.effectProps.speed + this.effectProps.speedVariance * (2 * Math.random() - 1), this.effectProps.rise + this.effectProps.riseVariance * (2 * Math.random() - 1), z_);
            map_.addObj(newParticle, x_ + this.effectProps.rangeX * (2 * Math.random() - 1), y_ + this.effectProps.rangeY * (2 * Math.random() - 1));
            this.liveParticles.push(newParticle);
        }
        this.generatedParticles = this.generatedParticles + particlesToGen;
        for (var j:int = 0; j < this.liveParticles.length; j++) {
            particle = this.liveParticles[j];
            particle.timeLeft = particle.timeLeft - tDelta;
            if (particle.timeLeft <= 0) {
                this.liveParticles.splice(j, 1);
                map_.removeObj(particle.objectId_);
                j--;
                this.particlePool.push(particle);
            } else {
                particle.spdZ = particle.spdZ + this.effectProps.riseAcc * tDelta;
                particle.x_ = particle.x_ + particle.spdX * tDelta;
                particle.y_ = particle.y_ + particle.spdY * tDelta;
                particle.z_ = particle.z_ + particle.spdZ * tDelta;
            }
        }
        return true;
    }

    override public function removeFromMap():void {
        var particle:BaseParticle = null;
        for each(particle in this.liveParticles) {
            map_.removeObj(particle.objectId_);
        }
        this.liveParticles = null;
        this.particlePool = null;
        super.removeFromMap();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/VentEffect.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.util.FreeList;

public class VentEffect extends ParticleEffect {

    private static const BUBBLE_PERIOD:int = 50;


    public var go_:GameObject;

    public var lastUpdate_:int = -1;

    public function VentEffect(go:GameObject) {
        super();
        this.go_ = go;
    }

    override public function update(time:int, dt:int):Boolean {
        var t:int = 0;
        var part:VentParticle = null;
        var angle:Number = NaN;
        var d:Number = NaN;
        var x:Number = NaN;
        var y:Number = NaN;
        if (this.go_.map_ == null) {
            return false;
        }
        if (this.lastUpdate_ < 0) {
            this.lastUpdate_ = Math.max(0, time - 400);
        }
        x_ = this.go_.x_;
        y_ = this.go_.y_;
        for (var i:int = int(this.lastUpdate_ / BUBBLE_PERIOD); i < int(time / BUBBLE_PERIOD); i++) {
            t = i * BUBBLE_PERIOD;
            part = FreeList.newObject(VentParticle) as VentParticle;
            part.restart(t, time);
            angle = Math.random() * Math.PI;
            d = Math.random() * 0.4;
            x = this.go_.x_ + d * Math.cos(angle);
            y = this.go_.y_ + d * Math.sin(angle);
            map_.addObj(part, x, y);
        }
        this.lastUpdate_ = time;
        return true;
    }
}
}

import com.company.assembleegameclient.objects.particles.Particle;
import com.company.assembleegameclient.util.FreeList;

class VentParticle extends Particle {


    public var startTime_:int;

    public var speed_:int;

    function VentParticle() {
        var r:Number = Math.random();
        super(2542335, 0, 75 + r * 50);
        this.speed_ = 2.5 - r * 1.5;
    }

    public function restart(startTime:int, time:int):void {
        this.startTime_ = startTime;
        var t:Number = (time - this.startTime_) / 1000;
        z_ = this.speed_ * t;
    }

    override public function removeFromMap():void {
        super.removeFromMap();
        FreeList.deleteObject(this);
    }

    override public function update(time:int, dt:int):Boolean {
        var t:Number = (time - this.startTime_) / 1000;
        z_ = speed_ * t;
        return z_ < 1;
    }
}
</file>

<file path="src/com/company/assembleegameclient/objects/particles/XMLParticle.as">
package com.company.assembleegameclient.objects.particles {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Square;
import com.company.assembleegameclient.objects.BasicObject;
import com.company.assembleegameclient.objects.animation.Animations;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.GraphicsUtil;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;
import flash.geom.Vector3D;

public class XMLParticle extends BasicObject {


    public var texture_:BitmapData = null;

    public var animations_:Animations = null;

    public var size_:int;

    public var durationLeft_:Number;

    public var moveVec_:Vector3D;

    protected var bitmapFill_:GraphicsBitmapFill;

    protected var path_:GraphicsPath;

    protected var vS_:Vector.<Number>;

    protected var uvt_:Vector.<Number>;

    protected var fillMatrix_:Matrix;

    public function XMLParticle(props:ParticleProperties) {
        this.bitmapFill_ = new GraphicsBitmapFill(null, null, false, false);
        this.path_ = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, null);
        this.vS_ = new Vector.<Number>();
        this.uvt_ = new Vector.<Number>();
        this.fillMatrix_ = new Matrix();
        super();
        objectId_ = getNextFakeObjectId();
        this.size_ = props.size_;
        z_ = props.z_;
        this.durationLeft_ = props.duration_;
        this.texture_ = props.textureData_.getTexture(objectId_);
        if (props.animationsData_ != null) {
            this.animations_ = new Animations(props.animationsData_);
        }
        this.moveVec_ = new Vector3D();
        var moveAngle:Number = Math.PI * 2 * Math.random();
        this.moveVec_.x = Math.cos(moveAngle) * 0.1 * 5;
        this.moveVec_.y = Math.sin(moveAngle) * 0.1 * 5;
    }

    public function moveTo(x:Number, y:Number):Boolean {
        var square:Square;
        square = map_.getSquare(x, y);
        if (square == null) {
            return false;
        }
        x_ = x;
        y_ = y;
        square_ = square;
        return true;
    }

    override public function update(time:int, dt:int):Boolean {
        var fdt:Number = dt / 1000;
        this.durationLeft_ = this.durationLeft_ - fdt;
        if (this.durationLeft_ <= 0) {
            return false;
        }
        x_ = x_ + this.moveVec_.x * fdt;
        y_ = y_ + this.moveVec_.y * fdt;
        return true;
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var animTexture:BitmapData = null;
        var texture:BitmapData = this.texture_;
        if (this.animations_ != null) {
            animTexture = this.animations_.getTexture(time);
            if (animTexture != null) {
                texture = animTexture;
            }
        }
        texture = TextureRedrawer.redraw(texture, this.size_, true, 0);
        var w:int = texture.width;
        var h:int = texture.height;
        this.vS_.length = 0;
        this.vS_.push(posS_[3] - w / 2, posS_[4] - h, posS_[3] + w / 2, posS_[4] - h, posS_[3] + w / 2, posS_[4], posS_[3] - w / 2, posS_[4]);
        this.path_.data = this.vS_;
        this.bitmapFill_.bitmapData = texture;
        this.fillMatrix_.identity();
        this.fillMatrix_.translate(this.vS_[0], this.vS_[1]);
        this.bitmapFill_.matrix = this.fillMatrix_;
        graphicsData.push(this.bitmapFill_);
        graphicsData.push(this.path_);
        graphicsData.push(GraphicsUtil.END_FILL);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/SpiderWeb.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Square;

import flash.display.IGraphicsData;

public class SpiderWeb extends GameObject {


    private var wallFound_:Boolean = false;

    public function SpiderWeb(objectXML:XML) {
        super(objectXML);
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        if (!this.wallFound_) {
            this.wallFound_ = this.findWall();
        }
        if (this.wallFound_) {
            super.draw(graphicsData, camera, time);
        }
    }

    private function findWall():Boolean {
        var sq:Square;
        sq = map_.lookupSquare(x_ - 1, y_);
        if (sq != null && sq.obj_ is Wall) {
            return true;
        }
        sq = map_.lookupSquare(x_, y_ - 1);
        if (sq != null && sq.obj_ is Wall) {
            obj3D_.setPosition(x_, y_, 0, 90);
            return true;
        }
        sq = map_.lookupSquare(x_ + 1, y_);
        if (sq != null && sq.obj_ is Wall) {
            obj3D_.setPosition(x_, y_, 0, 180);
            return true;
        }
        sq = map_.lookupSquare(x_, y_ + 1);
        if (sq != null && sq.obj_ is Wall) {
            obj3D_.setPosition(x_, y_, 0, 270);
            return true;
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Wall.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.engine3d.Face3D;
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Square;
import com.company.util.BitmapUtil;

import flash.display.BitmapData;
import flash.display.IGraphicsData;

public class Wall extends GameObject {

    private static const UVT:Vector.<Number> = new <Number>[0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0];

    private static const sqX:Vector.<int> = new <int>[0, 1, 0, -1];

    private static const sqY:Vector.<int> = new <int>[-1, 0, 1, 0];

    private static const black:BitmapData = new BitmapData(1, 1, false, 0);


    public var faces_:Vector.<Face3D>;

    private var topFace_:Face3D = null;

    private var topTexture_:BitmapData = null;

    public function Wall(objectXML:XML) {
        this.faces_ = new Vector.<Face3D>();
        super(objectXML);
        hasShadow_ = false;
        var topTextureData:TextureData = ObjectLibrary.typeToTopTextureData_[objectType_];
        this.topTexture_ = topTextureData.getTexture(0);
    }

    override public function setObjectId(objectId:int):void {
        super.setObjectId(objectId);
        var topTextureData:TextureData = ObjectLibrary.typeToTopTextureData_[objectType_];
        this.topTexture_ = topTextureData.getTexture(objectId);
    }

    override public function getColor():uint {
        return BitmapUtil.mostCommonColor(this.topTexture_);
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var animTexture:BitmapData = null;
        var face:Face3D = null;
        var sq:Square = null;
        if (texture_ == null) {
            return;
        }
        if (this.faces_.length == 0) {
            this.rebuild3D();
        }
        var texture:BitmapData = texture_;
        if (animations_ != null) {
            animTexture = animations_.getTexture(time);
            if (animTexture != null) {
                texture = animTexture;
            }
        }
        for (var f:int = 0; f < this.faces_.length; f++) {
            face = this.faces_[f];
            sq = map_.lookupSquare(x_ + sqX[f], y_ + sqY[f]);
            if (sq != null && sq.obj_ is Wall) {
                face.visible_ = false;
            } else {
                face.setTexture(sq == null || sq.texture_ == null ? black : texture);
                face.visible_ = true;
                /*if(animations_ != null)
                {
                   face.setTexture(texture);
                }*/
            }
            face.draw(graphicsData, camera);
        }
        this.topFace_.draw(graphicsData, camera);
    }

    public function rebuild3D():void {
        this.faces_.length = 0;
        var xi:int = x_;
        var yi:int = y_;
        var vin:Vector.<Number> = new <Number>[xi, yi, 1, xi + 1, yi, 1, xi + 1, yi + 1, 1, xi, yi + 1, 1];
        this.topFace_ = new Face3D(this.topTexture_, vin, UVT, false, true);
        this.topFace_.bitmapFill_.repeat = true;
        this.addWall(xi, yi, 1, xi + 1, yi, 1);
        this.addWall(xi + 1, yi, 1, xi + 1, yi + 1, 1);
        this.addWall(xi + 1, yi + 1, 1, xi, yi + 1, 1);
        this.addWall(xi, yi + 1, 1, xi, yi, 1);
    }

    private function addWall(x0:Number, y0:Number, z0:Number, x1:Number, y1:Number, z1:Number):void {
        var vin:Vector.<Number> = new <Number>[x0, y0, z0, x1, y1, z1, x1, y1, z1 - 1, x0, y0, z0 - 1];
        var face:Face3D = new Face3D(texture_, vin, UVT, true, true);
        face.bitmapFill_.repeat = true;
        this.faces_.push(face);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/AccountScreen.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.ui.GuildText;
import com.company.assembleegameclient.ui.RankText;
import com.company.assembleegameclient.ui.tooltip.RankToolTip;

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.account.core.view.AccountInfoView;

public class AccountScreen extends Sprite {
    public var tooltip:Signal;

    private var rankLayer:Sprite;

    private var guildLayer:Sprite;

    private var accountInfoLayer:Sprite;

    private var guildName:String;

    private var guildRank:int;

    private var stars:int;

    private var rankText:RankText;

    private var guildText:GuildText;

    private var accountInfo:AccountInfoView;

    public function AccountScreen() {
        super();
        this.tooltip = new Signal();
        this.makeLayers();
    }

    private function makeLayers():void {
        addChild(this.rankLayer = new Sprite());
        addChild(this.guildLayer = new Sprite());
        addChild(this.accountInfoLayer = new Sprite());
    }

    public function setGuild(guildName:String, guildRank:int):void {
        this.guildName = guildName;
        this.guildRank = guildRank;
        this.makeGuildText();
    }

    private function makeGuildText():void {
        this.guildText = new GuildText(this.guildName, this.guildRank);
        this.guildText.x = 92;
        this.guildText.y = 6;
        this.guildLayer.addChild(this.guildText);
    }

    public function setRank(stars:int):void {
        this.stars = stars;
        this.makeRankText();
    }

    private function makeRankText():void {
        this.rankText = new RankText(this.stars, true, false);
        this.rankText.x = 36;
        this.rankText.y = 4;
        this.rankText.mouseEnabled = true;
        this.rankText.addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        this.rankText.addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        this.rankLayer.addChild(this.rankText);
    }

    public function setAccountInfo(accountInfo:AccountInfoView):void {
        var display:DisplayObject = accountInfo as DisplayObject;
        this.accountInfo = accountInfo;
        display.x = GameClient.StageWidth - 10;
        display.y = 2;

        function OnResize(e:Event):void {
            display.x = GameClient.StageWidth - 10;
        }

        GameClient.STAGE.addEventListener(Event.RESIZE, OnResize, false, 0, true);
        this.accountInfoLayer.addChild(display);
    }

    protected function onMouseOver(event:MouseEvent):void {
        this.tooltip.dispatch(new RankToolTip(this.stars));
    }

    protected function onRollOut(event:MouseEvent):void {
        this.tooltip.dispatch(null);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/LoadingScreen.as">
package com.company.assembleegameclient.screens {
import com.company.ui.SimpleText;
import com.company.untiered.graphics.ScreenGraphic;

import flash.display.Sprite;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

import svera.untiered.ui.view.components.ScreenBase;

public class LoadingScreen extends Sprite {
    private var text:SimpleText;

    public function LoadingScreen() {
        super();
        addChild(new ScreenBase());
        addChild(new ScreenGraphic());
        this.text = new SimpleText(30, 16777215, false, 0, 0);
        this.text.y = 526;
        this.text.setBold(true);
        this.text.htmlText = "<p align=\"center\">Loading...</p>";
        this.text.autoSize = TextFieldAutoSize.CENTER;
        this.text.updateMetrics();
        this.text.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4)];
        addChild(this.text);
    }

    public function setText(value:String):void {
        this.text.htmlText = value;
        this.text.x = (stage.stageWidth - this.text.width) * 0.5;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/NewsLine.as">
package com.company.assembleegameclient.screens {
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.net.URLRequest;
import flash.net.navigateToURL;

import org.osflash.signals.Signal;

public class NewsLine extends Sprite {

    public static const WIDTH:int = 388;

    public static const HEIGHT:int = 52;

    public static const COLOR:uint = 11776947;

    public static const OVER_COLOR:uint = 16762880;


    public var viewCharacterHonor:Signal;

    public var icon_:Bitmap;

    public var titleText_:SimpleText;

    public var taglineText_:SimpleText;

    public var dtText_:SimpleText;

    public var link:String;

    public var accountId:int;

    public function NewsLine(icon:BitmapData, title:String, tagLine:String, link:String, time:int, accountId:int) {
        this.viewCharacterHonor = new Signal(int);
        super();
        this.link = link;
        this.accountId = accountId;
        buttonMode = true;
        useHandCursor = true;
        tabEnabled = false;
        this.icon_ = new Bitmap();
        this.icon_.bitmapData = icon;
        this.icon_.x = 0;
        this.icon_.y = HEIGHT / 2 - icon.height / 2 - 3;
        addChild(this.icon_);
        this.titleText_ = new SimpleText(18, COLOR, false, 0, 0);
        this.titleText_.text = title;
        this.titleText_.updateMetrics();
        this.titleText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.titleText_.x = 61;
        addChild(this.titleText_);
        this.taglineText_ = new SimpleText(14, COLOR, false, 0, 0);
        this.taglineText_.text = tagLine;
        this.taglineText_.updateMetrics();
        this.taglineText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.taglineText_.x = 61;
        this.taglineText_.y = 24;
        addChild(this.taglineText_);
        this.dtText_ = new SimpleText(16, COLOR, false, 0, 0);
        this.dtText_.text = this.getTimeDiff(time);
        this.dtText_.updateMetrics();
        this.dtText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.dtText_.x = WIDTH - this.dtText_.width;
        addChild(this.dtText_);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
    }

    protected function onMouseOver(event:MouseEvent):void {
        this.titleText_.setColor(OVER_COLOR);
        this.taglineText_.setColor(OVER_COLOR);
        this.dtText_.setColor(OVER_COLOR);
    }

    protected function onRollOut(event:MouseEvent):void {
        this.titleText_.setColor(COLOR);
        this.taglineText_.setColor(COLOR);
        this.dtText_.setColor(COLOR);
    }

    protected function onMouseDown(event:MouseEvent):void {
        var parts:Array = this.link.split(":", 2);
        switch (parts[0]) {
            case "honor":
                this.viewCharacterHonor.dispatch(int(parts[1]));
                break;
            case "http":
            case "https":
            default:
                navigateToURL(new URLRequest(this.link), "_blank");
        }
    }

    private function getTimeDiff(time:int):String {
        var now:Number = new Date().getTime() / 1000;
        var dt:int = now - time;
        if (dt <= 0) {
            return "now";
        }
        if (dt < 60) {
            return dt + " secs";
        }
        if (dt < 60 * 60) {
            return int(dt / 60) + " mins";
        }
        if (dt < 60 * 60 * 24) {
            return int(dt / (60 * 60)) + " hours";
        }
        return int(dt / (60 * 60 * 24)) + " days";
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/NewsList.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.appengine.SavedNewsItem;

import flash.display.Sprite;

import svera.untiered.core.model.PlayerModel;

public class NewsList extends Sprite {

    private var lines_:Vector.<NewsLine>;

    public function NewsList(model:PlayerModel) {
        super();
        this.lines_ = new Vector.<NewsLine>();
        var news:SavedNewsItem;
        for each (news in model.getNews()) {
            this.addLine(new NewsLine(news.getIcon(), news.title_, news.tagline_, news.link_, news.date_, model.getAccountId()));
        }
    }

    public function addLine(newsLine:NewsLine):void {
        newsLine.y = 4 + this.lines_.length * (NewsLine.HEIGHT + 4);
        this.lines_.push(newsLine);
        addChild(newsLine);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/ScoringBox.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.util.BitmapUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.geom.Rectangle;
import flash.utils.getTimer;

public class ScoringBox extends Sprite {


    private var rect_:Rectangle;

    private var mask_:Shape;

    private var linesSprite_:Sprite;

    private var scoreTextLines_:Vector.<ScoreTextLine>;

    private var scrollbar_:Scrollbar;

    private var startTime_:int;

    public function ScoringBox(rect:Rectangle, honorXML:XML) {
        var bonusXML:XML = null;
        this.mask_ = new Shape();
        this.linesSprite_ = new Sprite();
        this.scoreTextLines_ = new Vector.<ScoreTextLine>();
        super();
        this.rect_ = rect;
        graphics.lineStyle(1, 4802889, 2);
        graphics.drawRect(this.rect_.x + 1, this.rect_.y + 1, this.rect_.width - 2, this.rect_.height - 2);
        graphics.lineStyle();
        this.scrollbar_ = new Scrollbar(16, this.rect_.height);
        this.scrollbar_.addEventListener(Event.CHANGE, this.onScroll);
        this.mask_.graphics.beginFill(16777215, 1);
        this.mask_.graphics.drawRect(this.rect_.x, this.rect_.y, this.rect_.width, this.rect_.height);
        this.mask_.graphics.endFill();
        addChild(this.mask_);
        mask = this.mask_;
        addChild(this.linesSprite_);
        this.addLine("Minutes Active", null, honorXML.MinutesActive, 5746018);
        this.addLine("Shots", null, honorXML.Shots, 5746018);
        this.addLine("Accuracy", null, 100 * Number(honorXML.ShotsThatDamage) / Number(honorXML.Shots), 5746018, "", "%");
        this.addLine("Abilities Used", null, honorXML.AbilitiesUsed, 5746018);
        this.addLine("Tiles Seen", null, honorXML.TilesUncovered, 5746018);
        this.addLine("Monster Kills", null, honorXML.MonsterKills, 5746018);
        this.addLine("God Kills", null, honorXML.GodKills, 5746018);
        this.addLine("Oryx Kills", null, honorXML.OryxKills, 5746018);
        this.addLine("Cube Kills", null, honorXML.CubeKills, 5746018);
        this.addLine("Cyan Bags", null, honorXML.CyanBags, 5746018);
        this.addLine("Blue Bags", null, honorXML.BlueBags, 5746018);
        this.addLine("White Bags", null, honorXML.WhiteBags, 5746018);
        this.addLine("Damage Taken", null, honorXML.DamageTaken, 5746018);
        this.addLine("Damage Dealt", null, honorXML.DamageDealt, 5746018);
        this.addLine("Teleports", null, honorXML.Teleports, 5746018);
        this.addLine("Potions Drank", null, honorXML.PotionsDrank, 5746018);
        this.addLine("Quests Completed", null, honorXML.QuestsCompleted, 5746018);
        this.addLine("Dungeons Completed", null, int(honorXML.PirateCavesCompleted) + int(honorXML.UndeadLairsCompleted) + int(honorXML.AbyssOfDemonsCompleted) + int(honorXML.SnakePitsCompleted) + int(honorXML.SpiderDensCompleted) + int(honorXML.SpriteWorldsCompleted) + int(honorXML.TombsCompleted), 5746018);
        this.addLine("Escapes", null, int(honorXML.Escapes), 5746018);
        this.addLine("Near Death Escapes", null, int(honorXML.NearDeathEscapes), 5746018);
        this.addLine("Party Member Level Ups", null, honorXML.LevelUpAssists, 5746018);
        var honorBD:BitmapData = HonorUtil.getHonorIcon();
        honorBD = BitmapUtil.cropToBitmapData(honorBD, 6, 6, honorBD.width - 12, honorBD.height - 12);
        this.addLine("Base Honor Earned", null, honorXML.BaseHonor, 16762880, "", "", new Bitmap(honorBD));
        for each(bonusXML in honorXML.Bonus) {
            this.addLine("Bonus: " + bonusXML.@id, null, int(bonusXML), 16762880, "+", "", new Bitmap(honorBD));
        }
    }

    public function showScore():void {
        var textLine:ScoreTextLine = null;
        this.animateScore();
        this.startTime_ = -int.MAX_VALUE;
        for each(textLine in this.scoreTextLines_) {
            textLine.skip();
        }
    }

    public function animateScore():void {
        this.startTime_ = getTimer();
        addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
    }

    private function onScroll(event:Event):void {
        var v:Number = this.scrollbar_.pos();
        this.linesSprite_.y = v * (this.rect_.height - this.linesSprite_.height - 15) + 5;
    }

    private function addLine(name:String, desc:String, val:int, color:uint, numberPrefix:String = "", unit:String = "", unitIcon:DisplayObject = null):void {
        this.scoreTextLines_.push(new ScoreTextLine(20, 11776947, color, name, desc, val, numberPrefix, unit, unitIcon));
    }

    private function onEnterFrame(event:Event):void {
        var stl:ScoreTextLine = null;
        var endTime:Number = this.startTime_ + 1000 * (this.scoreTextLines_.length - 1) / 2;
        var time:Number = getTimer();
        var maxI:int = Math.min(this.scoreTextLines_.length, 2 * (getTimer() - this.startTime_) / 1000 + 1);
        for (var i:int = 0; i < maxI; i++) {
            stl = this.scoreTextLines_[i];
            stl.y = 28 * i;
            this.linesSprite_.addChild(stl);
        }
        this.linesSprite_.y = this.rect_.height - this.linesSprite_.height - 10;
        if (time > endTime + 600) {
            this.addScrollbar();
            dispatchEvent(new Event(Event.COMPLETE));
            removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
    }

    private function addScrollbar():void {
        graphics.clear();
        graphics.lineStyle(1, 4802889, 2);
        graphics.drawRect(this.rect_.x + 1, this.rect_.y + 1, this.rect_.width - 26, this.rect_.height - 2);
        graphics.lineStyle();
        this.scrollbar_.x = this.rect_.width - 16;
        this.scrollbar_.setIndicatorSize(this.mask_.height, this.linesSprite_.height);
        this.scrollbar_.setPos(1);
        addChild(this.scrollbar_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/board/GuildBoardWindow.as">
package com.company.assembleegameclient.ui.board {
import com.company.assembleegameclient.ui.dialogs.Dialog;
import com.company.util.MoreObjectUtil;

import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;

import svera.untiered.account.core.Account;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.core.StaticInjectorContext;

public class GuildBoardWindow extends Sprite {


    private var canEdit_:Boolean;

    private var darkBox_:Shape;

    private var dialog_:Dialog;

    private var text_:String;

    private var viewBoard_:ViewBoard;

    private var editBoard_:EditBoard;

    private var client:AppEngineClient;

    public function GuildBoardWindow(canEdit:Boolean) {
        super();
        this.canEdit_ = canEdit;
        this.darkBox_ = new Shape();
        var g:Graphics = this.darkBox_.graphics;
        g.clear();
        g.beginFill(0, 0.8);
        g.drawRect(0, 0, GameClient.StageWidth, 600);
        g.endFill();
        addChild(this.darkBox_);
        this.load();
    }

    private function load():void {
        var account:Account = StaticInjectorContext.getInjector().getInstance(Account);
        this.client = StaticInjectorContext.getInjector().getInstance(AppEngineClient);
        this.client.complete.addOnce(this.onGetBoardComplete);
        this.client.sendRequest("/guild/getBoard", account.getCredentials());
        this.dialog_ = new Dialog("Loading...", null, null, null);
        addChild(this.dialog_);
        this.darkBox_.visible = false;
    }

    private function onGetBoardComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.showGuildBoard(data);
        } else {
            this.reportError(data);
        }
    }

    private function showGuildBoard(data:String):void {
        this.darkBox_.visible = true;
        removeChild(this.dialog_);
        this.dialog_ = null;
        this.text_ = data;
        this.show();
    }

    private function show():void {
        this.viewBoard_ = new ViewBoard(this.text_, this.canEdit_);
        this.viewBoard_.x = GameClient.HalfStageWidth - this.viewBoard_.w_ / 2;
        this.viewBoard_.y = 600 / 2 - this.viewBoard_.h_ / 2;
        this.viewBoard_.addEventListener(Event.COMPLETE, this.onViewComplete);
        this.viewBoard_.addEventListener(Event.CHANGE, this.onViewChange);
        addChild(this.viewBoard_);
    }

    private function reportError(error:String):void {
        trace("load error: " + error);
    }

    private function onViewComplete(event:Event):void {
        parent.removeChild(this);
    }

    private function onViewChange(event:Event):void {
        removeChild(this.viewBoard_);
        this.viewBoard_ = null;
        this.editBoard_ = new EditBoard(this.text_);
        this.editBoard_.x = GameClient.HalfStageWidth - this.editBoard_.w_ / 2;
        this.editBoard_.y = 600 / 2 - this.editBoard_.h_ / 2;
        this.editBoard_.addEventListener(Event.CANCEL, this.onEditCancel);
        this.editBoard_.addEventListener(Event.COMPLETE, this.onEditComplete);
        addChild(this.editBoard_);
    }

    private function onEditCancel(event:Event):void {
        removeChild(this.editBoard_);
        this.editBoard_ = null;
        this.show();
    }

    private function onEditComplete(event:Event):void {
        var account:Account = StaticInjectorContext.getInjector().getInstance(Account);
        var params:Object = {"board": this.editBoard_.getText()};
        MoreObjectUtil.addToObject(params, account.getCredentials());
        this.client = StaticInjectorContext.getInjector().getInstance(AppEngineClient);
        this.client.complete.addOnce(this.onSetBoardComplete);
        this.client.sendRequest("/guild/setBoard", params);
        removeChild(this.editBoard_);
        this.editBoard_ = null;
        this.dialog_ = new Dialog("Saving...", null, null, null);
        addChild(this.dialog_);
        this.darkBox_.visible = false;
    }

    private function onSetBoardComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.onSaveDone(data);
        } else {
            this.onSaveError(data);
        }
    }

    private function onSaveDone(data:String):void {
        this.darkBox_.visible = true;
        removeChild(this.dialog_);
        this.dialog_ = null;
        this.text_ = data;
        this.show();
    }

    private function onSaveError(error:String):void {
        trace("save error: " + error);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/board/ViewBoard.as">
package com.company.assembleegameclient.ui.board {
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;
import com.company.util.HTMLUtil;

import flash.display.CapsStyle;
import flash.display.Graphics;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

public class ViewBoard extends Sprite {

    public static const TEXT_WIDTH:int = 400;

    public static const TEXT_HEIGHT:int = 400;

    private static const URL_REGEX:RegExp = /((https?|ftp):((\/\/)|(\\\\))+[\w\d:#@%\/;$()~_?\+-=\\\.&]*)/g;


    private var text_:String;

    public var w_:int;

    public var h_:int;

    private var boardText_:SimpleText;

    private var mainSprite_:Sprite;

    private var fullTextSprite_:Sprite;

    private var scrollBar_:Scrollbar;

    private var editButton_:TextButton;

    private var closeButton_:TextButton;

    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(3355443, 1);

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(2, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[lineStyle_, backgroundFill_, path_, GraphicsUtil.END_FILL, GraphicsUtil.END_STROKE];

    function ViewBoard(text:String, canEdit:Boolean) {
        super();
        this.text_ = text;
        this.mainSprite_ = new Sprite();
        var shape:Shape = new Shape();
        var g:Graphics = shape.graphics;
        g.beginFill(0);
        g.drawRect(0, 0, TEXT_WIDTH, TEXT_HEIGHT);
        g.endFill();
        this.mainSprite_.addChild(shape);
        this.mainSprite_.mask = shape;
        addChild(this.mainSprite_);
        var viewText:String = HTMLUtil.escape(text);
        viewText = viewText.replace(URL_REGEX, "<font color=\"#7777EE\"><a href=\"$1\" target=\"_blank\">" + "$1</a></font>");
        this.boardText_ = new SimpleText(16, 11776947, false, TEXT_WIDTH, 0);
        this.boardText_.border = false;
        this.boardText_.mouseEnabled = true;
        this.boardText_.multiline = true;
        this.boardText_.wordWrap = true;
        this.boardText_.htmlText = viewText;
        this.boardText_.useTextDimensions();
        this.mainSprite_.addChild(this.boardText_);
        var showScrollbar:Boolean = this.boardText_.height > 400;
        if (showScrollbar) {
            this.scrollBar_ = new Scrollbar(16, TEXT_HEIGHT - 4);
            this.scrollBar_.x = TEXT_WIDTH + 6;
            this.scrollBar_.y = 0;
            this.scrollBar_.setIndicatorSize(400, this.boardText_.height);
            this.scrollBar_.addEventListener(Event.CHANGE, this.onScrollBarChange);
            addChild(this.scrollBar_);
        }
        this.w_ = TEXT_WIDTH + (showScrollbar ? 26 : 0);
        this.editButton_ = new TextButton(14, "Edit", 120);
        this.editButton_.x = 4;
        this.editButton_.y = TEXT_HEIGHT + 4;
        this.editButton_.addEventListener(MouseEvent.CLICK, this.onEdit);
        addChild(this.editButton_);
        this.editButton_.visible = canEdit;
        this.closeButton_ = new TextButton(14, "Close", 120);
        this.closeButton_.x = this.w_ - this.closeButton_.width - 4;
        this.closeButton_.y = TEXT_HEIGHT + 4;
        this.closeButton_.addEventListener(MouseEvent.CLICK, this.onClose);
        addChild(this.closeButton_);
        this.h_ = TEXT_HEIGHT + this.closeButton_.height + 8;
        graphics.clear();
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(-6, -6, this.w_ + 12, this.h_ + 12, 4, [1, 1, 1, 1], this.path_);
        graphics.drawGraphicsData(this.graphicsData_);
    }

    private function onScrollBarChange(event:Event):void {
        this.boardText_.y = -this.scrollBar_.pos() * (this.boardText_.height - 400);
    }

    private function onEdit(event:Event):void {
        dispatchEvent(new Event(Event.CHANGE));
    }

    private function onClose(event:Event):void {
        dispatchEvent(new Event(Event.COMPLETE));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/dialogs/DebugDialog.as">
package com.company.assembleegameclient.ui.dialogs {
import flash.events.Event;

public class DebugDialog extends Dialog {


    public function DebugDialog(text:String) {
        super(text, "Debug", "OK", null);
        addEventListener(Dialog.LEFT_BUTTON, this.onDialogComplete);
    }

    private function onDialogComplete(event:Event):void {
        if (this.parent != null) {
            this.parent.removeChild(this);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/dialogs/Dialog.as">
package com.company.assembleegameclient.ui.dialogs {
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.Graphics;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

public class Dialog extends Sprite {

    public static const LEFT_BUTTON:String = "DIALOG_BUTTON1";

    public static const RIGHT_BUTTON:String = "DIALOG_BUTTON2";

    private static const WIDTH:int = 300;


    public var box_:Sprite;

    public var rect_:Shape;

    public var textText_:SimpleText;

    public var titleText_:SimpleText = null;

    public var button1_:TextButton = null;

    public var button2_:TextButton = null;

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(3552822, 1);

    protected var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    protected const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[lineStyle_, backgroundFill_, path_, GraphicsUtil.END_FILL, GraphicsUtil.END_STROKE];

    public var offsetX:Number = 0;

    public var offsetY:Number = 0;

    public function Dialog(text:String, title:String, button1:String, button2:String) {
        this.box_ = new Sprite();
        super();
        this.initText(text);
        this.initTitleText(title);
        if (button1 != null) {
            this.button1_ = new TextButton(16, button1, 120);
            this.button1_.addEventListener(MouseEvent.CLICK, this.onButton1Click);
        }
        if (button2 != null) {
            this.button2_ = new TextButton(16, button2, 120);
            this.button2_.addEventListener(MouseEvent.CLICK, this.onButton2Click);
        }
        this.draw();
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
    }

    protected function initText(text:String):void {
        this.textText_ = new SimpleText(14, 11776947, false, WIDTH - 40, 0);
        this.textText_.x = 20;
        this.textText_.multiline = true;
        this.textText_.wordWrap = true;
        this.textText_.htmlText = "<p align=\"center\">" + text + "</p>";
        this.textText_.autoSize = TextFieldAutoSize.CENTER;
        this.textText_.mouseEnabled = true;
        this.textText_.updateMetrics();
        this.textText_.filters = [new DropShadowFilter(0, 0, 0, 1, 6, 6, 1)];
    }

    private function initTitleText(title:String):void {
        if (title != null) {
            this.titleText_ = new SimpleText(18, 5746018, false, WIDTH, 0);
            this.titleText_.setBold(true);
            this.titleText_.htmlText = "<p align=\"center\">" + title + "</p>";
            this.titleText_.updateMetrics();
            this.titleText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8, 1)];
        }
    }

    protected function draw():void {
        var by:int = 0;
        if (this.titleText_ != null) {
            this.titleText_.y = 2;
            this.box_.addChild(this.titleText_);
            this.textText_.y = this.box_.height + 8;
        } else {
            this.textText_.y = 4;
        }
        this.box_.addChild(this.textText_);
        if (this.button1_ != null) {
            by = this.box_.height + 16;
            this.box_.addChild(this.button1_);
            this.button1_.y = by;
            if (this.button2_ == null) {
                this.button1_.x = WIDTH / 2 - this.button1_.width / 2;
            } else {
                this.button1_.x = WIDTH / 4 - this.button1_.width / 2;
                this.box_.addChild(this.button2_);
                this.button2_.x = 3 * WIDTH / 4 - this.button2_.width / 2;
                this.button2_.y = by;
            }
        }
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, WIDTH, this.box_.height + 10, 4, [1, 1, 1, 1], this.path_);
        this.rect_ = new Shape();
        var g:Graphics = this.rect_.graphics;
        g.drawGraphicsData(this.graphicsData_);
        this.box_.addChildAt(this.rect_, 0);
        this.box_.filters = [new DropShadowFilter(0, 0, 0, 1, 16, 16, 1)];
        addChild(this.box_);
    }

    private function onAddedToStage(event:Event):void {
        this.box_.x = this.offsetX + stage.stageWidth / 2 - this.box_.width / 2;
        this.box_.y = this.offsetY + stage.stageHeight / 2 - this.box_.height / 2;
    }

    private function onButton1Click(event:MouseEvent):void {
        dispatchEvent(new Event(LEFT_BUTTON));
    }

    private function onButton2Click(event:Event):void {
        dispatchEvent(new Event(RIGHT_BUTTON));
    }

    public function setBaseAlpha(value:Number):void {
        this.rect_.alpha = value > 1 ? Number(1) : value < 0 ? Number(0) : Number(value);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/dialogs/ErrorDialog.as">
package com.company.assembleegameclient.ui.dialogs {
import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class ErrorDialog extends Dialog {


    public var ok:Signal;

    public function ErrorDialog(errorText:String) {
        super("An error has occured:\n" + errorText, "D\'oh, this isn\'t good", "Ok", null);
        this.ok = new NativeMappedSignal(this, LEFT_BUTTON);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/dropdown/DropDown.as">
package com.company.assembleegameclient.ui.dropdown {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.Point;

public class DropDown extends Sprite {


    protected var strings_:Vector.<String>;

    protected var w_:int;

    protected var h_:int;

    protected var labelText_:SimpleText;

    protected var xOffset_:int = 0;

    protected var selected_:DropDownItem;

    protected var all_:Sprite;

    public function DropDown(strings:Vector.<String>, w:int, h:int, label:String = null) {
        this.all_ = new Sprite();
        super();
        this.strings_ = strings;
        this.w_ = w;
        this.h_ = h;
        if (label != null) {
            this.labelText_ = new SimpleText(16, 16777215, false, 0, 0);
            this.labelText_.setBold(true);
            this.labelText_.text = label + ":";
            this.labelText_.updateMetrics();
            addChild(this.labelText_);
            this.xOffset_ = this.labelText_.width + 5;
        }
        this.setIndex(0);
    }

    public function getValue():String {
        return this.selected_.getValue();
    }

    public function setValue(value:String):void {
        for (var i:int = 0; i < this.strings_.length; i++) {
            if (value == this.strings_[i]) {
                this.setIndex(i);
                return;
            }
        }
    }

    public function setIndex(index:int):void {
        this.setSelected(this.strings_[index]);
    }

    public function getIndex():int {
        for (var i:int = 0; i < this.strings_.length; i++) {
            if (this.selected_.getValue() == this.strings_[i]) {
                return i;
            }
        }
        return -1;
    }

    private function setSelected(value:String):void {
        var prevValue:String = this.selected_ != null ? this.selected_.getValue() : null;
        this.selected_ = new DropDownItem(value, this.w_, this.h_);
        this.selected_.x = this.xOffset_;
        this.selected_.y = 0;
        addChild(this.selected_);
        this.selected_.addEventListener(MouseEvent.CLICK, this.onClick);
        if (value != prevValue) {
            dispatchEvent(new Event(Event.CHANGE));
        }
    }

    private function onClick(event:MouseEvent):void {
        event.stopImmediatePropagation();
        this.selected_.removeEventListener(MouseEvent.CLICK, this.onClick);
        if (contains(this.selected_)) {
            removeChild(this.selected_);
        }
        this.showAll();
    }

    private function showAll():void {
        var global:Point;
        var item:DropDownItem = null;
        var yOffset:int = 0;
        global = parent.localToGlobal(new Point(x, y));
        this.all_.x = global.x;
        this.all_.y = global.y;
        for (var i:int = 0; i < this.strings_.length; i++) {
            item = new DropDownItem(this.strings_[i], this.w_, this.h_);
            item.addEventListener(MouseEvent.CLICK, this.onSelect);
            item.x = this.xOffset_;
            item.y = yOffset;
            this.all_.addChild(item);
            yOffset = yOffset + item.h_;
        }
        this.all_.addEventListener(MouseEvent.ROLL_OUT, this.onOut);
        stage.addChild(this.all_);
    }

    private function hideAll():void {
        this.all_.removeEventListener(MouseEvent.ROLL_OUT, this.onOut);
        stage.removeChild(this.all_);
    }

    private function onSelect(event:MouseEvent):void {
        event.stopImmediatePropagation();
        this.hideAll();
        var dropDownItem:DropDownItem = event.target as DropDownItem;
        this.setSelected(dropDownItem.getValue());
    }

    private function onOut(event:MouseEvent):void {
        this.hideAll();
        this.setSelected(this.selected_.getValue());
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/FrameOverlay.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.account.ui.Frame;

import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;

public class FrameOverlay extends Sprite {


    private var darkBox_:Shape;

    private var frame_:Frame;

    public function FrameOverlay(frame:Frame) {
        super();
        this.darkBox_ = new Shape();
        var g:Graphics = this.darkBox_.graphics;
        g.clear();
        g.beginFill(0, 0.8);
        g.drawRect(0, 0, GameClient.StageWidth, 600);
        g.endFill();
        addChild(this.darkBox_);
        this.frame_ = frame;
        this.frame_.addEventListener(Event.COMPLETE, this.onFrameDone);
        addChild(this.frame_);
    }

    private function onFrameDone(event:Event):void {
        parent.removeChild(this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/GameObjectListItem.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.ui.SimpleText;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

public class GameObjectListItem extends Sprite {


    private var portrait_:Bitmap;

    private var nameText_:SimpleText;

    private var rankIcon_:Sprite;

    private var color_:uint;

    public var longVersion_:Boolean;

    public var go_:GameObject;

    private var drawColor_:uint = 16777215;

    private var drawText_:String = null;

    private var isHtml_:Boolean = false;

    private var drawCT_:ColorTransform = null;

    public function GameObjectListItem(color:uint, longVersion:Boolean, go:GameObject) {
        super();
        this.longVersion_ = longVersion;
        this.color_ = color;
        this.portrait_ = new Bitmap();
        this.portrait_.x = -16;
        this.portrait_.y = -16;
        addChild(this.portrait_);
        if (this.longVersion_) {
            this.nameText_ = new SimpleText(13, color, false, 0, 0);
        } else {
            this.nameText_ = new SimpleText(13, color, false, 66, 20);
            this.nameText_.setBold(true);
        }
        this.nameText_.x = 32;
        this.nameText_.y = 6;
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.nameText_);
        this.draw(go);
    }

    public function draw(go:GameObject, ct:ColorTransform = null):void {
        this.go_ = go;
        visible = this.go_ != null;
        if (!visible) {
            return;
        }
        this.portrait_.bitmapData = this.go_.getPortrait();
        var drawColor:uint = this.color_;
        var drawText:String;
        var isHtml:Boolean = false;
        var p:Player = this.go_ as Player;
        if (p != null) {
            if (p.isFellowGuild_) {
                drawColor = Parameters.FELLOW_GUILD_COLOR;
            } else {
                drawColor = Parameters.NAME_COLOUR;
            }
        }
        if (this.longVersion_) {
            isHtml = true;
            if (this.go_.name_ != null && this.go_.name_ != "") {
                drawText = "<b>" + this.go_.name_ + "</b> (" + ObjectLibrary.typeToDisplayId_[this.go_.objectType_];
                if (this.go_.level_ < 1) {
                    drawText = drawText + ")";
                } else {
                    drawText = drawText + (" " + this.go_.level_ + ")");
                }
            } else {
                drawText = "<b>" + ObjectLibrary.typeToDisplayId_[this.go_.objectType_] + "</b>";
            }
        } else if (this.go_.name_ == null || this.go_.name_ == "") {
            drawText = ObjectLibrary.typeToDisplayId_[this.go_.objectType_];
        } else {
            drawText = this.go_.name_;
        }
        this.internalDraw(drawColor, drawText, isHtml, ct);
    }

    private function internalDraw(drawColor:uint, drawText:String, isHtml:Boolean, drawCT:ColorTransform):void {
        if (drawColor == this.drawColor_ && drawText == this.drawText_ && isHtml == this.isHtml_ && drawCT == this.drawCT_) {
            return;
        }
        this.nameText_.setColor(drawColor);
        if (isHtml) {
            this.nameText_.htmlText = drawText;
        } else {
            this.nameText_.text = drawText;
        }
        this.nameText_.updateMetrics();
        if (this.drawCT_ != null || drawCT != null) {
            transform.colorTransform = drawCT == null ? MoreColorUtil.identity : drawCT;
        }
        this.drawColor_ = drawColor;
        this.drawText_ = drawText;
        this.isHtml_ = isHtml;
        this.drawCT_ = drawCT;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/ChoiceBox.as">
package com.company.assembleegameclient.ui.options {
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.Graphics;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class ChoiceBox extends Sprite {

    public static const WIDTH:int = 80;

    public static const HEIGHT:int = 32;


    public var labels_:Vector.<String>;

    public var values_:Array;

    public var selectedIndex_:int = -1;

    private var labelText_:SimpleText = null;

    private var over_:Boolean = false;

    private var internalFill_:GraphicsSolidFill = new GraphicsSolidFill(3355443, 1);

    private var overLineFill_:GraphicsSolidFill = new GraphicsSolidFill(11776947, 1);

    private var normalLineFill_:GraphicsSolidFill = new GraphicsSolidFill(4473924, 1);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(2, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, normalLineFill_);

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[internalFill_, lineStyle_, path_, GraphicsUtil.END_STROKE, GraphicsUtil.END_FILL];

    public function ChoiceBox(labels:Vector.<String>, values:Array, value:Object) {
        super();
        this.labels_ = labels;
        this.values_ = values;
        this.labelText_ = new SimpleText(16, 16777215, false, 0, 0);
        this.labelText_.setBold(true);
        this.labelText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        addChild(this.labelText_);
        this.setValue(value);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function setValue(value:*):void {
        for (var i:int = 0; i < this.values_.length; i++) {
            if (value == this.values_[i]) {
                if (i == this.selectedIndex_) {
                    return;
                }
                this.selectedIndex_ = i;
                break;
            }
        }
        this.setSelected(this.selectedIndex_);
        dispatchEvent(new Event(Event.CHANGE));
    }

    public function value():* {
        return this.values_[this.selectedIndex_];
    }

    private function onMouseOver(event:MouseEvent):void {
        this.over_ = true;
        this.drawBackground();
    }

    private function onRollOut(event:MouseEvent):void {
        this.over_ = false;
        this.drawBackground();
    }

    private function onClick(event:MouseEvent):void {
        this.setSelected((this.selectedIndex_ + 1) % this.values_.length);
        dispatchEvent(new Event(Event.CHANGE));
    }

    private function drawBackground():void {
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, WIDTH, HEIGHT, 4, [1, 1, 1, 1], this.path_);
        this.lineStyle_.fill = this.over_ ? this.overLineFill_ : this.normalLineFill_;
        graphics.drawGraphicsData(this.graphicsData_);
        var g:Graphics = graphics;
        g.clear();
        g.drawGraphicsData(this.graphicsData_);
    }

    private function setSelected(index:int):void {
        this.selectedIndex_ = index;
        this.setText(this.labels_[this.selectedIndex_]);
    }

    private function setText(text:String):void {
        this.labelText_.text = text;
        this.labelText_.updateMetrics();
        this.labelText_.x = WIDTH / 2 - this.labelText_.width / 2;
        this.labelText_.y = HEIGHT / 2 - this.labelText_.height / 2 - 2;
        this.drawBackground();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/KeyMapper.as">
package com.company.assembleegameclient.ui.options {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.util.MoreColorUtil;

import flash.events.Event;

public class KeyMapper extends Option {


    private var keyCodeBox_:KeyCodeBox;

    private var disabled_:Boolean;

    public function KeyMapper(paramName:String, desc:String, tooltipText:String, disabled:Boolean = false) {
        super(paramName, desc, tooltipText);
        this.keyCodeBox_ = new KeyCodeBox(Parameters.data_[paramName_]);
        this.keyCodeBox_.addEventListener(Event.CHANGE, this.onChange);
        addChild(this.keyCodeBox_);
        this.setDisabled(disabled);
    }

    public function setDisabled(disabled:Boolean):void {
        this.disabled_ = disabled;
        transform.colorTransform = this.disabled_ ? MoreColorUtil.darkCT : MoreColorUtil.identity;
        mouseEnabled = !this.disabled_;
        mouseChildren = !this.disabled_;
    }

    override public function refresh():void {
        this.keyCodeBox_.setKeyCode(Parameters.data_[paramName_]);
    }

    private function onChange(event:Event):void {
        Parameters.setKey(paramName_, this.keyCodeBox_.value());
        Parameters.save();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/OptionsTabTitle.as">
package com.company.assembleegameclient.ui.options {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

public class OptionsTabTitle extends Sprite {

    private static const TEXT_SIZE:int = 16;


    public var text_:String;

    protected var textText_:SimpleText;

    protected var selected_:Boolean;

    public function OptionsTabTitle(text:String) {
        super();
        this.text_ = text;
        this.textText_ = new SimpleText(TEXT_SIZE, 11776947, false, 0, 0);
        this.textText_.setBold(true);
        this.textText_.text = this.text_;
        this.textText_.updateMetrics();
        this.textText_.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addChild(this.textText_);
        this.selected_ = false;
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    public function setSelected(selected:Boolean):void {
        this.selected_ = selected;
        this.redraw(false);
    }

    private function onMouseOver(event:MouseEvent):void {
        this.redraw(true);
    }

    private function onRollOut(event:MouseEvent):void {
        this.redraw(false);
    }

    private function redraw(over:Boolean):void {
        this.textText_.setSize(TEXT_SIZE).setColor(this.getColor(over));
    }

    private function getColor(isOver:Boolean):uint {
        if (this.selected_) {
            return 16762880;
        }
        return isOver ? uint(16777215) : uint(11776947);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/GiftChestPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.GiftChest;

import svera.untiered.storage.GiftWindow;

public class GiftChestPanel extends Panel {

    private var window_:GiftWindow;

    public function GiftChestPanel(go:GiftChest, gs:GameSprite) {
        super(gs);

        this.window_ = new GiftWindow(go, gs.map.player_);
        gs.addChild(this.window_);
    }

    public override function onRemoved():void {
        this.window_.dispose();
        this.gs_.removeChild(this.window_);

        this.window_ = null;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/InteractPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.IInteractiveObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;

import flash.display.Sprite;
import flash.events.Event;

public class InteractPanel extends Sprite {

    public static const MAX_DIST:Number = 1;


    public var gs_:GameSprite;

    public var player_:Player;

    public var w_:int;

    public var h_:int;

    public var currentPanel:Panel = null;

    public var currObj_:IInteractiveObject = null;

    public var partyPanel_:PartyPanel;

    private var overridePanel_:Panel;

    public var requestInteractive:Function;

    public function InteractPanel(gs:GameSprite, player:Player, w:int, h:int) {
        super();
        this.gs_ = gs;
        this.player_ = player;
        this.w_ = w;
        this.h_ = h;
        this.partyPanel_ = new PartyPanel(gs);
    }

    public function setOverride(panel:Panel):void {
        if (this.overridePanel_ != null) {
            this.overridePanel_.removeEventListener(Event.COMPLETE, this.onComplete);
        }
        this.overridePanel_ = panel;
        this.overridePanel_.addEventListener(Event.COMPLETE, this.onComplete);
    }

    public function removeOverride():void {
        if (this.overridePanel_)
            this.onComplete(new Event(Event.COMPLETE));
    }


    public function redraw():void {
        this.currentPanel.draw();
    }

    public function draw():void {
        var closestInteractive:IInteractiveObject = null;
        var panel:Panel = null;
        if (this.overridePanel_ != null) {
            this.setPanel(this.overridePanel_);
            this.currentPanel.draw();
            return;
        }
        closestInteractive = this.requestInteractive();
        if (this.currentPanel == null || closestInteractive != this.currObj_) {
            this.currObj_ = closestInteractive;
            panel = this.currObj_ != null ? this.currObj_.getPanel(this.gs_) : this.partyPanel_;
            this.setPanel(panel);
        }
        this.currentPanel.draw();
    }

    private function onComplete(event:Event):void {
        if (this.overridePanel_ != null) {
            this.overridePanel_.removeEventListener(Event.COMPLETE, this.onComplete);
            this.overridePanel_ = null;
        }
        this.setPanel(null);
        this.draw();
    }

    public function setPanel(panel:Panel):void {
        if (panel != this.currentPanel) {
            this.currentPanel && removeChild(this.currentPanel);
            this.currentPanel && this.currentPanel.onRemoved();
            this.currentPanel = panel;
            this.currentPanel && this.positionPanelAndAdd();
        }
    }

    private function positionPanelAndAdd():void {
        if (this.currentPanel is ItemGrid) {
            this.currentPanel.x = (this.w_ - this.currentPanel.width) * 0.5;
            this.currentPanel.y = 8;
        } else {
            this.currentPanel.x = 6;
            this.currentPanel.y = 8;
        }
        addChild(this.currentPanel);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/Panel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;

import flash.display.Sprite;

public class Panel extends Sprite {

    public static const WIDTH:int = 200 - 12;

    public static const HEIGHT:int = 100 - 16;


    public var gs_:GameSprite;

    public function Panel(gs:GameSprite) {
        super();
        this.gs_ = gs;
    }

    public function draw():void {
    }

    public function onRemoved():void {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/PartyPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Party;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.assembleegameclient.ui.menu.PlayerMenu;
import com.company.assembleegameclient.ui.tooltip.PlayerToolTip;
import com.company.util.MoreColorUtil;

import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;
import flash.utils.getTimer;

public class PartyPanel extends Panel {


    public var memberPanels_:Vector.<GameObjectListItem>;

    private var toolTip_:PlayerToolTip = null;

    private var menu_:PlayerMenu = null;

    private var mouseOver_:Boolean = false;

    public function PartyPanel(gs:GameSprite) {
        this.memberPanels_ = new Vector.<GameObjectListItem>(Party.NUM_MEMBERS, true);
        super(gs);
        this.memberPanels_[0] = this.createPartyMemberPanel(0, 0);
        this.memberPanels_[1] = this.createPartyMemberPanel(100, 0);
        this.memberPanels_[2] = this.createPartyMemberPanel(0, 32);
        this.memberPanels_[3] = this.createPartyMemberPanel(100, 32);
        this.memberPanels_[4] = this.createPartyMemberPanel(0, 64);
        this.memberPanels_[5] = this.createPartyMemberPanel(100, 64);
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private function createPartyMemberPanel(xPos:int, yPos:int):GameObjectListItem {
        var pmp:GameObjectListItem;
        pmp = new GameObjectListItem(16777215, false, null);
        addChild(pmp);
        pmp.x = xPos;
        pmp.y = yPos;
        return pmp;
    }

    private function onAddedToStage(event:Event):void {
        var pmp:GameObjectListItem = null;
        for each(pmp in this.memberPanels_) {
            pmp.addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
            pmp.addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
            pmp.addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        }
    }

    private function onRemovedFromStage(event:Event):void {
        var pmp:GameObjectListItem = null;
        this.removeTooltip();
        this.removeMenu();
        for each(pmp in this.memberPanels_) {
            pmp.removeEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
            pmp.removeEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
            pmp.removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
        }
    }

    private function onMouseOver(event:MouseEvent):void {
        this.removeTooltip();
        if (this.menu_ != null && this.menu_.parent != null) {
            return;
        }
        var pmp:GameObjectListItem = event.target as GameObjectListItem;
        var player:Player = pmp.go_ as Player;
        if (player == null || player.texture_ == null) {
            return;
        }
        this.toolTip_ = new PlayerToolTip(player);
        stage.addChild(this.toolTip_);
        this.mouseOver_ = true;
    }

    private function onMouseOut(event:MouseEvent):void {
        this.removeTooltip();
        this.mouseOver_ = false;
    }

    private function onMouseDown(event:MouseEvent):void {
        this.removeTooltip();
        this.removeMenu();
        var pmp:GameObjectListItem = event.target as GameObjectListItem;
        this.menu_ = new PlayerMenu(gs_, pmp.go_ as Player);
        stage.addChild(this.menu_);
    }

    private function removeTooltip():void {
        if (this.toolTip_ != null) {
            if (this.toolTip_.parent != null) {
                this.toolTip_.parent.removeChild(this.toolTip_);
            }
            this.toolTip_ = null;
        }
    }

    private function removeMenu():void {
        if (this.menu_ != null) {
            if (this.menu_.parent != null) {
                this.menu_.parent.removeChild(this.menu_);
            }
            this.menu_ = null;
        }
    }

    override public function draw():void {
        var memberPanel:GameObjectListItem = null;
        var player:Player = null;
        var ct:ColorTransform = null;
        var rv:Number = NaN;
        var c:int = 0;
        var party:Party = gs_.map.party_;
        if (party == null) {
            for each(memberPanel in this.memberPanels_) {
                memberPanel.draw(null);
            }
            return;
        }
        var time:int = 0;
        for (var i:int = 0; i < Party.NUM_MEMBERS; i++) {
            if (this.mouseOver_ || this.menu_ != null && this.menu_.parent != null) {
                player = this.memberPanels_[i].go_ as Player;
            } else {
                player = party.members_[i];
            }
            if (player != null && player.map_ == null) {
                player = null;
            }
            ct = null;
            if (player != null) {
                if (player.hp_ < player.maxHP_ * 0.2) {
                    if (time == 0) {
                        time = getTimer();
                    }
                    rv = int(Math.abs(Math.sin(time / 200)) * 10) / 10;
                    c = 128;
                    ct = new ColorTransform(1, 1, 1, 1, rv * c, -rv * c, -rv * c);
                }
                if (!player.starred_) {
                    if (ct != null) {
                        ct.concat(MoreColorUtil.darkCT);
                    } else {
                        ct = MoreColorUtil.darkCT;
                    }
                }
            }
            this.memberPanels_[i].draw(player, ct);
        }
        if (this.toolTip_ != null) {
            this.toolTip_.draw();
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/VaultChestPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.VaultChest;

import svera.untiered.storage.VaultWindow;

public class VaultChestPanel extends Panel {

    private var window_:VaultWindow;

    public function VaultChestPanel(go:VaultChest, gs:GameSprite) {
        super(gs);
        this.window_ = new VaultWindow(go, gs.map.player_);
        this.gs_.addChild(this.window_);
    }

    override public function onRemoved():void {
        this.window_.dispose();
        this.gs_.removeChild(this.window_);

        this.window_ = null;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/Scrollbar.as">
package com.company.assembleegameclient.ui {
import com.company.util.GraphicsUtil;

import flash.display.Graphics;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;
import flash.geom.Rectangle;
import flash.utils.getTimer;

public class Scrollbar extends Sprite {
    private var width_:int;
    private var height_:int;
    private var speed_:Number;
    private var indicatorRect_:Rectangle;
    private var jumpDist_:Number;
    private var background_:Sprite;
    private var upArrow_:Sprite;
    private var downArrow_:Sprite;
    private var posIndicator_:Sprite;
    private var lastUpdateTime_:int;
    private var change_:Number;
    private var backgroundFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);
    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[backgroundFill_, path_, GraphicsUtil.END_FILL];

    public function Scrollbar(widthParam:int, heightParam:int, speed:Number = 1.0) {
        super();
        this.background_ = new Sprite();
        this.background_.addEventListener(MouseEvent.MOUSE_DOWN, this.onBackgroundDown);
        addChild(this.background_);
        this.upArrow_ = this.getSprite(this.onUpArrowDown);
        addChild(this.upArrow_);
        this.downArrow_ = this.getSprite(this.onDownArrowDown);
        addChild(this.downArrow_);
        this.posIndicator_ = this.getSprite(this.onStartIndicatorDrag);
        addChild(this.posIndicator_);
        this.resize(widthParam, heightParam, speed);
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private static function drawArrow(w:int, h:int, g:Graphics):void {
        g.clear();
        g.beginFill(3487029, 0.01);
        g.drawRect(-w / 2, -h / 2, w, h);
        g.endFill();
        g.beginFill(16777215, 1);
        g.moveTo(-w / 2, -h / 2);
        g.lineTo(w / 2, 0);
        g.lineTo(-w / 2, h / 2);
        g.lineTo(-w / 2, -h / 2);
        g.endFill();
    }

    protected function onAddedToStage(event:Event):void {
        parent.addEventListener(MouseEvent.MOUSE_WHEEL, this.onMouseWheel);
    }

    protected function onRemovedFromStage(event:Event):void {
        parent.removeEventListener(MouseEvent.MOUSE_WHEEL, this.onMouseWheel);
        removeEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        removeEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    protected function onMouseWheel(event:MouseEvent):void {
        if (event.delta > 0) {
            this.jumpUp(0.2);
        } else {
            if (event.delta < 0) {
                this.jumpDown(0.2);
            }
        }
    }

    public function pos():Number {
        return (this.posIndicator_.y - this.indicatorRect_.y) / (this.indicatorRect_.height - this.posIndicator_.height);
    }

    public function setIndicatorSize(windowHeight:Number, totalHeight:Number, doSetPos:Boolean = true):void {
        var h:int = totalHeight == 0 ? int(this.indicatorRect_.height) : int(windowHeight / totalHeight * this.indicatorRect_.height);
        h = Math.min(this.indicatorRect_.height, Math.max(this.width_, h));
        this.drawIndicator(this.width_, h, this.posIndicator_.graphics);
        this.jumpDist_ = windowHeight / (totalHeight - windowHeight);
        if (doSetPos) {
            this.setPos(0);
        }
    }

    public function setPos(v:Number):void {
        v = Math.max(0, Math.min(1, v));
        this.posIndicator_.y = v * (this.indicatorRect_.height - this.posIndicator_.height) + this.indicatorRect_.y;
        this.sendPos();
    }

    public function jumpUp(mult:Number):void {
        this.setPos(this.pos() - this.jumpDist_ * mult);
    }

    public function jumpDown(mult:Number):void {
        this.setPos(this.pos() + this.jumpDist_ * mult);
    }

    private function getSprite(downFunction:Function):Sprite {
        var sprite:Sprite = new Sprite();
        sprite.addEventListener(MouseEvent.MOUSE_DOWN, downFunction);
        sprite.addEventListener(MouseEvent.ROLL_OVER, this.onRollOver);
        sprite.addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        return sprite;
    }

    private function onRollOver(event:MouseEvent):void {
        var sprite:Sprite = event.target as Sprite;
        sprite.transform.colorTransform = new ColorTransform(1, 0.8627, 0.5216);
    }

    private function onRollOut(event:MouseEvent):void {
        var sprite:Sprite = event.target as Sprite;
        sprite.transform.colorTransform = new ColorTransform(1, 1, 1);
    }

    private function onBackgroundDown(event:MouseEvent):void {
        if (event.localY < this.posIndicator_.y) {
            this.jumpUp(1);
        } else {
            this.jumpDown(1);
        }
    }

    private function onUpArrowDown(event:MouseEvent):void {
        addEventListener(Event.ENTER_FRAME, this.onArrowFrame);
        addEventListener(MouseEvent.MOUSE_UP, this.onArrowUp);
        this.lastUpdateTime_ = getTimer();
        this.change_ = -this.speed_;
    }

    private function onDownArrowDown(event:MouseEvent):void {
        addEventListener(Event.ENTER_FRAME, this.onArrowFrame);
        addEventListener(MouseEvent.MOUSE_UP, this.onArrowUp);
        this.lastUpdateTime_ = getTimer();
        this.change_ = this.speed_;
    }

    private function onArrowFrame(event:Event):void {
        var time:int = getTimer();
        var dt:Number = (time - this.lastUpdateTime_) / 1000;
        var dist:int = (this.height_ - this.width_ * 3) * dt * this.change_;
        this.setPos((this.posIndicator_.y + dist - this.indicatorRect_.y) / (this.indicatorRect_.height - this.posIndicator_.height));
        this.lastUpdateTime_ = time;
    }

    private function onArrowUp(event:Event):void {
        removeEventListener(Event.ENTER_FRAME, this.onArrowFrame);
        removeEventListener(MouseEvent.MOUSE_UP, this.onArrowUp);
    }

    private function onStartIndicatorDrag(event:MouseEvent):void {
        this.posIndicator_.startDrag(false, new Rectangle(0, this.indicatorRect_.y, 0, this.indicatorRect_.height - this.posIndicator_.height));
        stage.addEventListener(MouseEvent.MOUSE_UP, this.onStopIndicatorDrag);
        stage.addEventListener(MouseEvent.MOUSE_MOVE, this.onDragMove);
        this.sendPos();
    }

    private function onStopIndicatorDrag(event:MouseEvent):void {
        stage.removeEventListener(MouseEvent.MOUSE_UP, this.onStopIndicatorDrag);
        stage.removeEventListener(MouseEvent.MOUSE_MOVE, this.onDragMove);
        this.posIndicator_.stopDrag();
        this.sendPos();
    }

    private function onDragMove(event:MouseEvent):void {
        this.sendPos();
    }

    private function sendPos():void {
        dispatchEvent(new Event(Event.CHANGE));
    }

    public function resize(widthParam:int, heightParam:int, speed:Number = 1.0):void {
        this.width_ = widthParam;
        this.height_ = heightParam;
        this.speed_ = speed;
        var arrowHeight:int = this.width_ * 0.75;
        this.indicatorRect_ = new Rectangle(0, arrowHeight + 5, this.width_, this.height_ - arrowHeight * 2 - 10);
        var g:Graphics = this.background_.graphics;
        g.clear();
        g.beginFill(5526612, 1);
        g.drawRect(this.indicatorRect_.x, this.indicatorRect_.y, this.indicatorRect_.width, this.indicatorRect_.height);
        g.endFill();
        drawArrow(arrowHeight, this.width_, this.upArrow_.graphics);
        this.upArrow_.rotation = -90;
        this.upArrow_.x = this.width_ / 2;
        this.upArrow_.y = arrowHeight / 2;
        drawArrow(arrowHeight, this.width_, this.downArrow_.graphics);
        this.downArrow_.x = this.width_ / 2;
        this.downArrow_.y = this.height_ - arrowHeight / 2;
        this.downArrow_.rotation = 90;
        this.drawIndicator(this.width_, this.height_, this.posIndicator_.graphics);
        this.posIndicator_.x = 0;
        this.posIndicator_.y = this.indicatorRect_.y;
    }

    private function drawIndicator(w:int, h:int, g:Graphics):void {
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, w, h, 4, [1, 1, 1, 1], this.path_);
        g.clear();
        g.drawGraphicsData(this.graphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/Slot.as">
package com.company.assembleegameclient.ui {
import com.company.ui.SimpleText;
import com.company.util.AssetLibrary;
import com.company.util.GraphicsUtil;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.display.Sprite;
import flash.filters.ColorMatrixFilter;
import flash.geom.Matrix;
import flash.geom.Point;

public class Slot extends Sprite {

    public static const ALL_TYPE:int = 0;

    public static const SWORD_TYPE:int = 1;

    public static const DAGGER_TYPE:int = 2;

    public static const BOW_TYPE:int = 3;

    public static const TOME_TYPE:int = 4;

    public static const SHIELD_TYPE:int = 5;

    public static const LEATHER_TYPE:int = 6;

    public static const PLATE_TYPE:int = 7;

    public static const WAND_TYPE:int = 8;

    public static const RING_TYPE:int = 9;

    public static const POTION_TYPE:int = 10;

    public static const SPELL_TYPE:int = 11;

    public static const SEAL_TYPE:int = 12;

    public static const CLOAK_TYPE:int = 13;

    public static const ROBE_TYPE:int = 14;

    public static const QUIVER_TYPE:int = 15;

    public static const HELM_TYPE:int = 16;

    public static const STAFF_TYPE:int = 17;

    public static const POISON_TYPE:int = 18;

    public static const SKULL_TYPE:int = 19;

    public static const TRAP_TYPE:int = 20;

    public static const ORB_TYPE:int = 21;

    public static const PRISM_TYPE:int = 22;

    public static const SCEPTER_TYPE:int = 23;

    public static const KATANA_TYPE:int = 24;

    public static const SHURIKEN_TYPE:int = 25;

    public static const WIDTH:int = 40;

    public static const HEIGHT:int = 40;

    public static const BORDER:int = 4;

    private static const greyColorFilter:ColorMatrixFilter = new ColorMatrixFilter(MoreColorUtil.singleColorFilterMatrix(3552822));


    public var type_:int;

    public var hotkey_:int;

    public var cuts_:Array;

    public var backgroundImage_:Bitmap;

    protected var fill_:GraphicsSolidFill;

    protected var path_:GraphicsPath;

    private var graphicsData_:Vector.<IGraphicsData>;

    public function Slot(type:int, hotkey:int, cuts:Array) {
        this.fill_ = new GraphicsSolidFill(5526612, 1);
        this.path_ = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        this.graphicsData_ = new <IGraphicsData>[this.fill_, this.path_, GraphicsUtil.END_FILL];
        super();
        this.type_ = type;
        this.hotkey_ = hotkey;
        this.cuts_ = cuts;
        this.drawBackground();
    }

    public static function slotTypeToName(type:int):String {
        switch (type) {
            case ALL_TYPE:
                return "Any";
            case SWORD_TYPE:
                return "Sword";
            case DAGGER_TYPE:
                return "Dagger";
            case BOW_TYPE:
                return "Bow";
            case TOME_TYPE:
                return "Tome";
            case SHIELD_TYPE:
                return "Shield";
            case LEATHER_TYPE:
                return "Leather Armor";
            case PLATE_TYPE:
                return "Armor";
            case WAND_TYPE:
                return "Wand";
            case RING_TYPE:
                return "Accessory";
            case POTION_TYPE:
                return "Potion";
            case SPELL_TYPE:
                return "Spell";
            case SEAL_TYPE:
                return "Holy Seal";
            case CLOAK_TYPE:
                return "Cloak";
            case ROBE_TYPE:
                return "Robe";
            case QUIVER_TYPE:
                return "Quiver";
            case HELM_TYPE:
                return "Helm";
            case STAFF_TYPE:
                return "Staff";
            case POISON_TYPE:
                return "Poison";
            case SKULL_TYPE:
                return "Skull";
            case TRAP_TYPE:
                return "Trap";
            case ORB_TYPE:
                return "Orb";
            case PRISM_TYPE:
                return "Prism";
            case SCEPTER_TYPE:
                return "Scepter";
            case KATANA_TYPE:
                return "Katana";
            case SHURIKEN_TYPE:
                return "Shuriken";
            default:
                return "Invalid Type!";
        }
    }

    protected function offsets(objectType:int, type:int, back:Boolean):Point {
        var p:Point = new Point();
        switch (type) {
            case RING_TYPE:
                p.x = objectType == 2878 ? Number(0) : Number(-2);
                p.y = back ? Number(-2) : Number(0);
                break;
            case SPELL_TYPE:
                p.y = -2;
        }
        return p;
    }

    protected function drawBackground():void {
        var offset:Point = null;
        var tempText:SimpleText = null;
        var m:Matrix = null;
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, WIDTH, HEIGHT, 4, this.cuts_, this.path_);
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData_);
        var bd:BitmapData = null;
        var dx:int = 0;
        var dy:int = 0;
        switch (this.type_) {
            case ALL_TYPE:
                break;
            case SWORD_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 48);
                break;
            case DAGGER_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 96);
                break;
            case BOW_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 80);
                break;
            case TOME_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 80);
                break;
            case SHIELD_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 112);
                break;
            case LEATHER_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 0);
                break;
            case PLATE_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 32);
                break;
            case WAND_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 64);
                break;
            case RING_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj", 44);
                break;
            case SPELL_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 64);
                break;
            case SEAL_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 160);
                break;
            case CLOAK_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 32);
                break;
            case ROBE_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 16);
                break;
            case QUIVER_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 48);
                break;
            case HELM_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 96);
                break;
            case STAFF_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj5", 112);
                break;
            case POISON_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 128);
                break;
            case SKULL_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 0);
                break;
            case TRAP_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 16);
                break;
            case ORB_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 144);
                break;
            case PRISM_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 176);
                break;
            case SCEPTER_TYPE:
                bd = AssetLibrary.getImageFromSet("lofiObj6", 192);
        }
        if (this.backgroundImage_ == null) {
            if (bd != null) {
                offset = this.offsets(-1, this.type_, true);
                this.backgroundImage_ = new Bitmap(bd);
                this.backgroundImage_.x = BORDER + offset.x;
                this.backgroundImage_.y = BORDER + offset.y;
                this.backgroundImage_.scaleX = 4;
                this.backgroundImage_.scaleY = 4;
                this.backgroundImage_.filters = [greyColorFilter];
                addChild(this.backgroundImage_);
            } else if (this.hotkey_ > 0) {
                tempText = new SimpleText(26, 3552822, false, 0, 0);
                tempText.text = String(this.hotkey_);
                tempText.setBold(true);
                tempText.updateMetrics();
                bd = new BitmapData(26, 30, true, 0);
                m = new Matrix();
                bd.draw(tempText, m);
                this.backgroundImage_ = new Bitmap(bd);
                this.backgroundImage_.x = WIDTH / 2 - tempText.width / 2;
                this.backgroundImage_.y = HEIGHT / 2 - 18;
                addChild(this.backgroundImage_);
            }
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/StatusBar.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.objects.Player;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.filters.DropShadowFilter;

public class StatusBar extends Sprite {
    public var w_:int;

    public var h_:int;

    public var color_:uint;

    public var backColor_:uint;

    public var pulseBackColor:uint;

    public var textColor_:uint;

    public var val_:int = -1;

    public var max_:int = -1;

    public var boost_:int = -1;

    public var maxMax_:int = -1;

    public var stat:int = -1;

    public var labelText_:SimpleText;

    public var valueText_:SimpleText;

    public var boostText_:SimpleText;

    private var colorSprite:Sprite;

    private var defaultForegroundColor:Number;

    private var defaultBackgroundColor:Number;

    private var repetitions:int;

    private var direction:int = -1;

    private var speed:Number = 0.1;

    private var player:Player;

    public function StatusBar(w:int, h:int, color:uint, backColor:uint, label:String = null, labelColor:uint = 16777215) {
        this.colorSprite = new Sprite();
        super();
        addChild(this.colorSprite);
        this.w_ = w;
        this.h_ = h;
        this.defaultForegroundColor = this.color_ = color;
        this.defaultBackgroundColor = this.backColor_ = backColor;
        this.textColor_ = 16777215;
        var valueColor:uint = 16777215;
        if (labelColor != this.textColor_ || labelColor != valueColor) {
            this.textColor_ = labelColor;
            valueColor = labelColor;
        }
        if (label != null && label.length != 0) {
            this.labelText_ = new SimpleText(14, labelColor != this.textColor_ ? labelColor : this.textColor_, false, 0, 0);
            this.labelText_.setBold(true);
            this.labelText_.text = label;
            this.labelText_.y = -3;
            this.labelText_.filters = [new DropShadowFilter(0, 0, 0, 1.0, 1.5, 1.5, 255)];
            this.labelText_.updateMetrics();
            addChild(this.labelText_);
        }
        this.valueText_ = new SimpleText(14, valueColor, false, 0, 0);
        this.valueText_.setBold(true);
        this.valueText_.filters = [new DropShadowFilter(0, 0, 0, 1.0, 1.5, 1.5, 255)];
        this.valueText_.y = -3;
        this.boostText_ = new SimpleText(14, this.textColor_, false, 0, 0);
        this.boostText_.setBold(true);
        this.boostText_.alpha = 0.6;
        this.boostText_.y = this.valueText_.y;
        this.boostText_.filters = [new DropShadowFilter(0, 0, 0, 1.0, 1.5, 1.5, 255)];
    }

    public function draw(val:int, max:int, boost:int, maxMax:int = -1):void {
        if (max > 0) {
            val = Math.min(max, Math.max(0, val));
        }
        if (val == this.val_ && max == this.max_ && boost == this.boost_ && maxMax == this.maxMax_) {
            return;
        }
        this.val_ = val;
        this.max_ = max;
        this.boost_ = boost;
        this.maxMax_ = maxMax;
        this.stat = stat;
        if (player != null)
            this.player = player;
        this.internalDraw();
    }

    private function setTextColor(textColor:uint):void {
        this.textColor_ = textColor;
        if (this.boostText_ != null) {
            this.boostText_.setColor(this.textColor_);
        }
        this.valueText_.setColor(this.textColor_);
    }

    private function internalDraw():void {
        graphics.clear();
        this.colorSprite.graphics.clear();
        var textColor:uint = 16777215;
        if (this.maxMax_ > 0 && this.max_ - this.boost_ == this.maxMax_) {
            textColor = 16572160;
        } else if (this.boost_ > 0) {
            textColor = 6206769;
        }
        if (this.textColor_ != textColor) {
            this.setTextColor(textColor);
        }
        if (color_ != 16777215) {
            graphics.beginFill(this.backColor_);
            graphics.drawRect(0, 0, this.w_, this.h_);
            graphics.endFill();
        }
        this.colorSprite.graphics.beginFill(this.color_);
        if (this.max_ > 0) {
            this.colorSprite.graphics.drawRect(0, 0, this.w_ * (this.val_ / this.max_), this.h_);
        } else {
            this.colorSprite.graphics.drawRect(0, 0, this.w_, this.h_);
        }
        this.colorSprite.graphics.endFill();
        if (this.max_ > 0) {
            this.valueText_.text = "" + NumberFormat(this.val_) + "/" + NumberFormat(this.max_);
        } else {
            this.valueText_.text = "" + NumberFormat(this.val_);
        }
        this.valueText_.updateMetrics();
        if (!contains(this.valueText_)) {
            addChild(this.valueText_);
        }
        if (this.boost_ != 0) {
            this.boostText_.text = " (" + (this.boost_ > 0 ? "+" : "") + NumberFormat(this.boost_) + ")";
            this.boostText_.updateMetrics();
            this.valueText_.x = this.w_ / 2 - (this.valueText_.width + this.boostText_.width) / 2;
            this.boostText_.x = this.valueText_.x + this.valueText_.width;
            if (!contains(this.boostText_)) {
                addChild(this.boostText_);
            }
        } else {
            this.valueText_.x = this.w_ / 2 - this.valueText_.width / 2;
            if (contains(this.boostText_)) {
                removeChild(this.boostText_);
            }
        }
    }

    private static function NumberFormat(number:int):String {
        var suffix:Array = ["K", "M", "B", "T"];
        var size:int = number != 0 ? logx(number) : 0;
        if (size >= 3) {
            while (size % 3 != 0)
                size = size - 1;
        }
        var notation:Number = Math.pow(10, size);
        var result:* = size >= 3 ? +(Math.round((number / notation) * 100) / 100.0) + suffix[size / 3 - 1] : +number + "";
        return result;
    }

    private static function logx(val:Number, base:Number = 10):Number {
        return Math.log(val) / Math.log(base);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/TextBox.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.events.TimerEvent;
import flash.filters.GlowFilter;
import flash.text.TextField;
import flash.text.TextFieldType;
import flash.text.TextFormat;
import flash.text.engine.TextBlock;
import flash.text.engine.TextLine;
import flash.ui.Keyboard;
import flash.utils.Timer;
import flash.utils.getTimer;

import org.osflash.signals.natives.NativeSignal;

public class TextBox extends Sprite {

    private static const MAX_LINES:int = 10;

    private static const LINE_SCROLL:int = 3;

    private static const LINE_TIME:int = 20000;

    private static const INDENT:int = 20;

    private static const MIN_LINE_HEIGHT:int = 16;

    private static const LINE_SPACING:int = 0;

    private static const BLOCK_SPACING:int = 4;

    private static var lines_:Vector.<TextBoxLine> = new Vector.<TextBoxLine>(0);

    public static var isInputtingText:Boolean = false;


    private var gs_:GameSprite;

    private var w_:int;

    private var h_:int;

    public var textSprite_:Sprite;

    private var textSpriteYPos_:Number;

    private var inputField_:TextField;

    private var showMax_:Boolean = false;

    private var lc_:int = 0;

    private var tellers_:Array;

    private var currentTeller_:int = 0;

    private var timer_:Timer;

    private var isInputAllowed:Boolean = true;

    private var speechBubbleIcon_:Bitmap;

    private var speechBubbleContainer:Sprite;

    private var inputNotAllowedMessage:String;

    public var inputTextClicked:NativeSignal;

    public var speechBubbleClicked:NativeSignal;

    public function TextBox(gs:GameSprite, w:int, h:int) {
        this.tellers_ = [];
        this.timer_ = new Timer(1000);
        super();
        this.gs_ = gs;
        this.w_ = w;
        this.h_ = h;
        this.textSprite_ = new Sprite();
        this.textSprite_.x = 2;
        this.textSprite_.filters = [new GlowFilter(0, 1, 3, 3, 2, 1)];
        this.textSprite_.mouseEnabled = false;
        this.textSprite_.mouseChildren = false;
        addChild(this.textSprite_);
        var format:TextFormat = new TextFormat();
        format.font = "Myriad Pro";
        format.size = 14;
        format.color = 16777215;
        format.bold = true;
        this.inputField_ = new TextField();
        this.inputField_.embedFonts = true;
        this.inputField_.defaultTextFormat = format;
        this.inputField_.type = TextFieldType.INPUT;
        this.inputField_.border = true;
        this.inputField_.borderColor = 16777215;
        this.inputField_.maxChars = 128;
        this.inputField_.filters = [new GlowFilter(0, 1, 3, 3, 2, 1)];
        this.inputField_.addEventListener(KeyboardEvent.KEY_UP, this.onInputFieldKeyUp);
        this.inputField_.width = this.w_ - 2;
        this.inputField_.height = 18;
        this.inputNotAllowedMessage = "Please REGISTER to see in-game chat.";
        this.speechBubbleContainer = new Sprite();
        addChild(this.speechBubbleContainer);
        var bubbleBD:BitmapData = AssetLibrary.getImageFromSet("lofiInterfaceBig", 21);
        bubbleBD = TextureRedrawer.redraw(bubbleBD, 20, true, 0, false);
        this.speechBubbleIcon_ = new Bitmap(bubbleBD);
        this.speechBubbleIcon_.x = this.speechBubbleIcon_.x - 5;
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        this.inputTextClicked = new NativeSignal(this.inputField_, MouseEvent.CLICK, MouseEvent);
        this.speechBubbleClicked = new NativeSignal(this.speechBubbleContainer, MouseEvent.CLICK, MouseEvent);
    }

    public function setInputNotAllowedMessage(message:String):void {
        this.inputNotAllowedMessage = message;
    }

    public function setInputTextAllowed(isInputAllowed:Boolean):void {
        if (this.isInputAllowed != isInputAllowed) {
            this.isInputAllowed = isInputAllowed;
            if (isInputAllowed) {
                this.inputField_.border = true;
                this.inputField_.borderColor = 16777215;
                this.inputField_.type = TextFieldType.INPUT;
                this.inputField_.selectable = true;
                if (this.speechBubbleContainer.contains(this.speechBubbleIcon_)) {
                    this.speechBubbleContainer.removeChild(this.speechBubbleIcon_);
                }
                this.inputField_.x = this.inputField_.x - 29;
                this.inputField_.addEventListener(KeyboardEvent.KEY_UP, this.onInputFieldKeyUp);
                stage.addEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
                this.inputField_.text = "";
                removeChild(this.inputField_);
            } else {
                this.inputField_.border = false;
                this.inputField_.type = TextFieldType.DYNAMIC;
                this.inputField_.removeEventListener(KeyboardEvent.KEY_UP, this.onInputFieldKeyUp);
                this.inputField_.text = this.inputNotAllowedMessage;
                this.inputField_.x = this.inputField_.x + 29;
                this.inputField_.selectable = false;
                stage.removeEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
                addChild(this.inputField_);
                this.speechBubbleContainer.addChild(this.speechBubbleIcon_);
                this.placeTextField();
            }
        }
    }

    public function addText(name:String, text:String):void {
        var textBoxLine:TextBoxLine = new TextBoxLine(getTimer(), name, -1, -1, "", false, text);
        lines_.push(textBoxLine);
        this.refreshStatusBox();
    }

    public function addTextFull(name:String, objectId:int, numStars:int, recipient:String, text:String):void {
        var fromMe:Boolean = recipient != "" && name == this.gs_.model.getName();
        var toMe:Boolean = recipient == this.gs_.model.getName();
        var textBoxLine:TextBoxLine = new TextBoxLine(getTimer(), name, objectId, numStars, recipient, toMe, text);
        lines_.push(textBoxLine);
        this.refreshStatusBox();
        if (toMe) {
            if (this.tellers_.length == 0 || this.tellers_[this.tellers_.length - 1] != name) {
                this.tellers_.push(name);
            }
        } else if (recipient != Parameters.GUILD_CHAT_NAME) {
            if (fromMe) {
                if (this.tellers_.length == 0 || this.tellers_[this.tellers_.length - 1] != recipient) {
                    this.tellers_.push(recipient);
                }
            }
        }
    }

    private function onTimer(event:TimerEvent):void {
        this.refreshStatusBox();
    }

    private function clearTextSprite():void {
        while (this.textSprite_.numChildren > 0) {
            this.textSprite_.removeChildAt(0);
        }
        this.textSprite_.graphics.clear();
        this.textSpriteYPos_ = 0;
    }

    private function addTextBlock(textBlock:TextBlock):void {
        var blockSprite:Sprite;
        blockSprite = new Sprite();
        var textLine:TextLine = null;
        var yPos:Number = 0;

//         textLine = textBlock.createTextLine(textLine,yPos == 0?Number(this.w_ - 4):Number(this.w_ - 4 - INDENT));
//         textLine.x = yPos == 0?Number(0):Number(INDENT);
//         textLine.y = textLine.ascent + yPos;
//         yPos = yPos + Math.max(MIN_LINE_HEIGHT,textLine.height);
//         blockSprite.addChild(textLine);

        while (textLine = textBlock.createTextLine(textLine, yPos == 0 ? Number(this.w_ - 4) : Number(this.w_ - 4 - INDENT))) {
            textLine.x = yPos == 0 ? Number(0) : Number(INDENT);
            textLine.y = textLine.ascent + yPos;
            yPos = yPos + Math.max(MIN_LINE_HEIGHT, textLine.height);
            blockSprite.addChild(textLine);
        }
        if (this.textSpriteYPos_ != 0) {
            this.textSpriteYPos_ = this.textSpriteYPos_ + BLOCK_SPACING;
        }
        blockSprite.y = this.textSpriteYPos_;
        this.textSprite_.addChild(blockSprite);
        this.textSpriteYPos_ = this.textSpriteYPos_ + yPos;
    }

    private function refreshStatusBox():void {
        var line:TextBoxLine = null;
        var textBlock:TextBlock = null;
        this.clearTextSprite();
        var now:int = getTimer();
        var startL:int = Math.max(0, lines_.length - 1 - this.lc_ - MAX_LINES);
        var endL:int = Math.min(lines_.length, startL + MAX_LINES + 1);
        for (var l:int = startL; l < endL; l++) {
            line = lines_[l];
            if (!(!this.showMax_ && now > line.time_ + 20000)) {
                textBlock = line.getTextBlock();
                this.addTextBlock(textBlock);
            }
        }
        this.placeTextField();
    }

    private function onAddedToStage(event:Event):void {
        var yMod:uint;
        if (this.isInputAllowed) {
            stage.addEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
            yMod = 20;
        } else {
            yMod = 25;
        }
        this.inputField_.y = this.h_ - yMod;
        this.speechBubbleIcon_.y = this.inputField_.y - 8;
        this.placeTextField();
        this.timer_.addEventListener(TimerEvent.TIMER, this.onTimer);
        this.timer_.start();
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
        this.timer_.stop();
        this.timer_.removeEventListener(TimerEvent.TIMER, this.onTimer);
    }

    private function onKeyUp(event:KeyboardEvent):void {
        switch (event.keyCode) {
            case Parameters.data_.chatCommand:
                if (stage.focus == null) {
                    this.selectInput();
                    this.inputField_.text = "/";
                    this.inputField_.setSelection(this.inputField_.length, this.inputField_.length);
                }
                break;
            case Parameters.data_.chat:
                if (stage.focus == null) {
                    this.selectInput();
                }
                break;
            case Parameters.data_.tell:
                if (stage.focus == null) {
                    this.selectInput();
                }
                this.insertTellPrefix(event.shiftKey);
                break;
            case Parameters.data_.guildChat:
                if (stage.focus == null) {
                    this.selectInput();
                    this.inputField_.text = "/g ";
                    this.inputField_.setSelection(this.inputField_.length, this.inputField_.length);
                }
                break;
            case Parameters.data_.scrollChatUp:
                if (!this.showMax_) {
                    this.showMax_ = true;
                } else {
                    this.lc_ = Math.max(0, Math.min(lines_.length - LINE_SCROLL, this.lc_ + LINE_SCROLL));
                }
                this.refreshStatusBox();
                break;
            case Parameters.data_.scrollChatDown:
                if (this.lc_ == 0) {
                    this.showMax_ = false;
                } else {
                    this.lc_ = Math.max(0, this.lc_ - LINE_SCROLL);
                }
                this.refreshStatusBox();
        }
    }

    private function insertTellPrefix(backward:Boolean):void {
        this.inputField_.text = "/tell ";
        if (this.tellers_.length != 0) {
            if (backward) {
                this.currentTeller_++;
            } else {
                this.currentTeller_--;
            }
            if (this.currentTeller_ <= 0) {
                this.currentTeller_ = 0;
            }
            if (this.currentTeller_ >= this.tellers_.length) {
                this.currentTeller_ = this.tellers_.length - 1;
            }
            this.inputField_.appendText(this.tellers_[this.currentTeller_] + " ");
        }
        this.inputField_.setSelection(this.inputField_.length, this.inputField_.length);
    }

    private function onInputFieldKeyUp(event:KeyboardEvent):void {
        switch (event.keyCode) {
            case Keyboard.ENTER:
                var regex:RegExp = /[\s\r\n]+/gim;
                this.inputField_.text = this.inputField_.text.replace(regex, ' ');
                regex = /^\s*|\s*$/gim;
                this.inputField_.text = this.inputField_.text.replace(regex, '');
                if (this.inputField_.text.length != 0) {
                    if (this.gs_.map.player_ != null) {
                        this.gs_.gsc_.playerText(this.inputField_.text);
                    }
                    this.inputField_.text = "";
                }
                this.unselectInput();
                event.stopImmediatePropagation();
        }
    }

    private function selectInput():void {
        this.inputField_.type = TextFieldType.INPUT;
        this.inputField_.border = true;
        this.inputField_.borderColor = 16777215;
        TextBox.isInputtingText = true;
        addChild(this.inputField_);
        if (stage != null) {
            stage.focus = this.inputField_;
        }
        this.placeTextField();
        this.currentTeller_ = this.tellers_.length;
    }

    private function unselectInput():void {
        if (stage != null) {
            stage.focus = null;
        }
        if (contains(this.inputField_)) {
            TextBox.isInputtingText = false;
            removeChild(this.inputField_);
        }
        this.placeTextField();
    }

    private function placeTextField():void {
        if (contains(this.inputField_)) {
            this.textSprite_.y = this.h_ - 8 - this.inputField_.height - this.textSpriteYPos_;
        } else {
            this.textSprite_.y = this.h_ - 4 - this.textSpriteYPos_;
        }
    }

    public function onShowChatInput(text:String):void {
        this.inputField_.text = text;
        this.selectInput()
        this.inputField_.setSelection(this.inputField_.length, this.inputField_.length);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/TextBoxLine.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.HonorUtil;

import flash.display.Sprite;
import flash.text.engine.ContentElement;
import flash.text.engine.ElementFormat;
import flash.text.engine.GraphicElement;
import flash.text.engine.GroupElement;
import flash.text.engine.TextBlock;
import flash.text.engine.TextElement;

public class TextBoxLine {
    private static var ELEMENT_FORMATS:ElementFormats = new ElementFormats();

    public var time_:int;
    public var name_:String;
    public var rankIcon_:Sprite = null;
    public var recipient_:String;
    public var toMe_:Boolean;
    public var text_:String;

    public function TextBoxLine(time:int, name:String, objectId:int, numStars:int, recipient:String, toMe:Boolean, text:String) {
        super();
        this.time_ = time;
        this.name_ = name;
        if (numStars >= 0) {
            this.rankIcon_ = HonorUtil.numStarsToIcon(numStars);
        }
        this.recipient_ = recipient;
        this.toMe_ = toMe;
        this.text_ = text;
    }

    public function getTextBlock():TextBlock {
        var vec:Vector.<ContentElement> = new Vector.<ContentElement>(0);
        var nameFormat:ElementFormat = ELEMENT_FORMATS.playerFormat_;
        var sepFormat:ElementFormat = ELEMENT_FORMATS.sepFormat_;
        var textFormat:ElementFormat = ELEMENT_FORMATS.normalFormat_;
        var name:String = this.name_;
        switch (this.name_) {
            case Parameters.SERVER_CHAT_NAME:
                name = "";
                textFormat = ELEMENT_FORMATS.serverFormat_;
                break;
            case Parameters.CLIENT_CHAT_NAME:
                name = "";
                textFormat = ELEMENT_FORMATS.clientFormat_;
                break;
            case Parameters.HELP_CHAT_NAME:
                name = "";
                textFormat = ELEMENT_FORMATS.helpFormat_;
                break;
            case Parameters.ERROR_CHAT_NAME:
                textFormat = ELEMENT_FORMATS.errorFormat_;
                name = "";
        }
        if (this.name_.charAt(0) == "#") {
            name = this.name_.substr(1);
            nameFormat = ELEMENT_FORMATS.enemyFormat_;
        }
        if (this.name_.charAt(0) == "@") {
            name = this.name_.substr(1);
            nameFormat = ELEMENT_FORMATS.adminFormat_;
            textFormat = ELEMENT_FORMATS.adminFormat_;
        }
        if (this.recipient_ == Parameters.GUILD_CHAT_NAME) {
            textFormat = ELEMENT_FORMATS.guildFormat_;
        } else if (this.recipient_ != "") {
            textFormat = ELEMENT_FORMATS.tellFormat_;
            if (!this.toMe_) {
                vec.push(new TextElement("To: ", ELEMENT_FORMATS.normalFormat_));
                name = this.recipient_;
                this.rankIcon_ = null;
            }
        }
        if (this.rankIcon_ != null) {
            this.rankIcon_.y = 3;
            vec.push(new GraphicElement(this.rankIcon_, this.rankIcon_.width + 2, this.rankIcon_.height, ELEMENT_FORMATS.normalFormat_));
        }
        if (name != "") {
            vec.push(new TextElement("<" + name + ">", nameFormat), new TextElement(" ", sepFormat));
        }
        vec.push(new TextElement(this.text_, textFormat));
        var groupElement:GroupElement = new GroupElement(vec);
        return new TextBlock(groupElement);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/RankToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.ui.LineBreakDesign;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.StarGraphic;

import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

public class RankToolTip extends ToolTip {


    private var earnedText_:SimpleText;

    private var star_:StarGraphic;

    private var howToText_:SimpleText;

    private var lineBreak_:LineBreakDesign;

    private var legendLines_:Vector.<LegendLine>;

    public function RankToolTip(numStars:int) {
        var line:LegendLine = null;
        super(3552822, 1, 16777215, 1);
        this.earnedText_ = new SimpleText(13, 11776947, false, 0, 0);
        this.earnedText_.setBold(true);
        this.earnedText_.text = "You have earned " + numStars;
        this.earnedText_.updateMetrics();
        this.earnedText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.earnedText_.x = 6;
        this.earnedText_.y = 2;
        addChild(this.earnedText_);
        this.star_ = new StarGraphic();
        this.star_.transform.colorTransform = new ColorTransform(179 / 255, 179 / 255, 179 / 255);
        this.star_.x = this.earnedText_.width + 7;
        this.star_.y = this.earnedText_.y + 4;
        addChild(this.star_);
        this.howToText_ = new SimpleText(13, 11776947, false, 174, 0);
        this.howToText_.wordWrap = true;
        this.howToText_.multiline = true;
        this.howToText_.text = "You can earn more by completing Class Quests.";
        this.howToText_.updateMetrics();
        this.howToText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.howToText_.x = 6;
        this.howToText_.y = 30;
        addChild(this.howToText_);
        this.lineBreak_ = new LineBreakDesign(100, 1842204);
        this.lineBreak_.x = 6;
        this.lineBreak_.y = height + 10;
        addChild(this.lineBreak_);
        var yOffset:int = this.lineBreak_.y + 4;
        for (var i:int = 0; i < HonorUtil.COLORS.length; i++) {
            line = new LegendLine(i * ObjectLibrary.playerChars_.length, (i + 1) * ObjectLibrary.playerChars_.length - 1, HonorUtil.COLORS[i]);
            line.x = 6;
            line.y = yOffset;
            addChild(line);
            yOffset = yOffset + line.height;
        }
        line = new LegendLine(HonorUtil.maxStars(), HonorUtil.maxStars(), new ColorTransform());
        line.x = 6;
        line.y = yOffset;
        addChild(line);
        height = height + 6;
    }

    override public function draw():void {
        this.lineBreak_.setWidthColor(width - 10, 1842204);
        super.draw();
    }
}
}

import com.company.ui.SimpleText;
import com.company.untiered.graphics.StarGraphic;

import flash.display.Sprite;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

class LegendLine extends Sprite {


    private var coloredStar_:StarGraphic;

    private var rangeText_:SimpleText;

    private var star_:StarGraphic;

    function LegendLine(minStars:int, maxStars:int, ct:ColorTransform) {
        super();
        this.coloredStar_ = new StarGraphic();
        this.coloredStar_.transform.colorTransform = ct;
        this.coloredStar_.y = 4;
        addChild(this.coloredStar_);
        this.rangeText_ = new SimpleText(13, 11776947, false, 0, 0);
        this.rangeText_.setBold(true);
        this.rangeText_.text = ": " + (minStars == maxStars ? minStars.toString() : minStars + " - " + maxStars);
        this.rangeText_.updateMetrics();
        this.rangeText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.rangeText_.x = this.coloredStar_.width;
        addChild(this.rangeText_);
        this.star_ = new StarGraphic();
        this.star_.transform.colorTransform = new ColorTransform(179 / 255, 179 / 255, 179 / 255);
        this.star_.x = this.rangeText_.x + this.rangeText_.width + 2;
        this.star_.y = 4;
        addChild(this.star_);
    }
}
</file>

<file path="src/com/company/assembleegameclient/ui/TradeButton.as">
package com.company.assembleegameclient.ui {
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.utils.getTimer;

public class TradeButton extends Sprite {

    private static const WAIT_TIME:int = 3000;

    private static const COUNTDOWN_STATE:int = 0;

    private static const NORMAL_STATE:int = 1;

    private static const WAITING_STATE:int = 2;

    private static const DISABLED_STATE:int = 3;


    public var statusBar_:Sprite;

    public var barMask_:Shape;

    public var text_:SimpleText;

    public var w_:int;

    public var h_:int;

    private var state_:int;

    private var lastResetTime_:int;

    private var enabledFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var disabledFill_:GraphicsSolidFill = new GraphicsSolidFill(8355711, 1);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[enabledFill_, path_, GraphicsUtil.END_FILL];

    private var barFill_:GraphicsSolidFill = new GraphicsSolidFill(12566463, 1);

    private const barGraphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[barFill_, path_, GraphicsUtil.END_FILL];

    private var outlineFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var lineStyle_:GraphicsStroke = new GraphicsStroke(2, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill_);

    private const outlineGraphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[lineStyle_, path_, GraphicsUtil.END_STROKE];

    public function TradeButton(size:int, bWidth:int = 0) {
        super();
        this.lastResetTime_ = getTimer();
        this.text_ = new SimpleText(size, 3552822, false, 0, 0);
        this.text_.setBold(true);
        this.text_.text = "Trade";
        this.text_.updateMetrics();
        this.w_ = bWidth != 0 ? int(bWidth) : int(this.text_.width + 12);
        this.h_ = this.text_.textHeight + 8;
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, this.w_, this.text_.textHeight + 8, 4, [1, 1, 1, 1], this.path_);
        this.text_.x = this.w_ / 2 - this.text_.textWidth / 2 - 2;
        this.text_.y = 1;
        this.statusBar_ = this.newStatusBar();
        addChild(this.statusBar_);
        addChild(this.text_);
        this.draw();
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function reset():void {
        this.lastResetTime_ = getTimer();
        this.state_ = COUNTDOWN_STATE;
        this.setEnabled(false);
        this.setText("Trade");
    }

    public function disable():void {
        this.state_ = DISABLED_STATE;
        this.setEnabled(false);
        this.setText("Trade");
    }

    private function setText(text:String):void {
        this.text_.text = text;
        this.text_.updateMetrics();
        this.text_.x = this.w_ / 2 - this.text_.textWidth / 2 - 2;
        this.text_.y = 1;
    }

    private function setEnabled(enabled:Boolean):void {
        if (enabled == mouseEnabled) {
            return;
        }
        mouseEnabled = enabled;
        mouseChildren = enabled;
        this.graphicsData_[0] = enabled ? this.enabledFill_ : this.disabledFill_;
        this.draw();
    }

    private function onAddedToStage(event:Event):void {
        addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        this.reset();
        this.draw();
    }

    private function onRemovedFromStage(event:Event):void {
        removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
    }

    private function onEnterFrame(event:Event):void {
        this.draw();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.enabledFill_.color = 16768133;
        this.draw();
    }

    private function onRollOut(event:MouseEvent):void {
        this.enabledFill_.color = 16777215;
        this.draw();
    }

    private function onClick(event:MouseEvent):void {
        this.state_ = WAITING_STATE;
        this.setEnabled(false);
        this.setText("Waiting");
    }

    private function newStatusBar():Sprite {
        var statusBar:Sprite = new Sprite();
        var bar:Sprite = new Sprite();
        var barShape:Shape = new Shape();
        barShape.graphics.clear();
        barShape.graphics.drawGraphicsData(this.barGraphicsData_);
        bar.addChild(barShape);
        this.barMask_ = new Shape();
        bar.addChild(this.barMask_);
        bar.mask = this.barMask_;
        statusBar.addChild(bar);
        var outline:Shape = new Shape();
        outline.graphics.clear();
        outline.graphics.drawGraphicsData(this.outlineGraphicsData_);
        statusBar.addChild(outline);
        return statusBar;
    }

    private function drawCountDown(t:Number):void {
        this.barMask_.graphics.clear();
        this.barMask_.graphics.beginFill(12566463);
        this.barMask_.graphics.drawRect(0, 0, this.w_ * t, this.h_);
        this.barMask_.graphics.endFill();
    }

    private function draw():void {
        var time:int;
        var t:Number = NaN;
        time = getTimer();
        if (this.state_ == COUNTDOWN_STATE) {
            if (time - this.lastResetTime_ > WAIT_TIME) {
                this.state_ = NORMAL_STATE;
                this.setEnabled(true);
            }
        }
        switch (this.state_) {
            case COUNTDOWN_STATE:
                this.statusBar_.visible = true;
                t = (time - this.lastResetTime_) / WAIT_TIME;
                this.drawCountDown(t);
                break;
            case DISABLED_STATE:
            case NORMAL_STATE:
            case WAITING_STATE:
                this.statusBar_.visible = false;
        }
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/TextureRedrawer.as">
package com.company.assembleegameclient.util {
import com.company.assembleegameclient.util.redrawers.GlowRedrawer;
import com.company.util.AssetLibrary;
import com.company.util.PointUtil;

import flash.display.BitmapData;
import flash.display.Shader;
import flash.filters.BitmapFilterQuality;
import flash.filters.GlowFilter;
import flash.filters.ShaderFilter;
import flash.geom.ColorTransform;
import flash.geom.Matrix;
import flash.geom.Rectangle;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

public class TextureRedrawer {

    public static const magic:int = 12;
    public static const minSize:int = 2 * magic;//24
    private static const BORDER:int = 4;
    public static const OUTLINE_FILTER:GlowFilter = new GlowFilter(0, 0.8, 1.4, 1.4, 0xFF, BitmapFilterQuality.LOW, false, false);

    private static var cache_:Dictionary = new Dictionary();
    private static var faceCache_:Dictionary = new Dictionary();
    private static var redrawCaches:Dictionary = new Dictionary();
    public static var sharedTexture_:BitmapData = null;
    private static var textureShaderEmbed_:Class = TextureRedrawer_textureShaderEmbed_;
    private static var textureShaderData_:ByteArray = new textureShaderEmbed_() as ByteArray;
    private static var colorTexture1:BitmapData = new BitmapData(1, 1, false);
    private static var colorTexture2:BitmapData = new BitmapData(1, 1, false);


    public static function redraw(tex:BitmapData, size:int, padBottom:Boolean, glowColor:uint, useCache:Boolean = true, sMult:Number = 5):BitmapData {
        var hash:int = getHash(size, padBottom, glowColor, sMult);
        if (useCache && isCached(tex, hash)) {
            return redrawCaches[tex][hash];
        }
        var modTex:BitmapData = resize(tex, null, size, padBottom, 0, 0, sMult);
        modTex = GlowRedrawer.outlineGlow(modTex, glowColor, 1.4, useCache);
        if (useCache) {
            cache(tex, hash, modTex);
        }
        return modTex;
    }

    private static function getHash(size:int, padBottom:Boolean, glowColor:uint, sMult:Number):* {
        var h:int = (padBottom ? 1 << 27 : 0) | size * sMult;
        if (glowColor == 0) {
            return h;
        }
        return h + glowColor;
    }

    private static function cache(tex:BitmapData, hash:*, modifiedTex:BitmapData):void {
        if (!(tex in redrawCaches)) {
            redrawCaches[tex] = {};
        }
        redrawCaches[tex][hash] = modifiedTex;
    }

    private static function isCached(tex:BitmapData, hash:int):Boolean {
        if (tex in redrawCaches) {
            if (hash in redrawCaches[tex]) {
                return true;
            }
        }
        return false;
    }

    public static function resize(tex:BitmapData, mask:BitmapData, size:int, padBottom:Boolean, op1:int, op2:int, sMult:Number = 5):BitmapData {
        if (mask != null && (op1 != 0 || op2 != 0)) {
            tex = retexture(tex, mask, op1, op2);
            size = size / 5;
        }
        var w:int = sMult * size / 100 * tex.width;
        var h:int = sMult * size / 100 * tex.height;
        var m:Matrix = new Matrix();
        m.scale(w / tex.width, h / tex.height);
        m.translate(magic, magic);
        var ret:BitmapData = new BitmapData(w + minSize, h + (padBottom ? magic : 1) + magic, true, 0);
        ret.draw(tex, m);
        return ret;
    }

    public static function redrawSolidSquare(color:uint, size:int):BitmapData {
        var colorDict:Dictionary = cache_[size];
        if (colorDict == null) {
            colorDict = new Dictionary();
            cache_[size] = colorDict;
        }
        var tex:BitmapData = colorDict[color];
        if (tex != null) {
            return tex;
        }
        tex = new BitmapData(size + 4 + 4, size + 4 + 4, true, 0);
        tex.fillRect(new Rectangle(4, 4, size, size), 0xFF000000 | color);
        tex.applyFilter(tex, tex.rect, PointUtil.ORIGIN, OUTLINE_FILTER);
        colorDict[color] = tex;
        return tex;
    }

    public static function clearCache():void {
        var tex:BitmapData;
        var dict:Dictionary;

        for each (dict in cache_) {
            for each (tex in dict) {
                tex.dispose();
            }
        }
        cache_ = new Dictionary();

        for each (dict in faceCache_) {
            for each (tex in dict) {
                tex.dispose();
            }
        }
        faceCache_ = new Dictionary();
    }

    public static function redrawFace(tex:BitmapData, shade:Number):BitmapData {
        if (shade == 1) {
            return tex;
        }
        var shadeInt:int = int(shade * 100);
        var dict:Dictionary = faceCache_[shadeInt];
        if (dict == null) {
            dict = new Dictionary();
            faceCache_[shadeInt] = dict;
        }
        var modTex:BitmapData = dict[tex];
        if (modTex != null) {
            return modTex;
        }
        modTex = tex.clone();
        modTex.colorTransform(modTex.rect, new ColorTransform(shade, shade, shade));
        dict[tex] = modTex;
        return modTex;
    }

    private static function getTexture(op:int, bmp:BitmapData):BitmapData {
        var ret:BitmapData;
        var type:int = op >> 24 & 0xFF;
        var value:uint = op & 0xFFFFFF; // could mean color or sprite index
        switch (type) {
            case 0:
                ret = bmp;
                break;
            case 1:
                bmp.setPixel(0, 0, value);
                ret = bmp;
                break;
            case 4:
                ret = AssetLibrary.getImageFromSet("textile4x4", value);
                break;
            case 5:
                ret = AssetLibrary.getImageFromSet("textile5x5", value);
                break;
            case 9:
                ret = AssetLibrary.getImageFromSet("textile9x9", value);
                break;
            case 10:
                ret = AssetLibrary.getImageFromSet("textile10x10", value);
                break;
            case 0xFF:
                ret = sharedTexture_;
                break;
            default:
                ret = bmp;
        }
        return ret;
    }

    private static function retexture(tex:BitmapData, mask:BitmapData, op1:int, op2:int):BitmapData {
        var m:Matrix = new Matrix();
        m.scale(5, 5);
        var ret:BitmapData = new BitmapData(tex.width * 5, tex.height * 5, true, 0);
        ret.draw(tex, m);
        var c1:BitmapData = getTexture(op1, colorTexture1);
        var c2:BitmapData = getTexture(op2, colorTexture2);
        var shader:Shader = new Shader(textureShaderData_);
        shader.data.src.input = ret;
        shader.data.mask.input = mask;
        shader.data.texture1.input = c1;
        shader.data.texture2.input = c2;
        shader.data.texture1Size.value = [op1 == 0 ? 0 : c1.width];
        shader.data.texture2Size.value = [op2 == 0 ? 0 : c2.width];
        ret.applyFilter(ret, ret.rect, PointUtil.ORIGIN, new ShaderFilter(shader));
        return ret;
    }

    private static function getDrawMatrix():Matrix {
        var m:Matrix = new Matrix();
        m.scale(8, 8);
        m.translate(BORDER, BORDER);
        return m;
    }


}
}
</file>

<file path="src/com/company/ui/SimpleText.as">
package com.company.ui {

import com.company.ui.fonts.MyriadPro;
import com.company.ui.fonts.MyriadProBold;
import com.company.ui.fonts.MyriadProBoldCFF;
import com.company.ui.fonts.MyriadProCFF;

import flash.events.Event;
import flash.text.Font;
import flash.text.TextField;
import flash.text.TextFieldType;
import flash.text.TextFormat;
import flash.text.TextLineMetrics;

public class SimpleText extends TextField {
    private static const GUTTER:int = 16;

    public static const _MyriadPro:Class = MyriadPro;
    public static const _MyriadProBold:Class = MyriadProBold;
    public static const _MyriadProCFF:Class = MyriadProCFF;
    public static const _MyriadProBoldCFF:Class = MyriadProBoldCFF;
    public static var _Font:Font;
    public static var _FontRegistered:Boolean = false;

    public var inputWidth_:int;
    public var inputHeight_:int;
    public var actualWidth_:int;
    public var actualHeight_:int;

    public function SimpleText(textSize:int, color:uint, makeSelectable:Boolean = false, widthParam:int = 0, heightParam:int = 0, isLink:Boolean = false) {
        if (!_FontRegistered) {
            Font.registerFont(_MyriadPro);
            Font.registerFont(_MyriadProBold);
            Font.registerFont(_MyriadProCFF);
            Font.registerFont(_MyriadProBoldCFF);
            _Font = new _MyriadPro();
            _FontRegistered = true;
        }

        super();
        this.inputWidth_ = widthParam;
        if (this.inputWidth_ != 0) {
            width = widthParam;
        }
        this.inputHeight_ = heightParam;
        if (this.inputHeight_ != 0) {
            height = heightParam;
        }
        var format:TextFormat = defaultTextFormat;
        format.font = _Font.fontName;
        format.bold = false;
        format.size = textSize;
        format.color = color;
        embedFonts = true;
        defaultTextFormat = format;
        if (makeSelectable) {
            selectable = true;
            mouseEnabled = true;
            type = TextFieldType.INPUT;
            border = true;
            borderColor = color;
            addEventListener(Event.CHANGE, this.onChange);
        } else {
            selectable = false;
            mouseEnabled = false;
        }

        if (isLink) {
            mouseEnabled = true;
        }
    }

    public function setSize(size:int):SimpleText {
        var format:TextFormat = defaultTextFormat;
        format.size = size;
        this.applyFormat(format);
        return this;
    }

    public function setColor(color:uint):SimpleText {
        var format:TextFormat = defaultTextFormat;
        format.color = color;
        this.applyFormat(format);
        return this;
    }

    public function setBold(bold:Boolean):SimpleText {
        var format:TextFormat = defaultTextFormat;
        format.bold = bold;
        this.applyFormat(format);
        return this;
    }

    public function setAlignment(alignment:String):SimpleText {
        var format:TextFormat = defaultTextFormat;
        format.align = alignment;
        this.applyFormat(format);
        return this;
    }

    public function setText(text:String):SimpleText {
        this.text = text;
        return this;
    }

    private function applyFormat(format:TextFormat):void {
        setTextFormat(format);
        defaultTextFormat = format;
    }

    private function onChange(event:Event):void {
        this.updateMetrics();
    }

    public function updateMetrics():SimpleText {
        var textMetrics:TextLineMetrics = null;
        var textWidth:int = 0;
        var textHeight:int = 0;
        this.actualWidth_ = 0;
        this.actualHeight_ = 0;
        for (var i:int = 0; i < numLines; i++) {
            textMetrics = getLineMetrics(i);
            textWidth = textMetrics.width + 4;
            textHeight = textMetrics.height + 4;
            if (textWidth > this.actualWidth_) {
                this.actualWidth_ = textWidth;
            }
            this.actualHeight_ = this.actualHeight_ + textHeight;
        }
        width = this.inputWidth_ == 0 ? this.actualWidth_ : this.inputWidth_;
        height = this.inputHeight_ == 0 ? this.actualHeight_ : this.inputHeight_;
        return this;
    }

    public function useTextDimensions():void {
        width = this.inputWidth_ == 0 ? textWidth + 4 : this.inputWidth_;
        height = this.inputHeight_ == 0 ? textHeight + 4 : this.inputHeight_;
    }

    /*override public function set x(newValue:Number) : void
    {
       super.x = newValue;
    }

    override public function set y(newValue:Number) : void
    {
       super.y = newValue;
    }*/
}
}
</file>

<file path="src/com/company/util/AssetLibrary.as">
package com.company.util {
import flash.display.BitmapData;
import flash.media.Sound;
import flash.media.SoundTransform;
import flash.utils.Dictionary;

public class AssetLibrary {

    private static var images_:Dictionary = new Dictionary();

    private static var imageSets_:Dictionary = new Dictionary();

    private static var sounds_:Dictionary = new Dictionary();

    private static var imageLookup_:Dictionary = new Dictionary();


    public function AssetLibrary(se:StaticEnforcer) {
        super();
    }

    public static function addImage(name:String, data:BitmapData):void {
        images_[name] = data;
        imageLookup_[data] = name;
    }

    public static function addImageSet(name:String, data:BitmapData, width:int, height:int):void {
        images_[name] = data;
        var imageSet:ImageSet = new ImageSet();
        imageSet.addFromBitmapData(data, width, height);
        imageSets_[name] = imageSet;
        for (var i:int = 0; i < imageSet.images_.length; i++) {
            imageLookup_[imageSet.images_[i]] = [name, i];
        }
    }

    public static function addToImageSet(name:String, data:BitmapData):void {
        var imageSet:ImageSet = imageSets_[name];
        if (imageSet == null) {
            imageSet = new ImageSet();
            imageSets_[name] = imageSet;
        }
        imageSet.add(data);
        var i:int = imageSet.images_.length - 1;
        imageLookup_[imageSet.images_[i]] = [name, i];
    }

    public static function addSound(name:String, soundClass:Class):void {
        var a:Array = sounds_[name];
        if (a == null) {
            sounds_[name] = [];
        }
        sounds_[name].push(soundClass);
    }

    public static function lookupImage(data:BitmapData):Object {
        return imageLookup_[data];
    }

    public static function getImage(name:String):BitmapData {
        return images_[name];
    }

    public static function getImageSet(name:String):ImageSet {
        return imageSets_[name];
    }

    public static function getImageFromSet(name:String, id:int):BitmapData {
        var imageSet:ImageSet = imageSets_[name];
        if (name == null || isNaN(id)) trace("Unknown File: ", name, id);
        try {
            if (imageSet.images_ == null || imageSet.images_[id] == null)
                trace("Unknown File: ", name, id);
        } catch (e:Error) {
            trace("Unknown File: ", name, id);
        }
        return imageSet.images_[id];
    }

    public static function getSound(name:String):Sound {
        var a:Array = sounds_[name];
        var i:int = Math.random() * a.length;
        return new sounds_[name][i]();
    }

    public static function playSound(name:String, volume:Number = 1.0):void {
        var a:Array = sounds_[name];
        var i:int = Math.random() * a.length;
        var sound:Sound = new sounds_[name][i]();
        var trans:SoundTransform = null;
        if (volume != 1) {
            trans = new SoundTransform(volume);
        }
        sound.play(0, 0, trans);
    }
}
}

class StaticEnforcer {


    function StaticEnforcer() {
        super();
    }
}
</file>

<file path="src/com/company/util/IntPoint.as">
package com.company.util {
import flash.geom.Matrix;
import flash.geom.Point;

public class IntPoint {


    public var x_:int;

    public var y_:int;

    public function IntPoint(x:int = 0, y:int = 0) {
        super();
        this.x_ = x;
        this.y_ = y;
    }

    public static function unitTest():void {
        var test:UnitTest = new UnitTest();
    }

    public static function fromPoint(p:Point):IntPoint {
        return new IntPoint(Math.round(p.x), Math.round(p.y));
    }

    public function x():int {
        return this.x_;
    }

    public function y():int {
        return this.y_;
    }

    public function setX(x:int):void {
        this.x_ = x;
    }

    public function setY(y:int):void {
        this.y_ = y;
    }

    public function clone():IntPoint {
        return new IntPoint(this.x_, this.y_);
    }

    public function same(p:IntPoint):Boolean {
        return this.x_ == p.x_ && this.y_ == p.y_;
    }

    public function distanceAsInt(p:IntPoint):int {
        var dx:int = p.x_ - this.x_;
        var dy:int = p.y_ - this.y_;
        return Math.round(Math.sqrt(dx * dx + dy * dy));
    }

    public function distanceAsNumber(p:IntPoint):Number {
        var dx:int = p.x_ - this.x_;
        var dy:int = p.y_ - this.y_;
        return Math.sqrt(dx * dx + dy * dy);
    }

    public function distanceToPoint(p:Point):Number {
        var dx:int = p.x - this.x_;
        var dy:int = p.y - this.y_;
        return Math.sqrt(dx * dx + dy * dy);
    }

    public function trunc1000():IntPoint {
        return new IntPoint(int(this.x_ / 1000) * 1000, int(this.y_ / 1000) * 1000);
    }

    public function round1000():IntPoint {
        return new IntPoint(Math.round(this.x_ / 1000) * 1000, Math.round(this.y_ / 1000) * 1000);
    }

    public function distanceSquared(p:IntPoint):int {
        var dx:int = p.x() - this.x_;
        var dy:int = p.y() - this.y_;
        return dx * dx + dy * dy;
    }

    public function toPoint():Point {
        return new Point(this.x_, this.y_);
    }

    public function transform(m:Matrix):IntPoint {
        var p:Point = m.transformPoint(this.toPoint());
        return new IntPoint(Math.round(p.x), Math.round(p.y));
    }

    public function toString():String {
        return "(" + this.x_ + ", " + this.y_ + ")";
    }
}
}

import com.company.util.IntPoint;

class UnitTest {


    function UnitTest() {
        var p:IntPoint;
        var rp:IntPoint;
        var n:Number;
        super();
        trace("STARTING UNITTEST: IntPoint");
        p = new IntPoint(999, 1001);
        rp = p.round1000();
        if (rp.x() != 1000 || rp.y() != 1000) {
            trace("ERROR IN UNITTEST: IntPoint1");
        }
        p = new IntPoint(500, 400);
        rp = p.round1000();
        if (rp.x() != 1000 || rp.y() != 0) {
            trace("ERROR IN UNITTEST: IntPoint2");
        }
        p = new IntPoint(-400, -500);
        rp = p.round1000();
        if (rp.x() != 0 || rp.y() != 0) {
            trace("ERROR IN UNITTEST: IntPoint3");
        }
        p = new IntPoint(-501, -999);
        rp = p.round1000();
        if (rp.x() != -1000 || rp.y() != -1000) {
            trace("ERROR IN UNITTEST: IntPoint4");
        }
        p = new IntPoint(-1000, -1001);
        rp = p.round1000();
        if (rp.x() != -1000 || rp.y() != -1000) {
            trace("ERROR IN UNITTEST: IntPoint5");
        }
        p = new IntPoint(999, 1001);
        rp = p.trunc1000();
        if (rp.x() != 0 || rp.y() != 1000) {
            trace("ERROR IN UNITTEST: IntPoint6");
        }
        p = new IntPoint(500, 400);
        rp = p.trunc1000();
        if (rp.x() != 0 || rp.y() != 0) {
            trace("ERROR IN UNITTEST: IntPoint7");
        }
        p = new IntPoint(-400, -500);
        rp = p.trunc1000();
        if (rp.x() != 0 || rp.y() != 0) {
            trace("ERROR IN UNITTEST: IntPoint8");
        }
        p = new IntPoint(-501, -999);
        rp = p.trunc1000();
        if (rp.x() != 0 || rp.y() != 0) {
            trace("ERROR IN UNITTEST: IntPoint9");
        }
        p = new IntPoint(-1000, -1001);
        rp = p.trunc1000();
        if (rp.x() != -1000 || rp.y() != -1000) {
            trace("ERROR IN UNITTEST: IntPoint10");
        }
        n = 0.9999998;
        if (int(n) != 0) {
            trace("ERROR IN UNITTEST: IntPoint40");
        }
        n = 0.5;
        if (int(n) != 0) {
            trace("ERROR IN UNITTEST: IntPoint41");
        }
        n = 0.499999;
        if (int(n) != 0) {
            trace("ERROR IN UNITTEST: IntPoint42");
        }
        n = -0.499999;
        if (int(n) != 0) {
            trace("ERROR IN UNITTEST: IntPoint43");
        }
        n = -0.5;
        if (int(n) != 0) {
            trace("ERROR IN UNITTEST: IntPoint44");
        }
        n = -0.99999;
        if (int(n) != 0) {
            trace("ERROR IN UNITTEST: IntPoint45");
        }
        trace("FINISHED UNITTEST: IntPoint");
    }
}
</file>

<file path="src/com/company/util/LineSegmentUtil.as">
package com.company.util {
import flash.geom.Point;

public class LineSegmentUtil {


    public function LineSegmentUtil() {
        super();
    }

    public static function intersection(l1x1:Number, l1y1:Number, l1x2:Number, l1y2:Number, l2x1:Number, l2y1:Number, l2x2:Number, l2y2:Number):Point {
        var d:Number = (l2y2 - l2y1) * (l1x2 - l1x1) - (l2x2 - l2x1) * (l1y2 - l1y1);
        if (d == 0) {
            return null;
        }
        var ua:Number = ((l2x2 - l2x1) * (l1y1 - l2y1) - (l2y2 - l2y1) * (l1x1 - l2x1)) / d;
        var ub:Number = ((l1x2 - l1x1) * (l1y1 - l2y1) - (l1y2 - l1y1) * (l1x1 - l2x1)) / d;
        if (ua > 1 || ua < 0 || ub > 1 || ub < 0) {
            return null;
        }
        var p:Point = new Point(l1x1 + ua * (l1x2 - l1x1), l1y1 + ua * (l1y2 - l1y1));
        return p;
    }

    public static function pointDistance(x:Number, y:Number, x0:Number, y0:Number, x1:Number, y1:Number):Number {
        var nx:Number;
        var ny:Number;
        var t:Number = NaN;
        var dx:Number = x1 - x0;
        var dy:Number = y1 - y0;
        var dd:Number = dx * dx + dy * dy;
        if (dd < 0.001) {
            nx = x0;
            ny = y0;
        } else {
            t = ((x - x0) * dx + (y - y0) * dy) / dd;
            if (t < 0) {
                nx = x0;
                ny = y0;
            } else if (t > 1) {
                nx = x1;
                ny = y1;
            } else {
                nx = x0 + t * dx;
                ny = y0 + t * dy;
            }
        }
        dx = x - nx;
        dy = y - ny;
        return Math.sqrt(dx * dx + dy * dy);
    }
}
}
</file>

<file path="src/com/company/util/PointUtil.as">
package com.company.util {
import flash.geom.Point;

public class PointUtil {

    public static const ORIGIN:Point = new Point(0, 0);


    public function PointUtil(se:StaticEnforcer) {
        super();
    }

    public static function roundPoint(p:Point):Point {
        var newP:Point = p.clone();
        newP.x = Math.round(newP.x);
        newP.y = Math.round(newP.y);
        return newP;
    }

    public static function distanceSquared(p1:Point, p2:Point):Number {
        return distanceSquaredXY(p1.x, p1.y, p2.x, p2.y);
    }

    public static function distanceSquaredXY(x1:Number, y1:Number, x2:Number, y2:Number):Number {
        var xdiff:Number = x2 - x1;
        var ydiff:Number = y2 - y1;
        return xdiff * xdiff + ydiff * ydiff;
    }

    public static function distanceXY(x1:Number, y1:Number, x2:Number, y2:Number):Number {
        var xdiff:Number = x2 - x1;
        var ydiff:Number = y2 - y1;
        return Math.sqrt(xdiff * xdiff + ydiff * ydiff);
    }

    public static function lerpXY(x1:Number, y1:Number, x2:Number, y2:Number, f:Number):Point {
        return new Point(x1 + (x2 - x1) * f, y1 + (y2 - y1) * f);
    }

    public static function angleTo(p1:Point, p2:Point):Number {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    }

    public static function pointAt(p:Point, angle:Number, r:Number):Point {
        var ret:Point = new Point();
        ret.x = p.x + r * Math.cos(angle);
        ret.y = p.y + r * Math.sin(angle);
        return ret;
    }
}
}

class StaticEnforcer {


    function StaticEnforcer() {
        super();
    }
}
</file>

<file path="src/com/company/util/Triangle.as">
package com.company.util {
import flash.geom.Point;
import flash.geom.Rectangle;

public class Triangle {


    public var x0_:Number;

    public var y0_:Number;

    public var x1_:Number;

    public var y1_:Number;

    public var x2_:Number;

    public var y2_:Number;

    public var vx1_:Number;

    public var vy1_:Number;

    public var vx2_:Number;

    public var vy2_:Number;

    public function Triangle(x0:Number, y0:Number, x1:Number, y1:Number, x2:Number, y2:Number) {
        super();
        this.x0_ = x0;
        this.y0_ = y0;
        this.x1_ = x1;
        this.y1_ = y1;
        this.x2_ = x2;
        this.y2_ = y2;
        this.vx1_ = this.x1_ - this.x0_;
        this.vy1_ = this.y1_ - this.y0_;
        this.vx2_ = this.x2_ - this.x0_;
        this.vy2_ = this.y2_ - this.y0_;
    }

    public static function containsXY(x0:Number, y0:Number, x1:Number, y1:Number, x2:Number, y2:Number, x:Number, y:Number):Boolean {
        var vx1:Number = x1 - x0;
        var vy1:Number = y1 - y0;
        var vx2:Number = x2 - x0;
        var vy2:Number = y2 - y0;
        var a:Number = (x * vy2 - y * vx2 - (x0 * vy2 - y0 * vx2)) / (vx1 * vy2 - vy1 * vx2);
        var b:Number = -(x * vy1 - y * vx1 - (x0 * vy1 - y0 * vx1)) / (vx1 * vy2 - vy1 * vx2);
        return a >= 0 && b >= 0 && a + b <= 1;
    }

    public static function intersectTriAABB(x0:Number, y0:Number, x1:Number, y1:Number, x2:Number, y2:Number, l:Number, t:Number, r:Number, b:Number):Boolean {
        if (l > x0 && l > x1 && l > x2 || r < x0 && r < x1 && r < x2 || t > y0 && t > y1 && t > y2 || b < y0 && b < y1 && b < y2) {
            return false;
        }
        if (l < x0 && x0 < r && t < y0 && y0 < b || l < x1 && x1 < r && t < y1 && y1 < b || l < x2 && x2 < r && t < y2 && y2 < b) {
            return true;
        }
        return lineRectIntersect(x0, y0, x1, y1, l, t, r, b) || lineRectIntersect(x1, y1, x2, y2, l, t, r, b) || lineRectIntersect(x2, y2, x0, y0, l, t, r, b);
    }

    private static function lineRectIntersect(x0:Number, y0:Number, x1:Number, y1:Number, l:Number, t:Number, r:Number, b:Number):Boolean {
        var top_intersection:Number;
        var bottom_intersection:Number;
        var toptrianglepoint:Number;
        var bottomtrianglepoint:Number;
        var m:Number = (y1 - y0) / (x1 - x0);
        var c:Number = y0 - m * x0;
        if (m > 0) {
            top_intersection = m * l + c;
            bottom_intersection = m * r + c;
        } else {
            top_intersection = m * r + c;
            bottom_intersection = m * l + c;
        }
        if (y0 < y1) {
            toptrianglepoint = y0;
            bottomtrianglepoint = y1;
        } else {
            toptrianglepoint = y1;
            bottomtrianglepoint = y0;
        }
        var topoverlap:Number = top_intersection > toptrianglepoint ? Number(top_intersection) : Number(toptrianglepoint);
        var botoverlap:Number = bottom_intersection < bottomtrianglepoint ? Number(bottom_intersection) : Number(bottomtrianglepoint);
        return topoverlap < botoverlap && !(botoverlap < t || topoverlap > b);
    }

    public function aabb():Rectangle {
        var minX:Number = Math.min(this.x0_, this.x1_, this.x2_);
        var maxX:Number = Math.max(this.x0_, this.x1_, this.x2_);
        var minY:Number = Math.min(this.y0_, this.y1_, this.y2_);
        var maxY:Number = Math.max(this.y0_, this.y1_, this.y2_);
        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    public function area():Number {
        return Math.abs((this.x0_ * (this.y1_ - this.y2_) + this.x1_ * (this.y2_ - this.y0_) + this.x2_ * (this.y0_ - this.y1_)) / 2);
    }

    public function incenter(result:Point):void {
        var a:Number = PointUtil.distanceXY(this.x1_, this.y1_, this.x2_, this.y2_);
        var b:Number = PointUtil.distanceXY(this.x0_, this.y0_, this.x2_, this.y2_);
        var c:Number = PointUtil.distanceXY(this.x0_, this.y0_, this.x1_, this.y1_);
        result.x = (a * this.x0_ + b * this.x1_ + c * this.x2_) / (a + b + c);
        result.y = (a * this.y0_ + b * this.y1_ + c * this.y2_) / (a + b + c);
    }

    public function contains(x:Number, y:Number):Boolean {
        var a:Number = (x * this.vy2_ - y * this.vx2_ - (this.x0_ * this.vy2_ - this.y0_ * this.vx2_)) / (this.vx1_ * this.vy2_ - this.vy1_ * this.vx2_);
        var b:Number = -(x * this.vy1_ - y * this.vx1_ - (this.x0_ * this.vy1_ - this.y0_ * this.vx1_)) / (this.vx1_ * this.vy2_ - this.vy1_ * this.vx2_);
        return a >= 0 && b >= 0 && a + b <= 1;
    }

    public function distance(x:Number, y:Number):Number {
        if (this.contains(x, y)) {
            return 0;
        }
        return Math.min(LineSegmentUtil.pointDistance(x, y, this.x0_, this.y0_, this.x1_, this.y1_), LineSegmentUtil.pointDistance(x, y, this.x1_, this.y1_, this.x2_, this.y2_), LineSegmentUtil.pointDistance(x, y, this.x0_, this.y0_, this.x2_, this.y2_));
    }

    public function intersectAABB(l:Number, t:Number, r:Number, b:Number):Boolean {
        return intersectTriAABB(this.x0_, this.y0_, this.x1_, this.y1_, this.x2_, this.y2_, l, t, r, b);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/BuyCharacterSlotCommand.as">
package svera.untiered.account.core {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;
import com.company.assembleegameclient.ui.dialogs.ErrorDialog;

import svera.lib.framework.ICommand;

import svera.lib.tasks.BranchingTask;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.Task;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.account.core.services.BuyCharacterSlotTask;
import svera.untiered.account.core.view.BuyingDialog;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.ui.view.MessageCloseDialog;

public class BuyCharacterSlotCommand implements ICommand {


    [Inject]
    public var price:int;

    [Inject]
    public var task:BuyCharacterSlotTask;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var closeDialog:CloseDialogsSignal;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var account:Account;

    public function BuyCharacterSlotCommand() {
        super();
    }

    public function execute():void {
        if (this.isSlotUnaffordable()) {
            this.nonSufficientFunds();
        } else {
            this.purchaseSlot();
        }
    }

    private function isSlotUnaffordable():Boolean {
        return this.model.getHonor() < Parameters.CHARACTER_SLOT_PRICE;
    }

    private function nonSufficientFunds():void {
        this.openDialog.dispatch(
                new MessageCloseDialog("Not Enough Honor",
                        "Insufficient funds when trying to buy a slot.", "Close"));
    }

    private function purchaseSlot():void {
        this.openDialog.dispatch(new BuyingDialog());
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(new BranchingTask(this.task, this.makeSuccessTask(), this.makeFailureTask()));
        sequence.add(new DispatchSignalTask(this.closeDialog));
        this.monitor.add(sequence);
        sequence.start();
    }

    private function makeSuccessTask():Task {
        var task:TaskSequence = new TaskSequence();
        task.add(new DispatchSignalTask(this.setScreen, new CharacterSelectionAndNewsScreen()));
        return task;
    }

    private function makeFailureTask():Task {
        return new DispatchSignalTask(this.openDialog, new ErrorDialog("Unable to complete character slot purchase"));
    }
}
}
</file>

<file path="src/svera/untiered/account/core/services/BuyCharacterSlotTask.as">
package svera.untiered.account.core.services {
import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class BuyCharacterSlotTask extends BaseTask {


    [Inject]
    public var account:Account;

    [Inject]
    public var price:int;

    [Inject]
    public var client:AppEngineClient;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var model:PlayerModel;

    public function BuyCharacterSlotTask() {
        super();
    }

    override protected function startTask():void {
        this.client.setMaxRetries(2);
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/account/purchaseCharSlot", this.account.getCredentials());
    }

    private function onComplete(isOK:Boolean, data:*):void {
        isOK && this.updatePlayerData();
        completeTask(isOK, data);
    }

    private function updatePlayerData():void {
        this.model.setMaxCharacters(this.model.getMaxCharacters() + 1);
        this.model.changeHonor(-this.price);
    }
}
}
</file>

<file path="src/svera/untiered/account/core/services/GetCharListTask.as">
package svera.untiered.account.core.services {
import flash.events.TimerEvent;
import flash.utils.Timer;

import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.account.core.signals.CharListDataSignal;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetLoadingMessageSignal;

public class GetCharListTask extends BaseTask {

    private static const ONE_SECOND_IN_MS:int = 1000;


    [Inject]
    public var account:Account;

    [Inject]
    public var client:AppEngineClient;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var setLoadingMessage:SetLoadingMessageSignal;

    [Inject]
    public var charListData:CharListDataSignal;

    private var requestData:Object;

    private var retryTimer:Timer;

    public function GetCharListTask() {
        super();
    }

    override protected function startTask():void {
        this.requestData = this.makeRequestData();
        this.sendRequest();
    }

    private function sendRequest():void {
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/char/list", this.requestData);
    }

    private function onComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.onListComplete(data);
        } else {
            this.onTextError(data);
        }
    }

    public function makeRequestData():Object {
        var params:Object = this.account.getCredentials();
        return params;
    }

    private function onListComplete(data:String):void {
        this.charListData.dispatch(XML(data));
        completeTask(true);
        if (this.retryTimer != null) {
            this.stopRetryTimer();
        }
    }

    private function onTextError(error:String):void {
        this.setLoadingMessage.dispatch("<p align=\"center\">Load error, retrying</p>");
        if (error == "Account credentials not valid") {
            this.clearAccountAndReloadCharacters();
        } else {
            this.waitForASecondThenRetryRequest();
        }
    }

    private function clearAccountAndReloadCharacters():void {
        this.account.clear();
        this.client.sendRequest("/char/list", this.requestData);
    }

    private function waitForASecondThenRetryRequest():void {
        this.retryTimer = new Timer(ONE_SECOND_IN_MS, 1);
        this.retryTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onRetryTimer);
        this.retryTimer.start();
    }

    private function stopRetryTimer():void {
        this.retryTimer.stop();
        this.retryTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onRetryTimer);
        this.retryTimer = null;
    }

    private function onRetryTimer(event:TimerEvent):void {
        this.stopRetryTimer();
        this.sendRequest();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/signals/OpenQuitDialogSignal.as">
package svera.untiered.account.core.signals {
import org.osflash.signals.Signal;

public class OpenQuitDialogSignal extends Signal {


    public function OpenQuitDialogSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/account/core/view/AccountInfoView.as">
package svera.untiered.account.core.view {
import flash.events.IEventDispatcher;

public interface AccountInfoView extends IEventDispatcher {
    function setInfo(param1:String, param2:Boolean):void;
}
}
</file>

<file path="src/svera/untiered/account/core/view/RegisterPromptDialog.as">
package svera.untiered.account.core.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class RegisterPromptDialog extends Dialog {


    public var cancel:Signal;

    public var register:Signal;

    public function RegisterPromptDialog(message:String) {
        super(message, "Not Registered", "Cancel", "Register");
        this.cancel = new NativeMappedSignal(this, LEFT_BUTTON);
        this.register = new NativeMappedSignal(this, RIGHT_BUTTON);
    }
}
}
</file>

<file path="src/svera/untiered/account/ui/components/DateField.as">
package svera.untiered.account.ui.components {
import com.company.ui.SimpleText;

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.FocusEvent;
import flash.events.TextEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFormat;
import flash.text.TextFormatAlign;

import svera.lib.util.DateValidator;

public class DateField extends Sprite {

    private static const BACKGROUND_COLOR:uint = 3355443;

    private static const ERROR_BORDER_COLOR:uint = 16549442;

    private static const NORMAL_BORDER_COLOR:uint = 4539717;

    private static const TEXT_COLOR:uint = 11776947;

    private static const INPUT_RESTRICTION:String = "1234567890";

    private static const FORMAT_HINT_COLOR:uint = 5592405;


    public var label:SimpleText;

    public var days:SimpleText;

    public var months:SimpleText;

    public var years:SimpleText;

    private var dayFormatText:SimpleText;

    private var monthFormatText:SimpleText;

    private var yearFormatText:SimpleText;

    private var thisYear:int;

    private var validator:DateValidator;

    public function DateField() {
        super();
        this.validator = new DateValidator();
        this.thisYear = new Date().getFullYear();
        this.label = new SimpleText(18, 11776947, false, 0, 0);
        this.label.setBold(true);
        this.label.text = name;
        this.label.updateMetrics();
        this.label.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.label);
        this.months = new SimpleText(20, TEXT_COLOR, true, 35, 30);
        this.months.restrict = INPUT_RESTRICTION;
        this.months.maxChars = 2;
        this.months.y = 30;
        this.months.x = 6;
        this.months.border = false;
        this.months.updateMetrics();
        this.months.addEventListener(TextEvent.TEXT_INPUT, this.onMonthInput);
        this.months.addEventListener(FocusEvent.FOCUS_OUT, this.onMonthFocusOut);
        this.months.addEventListener(Event.CHANGE, this.onEditMonth);
        this.monthFormatText = this.createFormatHint(this.months, "MM");
        addChild(this.monthFormatText);
        addChild(this.months);
        this.days = new SimpleText(20, TEXT_COLOR, true, 35, 30);
        this.days.restrict = INPUT_RESTRICTION;
        this.days.maxChars = 2;
        this.days.y = 30;
        this.days.x = 63;
        this.days.border = false;
        this.days.updateMetrics();
        this.days.addEventListener(TextEvent.TEXT_INPUT, this.onDayInput);
        this.days.addEventListener(FocusEvent.FOCUS_OUT, this.onDayFocusOut);
        this.days.addEventListener(Event.CHANGE, this.onEditDay);
        this.dayFormatText = this.createFormatHint(this.days, "DD");
        addChild(this.dayFormatText);
        addChild(this.days);
        this.years = new SimpleText(20, TEXT_COLOR, true, 55, 30);
        this.years.restrict = INPUT_RESTRICTION;
        this.years.maxChars = 4;
        this.years.y = 30;
        this.years.x = 118;
        this.years.border = false;
        this.years.updateMetrics();
        this.years.restrict = INPUT_RESTRICTION;
        this.years.addEventListener(TextEvent.TEXT_INPUT, this.onYearInput);
        this.years.addEventListener(Event.CHANGE, this.onEditYear);
        this.yearFormatText = this.createFormatHint(this.years, "YYYY");
        addChild(this.yearFormatText);
        addChild(this.years);
        this.setErrorHighlight(false);
    }

    public function setTitle(title:String):void {
        this.label.text = title;
    }

    public function setErrorHighlight(hasError:Boolean):void {
        this.drawSimpleTextBackground(this.months, 0, 0, hasError);
        this.drawSimpleTextBackground(this.days, 0, 0, hasError);
        this.drawSimpleTextBackground(this.years, 0, 0, hasError);
    }

    private function drawSimpleTextBackground(simpleText:SimpleText, hPadding:int, vPadding:int, hasError:Boolean):void {
        var borderColor:uint = hasError ? uint(ERROR_BORDER_COLOR) : uint(NORMAL_BORDER_COLOR);
        graphics.lineStyle(2, borderColor, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);
        graphics.beginFill(BACKGROUND_COLOR, 1);
        graphics.drawRect(simpleText.x - hPadding - 5, simpleText.y - vPadding, simpleText.width + hPadding * 2, simpleText.height + vPadding * 2);
        graphics.endFill();
        graphics.lineStyle();
    }

    private function createFormatHint(simpleText:SimpleText, hintText:String):SimpleText {
        var formatHint:SimpleText = new SimpleText(16, FORMAT_HINT_COLOR, false, simpleText.width + 4, simpleText.height);
        formatHint.x = simpleText.x - 6;
        formatHint.y = simpleText.y + 3;
        formatHint.border = false;
        var format:TextFormat = formatHint.defaultTextFormat;
        format.align = TextFormatAlign.CENTER;
        formatHint.defaultTextFormat = format;
        formatHint.text = hintText;
        formatHint.updateMetrics();
        return formatHint;
    }

    private function onMonthInput(event:TextEvent):void {
        var string:String = this.months.text + event.text;
        var value:int = int(string);
        if (string != "0" && !this.validator.isValidMonth(value)) {
            event.preventDefault();
        }
    }

    private function onMonthFocusOut(event:FocusEvent):void {
        var value:int = int(this.months.text);
        if (value < 10 && this.days.text != "") {
            this.months.text = "0" + value.toString();
        }
    }

    private function onEditMonth(e:Event):void {
        this.monthFormatText.visible = !this.months.text;
    }

    private function onDayInput(event:TextEvent):void {
        var string:String = this.days.text + event.text;
        var value:int = int(string);
        if (string != "0" && !this.validator.isValidDay(value)) {
            event.preventDefault();
        }
    }

    private function onDayFocusOut(event:FocusEvent):void {
        var value:int = int(this.days.text);
        if (value < 10 && this.days.text != "") {
            this.days.text = "0" + value.toString();
        }
    }

    private function onEditDay(e:Event):void {
        this.dayFormatText.visible = !this.days.text;
    }

    private function onYearInput(event:TextEvent):void {
        var string:String = this.years.text + event.text;
        var earliest:int = this.getEarliestYear(string);
        if (earliest > this.thisYear) {
            event.preventDefault();
        }
    }

    private function getEarliestYear(value:String):int {
        while (value.length < 4) {
            value = value + "0";
        }
        return int(value);
    }

    private function onEditYear(e:Event):void {
        this.yearFormatText.visible = !this.years.text;
    }

    public function isValidDate():Boolean {
        var mm:int = int(this.months.text);
        var dd:int = int(this.days.text);
        var yyyy:int = int(this.years.text);
        return this.validator.isValidDate(mm, dd, yyyy, 100);
    }

    public function getDate():String {
        var mm:String = this.getFixedLengthString(this.months.text, 2);
        var dd:String = this.getFixedLengthString(this.days.text, 2);
        var yyyy:String = this.getFixedLengthString(this.years.text, 4);
        return mm + "/" + dd + "/" + yyyy;
    }

    private function getFixedLengthString(value:String, length:int):String {
        while (value.length < length) {
            value = "0" + value;
        }
        return value;
    }
}
}
</file>

<file path="src/svera/untiered/account/web/commands/WebOpenQuitDialogCommand.as">
package svera.untiered.account.web.commands {
import svera.lib.framework.ICommand;
import svera.untiered.account.core.Account;
import svera.untiered.account.web.view.WebQuitDialog;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class WebOpenQuitDialogCommand implements ICommand {


    [Inject]
    public var account:Account;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function WebOpenQuitDialogCommand() {
        super();
    }

    public function execute():void {
        this.openDialog.dispatch(new WebQuitDialog());
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/FormField.as">
package svera.untiered.account.web.view {
import com.company.ui.SimpleText;

import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;

public class FormField extends Sprite {

    protected static const BACKGROUND_COLOR:uint = 3355443;

    protected static const ERROR_BORDER_COLOR:uint = 16549442;

    protected static const NORMAL_BORDER_COLOR:uint = 4539717;

    protected static const TEXT_COLOR:uint = 11776947;


    public function FormField() {
        super();
    }

    public function getHeight():Number {
        return 0;
    }

    protected function drawSimpleTextBackground(simpleText:SimpleText, hPadding:int, vPadding:int, hasError:Boolean):void {
        var borderColor:uint = hasError ? uint(ERROR_BORDER_COLOR) : uint(NORMAL_BORDER_COLOR);
        graphics.lineStyle(2, borderColor, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);
        graphics.beginFill(BACKGROUND_COLOR, 1);
        graphics.drawRect(simpleText.x - hPadding - 5, simpleText.y - vPadding, simpleText.width + hPadding * 2, simpleText.height + vPadding * 2);
        graphics.endFill();
        graphics.lineStyle();
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebAccountInfoView.as">
package svera.untiered.account.web.view {
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.ui.SimpleText;

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.account.core.view.AccountInfoView;

public class WebAccountInfoView extends Sprite implements AccountInfoView {
    private static const LOG_IN:String = "log in";

    private static const LOG_OUT:String = "log out";

    private static const LOGGED_IN_TEXT:String = "logged in as ${userName} - ";

    private static const GUEST_ACCOUNT:String = "guest account - ";

    private static const REGISTER:String = "register";

    private static const FONT_SIZE:int = 18;


    private var _login:Signal;

    private var _register:Signal;

    private var userName:String = "";

    private var isRegistered:Boolean;

    private var accountText:SimpleText;

    private var registerButton:TitleMenuOption;

    private var dividerText:SimpleText;

    private var loginButton:TitleMenuOption;

    public function WebAccountInfoView() {
        super();
        this.makeUIElements();
        this.makeSignals();
    }

    public function get login():Signal {
        return this._login;
    }

    public function get register():Signal {
        return this._register;
    }

    private function makeUIElements():void {
        this.makeAccountText();
        this.makeLoginButton();
        this.makeDividerText();
        this.makeRegisterButton();
    }

    private function makeSignals():void {
        this._login = new NativeMappedSignal(this.loginButton, MouseEvent.CLICK);
        this._register = new NativeMappedSignal(this.registerButton, MouseEvent.CLICK);
    }

    private function makeAccountText():void {
        this.accountText = new SimpleText(FONT_SIZE, 11776947, false, 0, 0);
        this.accountText.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4)];
    }

    private function makeLoginButton():void {
        this.loginButton = new TitleMenuOption("log in", FONT_SIZE, false);
    }

    private function makeRegisterButton():void {
        this.registerButton = new TitleMenuOption(REGISTER, FONT_SIZE, false);
    }

    private function makeDividerText():void {
        this.dividerText = new SimpleText(FONT_SIZE, 11776947, false, 0, 0);
        this.dividerText.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4)];
        this.dividerText.text = " - ";
        this.dividerText.updateMetrics();
    }

    public function setInfo(userName:String, isRegistered:Boolean):void {
        this.userName = userName;
        this.isRegistered = isRegistered;
        this.updateUI();
    }

    private function updateUI():void {
        this.removeUIElements();
        if (this.isRegistered) {
            this.showUIForRegisteredAccount();
        } else {
            this.showUIForGuestAccount();
        }
    }

    private function removeUIElements():void {
        while (numChildren) {
            removeChildAt(0);
        }
    }

    private function showUIForRegisteredAccount():void {
        this.accountText.text = LOGGED_IN_TEXT.replace("${userName}", this.userName);
        this.accountText.updateMetrics();
        this.loginButton.setText(LOG_OUT);
        this.addAndAlignHorizontally(this.accountText, this.loginButton);
    }

    private function showUIForGuestAccount():void {
        this.accountText.text = GUEST_ACCOUNT;
        this.accountText.updateMetrics();
        this.loginButton.setText(LOG_IN);
        this.addAndAlignHorizontally(this.accountText, this.registerButton, this.dividerText, this.loginButton);
    }

    private function addAndAlignHorizontally(...uiElements):void {
        var ui:DisplayObject = null;
        var x:int = 0;
        var i:int = uiElements.length;
        while (i--) {
            ui = uiElements[i];
            x = x - ui.width;
            ui.x = x;
            addChild(ui);
        }
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebQuitDialog.as">
package svera.untiered.account.web.view {
import com.company.assembleegameclient.account.ui.Frame;

import flash.events.MouseEvent;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class WebQuitDialog extends Frame {
    public var cancel:Signal;
    public var quit:Signal;

    public function WebQuitDialog() {
        super("Would you like to quit?", "Yes", "No");
        this.cancel = new NativeMappedSignal(rightButton_, MouseEvent.CLICK);
        this.quit = new NativeMappedSignal(leftButton_, MouseEvent.CLICK);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebRegisterDialog.as">
package svera.untiered.account.web.view {
import com.company.assembleegameclient.account.ui.Frame;
import com.company.ui.SimpleText;

import flash.events.MouseEvent;
import flash.events.TextEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.account.web.model.AccountData;

public class WebRegisterDialog extends Frame {
    private const SIGN_IN_TEXT:String = "Already registered? <font color=\"#7777EE\"><a href=\"event:flash.events.TextEvent\">here</a></font> to sign in!";

    private const REGISTER_IMPERATIVE:String = "Register in order to save your progress";

    private const PASSWORDS_DONT_MATCH:String = "The password did not match";

    private const PASSWORD_TOO_SHORT:String = "Password must be at least 9 characters long";

    private const INVALID_USERNAME:String = "Username must be between 1-12 characters and no spaces";

    public var register:Signal;

    public var signIn:Signal;

    public var cancel:Signal;

    private const errors:Array = [];

    private var usernameInput:LabeledField;

    private var passwordInput:LabeledField;

    private var retypePasswordInput:LabeledField;

    private var signInText:SimpleText;

    public function WebRegisterDialog() {
        super(this.REGISTER_IMPERATIVE, "Cancel", "Register", 326);
        this.makeUIElements();
        this.makeSignals();
    }

    private function makeUIElements():void {
        this.usernameInput = new LabeledField("Username", false, 275);
        this.passwordInput = new LabeledField("Password", true, 275);
        this.retypePasswordInput = new LabeledField("Retype Password", true, 275);
        this.signInText = new SimpleText(12, 11776947, false, 0, 0, true);
        this.signInText.setBold(true);
        this.signInText.htmlText = this.SIGN_IN_TEXT;
        this.signInText.updateMetrics();
        this.signInText.filters = [new DropShadowFilter(0, 0, 0)];
        this.signInText.addEventListener(TextEvent.LINK, this.linkEvent);
        addLabeledField(this.usernameInput);
        addLabeledField(this.passwordInput);
        addLabeledField(this.retypePasswordInput);
        addSpace(8);
        addComponent(this.signInText, 14);
    }

    private function linkEvent(event_:TextEvent):void {
        this.signIn.dispatch();
    }

    private function makeSignals():void {
        this.cancel = new NativeMappedSignal(leftButton_, MouseEvent.CLICK);
        rightButton_.addEventListener(MouseEvent.CLICK, this.onRegister);
        this.register = new Signal(AccountData);
        this.signIn = new Signal();
    }

    private function onRegister(event:MouseEvent):void {
        var areValid:Boolean = this.areInputsValid();
        this.displayErrors();
        if (areValid) {
            this.sendData();
        }
    }

    private function areInputsValid():Boolean {
        this.errors.length = 0;
        var isValid:Boolean = true;
        isValid = this.isUsernameValid() && isValid;
        isValid = this.isPasswordValid() && isValid;
        isValid = this.isPasswordVerified() && isValid;
        return isValid;
    }

    private function isUsernameValid():Boolean {
        var isValid:Boolean = Boolean(usernameInput.text().match(/[a-zA-Z]/)) && this.usernameInput.text().length > 2 && this.usernameInput.text().length <= 12;
        this.passwordInput.setErrorHighlight(!isValid);
        if (!isValid) {
            this.errors.push(this.INVALID_USERNAME);
        }
        return isValid;
    }

    private function isPasswordValid():Boolean {
        var isValid:Boolean = this.passwordInput.text().length >= 8;
        this.passwordInput.setErrorHighlight(!isValid);
        if (!isValid) {
            this.errors.push(this.PASSWORD_TOO_SHORT);
        }
        return isValid;
    }

    private function isPasswordVerified():Boolean {
        var isValid:Boolean = this.passwordInput.text() == this.retypePasswordInput.text();
        this.retypePasswordInput.setErrorHighlight(!isValid);
        if (!isValid) {
            this.errors.push(this.PASSWORDS_DONT_MATCH);
        }
        return isValid;
    }

    public function displayErrors():void {
        if (this.errors.length == 0) {
            this.clearErrors();
        } else {
            this.displayErrorText(this.errors[0]);
        }
    }

    public function displayServerError(value:String):void {
        this.displayErrorText(value);
    }

    private function clearErrors():void {
        titleText_.text = this.REGISTER_IMPERATIVE;
        titleText_.updateMetrics();
        titleText_.setColor(11776947);
    }

    private function displayErrorText(value:String):void {
        titleText_.text = value;
        titleText_.updateMetrics();
        titleText_.setColor(16549442);
    }

    private function sendData():void {
        var data:AccountData = new AccountData();
        data.username = this.usernameInput.text();
        data.password = this.passwordInput.text();
        this.register.dispatch(data);
    }
}
}
</file>

<file path="src/svera/untiered/account/web/WebAccount.as">
package svera.untiered.account.web {
import com.company.assembleegameclient.parameters.Parameters;

import flash.net.SharedObject;

import svera.untiered.account.core.Account;

public class WebAccount implements Account {
    private var username:String = "";
    private var password:String;

    public function WebAccount() {
        super();
    }

    public function getUserName():String {
        return this.username;
    }

    public function getUsername():String {
        return this.username = this.username || null;
    }

    public function getPassword():String {
        return this.password || "";
    }

    public function getCredentials():Object {
        return {
            "username": this.getUsername(),
            "password": this.getPassword()
        };
    }

    public function isRegistered():Boolean {
        return this.getPassword() != "";
    }

    public function updateUser(userId:String, password:String):void {
        var rotmg:SharedObject = null;
        this.username = userId;
        this.password = password;
        try {
            rotmg = SharedObject.getLocal("OWRotMG", "/");
            rotmg.data["Username"] = userId;
            rotmg.data["Password"] = password;
            rotmg.flush();
        } catch (error:Error) {
        }
    }

    public function clear():void {
        this.updateUser(null, null);
        Parameters.data_.charIdUseMap = {};
        Parameters.save();
    }

    public function reportIntStat(name:String, value:int):void {
        trace("Setting int stat \"" + name + "\" to \"" + value + "\"");
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/control/ReskinHandler.as">
package svera.untiered.characters.reskin.control {
import com.company.assembleegameclient.objects.Player;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.game.model.GameModel;
import svera.untiered.messaging.impl.outgoing.Reskin;

public class ReskinHandler {


    [Inject]
    public var model:GameModel;

    [Inject]
    public var classes:ClassesModel;

    [Inject]
    public var factory:CharacterFactory;

    public function ReskinHandler() {
        super();
    }

    public function execute(reskin:Reskin):void {
        var player:Player;
        var skinID:int;
        var charType:CharacterClass;
        player = reskin.player || this.model.player;
        skinID = reskin.skinID;
        charType = this.classes.getCharacterClass(player.objectType_);
        var skin:CharacterSkin = charType.skins.getSkin(skinID);
        player.skinId = skinID;
        player.skin = this.factory.makeCharacter(skin.template);
        player.isDefaultAnimatedChar = false;
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/view/ReskinPanel.as">
package svera.untiered.characters.reskin.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.ui.SimpleText;

import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class ReskinPanel extends Panel {

    private static const TITLE:String = "Change Skin";

    private static const CHOOSE:String = "Choose";


    private const title:SimpleText = makeTitle();

    private const button:TextButton = makeButton();

    public const reskin:Signal = new NativeMappedSignal(button, MouseEvent.CLICK);

    public function ReskinPanel(gs:GameSprite) {
        super(gs);
    }

    private function makeTitle():SimpleText {
        var title:SimpleText;
        title = new SimpleText(18, 16777215, false, WIDTH, 0);
        title.setBold(true);
        title.wordWrap = true;
        title.multiline = true;
        title.autoSize = TextFieldAutoSize.CENTER;
        title.filters = [new DropShadowFilter(0, 0, 0)];
        title.htmlText = "<p align=\"center\">" + TITLE + "</p>";
        addChild(title);
        return title;
    }

    private function makeButton():TextButton {
        var button:TextButton = new TextButton(16, CHOOSE);
        button.x = WIDTH / 2 - button.width / 2;
        button.y = HEIGHT - button.height - 4;
        addChild(button);
        return button;
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/BuyCharacterSkinSignal.as">
package svera.untiered.classes.control {
import org.osflash.signals.Signal;

import svera.untiered.classes.model.CharacterSkin;

public class BuyCharacterSkinSignal extends Signal {
    public function BuyCharacterSkinSignal() {
        super(CharacterSkin);
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/FocusCharacterSkinSignal.as">
package svera.untiered.classes.control {
import org.osflash.signals.Signal;

import svera.untiered.classes.model.CharacterSkin;

public class FocusCharacterSkinSignal extends Signal {
    public function FocusCharacterSkinSignal() {
        super(CharacterSkin);
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/ParseClassesXMLSignal.as">
package svera.untiered.classes.control {
import org.osflash.signals.Signal;

public class ParseClassesXMLSignal extends Signal {
    public function ParseClassesXMLSignal() {
        super(XML);
    }
}
}
</file>

<file path="src/svera/untiered/classes/model/CharacterClass.as">
package svera.untiered.classes.model {
import com.company.assembleegameclient.appengine.CharacterStats;

import org.osflash.signals.Signal;

public class CharacterClass {
    public const selected:Signal = new Signal(CharacterClass);

    public var id:int;

    public var name:String;

    public var description:String;

    public var hitSound:String;

    public var deathSound:String;

    public var bloodProb:Number;

    public var slotTypes:Vector.<int>;

    public var defaultEquipment:Vector.<int>;

    public var hp:CharacterClassStat;

    public var sp:CharacterClassStat;

    public var rp:CharacterClassStat;

    public var attack:CharacterClassStat;

    public var armor:CharacterClassStat;

    public var speed:CharacterClassStat;

    public var dexterity:CharacterClassStat;

    public var hpRegeneration:CharacterClassStat;

    public var mpRegeneration:CharacterClassStat;

    private var maxLevelAchieved:int;

    private var isSelected:Boolean;

    public const skins:CharacterSkins = new CharacterSkins();

    private var stats:CharacterStats;

    public function CharacterClass() {
        super();
    }

    public function getIsSelected():Boolean {
        return this.isSelected;
    }

    public function setIsSelected(value:Boolean):void {
        if (this.isSelected != value) {
            this.isSelected = value;
            this.isSelected && this.selected.dispatch(this);
        }
    }

    public function getStats():CharacterStats {
        return this.stats;
    }
}
}
</file>

<file path="src/svera/untiered/classes/model/CharacterSkin.as">
package svera.untiered.classes.model {
import com.company.assembleegameclient.parameters.Parameters;

import org.osflash.signals.Signal;

import svera.untiered.assets.model.CharacterTemplate;

public class CharacterSkin {
    public const changed:Signal = new Signal(CharacterSkin);
    public var bought:Signal = new Signal(CharacterSkin);

    public var id:int = 0;
    public var name:String = "";
    public var template:CharacterTemplate;
    public var cost:int = Parameters.CHARACTER_SKIN_PRICE;
    private var state:CharacterSkinState;
    private var isSelected:Boolean;

    public function CharacterSkin() {
        this.state = CharacterSkinState.NULL;
        super();
    }

    public function getIsSelected():Boolean {
        return this.isSelected;
    }

    public function setIsSelected(value:Boolean):void {
        if (this.isSelected != value) {
            this.isSelected = value;
            this.changed.dispatch(this);
        }
    }

    public function getState():CharacterSkinState {
        return this.state;
    }

    public function setState(value:CharacterSkinState):void {
        if (this.state != value) {
            this.state = value;
            this.changed.dispatch(this);
        }
    }
}
}
</file>

<file path="src/svera/untiered/classes/services/BuySkinTask.as">
package svera.untiered.classes.services {
import com.company.assembleegameclient.ui.dialogs.ErrorDialog;

import svera.lib.tasks.BaseTask;
import svera.untiered.account.core.Account;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class BuySkinTask extends BaseTask {


    [Inject]
    public var skin:CharacterSkin;

    [Inject]
    public var client:AppEngineClient;

    [Inject]
    public var account:Account;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function BuySkinTask() {
        super();
    }

    override protected function startTask():void {
        this.skin.setState(CharacterSkinState.PURCHASING);
        this.player.changeTsavorite(-this.skin.cost);
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("account/purchaseSkin", this.makeCredentials());
    }

    private function makeCredentials():Object {
        var credentials:Object = this.account.getCredentials();
        credentials.skinType = this.skin.id;
        return credentials;
    }

    private function onComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.completePurchase();
        } else {
            this.abandonPurchase(data);
        }
        completeTask(isOK, data);
    }

    private function completePurchase():void {
        this.skin.setState(CharacterSkinState.OWNED);
        this.skin.setIsSelected(true);
        skin.bought.dispatch(skin);
    }

    private function abandonPurchase(problem:String):void {
        var errorDialog:ErrorDialog = new ErrorDialog(problem);
        this.openDialog.dispatch(errorDialog);
        this.skin.setState(CharacterSkinState.PURCHASABLE);
        this.player.changeTsavorite(this.skin.cost);
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinListMediator.as">
package svera.untiered.classes.view {
import flash.display.DisplayObject;

import svera.lib.framework.Mediator;

import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.ClassesModel;

public class CharacterSkinListMediator extends Mediator {
    [Inject]
    public var view:CharacterSkinListView;

    [Inject]
    public var model:ClassesModel;

    [Inject]
    public var factory:CharacterSkinListItemFactory;

    public function CharacterSkinListMediator() {
        super();
    }

    override public function initialize():void {
        this.model.selected.add(this.setSkins);
        this.setSkins(this.model.getSelected());
    }

    override public function destroy():void {
        this.model.selected.remove(this.setSkins);
    }

    private function setSkins(charClass:CharacterClass):void {
        var items:Vector.<CharacterSkinListItem> = this.factory.make(charClass.skins);
        this.view.setItems(items);
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinMediator.as">
package svera.untiered.classes.view {
import com.company.assembleegameclient.screens.NewCharacterScreen;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.traits.TraitsGUI;

public class CharacterSkinMediator extends Mediator {
    [Inject]
    public var view:CharacterSkinView;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    public function CharacterSkinMediator() {
        super();
    }

    override public function initialize():void {
        var hasSlot:Boolean = this.model.hasAvailableCharSlot();
        this.view.setPlayButtonEnabled(hasSlot);
        if (hasSlot) {
            this.view.play.addOnce(this.onPlay);
        }
        this.view.back.addOnce(this.onBack);
    }

    override public function destroy():void {
        this.view.back.remove(this.onBack);
        this.view.play.remove(this.onPlay);
    }

    private function onBack():void {
        this.setScreen.dispatch(new NewCharacterScreen());
    }

    private function onPlay():void {
        if (view.playBtn.active)
            setScreen.dispatch(new TraitsGUI());
    }
}
}
</file>

<file path="src/svera/untiered/core/model/PlayerModel.as">
package svera.untiered.core.model {
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.appengine.SavedCharactersList;
import com.company.assembleegameclient.appengine.SavedNewsItem;

import org.osflash.signals.Signal;

import svera.untiered.account.core.Account;

public class PlayerModel {
    public const tsavoriteChanged:Signal = new Signal(int);
    public const medallionsChanged:Signal = new Signal(int);
    public const honorChanged:Signal = new Signal(int);
    public var charList:SavedCharactersList;
    public var isInvalidated:Boolean;
    public var currentCharId:int;

    [Inject]
    public var account:Account;

    public function PlayerModel() {
        super();
        this.isInvalidated = true;
    }

    public function getMaxCharacters():int {
        return this.charList.maxNumChars_;
    }

    public function setMaxCharacters(value:int):void {
        this.charList.maxNumChars_ = value;
    }

    public function getTraits():Array {
        return [this.charList.traitOne_, this.charList.traitTwo_, this.charList.traitThree_];
    }

    public function getTsavorite():int {
        return this.charList.tsavorite_;
    }

    public function changeTsavorite(tsavorite:int):void {
        this.charList.tsavorite_ = this.charList.tsavorite_ + tsavorite;
        this.tsavoriteChanged.dispatch(this.charList.tsavorite_);
    }

    public function setTsavorite(tsavorite:int):void {
        if (this.charList.tsavorite_ != tsavorite) {
            this.charList.tsavorite_ = tsavorite;
            this.tsavoriteChanged.dispatch(tsavorite);
        }
    }

    public function getMedallions():int {
        return this.charList.medallions_;
    }

    public function changeMedallions(medallions:int):void {
        this.charList.medallions_ = this.charList.medallions_ + medallions;
        this.medallionsChanged.dispatch(this.charList.medallions_);
    }

    public function setMedallions(medallions:int):void {
        if (this.charList.medallions_ != medallions) {
            this.charList.medallions_ = medallions;
            this.medallionsChanged.dispatch(medallions);
        }
    }

    public function getHonor():int {
        return this.charList.honor_;
    }

    public function changeHonor(honor:int):void {
        this.charList.honor_ = this.charList.honor_ + honor;
        this.honorChanged.dispatch(this.charList.honor_);
    }

    public function setHonor(honor:int):void {
        if (this.charList.honor_ != honor) {
            this.charList.honor_ = honor;
            this.honorChanged.dispatch(honor);
        }
    }

    public function getCharacterCount():int {
        return this.charList.numChars_;
    }

    public function getCharById(characterId:int):SavedCharacter {
        return this.charList.getCharById(characterId);
    }

    public function deleteCharacter(characterId:int):void {
        var char:SavedCharacter = this.charList.getCharById(characterId);
        var i:int = this.charList.savedChars_.indexOf(char);
        if (i != -1) {
            this.charList.savedChars_.splice(i, 1);
            this.charList.numChars_--;
        }
    }

    public function getAccountId():int {
        return this.charList.accountId_;
    }

    public function hasAccount():Boolean {
        return this.charList.accountId_ != -1;
    }

    public function getNumStars():int {
        return this.charList.numStars_;
    }

    public function getGuildName():String {
        return this.charList.guildName_;
    }

    public function getGuildRank():int {
        return this.charList.guildRank_;
    }

    public function getNextCharId():int {
        return this.charList.nextCharId_;
    }

    public function getCharacterById(id:int):SavedCharacter {
        var savedChar:SavedCharacter = null;
        for each(savedChar in this.charList.savedChars_) {
            if (savedChar.charId() == id) {
                return savedChar;
            }
        }
        return null;
    }

    public function getCharacterByIndex(i:int):SavedCharacter {
        return this.charList.savedChars_[i];
    }

    public function getNews():Vector.<SavedNewsItem> {
        return this.charList.news_;
    }

    public function getName():String {
        return this.charList.name_;
    }

    public function setName(value:String):void {
        this.charList.name_ = value;
    }

    public function hasAvailableCharSlot():Boolean {
        return this.charList.hasAvailableCharSlot();
    }

    public function getAvailableCharSlots():int {
        return this.charList.availableCharSlots();
    }

    public function getSavedCharacters():Vector.<SavedCharacter> {
        return this.charList.savedChars_;
    }

    public function getCharStats():Object {
        return this.charList.charStats_;
    }

    public function getBestHonor(objectType:int):int {
        return this.charList.bestHonor(objectType);
    }

    public function getBestLevel(unlockType:int):int {
        return this.charList.bestLevel(unlockType);
    }

    public function setCharacterList(savedCharactersList:SavedCharactersList):void {
        this.charList = savedCharactersList;
    }
}
}
</file>

<file path="src/svera/untiered/core/signals/SetScreenSignal.as">
package svera.untiered.core.signals {
import flash.display.Sprite;

import org.osflash.signals.Signal;

public class SetScreenSignal extends Signal {
    public function SetScreenSignal() {
        super(Sprite);
    }
}
}
</file>

<file path="src/svera/untiered/core/view/ScreensMediator.as">
package svera.untiered.core.view {
import flash.display.Sprite;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.ScreenModel;
import svera.untiered.core.signals.GotoPreviousScreenSignal;
import svera.untiered.core.signals.SetScreenSignal;

public class ScreensMediator extends Mediator {
    [Inject]
    public var view:ScreensView;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var model:ScreenModel;

    [Inject]
    public var gotoPrevious:GotoPreviousScreenSignal;

    public function ScreensMediator() {
        super();
    }

    override public function initialize():void {
        this.setScreen.add(this.onSetScreen);
        this.gotoPrevious.add(this.onGotoPrevious);
    }

    override public function destroy():void {
        this.setScreen.remove(this.onSetScreen);
        this.gotoPrevious.add(this.onGotoPrevious);
    }

    private function onSetScreen(screen:Sprite):void {
        this.model.currentType = Object(screen).constructor as Class;
        this.view.setScreen(screen);
    }

    private function onGotoPrevious():void {
        this.view.setScreen(this.view.getPrevious());
    }
}
}
</file>

<file path="src/svera/untiered/core/view/ScreensView.as">
package svera.untiered.core.view {
import flash.display.Sprite;

public class ScreensView extends Sprite {
    private var current:Sprite;

    private var previous:Sprite;

    public function ScreensView() {
        super();
    }

    public function setScreen(sprite:Sprite):void {
        if (this.current == sprite) {
            return;
        }
        this.removePrevious();
        this.current = sprite;

        addChild(sprite);
    }

    private function removePrevious():void {
        if (this.current && contains(this.current)) {
            this.previous = this.current;
            removeChild(this.current);
        }
    }

    public function getPrevious():Sprite {
        return this.previous;
    }
}
}
</file>

<file path="src/svera/untiered/death/control/HandleDeathCommand.as">
package svera.untiered.death.control {
import com.company.assembleegameclient.sound.Music;

import svera.lib.framework.ICommand;

import svera.untiered.core.model.PlayerModel;
import svera.untiered.death.model.DeathModel;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.messaging.impl.incoming.Death;

public class HandleDeathCommand implements ICommand {


    [Inject]
    public var death:Death;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    [Inject]
    public var model:DeathModel;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var normal:HandleNormalDeathSignal;

    public function HandleDeathCommand() {
        super();
    }

    public function execute():void {
        Music.load(Music.DEATH_MUSIC);
        this.closeDialogs.dispatch();
        if (this.isDeathPending()) {
            this.passPreviousDeathToHonorView();
        } else {
            this.updateModelAndHandleDeath();
        }
    }

    private function isDeathPending():Boolean {
        return this.model.getIsDeathViewPending();
    }

    private function passPreviousDeathToHonorView():void {
        this.normal.dispatch(this.model.getLastDeath());
    }

    private function updateModelAndHandleDeath():void {
        this.model.setLastDeath(this.death);
        this.normal.dispatch(this.death);
    }
}
}
</file>

<file path="src/svera/untiered/death/control/HandleNormalDeathCommand.as">
package svera.untiered.death.control {

import svera.lib.framework.ICommand;
import svera.lib.tasks.DispatchSignalTask;
import svera.lib.tasks.TaskMonitor;
import svera.lib.tasks.TaskSequence;
import svera.untiered.account.core.services.GetCharListTask;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.honor.control.ShowHonorViewSignal;
import svera.untiered.honor.model.HonorVO;
import svera.untiered.honor.model.SimpleHonorVO;
import svera.untiered.game.signals.DisconnectGameSignal;
import svera.untiered.messaging.impl.incoming.Death;

public class HandleNormalDeathCommand implements ICommand {


    [Inject]
    public var death:Death;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var task:GetCharListTask;

    [Inject]
    public var showHonor:ShowHonorViewSignal;

    [Inject]
    public var monitor:TaskMonitor;

    [Inject]
    public var disconnect:DisconnectGameSignal;

    private var honorVO:HonorVO;

    public function HandleNormalDeathCommand() {
        super();
    }

    public function execute():void {
        this.honorVO = new SimpleHonorVO(this.death.accountId_, this.death.charId_);
        this.gotoHonorView();
    }

    private function gotoHonorView():void {
        if (this.player.getAccountId() == -1) {
            this.gotoHonorViewOnceDataIsLoaded();
        } else {
            this.showHonor.dispatch(this.honorVO);
        }
    }

    private function gotoHonorViewOnceDataIsLoaded():void {
        var sequence:TaskSequence = new TaskSequence();
        sequence.add(this.task);
        sequence.add(new DispatchSignalTask(this.showHonor, this.honorVO));
        this.monitor.add(sequence);
        sequence.start();
    }
}
}
</file>

<file path="src/svera/untiered/death/model/DeathModel.as">
package svera.untiered.death.model {
import svera.untiered.messaging.impl.incoming.Death;

public class DeathModel {


    private var isDeathHonorViewPending:Boolean;

    private var lastDeath:Death;

    public function DeathModel() {
        super();
    }

    public function setLastDeath(death:Death):void {
        this.lastDeath = death;
        this.isDeathHonorViewPending = true;
    }

    public function getLastDeath():Death {
        return this.lastDeath;
    }

    public function getIsDeathViewPending():Boolean {
        return this.isDeathHonorViewPending;
    }

    public function clearPendingDeathView():void {
        this.isDeathHonorViewPending = false;
    }
}
}
</file>

<file path="src/svera/untiered/dialogs/control/OpenDialogSignal.as">
package svera.untiered.dialogs.control {
import flash.display.Sprite;

import org.osflash.signals.Signal;

public class OpenDialogSignal extends Signal {
    public function OpenDialogSignal() {
        super(Sprite);
    }
}
}
</file>

<file path="src/svera/untiered/dialogs/control/ShowDialogBackgroundSignal.as">
package svera.untiered.dialogs.control {
import org.osflash.signals.Signal;

public class ShowDialogBackgroundSignal extends Signal {
    public function ShowDialogBackgroundSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/dialogs/view/DialogsView.as">
package svera.untiered.dialogs.view {
import flash.display.DisplayObjectContainer;
import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;

public class DialogsView extends Sprite {
    private var background:Shape;

    private var container:DisplayObjectContainer;

    private var current:Sprite;

    public function DialogsView() {
        super();
        addChild(this.background = new Shape());
        addChild(this.container = new Sprite());
        this.background.visible = false;
    }

    public function showBackground(color:int = 1381653):void {
        var g:Graphics = this.background.graphics;
        g.clear();
        g.beginFill(color, 0.6);
        g.drawRect(0, 0, GameClient.StageWidth, GameClient.StageHeight);
        g.endFill();
        this.background.visible = true;
    }

    public function show(dialog:Sprite):void {
        this.removeCurrentDialog();
        this.addDialog(dialog);
    }

    public function hideAll():void {
        this.background.visible = false;
        this.removeCurrentDialog();
    }

    private function addDialog(dialog:Sprite):void {
        this.current = dialog;
        dialog.addEventListener(Event.REMOVED, this.onRemoved);
        this.container.addChild(dialog);
        this.showBackground();
    }

    private function onRemoved(event:Event):void {
        var target:Sprite = event.target as Sprite;
        if (this.current == target) {
            this.background.visible = false;
            this.current = null;
        }
    }

    private function removeCurrentDialog():void {
        if (this.current && this.container.contains(this.current)) {
            this.current.removeEventListener(Event.REMOVED, this.onRemoved);
            this.container.removeChild(this.current);
            this.background.visible = false;
        }
    }
}
}
</file>

<file path="src/svera/untiered/game/commands/PlayGameCommand.as">
package svera.untiered.game.commands {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.parameters.Parameters;

import svera.lib.framework.ICommand;

import svera.lib.tasks.TaskMonitor;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.game.model.GameInitData;

public class PlayGameCommand implements ICommand {


    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var data:GameInitData;

    [Inject]
    public var model:PlayerModel;

    [Inject]
    public var monitor:TaskMonitor;

    public function PlayGameCommand() {
        super();
    }

    public function execute():void {
        this.recordCharacterUseInSharedObject();
        this.makeGameView();
    }

    private function recordCharacterUseInSharedObject():void {
        Parameters.data_.charIdUseMap[this.data.charId] = new Date().getTime();
        Parameters.save();
    }

    private function makeGameView():void {
        var gameId:int = this.data.isNewGame ? int(this.getInitialGameId()) : int(this.data.gameId);
        var createCharacter:Boolean = this.data.createCharacter;
        var charId:int = this.data.charId;
        this.model.currentCharId = charId;
        this.setScreen.dispatch(new GameSprite(gameId, createCharacter, charId, this.model, null, this.data.traits));
    }

    private function getInitialGameId():int {
        var gameId:int;
        gameId = Parameters.NEXUS_GAMEID;
        return gameId;
    }
}
}
</file>

<file path="src/svera/untiered/game/commands/TransitionFromGameToMenuCommand.as">
package svera.untiered.game.commands {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;

import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.death.model.DeathModel;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.honor.control.ShowHonorViewSignal;
import svera.untiered.honor.model.HonorVO;
import svera.untiered.honor.model.SimpleHonorVO;
import svera.untiered.messaging.impl.incoming.Death;

public class TransitionFromGameToMenuCommand {


    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var model:DeathModel;

    [Inject]
    public var invalidate:InvalidateDataSignal;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var showHonorView:ShowHonorViewSignal;

    [Inject]
    public var closeDialogsSignal:CloseDialogsSignal;

    public function TransitionFromGameToMenuCommand() {
        super();
    }

    public function execute():void {
        this.invalidate.dispatch();
        closeDialogsSignal.dispatch();
        if (this.model.getIsDeathViewPending()) {
            this.showDeathView();
        } else {
            this.showCurrentCharacterScreen();
        }
    }

    private function showDeathView():void {
        var death:Death = this.model.getLastDeath();
        var honorVO:HonorVO = new SimpleHonorVO(this.player.getAccountId(), death.charId_);
        this.showHonorView.dispatch(honorVO);
    }

    private function showCurrentCharacterScreen():void {
        this.setScreenWithValidData.dispatch(new CharacterSelectionAndNewsScreen());
    }
}
}
</file>

<file path="src/svera/untiered/game/model/PotionInventoryModel.as">
package svera.untiered.game.model {
import flash.utils.Dictionary;

import org.osflash.signals.Signal;

import svera.untiered.ui.model.PotionModel;

public class PotionInventoryModel {

    public static const HEALTH_POTION_ID:int = 2594;
    public static const HEALTH_POTION_SLOT:int = 254;

    public static const MAGIC_POTION_ID:int = 2595;
    public static const MAGIC_POTION_SLOT:int = 255;

    public static const MAX_STACKS:int = 6;


    public var potionModels:Dictionary;

    public var updatePosition:Signal;

    public function PotionInventoryModel() {
        super();
        this.potionModels = new Dictionary();
        this.updatePosition = new Signal(int);

        var potModel:PotionModel;
        potModel = new PotionModel();
        potModel.maxPotionCount = MAX_STACKS;
        potModel.objectId = HEALTH_POTION_ID;
        potModel.position = 0;
        this.potionModels[potModel.position] = potModel;
        potModel.update.add(this.update);
        potModel = new PotionModel();
        potModel.maxPotionCount = MAX_STACKS;
        potModel.objectId = MAGIC_POTION_ID;
        potModel.position = 1;
        this.potionModels[potModel.position] = potModel;
        potModel.update.add(this.update);
    }

    public static function getPotionSlot(objectType:int):int {
        switch (objectType) {
            case HEALTH_POTION_ID:
                return HEALTH_POTION_SLOT;
            case MAGIC_POTION_ID:
                return MAGIC_POTION_SLOT;
            default:
                return -1;
        }
    }

    public function getPotionModel(objectId:uint):PotionModel {
        var key:* = null;
        for (key in this.potionModels) {
            if (this.potionModels[key].objectId == objectId) {
                return this.potionModels[key];
            }
        }
        return null;
    }

    private function update(position:int):void {
        this.updatePosition.dispatch(position);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/components/StatView.as">
package svera.untiered.game.view.components {
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.filters.DropShadowFilter;
import flash.text.TextFormat;

public class StatView extends Sprite {
    public var fullName_:String;

    public var description_:String;

    public var nameText_:SimpleText;

    public var valText_:SimpleText;

    public var redOnZero_:Boolean;

    public var val_:int = -1;

    public var boost_:int = -1;

    public var valColor_:uint = 11776947;

    public function StatView(name:String, fullName:String, desc:String, redOnZero:Boolean) {
        super();
        this.fullName_ = fullName;
        this.description_ = desc;
        this.nameText_ = new SimpleText(13, 11776947, false, 0, 0);
        this.nameText_.text = name + " -";
        this.nameText_.updateMetrics();
        //nameText_.x = -this.nameText_.width;
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.nameText_);
        this.valText_ = new SimpleText(13, this.valColor_, false, 0, 0);
        this.valText_.x = this.nameText_.width;

        this.valText_.setBold(true);
        this.valText_.text = "-";
        this.valText_.updateMetrics();
        this.valText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.valText_);
        this.redOnZero_ = redOnZero;
    }

    public function draw(val:int, boost:int, max:int):void {
        var newValColor:uint = 0;
        var format:TextFormat = null;
        if (val == this.val_ && boost == this.boost_) {
            return;
        }
        this.val_ = val;
        this.boost_ = boost;
        if (val - boost >= max) {
            newValColor = 16572160;
        } else if (this.redOnZero_ && this.val_ <= 0 || this.boost_ < 0) {
            newValColor = 16726072;
        } else if (this.boost_ > 0) {
            newValColor = 6206769;
        } else {
            newValColor = 11776947;
        }
        if (this.valColor_ != newValColor) {
            this.valColor_ = newValColor;
            format = this.valText_.defaultTextFormat;
            format.color = this.valColor_;
            this.valText_.setTextFormat(format);
            this.valText_.defaultTextFormat = format;
        }
        this.valText_.text = this.val_.toString();
        if (this.boost_ != 0) {
            this.valText_.text = this.valText_.text + (" (" + (this.boost_ > 0 ? "+" : "") + this.boost_.toString() + ")");
        }
        this.valText_.updateMetrics();
    }
}
}
</file>

<file path="src/svera/untiered/game/view/CurrencyDisplayMediator.as">
package svera.untiered.game.view {
import svera.lib.framework.Mediator;

import svera.untiered.core.model.PlayerModel;

public class CurrencyDisplayMediator extends Mediator {


    [Inject]
    public var view:CurrencyDisplay;

    [Inject]
    public var model:PlayerModel;

    public function CurrencyDisplayMediator() {
        super();
    }

    override public function initialize():void {
        this.model.tsavoriteChanged.add(this.onTsavoriteChanged);
        this.model.medallionsChanged.add(this.onMedallionsChanged);
        this.model.honorChanged.add(this.onHonorChanged);
        this.model.honorChanged.add(this.onHonorChanged);
        this.view.draw(this.model.getTsavorite(), this.model.getMedallions(), this.model.getHonor());
    }

    override public function destroy():void {
        this.model.tsavoriteChanged.remove(this.onTsavoriteChanged);
        this.model.medallionsChanged.remove(this.onMedallionsChanged);
        this.model.honorChanged.remove(this.onHonorChanged);
        this.model.honorChanged.remove(this.onHonorChanged);
    }

    private function onTsavoriteChanged(tsavorite:int):void {
        this.view.draw(tsavorite, this.model.getMedallions(), this.model.getHonor());
    }

    private function onMedallionsChanged(medallions:int):void {
        this.view.draw(this.model.getTsavorite(), medallions, this.model.getHonor());
    }

    private function onHonorChanged(honor:int):void {
        this.view.draw(this.model.getTsavorite(), this.model.getMedallions(), honor);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/GameSpriteMediator.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.game.events.ReconnectEvent;
import com.company.assembleegameclient.objects.Player;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.MapModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.InvalidateDataSignal;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.game.model.GameInitData;
import svera.untiered.game.signals.DisconnectGameSignal;
import svera.untiered.game.signals.GameClosedSignal;
import svera.untiered.game.signals.PlayGameSignal;
import svera.untiered.game.signals.SetWorldInteractionSignal;
import svera.untiered.ui.signals.HUDModelInitialized;
import svera.untiered.ui.signals.HUDSetupStarted;
import svera.untiered.ui.signals.UpdateHUDSignal;

public class GameSpriteMediator extends Mediator {

    [Inject]
    public var setWorldInteraction:SetWorldInteractionSignal;

    [Inject]
    public var invalidate:InvalidateDataSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var playGame:PlayGameSignal;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var gameClosed:GameClosedSignal;

    [Inject]
    public var mapModel:MapModel;

    [Inject]
    public var closeDialogs:CloseDialogsSignal;

    [Inject]
    public var disconnect:DisconnectGameSignal;

    [Inject]
    public var hudSetupStarted:HUDSetupStarted;

    [Inject]
    public var updateHUDSignal:UpdateHUDSignal;

    [Inject]
    public var hudModelInitialized:HUDModelInitialized;

    // Type-safe view accessor
    private function get gameSprite():GameSprite {
        return view as GameSprite;
    }

    override protected function onInitialize():void {
        this.setWorldInteraction.add(this.onSetWorldInteraction);

        // Replace addViewListener with direct addEventListener
        gameSprite.addEventListener(ReconnectEvent.RECONNECT, this.onReconnect);

        gameSprite.modelInitialized.add(this.onGameSpriteModelInitialized);
        gameSprite.drawCharacterWindow.add(this.onStatusPanelDraw);
        this.hudModelInitialized.add(this.onHUDModelInitialized);
        this.disconnect.add(this.onDisconnect);
        gameSprite.closed.add(this.onClosed);
        gameSprite.mapModel = this.mapModel;
        gameSprite.connect();
    }

    override protected function onDestroy():void {
        this.setWorldInteraction.remove(this.onSetWorldInteraction);

        // Replace removeViewListener with direct removeEventListener
        gameSprite.removeEventListener(ReconnectEvent.RECONNECT, this.onReconnect);

        gameSprite.modelInitialized.remove(this.onGameSpriteModelInitialized);
        gameSprite.drawCharacterWindow.remove(this.onStatusPanelDraw);
        this.hudModelInitialized.remove(this.onHUDModelInitialized);
        this.disconnect.remove(this.onDisconnect);
        gameSprite.closed.remove(this.onClosed);
        gameSprite.disconnect();
    }

    private function onDisconnect():void {
        gameSprite.disconnect();
    }

    public function onSetWorldInteraction(value:Boolean):void {
        gameSprite.mui_.setEnablePlayerInput(value);
    }

    private function onClosed():void {
        this.closeDialogs.dispatch();
        this.gameClosed.dispatch();
    }

    private function onReconnect(event:ReconnectEvent):void {
        if (gameSprite.isEditor) {
            return;
        }
        var data:GameInitData = new GameInitData();
        data.gameId = event.gameId_;
        data.createCharacter = event.createCharacter_;
        data.charId = event.charId_;
        this.playGame.dispatch(data);
    }

    private function onGameSpriteModelInitialized():void {
        this.hudSetupStarted.dispatch(gameSprite);
    }

    private function onStatusPanelDraw(player:Player):void {
        this.updateHUDSignal.dispatch(player);
    }

    private function onHUDModelInitialized():void {
        gameSprite.hudModelInitialized();
    }
}
}
</file>

<file path="src/svera/untiered/game/view/LootboxesDisplayMediator.as">
package svera.untiered.game.view {
import svera.lib.framework.Mediator;

public class LootboxesDisplayMediator extends Mediator {

    [Inject]
    public var view:LootboxesDisplay;
    [Inject]
    public var model:PlayerModel;
    [Inject]
    public var openMoneyWindow:OpenMoneyWindowSignal;


    override public function initialize():void {
        this.model.lootBox1Changed.add(this.onLootbox1Changed);
        this.model.lootBox2Changed.add(this.onLootbox2Changed);
        this.model.lootBox3Changed.add(this.onLootbox3Changed);
        this.model.lootBox4Changed.add(this.onLootbox4Changed);
        this.view.openAccountDialog.add(this.onOpenAccountDialog);
    }

    override public function destroy():void {
        this.model.lootBox1Changed.remove(this.onLootbox1Changed);
        this.model.lootBox2Changed.remove(this.onLootbox2Changed);
        this.model.lootBox3Changed.remove(this.onLootbox3Changed);
        this.model.lootBox4Changed.remove(this.onLootbox4Changed);
        this.view.openAccountDialog.remove(this.onOpenAccountDialog);
    }

    private function onLootbox1Changed(_arg_1:int):void {
        this.view.draw(this.model.getLootbox2(), this.model.getLootbox3(), this.model.getLootbox4());
    }

    private function onLootbox2Changed(_arg_1:int):void {
        this.view.draw(this.model.getLootbox2(), this.model.getLootbox3(), this.model.getLootbox4());
    }

    private function onLootbox3Changed(_arg_1:int):void {
        this.view.draw(this.model.getLootbox2(), this.model.getLootbox3(), this.model.getLootbox4());
    }

    private function onLootbox4Changed(_arg_1:int):void {
        this.view.draw(this.model.getLootbox2(), this.model.getLootbox3(), this.model.getLootbox4());
    }






    private function onOpenAccountDialog():void {
        this.openMoneyWindow.dispatch();
    }


}
}//package svera.untiered.game.view
</file>

<file path="src/svera/untiered/game/view/LootboxMediator.as">
package svera.untiered.game.view {

import svera.untiered.account.core.Account;
import svera.untiered.game.signals.UpdateLootboxButtonSignal;

public class LootboxMediator {

    [Inject]
    public var updateLootboxButtonSignal:UpdateLootboxButtonSignal;
    [Inject]
    public var view:LootboxModalButton;
    [Inject]
    public var account:Account;

    public function initialize():void {
        this.updateLootboxButtonSignal.add(this.onLootboxUpdate);
        if (this.account.isRegistered()) {
            this.view.drawAsOpen();
        }
        else {
            this.view.drawAsClosed();
        }
    }

    private function onLootboxUpdate():void {
        if (this.account.isRegistered()) {
            this.view.drawAsOpen();
        }
        else {
            this.view.drawAsClosed();
        }
    }


}
}//package svera.untiered.game.view
</file>

<file path="src/svera/untiered/game/view/SellableObjectPanel.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.objects.SellableObject;
import com.company.assembleegameclient.ui.RankText;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.assembleegameclient.util.GuildUtil;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

import org.osflash.signals.Signal;

import svera.untiered.util.components.LegacyBuyButton;

public class SellableObjectPanel extends Panel {


    public var buyItem:Signal;

    private var owner:SellableObject;

    private var nameText:SimpleText;

    private var buyButton:LegacyBuyButton;

    private var rankReqText:Sprite = null;

    private var guildRankReqText:SimpleText = null;

    private var coinIcon:Sprite;

    private var toolTip:ToolTip;

    private var bitmap:Bitmap;

    private const BUTTON_OFFSET:int = 17;

    public function SellableObjectPanel(gs:GameSprite, owner:SellableObject) {
        this.buyItem = new Signal(SellableObject);
        this.coinIcon = new Sprite();
        this.bitmap = new Bitmap();
        super(gs);
        this.createNameText();
        this.createBuyButton();
        this.setOwner(owner);
        this.createIcon();
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private static function createRankReqText(rankReq:int):Sprite {
        var requiredText:SimpleText;
        var rankText:Sprite;
        var rankReqText:Sprite = new Sprite();
        requiredText = new SimpleText(16, 16777215, false, 0, 0);
        rankText = new RankText(rankReq, false, false);
        requiredText.setBold(true);
        requiredText.text = "Rank Required:";
        requiredText.updateMetrics();
        requiredText.filters = [new DropShadowFilter(0, 0, 0)];
        rankText.x = requiredText.width + 4;
        rankText.y = (requiredText.height - rankText.height) * 0.5;
        rankReqText.addChild(requiredText);
        rankReqText.addChild(rankText);
        return rankReqText;
    }

    private static function createGuildRankReqText(guildRankReq:int):SimpleText {
        var requiredText:SimpleText;
        requiredText = new SimpleText(16, 16711680, false, 0, 0);
        requiredText.setBold(true);
        requiredText.text = GuildUtil.rankToString(guildRankReq) + " Rank Required";
        requiredText.useTextDimensions();
        requiredText.filters = [new DropShadowFilter(0, 0, 0)];
        return requiredText;
    }

    private function createBuyButton():void {
        this.buyButton = new LegacyBuyButton("", 16, 0, 0);
        this.buyButton.addEventListener(MouseEvent.CLICK, this.onBuyButtonClick);
        addChild(this.buyButton);
    }

    private function createIcon():void {
        this.bitmap.x = -4;
        this.bitmap.y = -8;
        this.bitmap.bitmapData = this.owner.getIcon();
        addChild(this.bitmap);
    }

    private function createNameText():void {
        this.nameText = new SimpleText(16, 16777215, false, WIDTH - 44, 0);
        this.nameText.setBold(true);
        this.nameText.htmlText = "<p align=\"center\">Thing For Sale</p>";
        this.nameText.wordWrap = true;
        this.nameText.multiline = true;
        this.nameText.autoSize = TextFieldAutoSize.CENTER;
        this.nameText.filters = [new DropShadowFilter(0, 0, 0)];
        this.nameText.x = 44;
        addChild(this.nameText);
    }

    public function setOwner(_owner:SellableObject):void {
        if (this.owner == _owner) {
            return;
        }
        this.owner = _owner;
        var title:String = this.owner.soldObjectName();
        this.buyButton.setPrice(this.owner.price_, _owner.currency_);
        this.nameText.htmlText = "<p align=\"center\">" + title + "</p>";
    }

    private function onAddedToStage(event:Event):void {
        this.coinIcon.addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        this.coinIcon.addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
    }

    private function onRemovedFromStage(event:Event):void {
        this.coinIcon.removeEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        this.coinIcon.removeEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        this.resetTooltip();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.resetTooltip();
        stage.addChild(this.toolTip = this.owner.getTooltip());
    }

    private function resetTooltip():void {
        if (this.toolTip) {
            if (this.toolTip.parent) {
                this.toolTip.parent.removeChild(this.toolTip);
            }
            this.toolTip = null;
        }
    }

    private function onMouseOut(event:MouseEvent):void {
        this.resetTooltip();
    }

    private function onBuyButtonClick(event:MouseEvent):void {
        this.buyItem.dispatch(this.owner, this.owner.currency_);
    }

    override public function draw():void {
        var player:Player = gs_.map.player_;
        this.nameText.y = this.nameText.height > 30 ? Number(0) : Number(12);
        var rankReq:int = this.owner.rankReq_;
        if (player.numStars_ < rankReq) {
            this.removeButtons();
            if (this.rankReqText == null || !contains(this.rankReqText)) {
                this.updateRankRequiredText(rankReq);
            }
        } else if (player.guildRank_ < this.owner.guildRankReq_) {
            this.removeButtons();
            if (this.guildRankReqText == null || !contains(this.guildRankReqText)) {
                this.updateGuildRankRequiredText();
            }
        } else {
            this.buyButton.setPrice(this.owner.price_, owner.currency_);
            this.buyButton.setEnabled(!gs_.gsc_.outstandingBuy_);
            this.buyButton.x = WIDTH / 2 - this.buyButton.width / 2;
            this.buyButton.y = HEIGHT - this.buyButton.height / 2 - this.BUTTON_OFFSET;
            this.addButtons();
            if (this.rankReqText != null && contains(this.rankReqText)) {
                removeChild(this.rankReqText);
            }
        }
    }

    private function updateRankRequiredText(rankReq:int):void {
        this.rankReqText = createRankReqText(rankReq);
        this.rankReqText.x = WIDTH / 2 - this.rankReqText.width / 2;
        this.rankReqText.y = HEIGHT - this.rankReqText.height / 2 - 20;
        addChild(this.rankReqText);
    }

    private function updateGuildRankRequiredText():void {
        this.guildRankReqText = createGuildRankReqText(this.owner.guildRankReq_);
        this.guildRankReqText.x = (WIDTH - this.guildRankReqText.width) * 0.5;
        this.guildRankReqText.y = HEIGHT - this.guildRankReqText.height / 2 - 20;
        addChild(this.guildRankReqText);
    }

    private function addButtons():void {
        if (!contains(this.buyButton)) {
            addChild(this.buyButton);
        }
    }

    private function removeButtons():void {
        if (contains(this.buyButton)) {
            removeChild(this.buyButton);
        }
    }
}
}
</file>

<file path="src/svera/untiered/itemdata/NewItemData.as">
package svera.untiered.itemdata {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.util.Base64Decoder;
import com.company.util.Guid;

import flash.utils.ByteArray;
import flash.utils.Dictionary;

public class NewItemData extends Item {

    private const keys:Dictionary = new Dictionary();// Closest thing to a hashset

    private var uuid:String = Guid.Empty;
    public final function get Uuid():String { return uuid }

    private var killTracker:int = 0;
    public final function get KillTracker():int { return killTracker; }
    public final function get HasKillTracker():Boolean { return DataKeys.KillTracker in keys; }

    private var soulbound:Boolean;
    public final override function get Soulbound():Boolean { return (DataKeys.Soulbound in keys) ? soulbound : super.Soulbound; }

    public function NewItemData(item:Item = null) {
        super(item);
        if (item == null) throw new Error("Item cannot be null");
    }

    public static function TempCreate(data:int): NewItemData {
        if (data == -1) return null;
        var item:NewItemData = new NewItemData(ObjectLibrary.baseItems[data]);
        return item;
    }

    public static function FromByteArray(data:ByteArray): NewItemData {
        var oType:int = data.readInt();
        if (oType < 1) return null;

        var item:NewItemData = new NewItemData(ObjectLibrary.baseItems[oType]);

        var keyCount:uint = data.readUnsignedShort();

        for (var i:uint = 0; i < keyCount; i++) {
            var key:int = data.readUnsignedShort();
            item.keys[key] = null;
            switch (key) {
                case DataKeys.Uuid:
                    item.uuid = Guid.guidDataToString(data);
                    break;
                case DataKeys.CommandTag:
                    data.position += 5;
                    break;
                case DataKeys.KillTracker:
                    item.killTracker = data.readInt();
                    break;
                case DataKeys.Soulbound:
                    item.soulbound = data.readBoolean();
                    break;
            }
        }

        //var low:uint = data.readUnsignedInt();
        //var high:uint = data.readUnsignedInt();
        //var ms:Number = high * 0x100000000 + low;
        //var time:Date = new Date(ms);

        return item;
    }

    public static function fromPlayerXML(obj:Object) : Vector.<NewItemData> {
        var equipment:Vector.<NewItemData> = new Vector.<NewItemData>();
        var data:Array = obj.toString().split(", ");
        var bytes:ByteArray;
        var decoder:Base64Decoder = new Base64Decoder();
        equipment.length = data.length;
        var i:Number = 0;
        while (i < equipment.length) {
            decoder.decode(data[i])
            bytes = decoder.toByteArray()
            bytes.position = 0;
            bytes.endian = "littleEndian"
            equipment[i] = NewItemData.FromByteArray(bytes);
            i++;
        }

        return equipment;
    }
}
}
</file>

<file path="src/svera/untiered/legends/service/GetLegendsListTask.as">
package svera.untiered.legends.service {
import svera.lib.tasks.BaseTask;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.legends.model.Legend;
import svera.untiered.legends.model.LegendFactory;
import svera.untiered.legends.model.LegendsModel;
import svera.untiered.legends.model.Timespan;

public class GetLegendsListTask extends BaseTask {


    [Inject]
    public var client:AppEngineClient;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var model:LegendsModel;

    [Inject]
    public var factory:LegendFactory;

    [Inject]
    public var timespan:Timespan;

    public var charId:int;

    public function GetLegendsListTask() {
        super();
    }

    override protected function startTask():void {
        this.client.complete.addOnce(this.onComplete);
        this.client.sendRequest("/honor/list", this.makeRequestObject());
    }

    private function onComplete(isOK:Boolean, data:*):void {
        isOK && this.updateHonorListData(data);
        completeTask(isOK, data);
    }

    private function updateHonorListData(data:String):void {
        var legends:Vector.<Legend> = this.factory.makeLegends(XML(data));
        this.model.setLegendList(legends);
    }

    private function makeRequestObject():Object {
        var request:Object = {};
        request.timespan = this.timespan.getId();
        request.accountId = this.player.getAccountId();
        request.charId = this.charId;
        return request;
    }
}
}
</file>

<file path="src/svera/untiered/legends/view/LegendsMediator.as">
package svera.untiered.legends.view {
import svera.lib.framework.Mediator;

import svera.untiered.death.model.DeathModel;
import svera.untiered.honor.control.ShowHonorViewSignal;
import svera.untiered.legends.control.ExitLegendsSignal;
import svera.untiered.legends.control.HonorListUpdateSignal;
import svera.untiered.legends.control.RequestHonorListSignal;
import svera.untiered.legends.model.Legend;
import svera.untiered.legends.model.LegendsModel;
import svera.untiered.legends.model.Timespan;

public class LegendsMediator extends Mediator {


    [Inject]
    public var view:LegendsView;

    [Inject]
    public var model:LegendsModel;

    [Inject]
    public var deathModel:DeathModel;

    [Inject]
    public var showHonorDetail:ShowHonorViewSignal;

    [Inject]
    public var requestHonorList:RequestHonorListSignal;

    [Inject]
    public var update:HonorListUpdateSignal;

    [Inject]
    public var exit:ExitLegendsSignal;

    public function LegendsMediator() {
        super();
    }

    override public function initialize():void {
        this.view.close.add(this.onClose);
        this.view.timespanChanged.add(this.onTimespanChanged);
        this.view.showDetail.add(this.onShowCharacter);
        this.update.add(this.updateLegendList);
        this.onTimespanChanged(this.model.getTimespan());
    }

    private function onClose():void {
        this.exit.dispatch();
    }

    override public function destroy():void {
        this.view.close.remove(this.onClose);
        this.view.timespanChanged.remove(this.onTimespanChanged);
        this.view.showDetail.remove(this.onShowCharacter);
        this.update.remove(this.updateLegendList);
        this.deathModel.clearPendingDeathView();
        this.model.clear();
    }

    private function onTimespanChanged(timespan:Timespan):void {
        this.model.setTimespan(timespan);
        if (this.model.hasLegendList()) {
            this.updateLegendList();
        } else {
            this.showLoadingAndRequestHonorList();
        }
    }

    private function showLoadingAndRequestHonorList():void {
        this.view.clear();
        this.view.showLoading();
        this.requestHonorList.dispatch(this.model.getTimespan());
    }

    private function updateLegendList(timespan:Timespan = null):void {
        timespan = timespan || this.model.getTimespan();
        this.view.hideLoading();
        this.view.setLegendsList(timespan, this.model.getLegendList());
    }

    private function onShowCharacter(legend:Legend):void {
        this.showHonorDetail.dispatch(legend);
    }
}
}
</file>

<file path="src/svera/untiered/lootBoxes/LootboxModalMediator.as">
package svera.untiered.lootBoxes {

import flash.events.MouseEvent;

import org.swiftsuspenders.Injector;

import svera.lib.framework.Mediator;

import svera.lib.net.api.MessageProvider;
import svera.lib.net.impl.SocketServer;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.signals.AddTextLineSignal;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.messaging.impl.outgoing.UnboxRequest;

public class LootboxModalMediator extends Mediator {


    [Inject]
    public var injector:Injector;
    [Inject]
    public var closeDialogs:CloseDialogsSignal;
    [Inject]
    public var socketServer:SocketServer;
    [Inject]
    public var messages:MessageProvider;
    [Inject]
    public var view:LootboxModal;
    [Inject]
    public var openNoModalDialog:OpenDialogSignal;
    [Inject]
    public var addTextLine:AddTextLineSignal;



    override public function initialize():void {
        this.view.Lootbox1Amount.addEventListener(MouseEvent.CLICK, this.onButton1);
        this.view.Lootbox2Amount.addEventListener(MouseEvent.CLICK, this.onButton2);
        this.view.Lootbox3Amount.addEventListener(MouseEvent.CLICK, this.onButton3);
        this.view.Lootbox4Amount.addEventListener(MouseEvent.CLICK, this.onButton4);
        this.view.Lootbox5Amount.addEventListener(MouseEvent.CLICK, this.onButton5);
    }

    override public function destroy():void {
        super.destroy();
    }

    protected function onButton1(_arg_1:MouseEvent):void {
        var _local_1:UnboxRequest;
        _local_1 = (this.messages.require(GameServerConnection.UNBOXREQUEST) as UnboxRequest);
        _local_1.lootboxType_ = 1;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch();
    }

    protected function onButton2(_arg_1:MouseEvent):void {
        var _local_1:UnboxRequest;
        _local_1 = (this.messages.require(GameServerConnection.UNBOXREQUEST) as UnboxRequest);
        _local_1.lootboxType_ = 2;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch();
    }

    protected function onButton3(_arg_1:MouseEvent):void {
        var _local_1:UnboxRequest;
        _local_1 = (this.messages.require(GameServerConnection.UNBOXREQUEST) as UnboxRequest);
        _local_1.lootboxType_ = 3;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch();
    }

    protected function onButton4(_arg_1:MouseEvent):void {
        var _local_1:UnboxRequest;
        _local_1 = (this.messages.require(GameServerConnection.UNBOXREQUEST) as UnboxRequest);
        _local_1.lootboxType_ = 4;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch();
    }

    protected function onButton5(_arg_1:MouseEvent):void {
        var _local_1:UnboxRequest;
        _local_1 = (this.messages.require(GameServerConnection.UNBOXREQUEST) as UnboxRequest);
        _local_1.lootboxType_ = 5;
        this.socketServer.sendMessage(_local_1);
        this.closeDialogs.dispatch();
    }




}
}//package svera.untiered.pets.view.components
</file>

<file path="src/svera/untiered/memMarket/content/MemMarketBuyItem.as">
package svera.untiered.memMarket.content {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.util.Currency;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;

import flash.display.Bitmap;

import flash.events.Event;

import flash.events.MouseEvent;
import flash.system.System;
import flash.text.TextFieldAutoSize;
import svera.untiered.assets.services.IconFactory;

import svera.untiered.memMarket.utils.DialogUtils;
import svera.untiered.messaging.impl.data.MarketData;

public class MemMarketBuyItem extends MemMarketItem
{
    private var buyButton_:TextButton;
    private var priceText_:SimpleText;
    private var timeText_:SimpleText;
    private var currency_:Bitmap;

    public function MemMarketBuyItem(gameSprite:GameSprite, data:MarketData)
    {
        super(gameSprite, OFFER_WIDTH, OFFER_HEIGHT, 80, data.itemType_, data);
        this.icon_.x = 22;
        this.icon_.y = -8;

        this.buyButton_ = new TextButton(10, "Buy", 96);
        this.buyButton_.x = 2;
        this.buyButton_.y = 62;

        this.updateButton();
        addChild(this.buyButton_);

        this.priceText_ = new SimpleText(10, 0xFFFFFF, false, width, 0);
        this.priceText_.setBold(true);
        this.priceText_.htmlText = "<p align=\"center\">" + this.data_.price_ + "</p>";
        this.priceText_.wordWrap = true;
        this.priceText_.multiline = true;
        this.priceText_.autoSize = TextFieldAutoSize.CENTER;
        this.priceText_.y = 49;
        addChild(this.priceText_);

        var unix:Number = this.data_.timeLeft_ * 1000;
        var later:Date = new Date(unix);
        var now:Date = new Date();
        var ms:Number = Math.floor(later.time - now.time);
        var hours:Number = ms / 3600000;
        this.timeText_ = new SimpleText(10, 0xFFFFFF, false, width, 0);
        this.timeText_.setBold(true);
        this.timeText_.htmlText = "<p align=\"center\">" + hours.toFixed(1) + "h</p>";
        this.timeText_.wordWrap = true;
        this.timeText_.multiline = true;
        this.timeText_.autoSize = TextFieldAutoSize.CENTER;
        this.timeText_.y = 39;
        addChild(this.timeText_);

        this.currency_ = new Bitmap(IconFactory.makeHonor());
        this.currency_.x = 76;
        this.currency_.y = 38;
        addChild(this.currency_);
    }

    private function onBuyClick(event:MouseEvent) : void
    {
        DialogUtils.makeCallbackDialog(this.gameSprite_, "Verification", "Are you sure you want to buy this item?", "Yes", "No", this.onVerified);
    }

    private function onVerified(event:Event) : void
    {
        this.gameSprite_.gsc_.marketBuy(this.id_);
    }

    public function updateButton() : void
    {
        var currencyAmount:int = this.gameSprite_.map.player_.honor_;
        if (currencyAmount >= this.data_.price_) /* Only add this event listener if we can afford the item */
        {
            this.buyButton_.addEventListener(MouseEvent.CLICK, this.onBuyClick);
            this.buyButton_.setEnabled(true);
        }
        else
        {
            this.buyButton_.removeEventListener(MouseEvent.CLICK, this.onBuyClick);
            this.buyButton_.setEnabled(false);
        }
    }
    /* Clear */
    public override function dispose() : void
    {
        this.buyButton_.removeEventListener(MouseEvent.CLICK, this.onBuyClick);
        this.buyButton_ = null;
        this.priceText_ = null;
        this.timeText_ = null;
        this.currency_ = null;

        super.dispose();
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/MemMarket.as">
package svera.untiered.memMarket {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.ui.options.OptionsTabTitle;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.ScreenGraphic;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

import svera.untiered.memMarket.tabs.MemMarketBuyTab;
import svera.untiered.memMarket.tabs.MemMarketSellTab;
import svera.untiered.memMarket.tabs.MemMarketTab;

import svera.untiered.memMarket.tabs.MemMarketTab;

public class MemMarket extends Sprite
{
    private static const BUY:String = "Buy";
    private static const SELL:String = "Sell";
    private static const TABS:Vector.<String> = new <String>[BUY, SELL];

    private var gameSprite_:GameSprite;
    private var titleText_:SimpleText;
    private var closeButton_:TitleMenuOption;
    private var tabs_:Vector.<OptionsTabTitle>;
    private var content_:Vector.<MemMarketTab>;
    private var selectedTab_:OptionsTabTitle;
    private var creatorText_:SimpleText;

    public function MemMarket(gameSprite:GameSprite)
    {
        this.gameSprite_ = gameSprite;

        /* Draw background */
        graphics.clear();
        graphics.beginFill(2829099,0.8);
        graphics.drawRect(0,0,GameClient.StageWidth,GameClient.StageHeight);
        graphics.endFill();
        graphics.lineStyle(1,6184542);
        graphics.moveTo(0,100);
        graphics.lineTo(GameClient.StageWidth,100);
        graphics.lineStyle();

        /* Draw title */
        this.titleText_ = new SimpleText(36, 0xFFFFFF, false, GameClient.StageWidth, 0);
        this.titleText_.setBold(true);
        this.titleText_.htmlText = "<p align=\"center\">Market</p>";
        this.titleText_.autoSize = TextFieldAutoSize.CENTER;
        this.titleText_.filters = [new DropShadowFilter(0,0,0)];
        this.titleText_.updateMetrics();
        this.titleText_.x = GameClient.HalfStageWidth - this.titleText_.width / 2;
        this.titleText_.y = 8;
        addChild(this.titleText_);

        /* Draw Menubar */
        addChild(new ScreenGraphic());

        /* Draw buttons */
        this.closeButton_ = new TitleMenuOption("Close", 36, false);
        this.closeButton_.x = 710 / 2 - this.closeButton_.width / 2;
        this.closeButton_.y = 530;
        this.closeButton_.addEventListener(MouseEvent.CLICK, this.onClose);
        addChild(this.closeButton_);

        /* Add tabs */
        this.tabs_ = new Vector.<OptionsTabTitle>();
        var xOffset:int = 14;
        for (var i:int = 0; i < TABS.length; i++)
        {
            var tab:OptionsTabTitle = new OptionsTabTitle(TABS[i]);
            tab.x = xOffset;
            tab.y = 78;
            tab.addEventListener(MouseEvent.CLICK, this.onTab);
            addChild(tab);
            this.tabs_.push(tab);
            xOffset += 108;
        }

        this.content_ = new Vector.<MemMarketTab>();

        /* Set tab to first in list. */
        this.setTab(this.tabs_[0]);

        this.creatorText_ = new SimpleText(16, 0xFFFFFF, false, 200);
        this.creatorText_.setBold(true);
        this.creatorText_.text = "";
        this.creatorText_.y = 582;
        addChild(this.creatorText_);
    }

    /* Change tab */
    private function onTab(event:MouseEvent) : void
    {
        var tab:OptionsTabTitle = event.currentTarget as OptionsTabTitle;
        this.setTab(tab);
    }

    /* Replace tab content */
    private function setTab(tab:OptionsTabTitle) : void
    {
        if (tab == this.selectedTab_)
        {
            return;
        }

        if (this.selectedTab_ != null)
        {
            this.selectedTab_.setSelected(false);
        }

        this.selectedTab_ = tab;
        this.selectedTab_.setSelected(true);

        this.removeLastContent();

        switch (this.selectedTab_.text_) /* Could potentially make this slightly faster by using pre-made tabs instead of creating new ones */
        {
            case SELL:
                this.addContent(new MemMarketSellTab(this.gameSprite_));
                break;
            case BUY:
                this.addContent(new MemMarketBuyTab(this.gameSprite_));
                break;
        }
    }

    /* Remove last tab content */
    private function removeLastContent() : void
    {
        for each (var i:MemMarketTab in this.content_)
        {
            i.dispose(); /* Clear the tab */
            removeChild(i); /* Remove it */
        }
        this.content_.length = 0;
    }

    /* Add tab content */
    private function addContent(content:MemMarketTab) : void
    {
        addChild(content);
        this.content_.push(content);
    }

    /* Remove */
    private function onClose(event:Event) : void
    {
        this.gameSprite_.mui_.setEnablePlayerInput(true); /* Enable player movement */
        this.gameSprite_ = null;
        this.titleText_ = null;
        this.closeButton_.removeEventListener(MouseEvent.CLICK, this.onClose);
        this.closeButton_ = null;

        for each (var tab:OptionsTabTitle in this.tabs_)
        {
            tab.removeEventListener(MouseEvent.CLICK, this.onTab);
            tab = null;
        }
        this.tabs_.length = 0;
        this.tabs_ = null;

        for each (var content:MemMarketTab in this.content_)
        {
            content.dispose(); /* Clear the tab */
            content = null;
        }
        this.content_.length = 0;
        this.content_ = null;

        this.selectedTab_ = null;

        this.creatorText_ = null;

        /* Remove all children */
        for (var i:int = numChildren - 1; i >= 0; i--)
        {
            removeChildAt(i);
        }

        stage.focus = null;
        parent.removeChild(this);
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/ObjectStatusData.as">
package svera.untiered.messaging.impl.data {
import com.company.assembleegameclient.util.FreeList;

import flash.utils.IDataInput;
import flash.utils.IDataOutput;

public class ObjectStatusData {


    public var objectId_:int;

    public var pos_:WorldPosData;

    public var stats_:Vector.<StatData>;

    public function ObjectStatusData() {
        this.pos_ = new WorldPosData();
        this.stats_ = new Vector.<StatData>();
        super();
    }

    public function parseFromInput(data:IDataInput):void {
        var s:int;
        this.objectId_ = data.readInt();
        this.pos_.parseFromInput(data);
        var len:int = data.readUnsignedByte();
        for (s = len; s < this.stats_.length; s++) {
            FreeList.deleteObject(this.stats_[s]);
        }
        this.stats_.length = Math.min(len, this.stats_.length);
        while (this.stats_.length < len) {
            this.stats_.push(FreeList.newObject(StatData) as StatData);
        }
        for (s = 0; s < len; s++) {
            this.stats_[s].parseFromInput(data);
        }
    }

    public function writeToOutput(data:IDataOutput):void {
        data.writeInt(this.objectId_);
        this.pos_.writeToOutput(data);
        data.writeShort(this.stats_.length);
        for (var s:int = 0; s < this.stats_.length; s++) {
            this.stats_[s].writeToOutput(data);
        }
    }

    public function toString():String {
        return "objectId_: " + this.objectId_ + " pos_: " + this.pos_ + " stats_: " + this.stats_;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/TradeItemData.as">
package svera.untiered.messaging.impl.data {
import flash.utils.ByteArray;
import flash.utils.IDataInput;

import svera.untiered.itemdata.NewItemData;

public class TradeItemData {

    public var itemType_:NewItemData;
    public var slotType_:int;
    public var tradeable_:Boolean;
    public var included_:Boolean;


    public function parseFromInput(data:IDataInput):void {
        var len:Number = data.readShort();
        var statByteArray:ByteArray = new ByteArray();
        for(var i:Number = 0; i < len; i++) {
            statByteArray.writeByte(data.readUnsignedByte());
        }
        statByteArray.endian = "littleEndian";
        statByteArray.position = 0;
        this.itemType_ = NewItemData.FromByteArray(statByteArray);
        this.slotType_ = data.readInt();
        this.tradeable_ = data.readBoolean();
        this.included_ = data.readBoolean();
    }

    public function toString():String {
        return "ItemType: " + itemType_ + " SlotType: " + slotType_ + " Tradeable: " + tradeable_ + " Included: " + included_;
    }


}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/AccountList.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.IDataInput;

public class AccountList extends IncomingMessage {


    public var accountListId_:int;

    public var accountIds_:Vector.<int>;

    public function AccountList(id:uint, callback:Function) {
        this.accountIds_ = new Vector.<int>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        var i:int;
        this.accountListId_ = data.readInt();
        this.accountIds_.length = 0;
        var num:int = data.readShort();
        for (i = 0; i < num; i++) {
            this.accountIds_.push(data.readInt());
        }
    }

    override public function toString():String {
        return formatToString("ACCOUNTLIST", "accountListId_", "accountIds_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/NewTick.as">
package svera.untiered.messaging.impl.incoming {
import com.company.assembleegameclient.util.FreeList;

import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.ObjectStatusData;
import svera.untiered.messaging.impl.data.StatData;

public class NewTick extends IncomingMessage {
    public var statuses_:Vector.<ObjectStatusData>;
    public var playerStats_:Vector.<StatData>;

    public function NewTick(id:uint, callback:Function) {
        this.statuses_ = new Vector.<ObjectStatusData>();
        this.playerStats_ = new Vector.<StatData>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        var i:int;
        var len:int = data.readShort();
        for (i = 0; i < this.statuses_.length; i++) {
            FreeList.deleteObject(this.statuses_[i]);
        }
        this.statuses_.length = 0;
        while (this.statuses_.length < len) {
            this.statuses_.push(FreeList.newObject(ObjectStatusData) as ObjectStatusData);
            this.statuses_[this.statuses_.length - 1].parseFromInput(data);
        }

        for (i = 0; i < this.playerStats_.length; i++) {
            FreeList.deleteObject(this.playerStats_[i]);
        }
        this.playerStats_.length = 0;
        if (data.bytesAvailable > 0) {
            len = data.readUnsignedByte();
            while (this.playerStats_.length < len) {
                this.playerStats_.push(FreeList.newObject(StatData) as StatData);
                this.playerStats_[this.playerStats_.length - 1].parseFromInput(data);
            }
        }
    }

    override public function toString():String {
        return formatToString("NEW_TICK", "statuses_", "playerStats_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/TradeStart.as">
package svera.untiered.messaging.impl.incoming {
import com.company.assembleegameclient.util.FreeList;

import flash.utils.IDataInput;

import svera.untiered.messaging.impl.data.TradeItemData;

public class TradeStart extends IncomingMessage {


    public var myItems_:Vector.<TradeItemData>;

    public var theirName_:String;

    public var theirItems_:Vector.<TradeItemData>;

    public function TradeStart(id:uint, callback:Function) {
        this.myItems_ = new Vector.<TradeItemData>();
        this.theirItems_ = new Vector.<TradeItemData>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        var i:int;
        var len:int = data.readByte();
        for (i = len; i < this.myItems_.length; i++) {
            FreeList.deleteObject(this.myItems_[i]);
        }
        this.myItems_.length = Math.min(len, this.myItems_.length);
        while (this.myItems_.length < len) {
            this.myItems_.push(FreeList.newObject(TradeItemData) as TradeItemData);
        }
        for (i = 0; i < len; i++) {
            this.myItems_[i].parseFromInput(data);
        }
        this.theirName_ = data.readUTF();
        len = data.readByte();
        for (i = len; i < this.theirItems_.length; i++) {
            FreeList.deleteObject(this.theirItems_[i]);
        }
        this.theirItems_.length = Math.min(len, this.theirItems_.length);
        while (this.theirItems_.length < len) {
            this.theirItems_.push(FreeList.newObject(TradeItemData) as TradeItemData);
        }
        for (i = 0; i < len; i++) {
            this.theirItems_[i].parseFromInput(data);
        }
    }

    override public function toString():String {
        return formatToString("TRADESTART", "myItems_", "theirName_", "theirItems_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/LaunchRaid.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class LaunchRaid extends OutgoingMessage {

    public function LaunchRaid(_arg_1:uint, _arg_2:Function) {
        super(_arg_1, _arg_2);
    }

    public var raidId_:int;


    override public function writeToOutput(_arg1:IDataOutput):void {
        _arg1.writeInt(this.raidId_);

    }

    override public function toString():String {
        return formatToString("LAUNCHRAID", "raidId_");
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/outgoing/UnboxRequest.as">
package svera.untiered.messaging.impl.outgoing {
import flash.utils.IDataOutput;

public class UnboxRequest extends OutgoingMessage {

    public var lootboxType_:int;

    public function UnboxRequest(_arg1:uint, _arg2:Function) {
        super(_arg1, _arg2);
    }

    override public function writeToOutput(_arg1:IDataOutput):void {
        _arg1.writeInt(this.lootboxType_);
    }

    override public function toString():String {
        return formatToString("UNBOXREQUEST", "lootboxType_");
    }


}
}
</file>

<file path="src/svera/untiered/minimap/view/MiniMapZoomButtons.as">
package svera.untiered.minimap.view {
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.geom.ColorTransform;

import org.osflash.signals.Signal;

public class MiniMapZoomButtons extends Sprite {


    private const FADE:ColorTransform = new ColorTransform(0.5, 0.5, 0.5);

    private const NORM:ColorTransform = new ColorTransform(1, 1, 1);

    public const zoom:Signal = new Signal(int);

    private var zoomOut:Sprite;

    private var zoomIn:Sprite;

    private var zoomLevels:int;

    private var zoomLevel:int;

    public function MiniMapZoomButtons() {
        super();
        this.zoomLevel = 0;
        this.makeZoomOut();
        this.makeZoomIn();
        this.updateButtons();
    }

    public function getZoomLevel():int {
        return this.zoomLevel;
    }

    public function setZoomLevel(value:int):int {
        if (this.zoomLevels == 0) {
            return this.zoomLevel;
        }
        if (value < 0) {
            value = 0;
        } else if (value >= this.zoomLevels - 1) {
            value = this.zoomLevels - 1;
        }
        this.zoomLevel = value;
        this.updateButtons();
        return this.zoomLevel;
    }

    public function setZoomLevels(count:int):int {
        this.zoomLevels = count;
        if (this.zoomLevel >= this.zoomLevels) {
            this.zoomLevel = this.zoomLevels - 1;
        }
        this.updateButtons();
        return this.zoomLevels;
    }

    private function makeZoomOut():void {
        var data:BitmapData = AssetLibrary.getImageFromSet("lofiInterface", 54);
        var bitmap:Bitmap = new Bitmap(data);
        bitmap.scaleX = 2;
        bitmap.scaleY = 2;
        this.zoomOut = new Sprite();
        this.zoomOut.x = 0;
        this.zoomOut.y = 4;
        this.zoomOut.addChild(bitmap);
        this.zoomOut.addEventListener(MouseEvent.CLICK, this.onZoomOut);
        addChild(this.zoomOut);
    }

    private function makeZoomIn():void {
        var data:BitmapData = AssetLibrary.getImageFromSet("lofiInterface", 55);
        var bitmap:Bitmap = new Bitmap(data);
        bitmap.scaleX = 2;
        bitmap.scaleY = 2;
        this.zoomIn = new Sprite();
        this.zoomIn.x = 0;
        this.zoomIn.y = 14;
        this.zoomIn.addChild(bitmap);
        this.zoomIn.addEventListener(MouseEvent.CLICK, this.onZoomIn);
        addChild(this.zoomIn);
    }

    private function onZoomOut(event:MouseEvent):void {
        if (this.canZoomOut()) {
            this.zoom.dispatch(--this.zoomLevel);
            this.zoomOut.transform.colorTransform = this.canZoomOut() ? this.NORM : this.FADE;
        }
    }

    private function canZoomOut():Boolean {
        return this.zoomLevel > 0;
    }

    private function onZoomIn(event:MouseEvent):void {
        if (this.canZoomIn()) {
            this.zoom.dispatch(++this.zoomLevel);
            this.zoomIn.transform.colorTransform = this.canZoomIn() ? this.NORM : this.FADE;
        }
    }

    private function canZoomIn():Boolean {
        return this.zoomLevel < this.zoomLevels - 1;
    }

    private function updateButtons():void {
        this.zoomIn.transform.colorTransform = this.canZoomIn() ? this.NORM : this.FADE;
        this.zoomOut.transform.colorTransform = this.canZoomOut() ? this.NORM : this.FADE;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/graphic3D/Program3DFactory.as">
package svera.untiered.stage3D.graphic3D {
import svera.untiered.stage3D.proxies.Context3DProxy;
import svera.untiered.stage3D.proxies.Program3DProxy;
import svera.untiered.stage3D.shaders.FragmentShader;
import svera.untiered.stage3D.shaders.FragmentShaderRepeat;
import svera.untiered.stage3D.shaders.VertextShader;

public class Program3DFactory {

    private static var instance:Program3DFactory;

    public static const TYPE_REPEAT_ON:Boolean = true;

    public static const TYPE_REPEAT_OFF:Boolean = false;


    private var repeatProgram:Program3DProxy;

    private var noRepeatProgram:Program3DProxy;

    public function Program3DFactory(password:String = "") {
        super();
        if (password != "yoThisIsInternal") {
            throw new Error("Program3DFactory is a singleton. Use Program3DFactory.getInstance()");
        }
    }

    public static function getInstance():Program3DFactory {
        if (instance == null) {
            instance = new Program3DFactory("yoThisIsInternal");
        }
        return instance;
    }

    public function dispose():void {
        if (this.repeatProgram != null) {
            this.repeatProgram.getProgram3D().dispose();
        }
        if (this.noRepeatProgram != null) {
            this.noRepeatProgram.getProgram3D().dispose();
        }
        instance = null;
    }

    public function getProgram(context3D:Context3DProxy, type:Boolean):Program3DProxy {
        var program:Program3DProxy;
        switch (type) {
            case TYPE_REPEAT_ON:
                if (this.repeatProgram == null) {
                    this.repeatProgram = context3D.createProgram();
                    this.repeatProgram.upload(new VertextShader().getVertexProgram(), new FragmentShaderRepeat().getVertexProgram());
                }
                program = this.repeatProgram;
                break;
            case TYPE_REPEAT_OFF:
                if (this.noRepeatProgram == null) {
                    this.noRepeatProgram = context3D.createProgram();
                    this.noRepeatProgram.upload(new VertextShader().getVertexProgram(), new FragmentShader().getVertexProgram());
                }
                program = this.noRepeatProgram;
                break;
            default:
                if (this.repeatProgram == null) {
                    this.repeatProgram = context3D.createProgram();
                    this.repeatProgram.upload(new VertextShader().getVertexProgram(), new FragmentShaderRepeat().getVertexProgram());
                }
                program = this.repeatProgram;
        }
        return program;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/graphic3D/TextureFactory.as">
package svera.untiered.stage3D.graphic3D {
import flash.display.BitmapData;
import flash.display3D.Context3DTextureFormat;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.utils.Dictionary;

import svera.untiered.stage3D.proxies.Context3DProxy;
import svera.untiered.stage3D.proxies.TextureProxy;

public class TextureFactory {
    private static var textures:Dictionary = new Dictionary();
    private static var flippedTextures:Dictionary = new Dictionary();
    private static var count:int = 0;


    [Inject]
    public var context3D:Context3DProxy;

    public function TextureFactory() {
        super();
    }

    public static function GetFlippedBitmapData(original:BitmapData):BitmapData {
        var flipped:BitmapData = null;
        if (original in flippedTextures) {
            return flippedTextures[original];
        }
        flipped = flipBitmapData(original, "y");
        flippedTextures[original] = flipped;
        return flipped;
    }

    private static function flipBitmapData(original:BitmapData, axis:String = "x"):BitmapData {
        var matrix:Matrix;
        var flipped:BitmapData = new BitmapData(original.width, original.height, true, 0);
        if (axis == "x") {
            matrix = new Matrix(-1, 0, 0, 1, original.width, 0);
        } else {
            matrix = new Matrix(1, 0, 0, -1, 0, original.height);
        }
        flipped.draw(original, matrix, null, null, null, true);
        return flipped;
    }

    private static function getNextPowerOf2(value:int):Number {
        value--;
        value = value | value >> 1;
        value = value | value >> 2;
        value = value | value >> 4;
        value = value | value >> 8;
        value = value | value >> 16;
        value++;
        return value;
    }

    public static function disposeTextures():void {
        var texture:TextureProxy = null;
        var bitmap:BitmapData = null;
        for each(texture in textures) {
            texture.dispose();
        }
        textures = new Dictionary();
        for each(bitmap in flippedTextures) {
            bitmap.dispose();
        }
        flippedTextures = new Dictionary();
        count = 0;
    }

    public static function disposeNormalTextures():void {
        var texture:TextureProxy = null;
        for each(texture in textures) {
            texture.dispose();
        }
        textures = new Dictionary();
    }

    public function make(bitmapData:BitmapData):TextureProxy {
        var width:int = 0;
        var height:int = 0;
        var texture:TextureProxy = null;
        var bitmapTexture:BitmapData = null;
        if (bitmapData == null) {
            return null;
        }
        if (bitmapData in textures) {
            return textures[bitmapData];
        }
        width = getNextPowerOf2(bitmapData.width);
        height = getNextPowerOf2(bitmapData.height);
        texture = this.context3D.createTexture(width, height, Context3DTextureFormat.BGRA, false);
        bitmapTexture = new BitmapData(width, height, true, 0);
        bitmapTexture.copyPixels(bitmapData, bitmapData.rect, new Point(0, 0));
        texture.uploadFromBitmapData(bitmapTexture);
        if (count > 1000) {
            disposeNormalTextures();
            count = 0;
        }
        textures[bitmapData] = texture;
        count++;
        return texture;
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/GraphicsFillExtra.as">
package svera.untiered.stage3D {
import com.company.assembleegameclient.parameters.Parameters;

import flash.display.BitmapData;
import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsSolidFill;
import flash.display3D.Context3DVertexBufferFormat;
import flash.display3D.VertexBuffer3D;
import flash.geom.ColorTransform;
import flash.utils.Dictionary;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.stage3D.proxies.Context3DProxy;

public class GraphicsFillExtra {
    private static var textureOffsets:Dictionary = new Dictionary();
    private static var textureOffsetsSize:uint = 0;
    private static var waterSinks:Dictionary = new Dictionary();
    private static var waterSinksSize:uint = 0;
    private static var colorTransforms:Dictionary = new Dictionary();
    private static var colorTransformsSize:uint = 0;
    private static var vertexBuffers:Dictionary = new Dictionary();
    private static var vertexBuffersSize:uint = 0;
    private static var softwareDraw:Dictionary = new Dictionary();
    private static var softwareDrawSize:uint = 0;
    private static var softwareDrawSolid:Dictionary = new Dictionary();
    private static var softwareDrawSolidSize:uint = 0;
    private static var lastChecked:uint = 0;
    private static const DEFAULT_OFFSET:Vector.<Number> = Vector.<Number>([0, 0, 0, 0]);

    public function GraphicsFillExtra() {
        super();
    }

    public static function setColorTransform(bitmap:BitmapData, value:ColorTransform):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        if (colorTransforms[bitmap] == null) {
            colorTransformsSize++;
        }
        colorTransforms[bitmap] = value;
    }

    public static function getColorTransform(bitmap:BitmapData):ColorTransform {
        var colorTransform:ColorTransform;
        if (bitmap in colorTransforms) {
            colorTransform = colorTransforms[bitmap];
        } else {
            colorTransform = new ColorTransform();
            colorTransforms[bitmap] = colorTransform;
            colorTransformsSize++;
        }
        return colorTransform;
    }

    public static function setOffsetUV(bitmapFill:GraphicsBitmapFill, u:Number, v:Number):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        testOffsetUV(bitmapFill);
        textureOffsets[bitmapFill][0] = u;
        textureOffsets[bitmapFill][1] = v;
    }

    public static function getOffsetUV(bitmapFill:GraphicsBitmapFill):Vector.<Number> {
        if (textureOffsets[bitmapFill] != null) {
            return textureOffsets[bitmapFill];
        }
        return DEFAULT_OFFSET;
    }

    private static function testOffsetUV(bitmapFill:GraphicsBitmapFill):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        if (textureOffsets[bitmapFill] == null) {
            textureOffsetsSize++;
            textureOffsets[bitmapFill] = Vector.<Number>([0, 0, 0, 0]);
        }
    }

    public static function setSinkLevel(bitmapFill:GraphicsBitmapFill, value:Number):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        if (waterSinks[bitmapFill] == null) {
            waterSinksSize++;
        }
        waterSinks[bitmapFill] = value;
    }

    public static function getSinkLevel(bitmapFill:GraphicsBitmapFill):Number {
        if (waterSinks[bitmapFill] != null && waterSinks[bitmapFill] is Number) {
            return waterSinks[bitmapFill];
        }
        return 0;
    }

    public static function setVertexBuffer(bitmapFill:GraphicsBitmapFill, verts:Vector.<Number>):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        var context3D:Context3DProxy = StaticInjectorContext.getInjector().getInstance(Context3DProxy);
        var vertexBufferCustom:VertexBuffer3D = context3D.GetContext3D().createVertexBuffer(4, 5);
        vertexBufferCustom.uploadFromVector(verts, 0, 4);
        context3D.GetContext3D().setVertexBufferAt(0, vertexBufferCustom, 0, Context3DVertexBufferFormat.FLOAT_3);
        context3D.GetContext3D().setVertexBufferAt(1, vertexBufferCustom, 3, Context3DVertexBufferFormat.FLOAT_2);
        if (vertexBuffers[bitmapFill] == null) {
            vertexBuffersSize++;
        }
        vertexBuffers[bitmapFill] = vertexBufferCustom;
    }

    public static function getVertexBuffer(bitmapFill:GraphicsBitmapFill):VertexBuffer3D {
        if (vertexBuffers[bitmapFill] != null && vertexBuffers[bitmapFill] is VertexBuffer3D) {
            return vertexBuffers[bitmapFill];
        }
        return null;
    }

    public static function clearSink(bitmapFill:GraphicsBitmapFill):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        if (waterSinks[bitmapFill] != null) {
            waterSinksSize--;
            delete waterSinks[bitmapFill];
        }
    }

    public static function setSoftwareDraw(bitmapFill:GraphicsBitmapFill, value:Boolean):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        if (softwareDraw[bitmapFill] == null) {
            softwareDrawSize++;
        }
        softwareDraw[bitmapFill] = value;
    }

    public static function isSoftwareDraw(bitmapFill:GraphicsBitmapFill):Boolean {
        if (softwareDraw[bitmapFill] != null && softwareDraw[bitmapFill] is Boolean) {
            return softwareDraw[bitmapFill];
        }
        return false;
    }

    public static function setSoftwareDrawSolid(solidFill:GraphicsSolidFill, value:Boolean):void {
        if (!Parameters.GPURenderFrame) {
            return;
        }
        if (softwareDrawSolid[solidFill] == null) {
            softwareDrawSolidSize++;
        }
        softwareDrawSolid[solidFill] = value;
    }

    public static function isSoftwareDrawSolid(solidFill:GraphicsSolidFill):Boolean {
        if (softwareDrawSolid[solidFill] != null && softwareDrawSolid[solidFill] is Boolean) {
            return softwareDrawSolid[solidFill];
        }
        return false;
    }

    public static function dispose():void {
        textureOffsets = new Dictionary();
        waterSinks = new Dictionary();
        colorTransforms = new Dictionary();
        disposeVertexBuffers();
        softwareDraw = new Dictionary();
        softwareDrawSolid = new Dictionary();
        textureOffsetsSize = 0;
        waterSinksSize = 0;
        colorTransformsSize = 0;
        vertexBuffersSize = 0;
        softwareDrawSize = 0;
        softwareDrawSolidSize = 0;
    }

    public static function disposeVertexBuffers():void {
        var buffer3d:VertexBuffer3D = null;
        for each(buffer3d in vertexBuffers) {
            buffer3d.dispose();
        }
        vertexBuffers = new Dictionary();
    }

    public static function manageSize():void {
        if (colorTransformsSize > 2000) {
            colorTransforms = new Dictionary();
            colorTransformsSize = 0;
        }
        if (textureOffsetsSize > 2000) {
            textureOffsets = new Dictionary();
            textureOffsetsSize = 0;
        }
        if (waterSinksSize > 2000) {
            waterSinks = new Dictionary();
            waterSinksSize = 0;
        }
        if (vertexBuffersSize > 1000) {
            disposeVertexBuffers();
            vertexBuffersSize = 0;
        }
        if (softwareDrawSize > 2000) {
            softwareDraw = new Dictionary();
            softwareDrawSize = 0;
        }
        if (softwareDrawSolidSize > 2000) {
            softwareDrawSolid = new Dictionary();
            softwareDrawSolidSize = 0;
        }
    }
}
}
</file>

<file path="src/svera/untiered/startup/control/StartupCommand.as">
package svera.untiered.startup.control {
import svera.lib.framework.ICommand;
import svera.untiered.ui.signals.ShowSplashUISignal;

public class StartupCommand implements ICommand {
    [Inject]
    public var startup:StartupSequence;

    [Inject]
    public var showSplash:ShowSplashUISignal;

    public function StartupCommand() {
        super();
    }

    public function execute():void {
        showSplash.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/storage/components/VaultUpgradeButton.as">
package svera.untiered.storage.components {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.ui.SimpleText;
import com.company.util.MoreColorUtil;
import com.company.util.SpriteUtil;

import flash.display.Bitmap;
import flash.display.Sprite;
import flash.events.MouseEvent;

import svera.untiered.util.components.LegacyBuyButton;

public class VaultUpgradeButton extends Sprite {

    private static const CAPACITY_INCREMENT:int = 8;

    private static const WIDTH:int = 120;
    private static const HEIGHT:int = 40;

    private var statusText_:SimpleText;
    private var purchaseText_:SimpleText;

    private var currencyIcon_:Bitmap;

    public function VaultUpgradeButton() {
        super();

        this.statusText_ = new SimpleText(14, 0xFFFFFF);
        this.statusText_.setBold(true);
        this.purchaseText_ = new SimpleText(14, 0xFFFFFF);

        this.currencyIcon_ = new Bitmap(LegacyBuyButton.tsavorite);
        this.currencyIcon_.scaleX = 0.75;
        this.currencyIcon_.scaleY = 0.75;
        addChild(this.currencyIcon_);

        graphics.clear();
        graphics.beginFill(0x161616);
        graphics.drawRect(0, 20, WIDTH, HEIGHT);
        graphics.endFill();

        this.addEventListener(MouseEvent.ROLL_OVER, this.rollOver);
        this.addEventListener(MouseEvent.ROLL_OUT, this.rollOut);
    }

    public function setPurchaseInfo(curCapacity:int):void {
        this.statusText_.setText(curCapacity + " > " + (curCapacity + CAPACITY_INCREMENT));
        this.purchaseText_.setText("Upgrade " + Parameters.VAULT_SLOT_PRICE);

        this.statusText_.updateMetrics();
        this.purchaseText_.updateMetrics();

        this.statusText_.x = (WIDTH - this.statusText_.actualWidth_) / 2;
        this.statusText_.y = 0;
        this.purchaseText_.x = (WIDTH - this.purchaseText_.actualWidth_) / 2 - 15;
        this.purchaseText_.y = 28;

        this.currencyIcon_.x = this.purchaseText_.actualWidth_ + this.purchaseText_.x;
        this.currencyIcon_.y = 25;

        SpriteUtil.safeAddChild(this, this.statusText_);
        SpriteUtil.safeAddChild(this, this.purchaseText_);
    }

    private function rollOver(e:MouseEvent):void {
        this.transform.colorTransform = MoreColorUtil.darkCT;
    }

    private function rollOut(e:MouseEvent):void {
        this.transform.colorTransform = MoreColorUtil.identity;
    }
}
}
</file>

<file path="src/svera/untiered/storage/signals/GiftUpdateSignal.as">
package svera.untiered.storage.signals {

import org.osflash.signals.Signal;

import svera.untiered.itemdata.NewItemData;

public class GiftUpdateSignal extends Signal {
    public function GiftUpdateSignal() {
        super(int, Vector.<NewItemData>);
    }
}
}
</file>

<file path="src/svera/untiered/storage/signals/VaultUpdateSignal.as">
package svera.untiered.storage.signals {

import org.osflash.signals.Signal;

import svera.untiered.itemdata.NewItemData;

public class VaultUpdateSignal extends Signal {
    public function VaultUpdateSignal() {
        super(int, Vector.<NewItemData>);
    }
}
}
</file>

<file path="src/svera/untiered/ui/commands/ShowTitleUICommand.as">
package svera.untiered.ui.commands {
import svera.lib.framework.ICommand;
import svera.untiered.account.core.signals.UpdateAccountInfoSignal;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.ui.view.TitleView;

public class ShowTitleUICommand implements ICommand {
    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var updateAccount:UpdateAccountInfoSignal;

    public function ShowTitleUICommand() {
        super();
    }

    public function execute():void {
        this.setScreen.dispatch(new TitleView());
        this.updateAccount.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/PlayerGroupMenuMediator.as">
package svera.untiered.ui {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.menu.PlayerGroupMenu;

import svera.lib.framework.Mediator;

import svera.untiered.game.model.AddTextLineVO;
import svera.untiered.game.signals.AddTextLineSignal;

public class PlayerGroupMenuMediator extends Mediator {


    [Inject]
    public var view:PlayerGroupMenu;

    [Inject]
    private var addTextLine:AddTextLineSignal;

    public function PlayerGroupMenuMediator() {
        super();
    }

    override public function initialize():void {
        this.view.unableToTeleport.add(this.onUnableToTeleport);
    }

    override public function destroy():void {
        this.view.unableToTeleport.remove(this.onUnableToTeleport);
    }

    private function onUnableToTeleport():void {
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, "No Players are eligible for teleporting"));
    }
}
}
</file>

<file path="src/svera/untiered/ui/signals/EnterGameSignal.as">
package svera.untiered.ui.signals {
import org.osflash.signals.Signal;

public class EnterGameSignal extends Signal {
    public function EnterGameSignal() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/AccountScreenMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.screens.AccountScreen;
import com.company.assembleegameclient.ui.tooltip.ToolTip;

import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.account.web.view.WebAccountInfoView;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.HideTooltipsSignal;
import svera.untiered.core.signals.ShowTooltipSignal;

public class AccountScreenMediator extends Mediator {
    [Inject]
    public var view:AccountScreen;

    [Inject]
    public var account:Account;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var showTooltip:ShowTooltipSignal;

    [Inject]
    public var hideTooltips:HideTooltipsSignal;

    public function AccountScreenMediator() {
        super();
    }

    override public function initialize():void {
        this.view.tooltip.add(this.onTooltip);
        this.view.setRank(this.playerModel.getNumStars());
        this.view.setGuild(this.playerModel.getGuildName(), this.playerModel.getGuildRank());
        this.view.setAccountInfo(new WebAccountInfoView());
    }


    override public function destroy():void {
        this.view.tooltip.remove(this.onTooltip);
        this.hideTooltips.dispatch();
    }

    private function onTooltip(tooltip:ToolTip):void {
        this.showTooltip.dispatch(tooltip);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterDetailsView.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.IconButton;
import com.company.assembleegameclient.ui.options.KeyCodeBox;
import com.company.ui.SimpleText;
import com.company.util.KeyCodes;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Shape;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;

import svera.untiered.ui.view.components.PotionSlotView;

public class CharacterDetailsView extends Sprite {

    public static const NEXUS_BUTTON:String = "NEXUS_BUTTON";

    private var potionsView:PotionSlotView;

    private var portrait_:Bitmap;

    private var button:IconButton;

    private var nameText_:SimpleText;
    private var recallText_:SimpleText;
    private var consumableOneText_:SimpleText;
    private var consumableTwoText_:SimpleText;

    private var portraitMask:Shape;
    private var content:Sprite;

    public function CharacterDetailsView() {

        this.content = new Sprite();
        this.portraitMask = new Shape();

        this.content.graphics.clear();
        this.content.graphics.beginFill(0, 0);
        this.content.graphics.drawRect(0, 0, 72, 64);
        this.content.graphics.endFill();
        this.portraitMask.graphics.clear();
        this.portraitMask.graphics.beginFill(0, 0);
        this.portraitMask.graphics.drawRect(0, 0, 72, 64);
        this.portraitMask.graphics.endFill();

        this.content.mask = this.portraitMask;
        this.content.addChild(this.portraitMask);

        addChild(this.content);
        this.nameText_ = new SimpleText(20, 11776947, false, 0, 0);
        this.recallText_ = new SimpleText(20, 11776947, false, 0, 0);
        this.consumableOneText_ = new SimpleText(10, 11776947, false, 0, 0);
        this.consumableTwoText_ = new SimpleText(10, 11776947, false, 0, 0);
        super();
    }

    public function init():void {
        this.createHotkeysText();
    }

    private function createHotkeysText():void {
        var keyCodeBox:KeyCodeBox = new KeyCodeBox(Parameters.data_["escapeToNexus"])
        this.recallText_.x = 80;
        this.recallText_.y = 2;
        this.recallText_.setBold(true);
        this.recallText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.recallText_.text = KeyCodes.CharCodeStrings[keyCodeBox.keyCode_];
        this.recallText_.updateMetrics();
        addChild(this.recallText_);
        keyCodeBox = new KeyCodeBox(Parameters.data_["useHealthPotion"])
        this.consumableOneText_.x = this.recallText_.x - 4;
        this.consumableOneText_.y = this.recallText_.y + 27;
        this.consumableOneText_.setBold(true);
        this.consumableOneText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.consumableOneText_.text = KeyCodes.CharCodeStrings[keyCodeBox.keyCode_];
        this.consumableOneText_.updateMetrics();
        addChild(this.consumableOneText_);
        keyCodeBox = new KeyCodeBox(Parameters.data_["useMagicPotion"])
        this.consumableTwoText_.x = this.recallText_.x + 10;
        this.consumableTwoText_.y = this.recallText_.y + 27;
        this.consumableTwoText_.setBold(true);
        this.consumableTwoText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.consumableTwoText_.text = KeyCodes.CharCodeStrings[keyCodeBox.keyCode_];
        this.consumableTwoText_.updateMetrics();
        addChild(this.consumableTwoText_);
        potionsView = new PotionSlotView(0);
        potionsView.x = consumableOneText_.x;
        potionsView.y = consumableOneText_.y;
        addChild(potionsView);
        potionsView = new PotionSlotView(1);
        potionsView.x = consumableTwoText_.x;
        potionsView.y = consumableTwoText_.y;
        addChild(potionsView);
    }

    public function update(player:Player):void {
    }

    public function draw(player:Player):void {
        if (portrait_ == null) {
            var bmd:BitmapData = ObjectLibrary.getRedrawnTextureFromType(player.objectType_, 64 * 3, false)
            this.portrait_ = new Bitmap(bmd);
            this.portrait_.x = this.content.width / 2 - this.portrait_.width / 2 + 5;
            this.portrait_.y = (64 - this.portrait_.height) / 2 - 64 / 2;
            this.content.addChild(this.portrait_);

            this.content.x = 1;
            this.content.y = 1;
        }
    }

    public function setName(name:String):void {
        this.nameText_.text = name;
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterSlotNeedTsavoriteDialog.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import flash.display.Sprite;
import flash.events.Event;

import org.osflash.signals.Signal;

public class CharacterSlotNeedTsavoriteDialog extends Sprite {

    private static const TEXT:String = "Another character slot costs ${price} Tsavorite. ";

    private static const TITLE:String = "Not Enough Tsavorite";

    private static const CANCEL:String = "Cancel";

    public const cancel:Signal = new Signal();

    private var dialog:Dialog;

    private var price:int;

    public function CharacterSlotNeedTsavoriteDialog() {
        super();
    }

    public function setPrice(price:int):void {
        this.price = price;
        this.dialog && contains(this.dialog) && removeChild(this.dialog);
        this.makeDialog();
        this.dialog.addEventListener(Dialog.LEFT_BUTTON, this.onCancel);
    }

    private function makeDialog():void {
        var text:String = TEXT.replace("${price}", this.price);
        this.dialog = new Dialog(text, TITLE, CANCEL, null);
        addChild(this.dialog);
    }

    public function onCancel(event:Event):void {
        this.cancel.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/CharacterSlotRegisterDialog.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import flash.display.Sprite;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class CharacterSlotRegisterDialog extends Sprite {

    private static const TEXT:String = "In order to have more than one character slot, you must be a registered user.";

    private static const TITLE:String = "Not Registered";

    private static const CANCEL:String = "Cancel";

    private static const REGISTER:String = "Register";


    public var cancel:Signal;

    public var register:Signal;

    private var dialog:Dialog;

    public function CharacterSlotRegisterDialog() {
        super();
        this.makeDialog();
        this.makeSignals();
    }

    private function makeDialog():void {
        this.dialog = new Dialog(TEXT, TITLE, CANCEL, REGISTER);
        addChild(this.dialog);
    }

    private function makeSignals():void {
        this.cancel = new NativeMappedSignal(this.dialog, Dialog.LEFT_BUTTON);
        this.register = new NativeMappedSignal(this.dialog, Dialog.RIGHT_BUTTON);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/ChooseNameRegisterDialog.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class ChooseNameRegisterDialog extends Dialog {

    private static const TEXT:String = "In order to select a unique name you must be a registered user.";

    private static const TITLE:String = "Not Registered";

    private static const CANCEL:String = "Cancel";

    private static const REGISTER:String = "Register";


    public var cancel:Signal;

    public var register:Signal;

    public function ChooseNameRegisterDialog() {
        super(TEXT, TITLE, CANCEL, REGISTER);
        this.cancel = new NativeMappedSignal(this, LEFT_BUTTON);
        this.register = new NativeMappedSignal(this, RIGHT_BUTTON);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/LoadingMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.screens.LoadingScreen;

import svera.lib.framework.Mediator;

import svera.untiered.core.signals.SetLoadingMessageSignal;

public class LoadingMediator extends Mediator {
    [Inject]
    public var view:LoadingScreen;

    [Inject]
    public var setMessage:SetLoadingMessageSignal;

    public function LoadingMediator() {
        super();
    }

    override public function initialize():void {
        this.setMessage.add(this.onSetMessage);
        this.view.setText("<p align=\"center\">Loading...</p>");
    }

    override public function destroy():void {
        this.setMessage.remove(this.onSetMessage);
    }

    private function onSetMessage(message:String):void {
        this.view.setText(message);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/MessageCloseDialog.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class MessageCloseDialog extends Dialog {
    private static const CLOSE:String = "Close";

    public var cancel:Signal;

    public function MessageCloseDialog(title:String = "", message:String = "", buttonText:String = "") {
        var text:String = message;
        super(text, title, buttonText == "" ? CLOSE : buttonText, null);
        this.cancel = new NativeMappedSignal(this, LEFT_BUTTON);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/NewsLineMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.screens.NewsLine;

import svera.lib.framework.Mediator;

import svera.untiered.honor.control.ShowHonorViewSignal;
import svera.untiered.honor.model.SimpleHonorVO;

public class NewsLineMediator extends Mediator {


    [Inject]
    public var view:NewsLine;

    [Inject]
    public var showHonorView:ShowHonorViewSignal;

    public function NewsLineMediator() {
        super();
    }

    override public function initialize():void {
        this.view.viewCharacterHonor.add(this.onViewHonor);
    }

    override public function destroy():void {
        this.view.viewCharacterHonor.remove(this.onViewHonor);
    }

    private function onViewHonor(characterId:int):void {
        this.showHonorView.dispatch(new SimpleHonorVO(this.view.accountId, characterId));
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/NotEnoughTsavoriteDialog.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

public class NotEnoughTsavoriteDialog extends Dialog {

    private static const TEXT:String = "You do not have enough Tsavorite for this item.";

    private static const TITLE:String = "Not Enough Tsavorite";

    private static const CANCEL:String = "Cancel";


    public var cancel:Signal;

    public function NotEnoughTsavoriteDialog(message:String = "") {
        var text:String = message == "" ? TEXT : message;
        super(text, TITLE, CANCEL, null);
        this.cancel = new NativeMappedSignal(this, LEFT_BUTTON);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/RadioButton.as">
package svera.untiered.util.components {
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.Graphics;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Shape;
import flash.display.Sprite;

import org.osflash.signals.Signal;

public class RadioButton extends Sprite {
    public const changed:Signal = new Signal(Boolean);

    private const WIDTH:int = 20;

    private const HEIGHT:int = 20;

    private var unselected:Shape;

    private var selected:Shape;

    public function RadioButton() {
        super();
        addChild(this.unselected = this.makeUnselected());
        addChild(this.selected = this.makeSelected());
        this.setSelected(false);
    }

    public function setSelected(value:Boolean):void {
        this.unselected.visible = !value;
        this.selected.visible = value;
        this.changed.dispatch(value);
    }

    private function makeUnselected():Shape {
        var shape:Shape = new Shape();
        this.drawOutline(shape.graphics);
        return shape;
    }

    private function makeSelected():Shape {
        var shape:Shape = new Shape();
        this.drawOutline(shape.graphics);
        this.drawFill(shape.graphics);
        return shape;
    }

    private function drawOutline(graphics:Graphics):void {
        var internalFill:GraphicsSolidFill = new GraphicsSolidFill(0, 0.01);
        var outlineFill:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);
        var outlineStyle:GraphicsStroke = new GraphicsStroke(2, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, outlineFill);
        var outlinePath:GraphicsPath = new GraphicsPath();
        GraphicsUtil.drawCutEdgeRect(0, 0, this.WIDTH, this.HEIGHT, 4, GraphicsUtil.ALL_CUTS, outlinePath);
        var data:Vector.<IGraphicsData> = new <IGraphicsData>[outlineStyle, internalFill, outlinePath, GraphicsUtil.END_FILL, GraphicsUtil.END_STROKE];
        graphics.drawGraphicsData(data);
    }

    private function drawFill(graphics:Graphics):void {
        var boxFill:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);
        var boxPath:GraphicsPath = new GraphicsPath();
        GraphicsUtil.drawCutEdgeRect(4, 4, this.WIDTH - 8, this.HEIGHT - 8, 2, GraphicsUtil.ALL_CUTS, boxPath);
        var data:Vector.<IGraphicsData> = new <IGraphicsData>[boxFill, boxPath, GraphicsUtil.END_FILL];
        graphics.drawGraphicsData(data);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/VerticalScrollbar.as">
package svera.untiered.util.components {
import flash.display.Sprite;

import org.osflash.signals.Signal;

import svera.lib.ui.api.Scrollbar;

public class VerticalScrollbar extends Sprite implements Scrollbar {
    public static const WIDTH:int = 20;
    public static const BEVEL:int = 4;
    public static const PADDING:int = 0;

    private var _positionChanged:Signal;
    public const groove:VerticalScrollbarGroove = new VerticalScrollbarGroove();
    public const bar:VerticalScrollbarBar = new VerticalScrollbarBar();

    private var position:Number = 0;
    private var range:int;
    private var invRange:Number;
    private var isEnabled:Boolean = true;

    public function VerticalScrollbar() {
        super();
        addChild(this.groove);
        addChild(this.bar);
        this.addMouseListeners();
    }

    public function get positionChanged():Signal {
        return this._positionChanged = this._positionChanged || new Signal(Number);
    }

    public function getIsEnabled():Boolean {
        return this.isEnabled;
    }

    public function setIsEnabled(isEnabled:Boolean):void {
        if (this.isEnabled != isEnabled) {
            this.isEnabled = isEnabled;
            if (isEnabled) {
                this.addMouseListeners();
            } else {
                this.removeMouseListeners();
            }
        }
    }

    private function addMouseListeners():void {
        this.groove.addMouseListeners();
        this.groove.clicked.add(this.onGrooveClicked);
        this.bar.addMouseListeners();
        this.bar.dragging.add(this.onBarDrag);
    }

    private function removeMouseListeners():void {
        this.groove.removeMouseListeners();
        this.groove.clicked.remove(this.onGrooveClicked);
        this.bar.removeMouseListeners();
        this.bar.dragging.remove(this.onBarDrag);
    }

    public function setSize(barSize:int, grooveSize:int):void {
        this.bar.rect.height = barSize;
        this.groove.rect.height = grooveSize;
        this.range = grooveSize - barSize - PADDING * 2;
        this.invRange = 1 / this.range;
        this.groove.redraw();
        this.bar.redraw();
        this.setPosition(this.getPosition());
    }

    public function getBarSize():int {
        return this.bar.rect.height;
    }

    public function getGrooveSize():int {
        return this.groove.rect.height;
    }

    public function getPosition():Number {
        return this.position;
    }

    public function setPosition(value:Number):void {
        if (value < 0) {
            value = 0;
        } else if (value > 1) {
            value = 1;
        }
        this.position = value;
        this.bar.y = PADDING + this.range * this.position;
        this._positionChanged && this._positionChanged.dispatch(this.position);
    }

    public function scrollPosition(value:Number):void {
        var position:Number = this.position + value;
        this.setPosition(position);
    }

    private function onBarDrag(value:int):void {
        this.setPosition((value - PADDING) * this.invRange);
    }

    private function onGrooveClicked(value:int):void {
        var barHeight:int = this.bar.rect.height;
        var numerator:int = value - barHeight * 0.5;
        var denominator:int = this.groove.rect.height - barHeight;
        this.setPosition(numerator / denominator);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/VerticalScrollingList.as">
package svera.untiered.util.components {
import flash.display.DisplayObject;
import flash.display.Sprite;

import org.osflash.signals.Signal;

import svera.lib.ui.api.List;
import svera.lib.ui.api.Size;
import svera.lib.ui.impl.LayoutList;
import svera.lib.ui.impl.VerticalLayout;

public class VerticalScrollingList extends Sprite implements List {
    public static const SCROLLBAR_PADDING:int = 2;
    public static const SCROLLBAR_GUTTER:int = VerticalScrollbar.WIDTH + SCROLLBAR_PADDING;

    public const scrollStateChanged:Signal = new Signal(Boolean);
    private var layout:VerticalLayout;
    private var list:LayoutList;
    private var scrollbar:VerticalScrollbar;
    private var isEnabled:Boolean = true;
    private var size:Size;

    public function VerticalScrollingList() {
        super();
        this.makeLayout();
        this.makeVerticalList();
        this.makeScrollbar();
    }

    public function getIsEnabled():Boolean {
        return this.isEnabled;
    }

    public function setIsEnabled(value:Boolean):void {
        this.isEnabled = value;
        this.scrollbar.setIsEnabled(value);
    }

    public function setSize(size:Size):void {
        this.size = size;
        if (this.isScrollbarVisible()) {
            size = new Size(size.width - SCROLLBAR_GUTTER, size.height);
        }
        this.list.setSize(size);
        this.refreshScrollbar();
    }

    public function setPadding(padding:int):void {
        this.layout.setPadding(padding);
        this.list.updateLayout();
        this.refreshScrollbar();
    }

    public function addItem(item:DisplayObject):void {
        this.list.addItem(item);
    }

    public function setItems(items:Vector.<DisplayObject>):void {
        this.list.setItems(items);
    }

    public function getItemAt(index:int):DisplayObject {
        return this.list.getItemAt(index);
    }

    public function getItemCount():int {
        return this.list.getItemCount();
    }

    public function getListHeight():int {
        return this.list.getSizeOfItems().height;
    }

    private function makeLayout():void {
        this.layout = new VerticalLayout();
    }

    public function isScrollbarVisible():Boolean {
        return this.scrollbar.visible;
    }

    private function makeVerticalList():void {
        this.list = new LayoutList();
        this.list.itemsChanged.add(this.refreshScrollbar);
        this.list.setLayout(this.layout);
        addChild(this.list);
    }

    private function refreshScrollbar():void {
        var isVisible:Boolean;
        var listSize:Size = this.list.getSize();
        var visibleSize:int = listSize.height;
        var itemsSize:int = this.list.getSizeOfItems().height;
        isVisible = itemsSize > visibleSize;
        var isChanged:Boolean = this.scrollbar.visible != isVisible;
        this.scrollbar.visible = isVisible;
        isVisible && this.updateScrollbarSize(visibleSize, itemsSize);
        isChanged && this.updateUiAndDispatchStateChange(isVisible);
    }

    private function updateUiAndDispatchStateChange(isVisible:Boolean):void {
        this.setSize(this.size);
        this.scrollStateChanged.dispatch(isVisible);
    }

    private function updateScrollbarSize(visibleSize:int, itemsSize:int):void {
        var barSize:int = visibleSize * (visibleSize / itemsSize);
        this.scrollbar.setSize(barSize, visibleSize);
        this.scrollbar.x = this.list.getSize().width + SCROLLBAR_PADDING;
    }

    private function makeScrollbar():void {
        this.scrollbar = new VerticalScrollbar();
        this.scrollbar.positionChanged.add(this.onPositionChanged);
        this.scrollbar.visible = false;
        addChild(this.scrollbar);
    }

    private function onPositionChanged(value:Number):void {
        var maxOffset:int = this.list.getSizeOfItems().height - this.list.getSize().height;
        this.list.setOffset(maxOffset * value);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/FrameuBox.as">
/**
 * Created by vooolox on 07-2-2016.
 */
package com.company.assembleegameclient.account.ui.unboxing {
import com.company.assembleegameclient.account.ui.*;

import com.company.assembleegameclient.ui.ClickableText;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.GraphicsGradientFill;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

public class FrameuBox extends Sprite
{

    public function FrameuBox(_arg1:String, button1Text:String, _arg5:int = 288) {

        this.frameTextInputBoxes = new Vector.<TextInputField>();
        this.frameTextButtons_ = new Vector.<ClickableText>();
        this.primaryColorLight = new GraphicsSolidFill(0x000000, 1);
        this.primaryColorDark = new GraphicsGradientFill("linear", [0x696969, 0xA9A9A9, 0xC0C0C0, 0xD3D3D3], null, null, null, "pad", "rgb")
        this.outlineFill_ = new GraphicsSolidFill(0xFFFFFF, 1);
        this._graphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, this.outlineFill_);
        this.path1_ = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        this.path2_ = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        this.graphicsData_ = new <IGraphicsData>[primaryColorDark, path2_, GraphicsUtil.END_FILL, primaryColorLight, path1_, GraphicsUtil.END_FILL, _graphicsStroke, path2_, GraphicsUtil.END_STROKE];
        super();
        this.w_ = _arg5;
        this.frameTitle = new SimpleText(12, 0xFFFFFF, false, 0, 0);
        this.frameTitle.text = _arg1;
        this.frameTitle.updateMetrics();
        this.frameTitle.filters = [new DropShadowFilter(0, 0, 0)];
        this.frameTitle.x = 5;
        this.frameTitle.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addChild(this.frameTitle);
        this.Button1 = new ClickableText(18, true, button1Text);
        if (button1Text != "") {
            this.Button1.buttonMode = true;
            this.Button1.x = this.w_ / 2 - Button1.width / 2;
            addChild(this.Button1);
        }
        this.XButton = new TextButton(12, "X");
        this.XButton.x = this.w_ - this.XButton.width - 15;
        addChild(this.XButton);
        filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }
    public var frameTitle:SimpleText;
    public var Button1:ClickableText;
    public var XButton:TextButton;
    public var frameTextInputBoxes:Vector.<TextInputField>;
    public var frameTextButtons_:Vector.<ClickableText>;
    protected var w_:int = 288;
    protected var h_:int = 100;
    private var graphicsData_:Vector.<IGraphicsData>;
    private var primaryColorLight:GraphicsSolidFill;
    private var primaryColorDark:GraphicsGradientFill;
    private var outlineFill_:GraphicsSolidFill;
    private var _graphicsStroke:GraphicsStroke;
    private var path1_:GraphicsPath;
    private var path2_:GraphicsPath;


    public function offsetH(_arg1:int):void
    {
        this.h_ = this.h_ + _arg1;
    }

    public function draw():void {
        this.graphics.clear();
        GraphicsUtil.clearPath(this.path1_);
        GraphicsUtil.drawUI(-6, -6, this.w_, 20 + 12, 4, [1, 1, 0, 0], this.path1_);
        GraphicsUtil.clearPath(this.path2_);
        GraphicsUtil.drawUI(-6, -6, this.w_, this.h_, 4, [1, 1, 1, 1], this.path2_);
        this.Button1.y = this.h_ - 48;
        this.graphics.drawGraphicsData(this.graphicsData_);
    }

    public function onAddedToStage(_arg1:Event):void {
        this.draw();
        this.x = GameClient.HalfStageWidth - (this.w_ - 6) / 2;
        this.y = GameClient.HalfStageHeight - h_ / 2; //was height
        if (this.frameTextInputBoxes.length > 0) {
            stage.focus = this.frameTextInputBoxes[0].inputText_;
        }
    }

    private function onRemovedFromStage(_arg1:Event):void {
    }

}
}
</file>

<file path="src/com/company/assembleegameclient/appengine/SavedCharacter.as">
package com.company.assembleegameclient.appengine {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.AnimatedChar;
import com.company.assembleegameclient.util.AnimatedChars;
import com.company.assembleegameclient.util.MaskedImage;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.assembleegameclient.util.redrawers.GlowRedrawer;
import com.company.util.CachingColorTransformer;

import flash.display.BitmapData;
import flash.geom.ColorTransform;

public class SavedCharacter {
    private static const dimmedCT:ColorTransform = new ColorTransform(0, 0, 0, 0.5, 0, 0, 0, 0);
    private static const selectedCT:ColorTransform = new ColorTransform(0.75, 0.75, 0.75, 1, 0, 0, 0, 0);

    public var charXML_:XML;

    public var name_:String = null;

    public function SavedCharacter(charXML:XML, name:String) {
        super();
        this.charXML_ = charXML;
        this.name_ = name;
    }

    public static function getImage(savedChar:SavedCharacter, playerXML:XML, dir:int, action:int, p:Number, selected:Boolean, dimmed:Boolean):BitmapData {
        var animatedChar:AnimatedChar = AnimatedChars.getAnimatedChar(String(playerXML.AnimatedTexture.File), int(playerXML.AnimatedTexture.Index));
        var image:MaskedImage = animatedChar.imageFromDir(dir, action, p);
        var tex1:int = savedChar != null ? int(savedChar.tex1()) : int(null);
        var tex2:int = savedChar != null ? int(savedChar.tex2()) : int(null);
        var size:int = 100
        var bd:BitmapData = TextureRedrawer.resize(image.image_, image.mask_, size, false, tex1, tex2);
        bd = GlowRedrawer.outlineGlow(bd, 0);
        if (dimmed) {
            bd = CachingColorTransformer.transformBitmapData(bd, dimmedCT);
        } else if (!selected) {
            bd = CachingColorTransformer.transformBitmapData(bd, selectedCT);
        }
        return bd;
    }

    public static function compare(char1:SavedCharacter, char2:SavedCharacter):Number {
        var char1Use:Number = Parameters.data_.charIdUseMap.hasOwnProperty(char1.charId().toString()) ? Number(Parameters.data_.charIdUseMap[char1.charId()]) : Number(0);
        var char2Use:Number = Parameters.data_.charIdUseMap.hasOwnProperty(char2.charId().toString()) ? Number(Parameters.data_.charIdUseMap[char2.charId()]) : Number(0);
        if (char1Use != char2Use) {
            return char2Use - char1Use;
        }
        return char2.xp() - char1.xp();
    }

    public function charId():int {
        return int(this.charXML_.@id);
    }

    public function name():String {
        return this.name_;
    }

    public function objectType():int {
        return int(this.charXML_.ObjectType);
    }

    public function skinType():int {
        return int(this.charXML_.Texture);
    }

    public function level():int {
        return int(this.charXML_.Level);
    }

    public function awakening():int {
        return int(this.charXML_.Awakening);
    }

    public function relic():int {
        return int(this.charXML_.Relic);
    }

    public function background():int {
        return int(this.charXML_.Background);
    }

    public function ascensionPoints():int {
        return int(this.charXML_.AscensionPoints);
    }

    public function statPoints():int {
        return int(this.charXML_.StatPoints);
    }

    public function tex1():int {
        return int(this.charXML_.Tex1);
    }

    public function tex2():int {
        return int(this.charXML_.Tex2);
    }

    public function xp():int {
        return int(this.charXML_.Exp);
    }

    public function honor():int {
        return int(this.charXML_.CurrentHonor);
    }

    public function displayId():String {
        return ObjectLibrary.typeToDisplayId_[this.objectType()];
    }

    public function toString():String {
        return "SavedCharacter: {" + this.charXML_ + "}";
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/appengine/SavedNewsItem.as">
package com.company.assembleegameclient.appengine {
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;

public class SavedNewsItem {

    private static const HONOR:String = "honor";
    private static const ORYX:String = "oryx";


    private var iconName:String;

    public var title_:String;

    public var tagline_:String;

    public var link_:String;

    public var date_:int;

    public function SavedNewsItem(iconName:String, title:String, tagline:String, link:String, date:int) {
        super();
        this.iconName = iconName;
        this.title_ = title;
        this.tagline_ = tagline;
        this.link_ = link;
        this.date_ = date;
    }

    private static function forumIcon():BitmapData {
        var bd:BitmapData = AssetLibrary.getImageFromSet("lofiInterface2", 4);
        return TextureRedrawer.redraw(bd, 80, true, 0);
    }

    private static function honorIcon():BitmapData {
        var bd:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 0);
        return TextureRedrawer.redraw(bd, 80, true, 0);
    }

    private static function oryxIcon():BitmapData {
        var bd:BitmapData = AssetLibrary.getImageFromSet("Utilities_PetStones8x8", 8);
        return TextureRedrawer.redraw(bd, 110, true, 0);
    }

    public function getIcon():BitmapData {
        switch (this.iconName.toLowerCase()) {
            case HONOR:
                return honorIcon();
            case ORYX:
                return oryxIcon();
        }
        return forumIcon();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/TextureData.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.objects.particles.EffectProperties;
import com.company.assembleegameclient.util.AnimatedChar;
import com.company.assembleegameclient.util.AnimatedChars;
import com.company.assembleegameclient.util.MaskedImage;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;
import flash.utils.Dictionary;

public class TextureData {
    public var texture_:BitmapData = null;

    public var mask_:BitmapData = null;

    public var animatedChar_:AnimatedChar = null;

    public var randomTextureData_:Vector.<TextureData> = null;

    public var altTextures_:Dictionary = null;

    public var effectProps_:EffectProperties = null;

    public function TextureData(objectXML:XML) {
        var altTexture:XML = null;
        super();
        if (objectXML.hasOwnProperty("Texture")) {
            try {
                this.parse(XML(objectXML.Texture))
            } catch (e:Error) {
                trace(String(objectXML.@id));
            }
        } else if (objectXML.hasOwnProperty("AnimatedTexture")) {
            this.parse(XML(objectXML.AnimatedTexture));
        } else if (objectXML.hasOwnProperty("RandomTexture")) {
            this.parse(XML(objectXML.RandomTexture));
        } else {
            this.parse(objectXML);
        }
        for each(altTexture in objectXML.AltTexture) {
            this.parse(altTexture);
        }
        if (objectXML.hasOwnProperty("Mask")) {
            this.parse(XML(objectXML.Mask));
        }
        if (objectXML.hasOwnProperty("Effect")) {
            this.parse(XML(objectXML.Effect));
        }
    }

    public function getTexture(id:int = 0):BitmapData {
        if (this.randomTextureData_ == null) {
            return this.texture_;
        }
        var textureData:TextureData = this.randomTextureData_[id % this.randomTextureData_.length];
        return textureData.getTexture(id);
    }

    public function getAltTextureData(id:int):TextureData {
        if (this.altTextures_ == null) {
            return null;
        }
        return this.altTextures_[id];
    }

    private function parse(xml:XML):void {
        var image:MaskedImage = null;
        var childXML:XML = null;
        //trace(xml.File);
        switch (xml.name().toString()) {
            case "Texture":
                this.texture_ = AssetLibrary.getImageFromSet(String(xml.File), int(xml.Index));
                break;
            case "Mask":
                this.mask_ = AssetLibrary.getImageFromSet(String(xml.File), int(xml.Index));
                break;
            case "Effect":
                this.effectProps_ = new EffectProperties(xml);
                break;
            case "AnimatedTexture":
                this.animatedChar_ = AnimatedChars.getAnimatedChar(String(xml.File), int(xml.Index));
                image = this.animatedChar_.imageFromAngle(0, AnimatedChar.STAND, 0);
                this.texture_ = image.image_;
                this.mask_ = image.mask_;
                break;
            case "RandomTexture":
                this.randomTextureData_ = new Vector.<TextureData>();
                for each(childXML in xml.children()) {
                    this.randomTextureData_.push(new TextureData(childXML));
                }
                break;
            case "AltTexture":
                if (this.altTextures_ == null) {
                    this.altTextures_ = new Dictionary();
                }
                this.altTextures_[int(xml.@id)] = new TextureData(xml);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/charrects/CharacterRectList.as">
package com.company.assembleegameclient.screens.charrects {
import com.company.assembleegameclient.appengine.CharacterStats;
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.parameters.Parameters;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;
import org.swiftsuspenders.Injector;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.core.StaticInjectorContext;
import svera.untiered.core.model.PlayerModel;

public class CharacterRectList extends Sprite {
    private var classes:ClassesModel;
    private var model:PlayerModel;
    private var assetFactory:CharacterFactory;
    public var newCharacter:Signal;
    public var buyCharacterSlot:Signal;

    public function CharacterRectList() {
        var savedChar:SavedCharacter = null;
        var buyRect:BuyCharacterRect;
        var charType:CharacterClass = null;
        var charStats:CharacterStats = null;
        var currCharBox:CurrentCharacterRect = null;
        var i:int = 0;
        var newCharRect:CreateNewCharacterRect = null;
        super();
        var injector:Injector = StaticInjectorContext.getInjector();
        this.classes = injector.getInstance(ClassesModel);
        this.model = injector.getInstance(PlayerModel);
        this.assetFactory = injector.getInstance(CharacterFactory);
        this.newCharacter = new Signal();
        this.buyCharacterSlot = new Signal();
        var charName:String = this.model.getName();
        var xOffset:int = 30;
        var savedChars:Vector.<SavedCharacter> = this.model.getSavedCharacters();
        for each(savedChar in savedChars) {
            charType = this.classes.getCharacterClass(savedChar.objectType());
            charStats = charType.getStats();
            currCharBox = new CurrentCharacterRect(charName, charType, savedChar, charStats);
            currCharBox.setIcon(this.getIcon(savedChar));
            currCharBox.x = xOffset;
            addChild(currCharBox);
            xOffset = xOffset + (CharacterRect.WIDTH + 30);
        }
        if (this.model.hasAvailableCharSlot()) {
            var numCharSlots:int = this.model.getAvailableCharSlots();
            var numRows:int = Math.ceil(numCharSlots / 5);
            var rowHeight:int = CharacterRect.HEIGHT + 30; // assuming CharacterRect.HEIGHT includes any padding or margins
            var rowOffset:int = 0;
            for (i = 0; i < numCharSlots; i++) {
                if (i > 0 && i % 5 == 0) {
                    // move the xOffset down by the height of a row
                    xOffset = 0;
                    rowOffset += rowHeight;
                }
                newCharRect = new CreateNewCharacterRect(this.model);
                newCharRect.addEventListener(MouseEvent.MOUSE_DOWN, this.onNewChar);
                newCharRect.x = xOffset;
                newCharRect.y = rowOffset;
                addChild(newCharRect);
                xOffset = xOffset + (CharacterRect.WIDTH + 30);
            }
        }
        buyRect = new BuyCharacterRect(this.model);
        buyRect.addEventListener(MouseEvent.MOUSE_DOWN, this.onBuyCharSlot);
        buyRect.x = xOffset;
        addChild(buyRect);
    }

    private function getIcon(savedChar:SavedCharacter):DisplayObject {
        var type:CharacterClass = this.classes.getCharacterClass(savedChar.objectType());
        var skin:CharacterSkin = type.skins.getSkin(savedChar.skinType()) || type.skins.getDefaultSkin();
        var data:BitmapData = this.assetFactory.makeIcon(skin.template, 50, savedChar.tex1(), savedChar.tex2());
        return new Bitmap(data);
    }

    private function onNewChar(event:Event):void {
        this.newCharacter.dispatch();
    }

    private function onBuyCharSlot(event:Event):void {
        this.buyCharacterSlot.dispatch(Parameters.CHARACTER_SLOT_PRICE);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/charrects/CurrentCharacterRect.as">
package com.company.assembleegameclient.screens.charrects {
import com.company.assembleegameclient.appengine.CharacterStats;
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.screens.events.DeleteCharacterEvent;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.DeleteXGraphic;

import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.classes.model.CharacterClass;

public class CurrentCharacterRect extends CharacterRect {
    private static var toolTip_:ToolTip = null;

    public var charName:String;
    private var charType:CharacterClass;
    public var char:SavedCharacter;
    public var charStats:CharacterStats;
    private var classNameText:SimpleText;
    private var taglineIcon:Sprite;
    private var taglineText:SimpleText;
    private var deleteButton:Sprite;
    public var selected:Signal;
    public var deleteCharacter:Signal;
    private var icon:DisplayObject;

    public function CurrentCharacterRect(charName:String, charType:CharacterClass, char:SavedCharacter, charStats:CharacterStats) {
        super(6052956, 8355711);
        this.charName = charName;
        this.charType = charType;
        this.char = char;
        this.charStats = charStats;
        makeContainer();
        this.makeClassNameText();
        this.makeDeleteButton();
        this.selected = new NativeMappedSignal(selectContainer, MouseEvent.CLICK).mapTo(char);
        this.deleteCharacter = new NativeMappedSignal(this.deleteButton, MouseEvent.CLICK).mapTo(char);
    }

    public function setIcon(value:DisplayObject):void {
        this.icon && selectContainer.removeChild(this.icon);
        this.icon = value;
        this.icon.x = this.width / 2 - this.icon.width / 2;
        this.icon.y = this.height / 2 - this.icon.height / 2 - 6;
        this.icon && selectContainer.addChild(this.icon);
    }

    private function makeClassNameText():void {
        this.classNameText = new SimpleText(12, 16777215, false, 0, 0);
        this.classNameText.setBold(true);
        this.classNameText.text = this.charType.name + " " + this.char.level();
        this.classNameText.updateMetrics();
        this.classNameText.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.classNameText.x = this.width / 2 - this.classNameText.width / 2;
        this.classNameText.y = this.y + this.height - this.classNameText.height;
        selectContainer.addChild(this.classNameText);
    }

    private function makeDeleteButton():void {
        this.deleteButton = new DeleteXGraphic();
        this.deleteButton.addEventListener(MouseEvent.MOUSE_DOWN, this.onDeleteDown);
        this.deleteButton.x = (this.x + this.deleteButton.width) * 0.2;
        this.deleteButton.y = (this.y + this.deleteButton.height) * 0.2;
        addChild(this.deleteButton);
    }

    override protected function onMouseOver(event:MouseEvent):void {
        super.onMouseOver(event);
    }

    override protected function onRollOut(event:MouseEvent):void {
        super.onRollOut(event);
    }

    private function onDeleteDown(event:MouseEvent):void {
        event.stopImmediatePropagation();
        dispatchEvent(new DeleteCharacterEvent(this.char));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/sound/SoundEffectLibrary.as">
package com.company.assembleegameclient.sound {
import com.company.assembleegameclient.parameters.Parameters;

import flash.events.IOErrorEvent;
import flash.media.Sound;
import flash.media.SoundTransform;
import flash.net.URLRequest;
import flash.utils.Dictionary;

public class SoundEffectLibrary {
    private static const URL_PATTERN:String = "{URLBASE}/sfx/{NAME}.mp3";
    public static var nameMap_:Dictionary = new Dictionary();
    private static var playMap_:Dictionary = new Dictionary();
    private static var clearTicks:int;


    public function SoundEffectLibrary() {
        super();
    }

    public static function load(name:String):Sound {
        return nameMap_[name] = nameMap_[name] || makeSound(name);
    }

    public static function makeSound(name:String):Sound {
        var sound:Sound = new Sound();
        sound.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
        sound.load(makeSoundRequest(name));
        return sound;
    }

    private static function makeSoundRequest(name:String):URLRequest {
        var url:String = URL_PATTERN.replace("{URLBASE}", Parameters.appServerAddress()).replace("{NAME}", name);
        return new URLRequest(url);
    }

    public static function clear():void {
        clearTicks++;
        if (clearTicks % 5 == 0) {
            playMap_ = new Dictionary();
        }
    }

    public static function play(name:String, volume:Number = 1.0, isFX:Boolean = true):void {
        var playFX:Boolean = Parameters.data_.playSFX && isFX || !isFX && Parameters.data_.playPewPew;
        if (!playFX) {
            return;
        }

        if (playMap_[name]) {
            return;
        }

        playMap_[name] = true;

        var actualVolume:Number = NaN;
        var trans:SoundTransform = null;
        var sound:Sound = load(name);
        try {
            actualVolume = volume;
            trans = new SoundTransform(actualVolume);
            if (trans && sound)
                sound.play(0, 0, trans);
        } catch (error:Error) {
            trace("ERROR playing " + name + ": " + error.message);
        }
    }

    public static function onIOError(event:IOErrorEvent):void {
        trace("ERROR loading sound: " + event.text);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/dialogs/NotEnoughFameDialog.as">
package com.company.assembleegameclient.ui.dialogs {
import flash.events.Event;

public class NotEnoughHonorDialog extends Dialog {


    public function NotEnoughHonorDialog() {
        super("You do not have enough Honor for this item.  " + "You gain Honor when your character dies after having " + "accomplished great things.", "Not Enough Honor", "Ok", null);
        addEventListener(LEFT_BUTTON, this.onOk);
    }

    public function onOk(event:Event):void {
        parent.removeChild(this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/guild/GuildChronicleScreen.as">
package com.company.assembleegameclient.ui.guild {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.game.events.GuildResultEvent;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.ui.dialogs.Dialog;
import com.company.untiered.graphics.ScreenGraphic;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;

public class GuildChronicleScreen extends Sprite {


    private var gs_:GameSprite;

    private var guildPlayerList_:GuildPlayerList;

    private var continueButton_:TitleMenuOption;

    public function GuildChronicleScreen(gs:GameSprite) {
        super();
        this.gs_ = gs;
        graphics.clear();
        graphics.beginFill(2829099, 0.8);
        graphics.drawRect(0, 0, GameClient.StageWidth, 600);
        graphics.endFill();
        this.addList();
        addChild(new ScreenGraphic());
        this.continueButton_ = new TitleMenuOption("continue", 36, false);
        this.continueButton_.addEventListener(MouseEvent.CLICK, this.onContinueClick);
        addChild(this.continueButton_);
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private function addList():void {
        var player:Player = this.gs_.map.player_;
        this.guildPlayerList_ = new GuildPlayerList(50, 0, player == null ? "" : player.name_, player.guildRank_);
        this.guildPlayerList_.addEventListener(GuildPlayerListEvent.SET_RANK, this.onSetRank);
        this.guildPlayerList_.addEventListener(GuildPlayerListEvent.REMOVE_MEMBER, this.onRemoveMember);
        addChild(this.guildPlayerList_);
    }

    private function removeList():void {
        this.guildPlayerList_.removeEventListener(GuildPlayerListEvent.SET_RANK, this.onSetRank);
        this.guildPlayerList_.removeEventListener(GuildPlayerListEvent.REMOVE_MEMBER, this.onRemoveMember);
        removeChild(this.guildPlayerList_);
    }

    private function onSetRank(event:GuildPlayerListEvent):void {
        this.removeList();
        this.gs_.addEventListener(GuildResultEvent.EVENT, this.onSetRankResult);
        this.gs_.gsc_.changeGuildRank(event.name_, event.rank_);
    }

    private function onSetRankResult(event:GuildResultEvent):void {
        this.gs_.removeEventListener(GuildResultEvent.EVENT, this.onSetRankResult);
        if (!event.success_) {
            this.showError(event.errorText_);
        } else {
            this.addList();
        }
    }

    private function onRemoveMember(event:GuildPlayerListEvent):void {
        this.removeList();
        this.gs_.addEventListener(GuildResultEvent.EVENT, this.onRemoveResult);
        this.gs_.gsc_.guildRemove(event.name_);
    }

    private function onRemoveResult(event:GuildResultEvent):void {
        this.gs_.removeEventListener(GuildResultEvent.EVENT, this.onRemoveResult);
        if (!event.success_) {
            this.showError(event.errorText_);
        } else {
            this.addList();
        }
    }

    private function showError(errorText:String):void {
        var dialog:Dialog = new Dialog(errorText, "Error", "Ok", null);
        dialog.addEventListener(Dialog.LEFT_BUTTON, this.onErrorTextDone);
        stage.addChild(dialog);
    }

    private function onErrorTextDone(event:Event):void {
        var dialog:Dialog = event.currentTarget as Dialog;
        stage.removeChild(dialog);
        this.addList();
    }

    private function onContinueClick(event:MouseEvent):void {
        this.close();
    }

    private function onAddedToStage(event:Event):void {
        this.continueButton_.x = stage.stageWidth / 2 - this.continueButton_.width / 2;
        this.continueButton_.y = 520;
        stage.addEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown, false, 1);
        stage.addEventListener(KeyboardEvent.KEY_UP, this.onKeyUp, false, 1);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown, false);
        stage.removeEventListener(KeyboardEvent.KEY_UP, this.onKeyUp, false);
    }

    private function onKeyDown(event:KeyboardEvent):void {
        event.stopImmediatePropagation();
    }

    private function onKeyUp(event:KeyboardEvent):void {
        event.stopImmediatePropagation();
    }

    private function close():void {
        stage.focus = null;
        parent.removeChild(this);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/guild/MemberListLine.as">
package com.company.assembleegameclient.ui.guild {
import com.company.assembleegameclient.ui.dialogs.Dialog;
import com.company.assembleegameclient.util.GuildUtil;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.DeleteXGraphic;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.Graphics;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

public class MemberListLine extends Sprite {

    public static const WIDTH:int = 756;

    public static const HEIGHT:int = 32;

    protected static const mouseOverCT:ColorTransform = new ColorTransform(1, 220 / 255, 133 / 255);


    private var name_:String;

    private var rank_:int;

    private var placeText_:SimpleText;

    private var nameText_:SimpleText;

    private var guildHonorText_:SimpleText;

    private var guildHonorIcon_:Bitmap;

    private var rankIcon_:Bitmap;

    private var rankText_:SimpleText;

    private var promoteButton_:Sprite;

    private var demoteButton_:Sprite;

    private var removeButton_:Sprite;

    function MemberListLine(place:int, name:String, rank:int, honor:int, isMe:Boolean, myRank:int) {
        super();
        this.name_ = name;
        this.rank_ = rank;
        var textColor:uint = 11776947;
        if (isMe) {
            textColor = 16564761;
        }
        this.placeText_ = new SimpleText(22, textColor, false, 0, 0);
        this.placeText_.setBold(true);
        this.placeText_.text = place.toString() + ".";
        this.placeText_.useTextDimensions();
        this.placeText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.placeText_.x = 60 - this.placeText_.width;
        this.placeText_.y = HEIGHT / 2 - this.placeText_.height / 2;
        addChild(this.placeText_);
        this.nameText_ = new SimpleText(22, textColor, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.text = name;
        this.nameText_.useTextDimensions();
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.nameText_.x = 100;
        this.nameText_.y = HEIGHT / 2 - this.nameText_.height / 2;
        addChild(this.nameText_);
        this.guildHonorText_ = new SimpleText(22, textColor, false, 0, 0);
        this.guildHonorText_.text = honor.toString();
        this.guildHonorText_.useTextDimensions();
        this.guildHonorText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.guildHonorText_.x = 408 - this.guildHonorText_.width;
        this.guildHonorText_.y = HEIGHT / 2 - this.guildHonorText_.height / 2;
        addChild(this.guildHonorText_);
        this.guildHonorIcon_ = new Bitmap(GuildUtil.guildHonorIcon(40));
        this.guildHonorIcon_.x = 400;
        this.guildHonorIcon_.y = HEIGHT / 2 - this.guildHonorIcon_.height / 2;
        addChild(this.guildHonorIcon_);
        this.rankIcon_ = new Bitmap(GuildUtil.rankToIcon(rank, 20));
        this.rankIcon_.x = 548;
        this.rankIcon_.y = HEIGHT / 2 - this.rankIcon_.height / 2;
        addChild(this.rankIcon_);
        this.rankText_ = new SimpleText(22, textColor, false, 0, 0);
        this.rankText_.text = GuildUtil.rankToString(rank);
        this.rankText_.useTextDimensions();
        this.rankText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.rankText_.x = 580;
        this.rankText_.y = HEIGHT / 2 - this.rankText_.height / 2;
        addChild(this.rankText_);
        if (GuildUtil.canPromote(myRank, rank)) {
            this.promoteButton_ = this.createArrow(true);
            this.addHighlighting(this.promoteButton_);
            this.promoteButton_.addEventListener(MouseEvent.CLICK, this.onPromote);
            this.promoteButton_.x = 670 + 6;
            this.promoteButton_.y = HEIGHT / 2;
            addChild(this.promoteButton_);
        }
        if (GuildUtil.canDemote(myRank, rank)) {
            this.demoteButton_ = this.createArrow(false);
            this.addHighlighting(this.demoteButton_);
            this.demoteButton_.addEventListener(MouseEvent.CLICK, this.onDemote);
            this.demoteButton_.x = 700 + 6;
            this.demoteButton_.y = HEIGHT / 2;
            addChild(this.demoteButton_);
        }
        if (GuildUtil.canRemove(myRank, rank)) {
            this.removeButton_ = new DeleteXGraphic();
            this.addHighlighting(this.removeButton_);
            this.removeButton_.addEventListener(MouseEvent.CLICK, this.onRemove);
            this.removeButton_.x = 730;
            this.removeButton_.y = HEIGHT / 2 - this.removeButton_.height / 2;
            addChild(this.removeButton_);
        }
    }

    private function createArrow(up:Boolean):Sprite {
        var sprite:Sprite = new Sprite();
        var g:Graphics = sprite.graphics;
        g.beginFill(16777215);
        g.moveTo(-8, -6);
        g.lineTo(8, -6);
        g.lineTo(0, 6);
        g.lineTo(-8, -6);
        if (up) {
            sprite.rotation = 180;
        }
        return sprite;
    }

    private function addHighlighting(sprite:Sprite):void {
        sprite.addEventListener(MouseEvent.MOUSE_OVER, this.onHighlightOver);
        sprite.addEventListener(MouseEvent.ROLL_OUT, this.onHighlightOut);
    }

    private function onHighlightOver(event:MouseEvent):void {
        var target:Sprite = event.currentTarget as Sprite;
        target.transform.colorTransform = mouseOverCT;
    }

    private function onHighlightOut(event:MouseEvent):void {
        var target:Sprite = event.currentTarget as Sprite;
        target.transform.colorTransform = MoreColorUtil.identity;
    }

    private function onPromote(event:MouseEvent):void {
        var dialog:Dialog = new Dialog("Are you sure you want to promote " + this.name_ + " to " + GuildUtil.rankToString(GuildUtil.promotedRank(this.rank_)) + "?", "Promote " + this.name_, "Cancel", "Promote");
        dialog.addEventListener(Dialog.LEFT_BUTTON, this.onCancelDialog);
        dialog.addEventListener(Dialog.RIGHT_BUTTON, this.onVerifiedPromote);
        stage.addChild(dialog);
    }

    private function onVerifiedPromote(event:Event):void {
        var dialog:Dialog = event.currentTarget as Dialog;
        stage.removeChild(dialog);
        dispatchEvent(new GuildPlayerListEvent(GuildPlayerListEvent.SET_RANK, this.name_, GuildUtil.promotedRank(this.rank_)));
    }

    private function onDemote(event:MouseEvent):void {
        var dialog:Dialog = new Dialog("Are you sure you want to demote " + this.name_ + " to " + GuildUtil.rankToString(GuildUtil.demotedRank(this.rank_)) + "?", "Demote " + this.name_, "Cancel", "Demote");
        dialog.addEventListener(Dialog.LEFT_BUTTON, this.onCancelDialog);
        dialog.addEventListener(Dialog.RIGHT_BUTTON, this.onVerifiedDemote);
        stage.addChild(dialog);
    }

    private function onVerifiedDemote(event:Event):void {
        var dialog:Dialog = event.currentTarget as Dialog;
        stage.removeChild(dialog);
        dispatchEvent(new GuildPlayerListEvent(GuildPlayerListEvent.SET_RANK, this.name_, GuildUtil.demotedRank(this.rank_)));
    }

    private function onRemove(event:MouseEvent):void {
        var dialog:Dialog = new Dialog("Are you sure you want to remove " + this.name_ + " from the guild?", "Remove " + this.name_, "Cancel", "Remove");
        dialog.addEventListener(Dialog.LEFT_BUTTON, this.onCancelDialog);
        dialog.addEventListener(Dialog.RIGHT_BUTTON, this.onVerifiedRemove);
        stage.addChild(dialog);
    }

    private function onVerifiedRemove(event:Event):void {
        var dialog:Dialog = event.currentTarget as Dialog;
        stage.removeChild(dialog);
        dispatchEvent(new GuildPlayerListEvent(GuildPlayerListEvent.REMOVE_MEMBER, this.name_));
    }

    private function onCancelDialog(event:Event):void {
        var dialog:Dialog = event.currentTarget as Dialog;
        stage.removeChild(dialog);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/GuildRegisterPanel.as">
package com.company.assembleegameclient.ui.panels {
import com.company.assembleegameclient.account.ui.CreateGuildFrame;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.FrameOverlay;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.ui.dialogs.Dialog;
import com.company.assembleegameclient.util.Currency;
import com.company.assembleegameclient.util.GuildUtil;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;

import svera.untiered.util.components.LegacyBuyButton;

public class GuildRegisterPanel extends Panel {


    private var title_:SimpleText;

    private var button_:Sprite;

    public function GuildRegisterPanel(gs:GameSprite) {
        var rankName:String = null;
        var buyButton:LegacyBuyButton = null;
        super(gs);
        if (gs_.map == null || gs_.map.player_ == null) {
            return;
        }
        var p:Player = gs_.map.player_;
        this.title_ = new SimpleText(18, 16777215, false, WIDTH, 0);
        this.title_.setBold(true);
        this.title_.wordWrap = true;
        this.title_.multiline = true;
        this.title_.autoSize = TextFieldAutoSize.CENTER;
        this.title_.filters = [new DropShadowFilter(0, 0, 0)];
        if (p.guildName_ != null && p.guildName_.length > 0) {
            rankName = GuildUtil.rankToString(p.guildRank_);
            this.title_.htmlText = "<p align=\"center\">" + rankName + " of \n" + p.guildName_ + "</p>";
            this.title_.y = 0;
            addChild(this.title_);
            this.button_ = new TextButton(16, "Renounce");
            this.button_.addEventListener(MouseEvent.CLICK, this.onRenounceClick);
            this.button_.x = WIDTH / 2 - this.button_.width / 2;
            this.button_.y = HEIGHT - this.button_.height - 4;
            addChild(this.button_);
        } else {
            this.title_.htmlText = "<p align=\"center\">Create a Guild</p>";
            this.title_.y = 0;
            addChild(this.title_);
            buyButton = new LegacyBuyButton("Create ", 16, Parameters.GUILD_CREATION_PRICE, Currency.HONOR);
            buyButton.addEventListener(MouseEvent.CLICK, this.onCreateClick);
            buyButton.x = WIDTH / 2 - buyButton.width / 2;
            buyButton.y = HEIGHT - buyButton.height / 2 - 31;
            addChild(buyButton);
            this.button_ = buyButton;
        }
    }

    public function onRenounceClick(event:MouseEvent):void {
        if (gs_.map == null || gs_.map.player_ == null) {
            return;
        }
        var p:Player = gs_.map.player_;
        var renounceDialog:Dialog = new Dialog("Are you sure you want to quit:\n" + p.guildName_, "Renounce Guild", "No, I\'ll stay", "Yes, I\'ll quit");
        renounceDialog.addEventListener(Dialog.LEFT_BUTTON, this.onNoRenounce);
        renounceDialog.addEventListener(Dialog.RIGHT_BUTTON, this.onRenounce);
        stage.addChild(renounceDialog);
    }

    private function onNoRenounce(event:Event):void {
        stage.removeChild(event.currentTarget as Dialog);
    }

    private function onRenounce(event:Event):void {
        if (gs_.map == null || gs_.map.player_ == null) {
            return;
        }
        var p:Player = gs_.map.player_;
        gs_.gsc_.guildRemove(p.name_);
        stage.removeChild(event.currentTarget as Dialog);
        visible = false;
    }

    public function onCreateClick(event:MouseEvent):void {
        var sprite:Sprite = new FrameOverlay(new CreateGuildFrame(gs_));
        stage.addChild(sprite);
        visible = false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/InteractiveItemTile.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;

import flash.display.DisplayObject;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.events.TimerEvent;
import flash.geom.Point;
import flash.utils.Timer;

public class InteractiveItemTile extends ItemTile {
    private static const DOUBLE_CLICK_PAUSE:uint = 250;
    private static const DRAG_DIST:int = 3;


    private var doubleClickTimer:Timer;
    private var dragStart:Point;
    private var pendingSecondClick:Boolean;
    private var isDragging:Boolean;

    public function InteractiveItemTile(id:int, parentGrid:ItemGrid, isInteractive:Boolean) {
        super(id, parentGrid);
        mouseChildren = false;
        this.doubleClickTimer = new Timer(DOUBLE_CLICK_PAUSE, 1);
        this.doubleClickTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onDoubleClickTimerComplete);
        this.setInteractive(isInteractive);
    }

    public function setInteractive(isInteractive:Boolean):void {
        if (isInteractive) {
            addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
            addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
            addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        } else {
            removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
            removeEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        }
    }

    public function getDropTarget():DisplayObject {
        return itemSprite.dropTarget;
    }

    protected function beginDragCallback():void {
    }

    protected function endDragCallback():void {
    }

    private function onMouseOut(e:MouseEvent):void {
        this.setPendingDoubleClick(false);
    }

    private function onMouseUp(e:MouseEvent):void {
        if (this.isDragging) {
            return;
        }
        if (e.shiftKey) {
            this.setPendingDoubleClick(false);
            dispatchEvent(new ItemTileEvent(ItemTileEvent.ITEM_SHIFT_CLICK, this));
        } else if (e.ctrlKey) {
            this.setPendingDoubleClick(false);
            dispatchEvent(new ItemTileEvent(ItemTileEvent.ITEM_CTRL_CLICK, this));
        } else if (!this.pendingSecondClick) {
            this.setPendingDoubleClick(true);
        } else {
            this.setPendingDoubleClick(false);
            dispatchEvent(new ItemTileEvent(ItemTileEvent.ITEM_DOUBLE_CLICK, this));
        }
    }

    private function onMouseDown(e:MouseEvent):void {
        trace("DRAG START: ", getItemData() != null)
        if (getItemData() == null) {
            return;
        }
        this.beginDragCheck(e);
    }

    private function setPendingDoubleClick(isPending:Boolean):void {
        this.pendingSecondClick = isPending;
        if (this.pendingSecondClick) {
            this.doubleClickTimer.reset();
            this.doubleClickTimer.start();
        } else {
            this.doubleClickTimer.stop();
        }
    }

    private function beginDragCheck(e:MouseEvent):void {
        this.dragStart = new Point(e.stageX, e.stageY);
        addEventListener(MouseEvent.MOUSE_MOVE, this.onMouseMoveCheckDrag);
        addEventListener(MouseEvent.MOUSE_OUT, this.cancelDragCheck);
        addEventListener(MouseEvent.MOUSE_UP, this.cancelDragCheck);
    }

    private function cancelDragCheck(e:MouseEvent):void {
        removeEventListener(MouseEvent.MOUSE_MOVE, this.onMouseMoveCheckDrag);
        removeEventListener(MouseEvent.MOUSE_OUT, this.cancelDragCheck);
        removeEventListener(MouseEvent.MOUSE_UP, this.cancelDragCheck);
    }

    private function onMouseMoveCheckDrag(e:MouseEvent):void {
        var dx:Number = e.stageX - this.dragStart.x;
        var dy:Number = e.stageY - this.dragStart.y;
        var distance:Number = Math.sqrt(dx * dx + dy * dy);
        if (distance > DRAG_DIST) {
            this.cancelDragCheck(null);
            this.setPendingDoubleClick(false);
            this.beginDrag(e);
        }
    }

    private function onDoubleClickTimerComplete(e:TimerEvent):void {
        this.setPendingDoubleClick(false);
        dispatchEvent(new ItemTileEvent(ItemTileEvent.ITEM_CLICK, this));
    }

    private function beginDrag(e:MouseEvent):void {
        this.isDragging = true;
        stage.addChild(itemSprite);
        itemSprite.startDrag(true);
        itemSprite.x = e.stageX;
        itemSprite.y = e.stageY;
        itemSprite.addEventListener(MouseEvent.MOUSE_UP, this.endDrag);
        this.beginDragCallback();
    }

    private function endDrag(e:MouseEvent):void {
        this.isDragging = false;
        itemSprite.stopDrag();
        itemSprite.removeEventListener(MouseEvent.MOUSE_UP, this.endDrag);
        dispatchEvent(new ItemTileEvent(ItemTileEvent.ITEM_MOVE, this));
        this.endDragCallback();
    }

    private function onRemovedFromStage(e:Event):void {
        //this.doubleClickTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onDoubleClickTimerComplete); //My addition. Needs testing
        this.setPendingDoubleClick(false);
        this.cancelDragCheck(null);
        this.stopDragging();
    }

    private function stopDragging():void {
        if (this.isDragging) {
            itemSprite.stopDrag();
            if (stage.contains(itemSprite)) {
                stage.removeChild(itemSprite);
            }
            this.isDragging = false;
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/RankText.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.filters.DropShadowFilter;

public class RankText extends Sprite {


    public var sprite_:Sprite = null;

    public var largeText_:Boolean;

    private var numStars_:int = -1;

    private var prefix_:SimpleText = null;

    public function RankText(numStars:int, largeText:Boolean, includePrefix:Boolean) {
        super();
        this.largeText_ = largeText;
        if (includePrefix) {
            this.prefix_ = new SimpleText(this.largeText_ ? int(18) : int(16), 11776947, false, 0, 0);
            this.prefix_.setBold(this.largeText_);
            this.prefix_.text = "Rank: ";
            this.prefix_.updateMetrics();
            this.prefix_.filters = [new DropShadowFilter(0, 0, 0)];
            addChild(this.prefix_);
        }
        mouseEnabled = false;
        mouseChildren = false;
        this.draw(numStars);
    }

    public function draw(numStars:int):void {
        var icon:Sprite = null;
        if (numStars == this.numStars_) {
            return;
        }
        this.numStars_ = numStars;
        if (this.sprite_ != null && contains(this.sprite_)) {
            removeChild(this.sprite_);
        }
        if (this.numStars_ < 0) {
            return;
        }
        this.sprite_ = new Sprite();
        var text:SimpleText = new SimpleText(this.largeText_ ? int(18) : int(16), 11776947, false, 0, 0);
        text.setBold(this.largeText_);
        text.text = this.numStars_.toString();
        text.updateMetrics();
        text.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        this.sprite_.addChild(text);
        icon = this.largeText_ ? HonorUtil.numStarsToBigImage(this.numStars_) : HonorUtil.numStarsToImage(this.numStars_);
        icon.x = text.width + 2;
        this.sprite_.addChild(icon);
        icon.y = int(text.height / 2 - icon.height / 2) + 1;
        var w:int = icon.x + icon.width;
        this.sprite_.graphics.clear();
        this.sprite_.graphics.beginFill(0, 0.4);
        this.sprite_.graphics.drawRoundRect(-2, icon.y - 3, w + 6, icon.height + 8, 12, 12);
        this.sprite_.graphics.endFill();
        addChild(this.sprite_);
        if (this.prefix_ != null) {
            addChild(this.prefix_);
            this.sprite_.x = this.prefix_.width;
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/TextButton.as">
package com.company.assembleegameclient.ui {
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.display.Sprite;
import flash.events.MouseEvent;

public class TextButton extends Sprite {
    public var text_:SimpleText;

    public var w_:int;

    private var enabledFill_:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);

    private var disabledFill_:GraphicsSolidFill = new GraphicsSolidFill(8355711, 1);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private const graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[enabledFill_, path_, GraphicsUtil.END_FILL];

    public function TextButton(size:int, text:String, bWidth:int = 0) {
        super();
        this.text_ = new SimpleText(size, 3552822, false, 0, 0);
        this.text_.setBold(true);
        this.text_.text = text;
        this.text_.updateMetrics();
        addChild(this.text_);
        this.w_ = bWidth != 0 ? int(bWidth) : int(this.text_.width + 12);
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, this.w_, this.text_.textHeight + 8, 4, [1, 1, 1, 1], this.path_);
        this.draw();
        this.text_.x = this.w_ / 2 - this.text_.textWidth / 2 - 2;
        this.text_.y = 1;
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    public function setText(text:String):void {
        this.text_.text = text;
        this.text_.updateMetrics();
        this.text_.x = this.w_ / 2 - this.text_.textWidth / 2 - 2;
        this.text_.y = 1;
    }

    public function setEnabled(enabled:Boolean):void {
        if (enabled == mouseEnabled) {
            return;
        }
        mouseEnabled = enabled;
        this.graphicsData_[0] = enabled ? this.enabledFill_ : this.disabledFill_;
        this.draw();
    }

    private function onMouseOver(event:MouseEvent):void {
        this.enabledFill_.color = 16768133;
        this.draw();
    }

    private function onRollOut(event:MouseEvent):void {
        this.enabledFill_.color = 16777215;
        this.draw();
    }

    private function draw():void {
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/ClassToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.appengine.CharacterStats;
import com.company.assembleegameclient.ui.LineBreakDesign;
import com.company.assembleegameclient.util.AnimatedChar;
import com.company.assembleegameclient.util.AnimatedChars;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.assembleegameclient.util.MaskedImage;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.filters.DropShadowFilter;

import svera.untiered.core.model.PlayerModel;

public class ClassToolTip extends ToolTip {


    private var portrait_:Bitmap;

    private var nameText_:SimpleText;

    private var descriptionText_:SimpleText;

    private var lineBreak_:LineBreakDesign;

    private var bestLevel_:SimpleText;

    private var nextClassQuest_:SimpleText;

    public function ClassToolTip(playerXML:XML, model:PlayerModel, charStats:CharacterStats) {
        var numStars:int;
        var nextStarHonor:int;
        super(3552822, 1, 16777215, 1);
        var animatedChar:AnimatedChar = AnimatedChars.getAnimatedChar(String(playerXML.AnimatedTexture.File), int(playerXML.AnimatedTexture.Index));
        var image:MaskedImage = animatedChar.imageFromDir(AnimatedChar.RIGHT, AnimatedChar.STAND, 0);
        var size:int = 16 * 3;
        var bd:BitmapData = TextureRedrawer.redraw(image.image_, size, true, 0);
        this.portrait_ = new Bitmap();
        this.portrait_.bitmapData = bd;
        this.portrait_.y = -16;
        addChild(this.portrait_);
        this.nameText_ = new SimpleText(13, 11776947, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.text = playerXML.@id;
        this.nameText_.updateMetrics();
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.nameText_.x = this.portrait_.x + this.portrait_.width / 2 + this.portrait_.width / 2;
        this.nameText_.y = 6;
        addChild(this.nameText_);
        this.descriptionText_ = new SimpleText(13, 11776947, false, 174, 0);
        this.descriptionText_.wordWrap = true;
        this.descriptionText_.multiline = true;
        this.descriptionText_.text = playerXML.Description;
        this.descriptionText_.updateMetrics();
        this.descriptionText_.filters = [new DropShadowFilter(0, 0, 0)];
        this.descriptionText_.x = 8;
        this.descriptionText_.y = 40;
        addChild(this.descriptionText_);
        this.lineBreak_ = new LineBreakDesign(100, 1842204);
        this.lineBreak_.x = 6;
        this.lineBreak_.y = height;
        addChild(this.lineBreak_);

        numStars = charStats == null ? int(0) : int(charStats.numStars());
        this.bestLevel_ = new SimpleText(14, 6206769, false, 0, 0);
        this.bestLevel_.text = numStars + " of 5 Class Quests Completed\n" + "Best Level Achieved: " + (charStats != null ? charStats.bestLevel() : 0) + "\n" + "Best Honor Achieved: " + (charStats != null ? charStats.bestHonor() : 0);
        this.bestLevel_.updateMetrics();
        this.bestLevel_.filters = [new DropShadowFilter(0, 0, 0)];
        this.bestLevel_.x = 8;
        this.bestLevel_.y = height - 2;
        addChild(this.bestLevel_);
        nextStarHonor = HonorUtil.nextStarHonor(charStats == null ? int(0) : int(charStats.bestHonor()), 0);
        if (nextStarHonor > 0) {
            this.nextClassQuest_ = new SimpleText(13, 16549442, false, 174, 0);
            this.nextClassQuest_.text = "Next Goal: Earn " + nextStarHonor + " Honor\n" + "  with a " + playerXML.@id;
            this.nextClassQuest_.updateMetrics();
            this.nextClassQuest_.filters = [new DropShadowFilter(0, 0, 0)];
            this.nextClassQuest_.x = 8;
            this.nextClassQuest_.y = height - 2;
            addChild(this.nextClassQuest_);
        }
    }

    override public function draw():void {
        this.lineBreak_.setWidthColor(width - 10, 1842204);
        super.draw();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/MyPlayerToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.appengine.CharacterStats;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.assembleegameclient.ui.LineBreakDesign;
import com.company.assembleegameclient.ui.StatusBar;
import com.company.assembleegameclient.ui.panels.itemgrids.EquippedGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.InventoryGrid;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;

import flash.filters.DropShadowFilter;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.constants.GeneralConstants;
import svera.untiered.core.StaticInjectorContext;

public class MyPlayerToolTip extends ToolTip {


    private var factory:CharacterFactory;

    private var classes:ClassesModel;

    public var player_:Player;

    private var playerPanel_:GameObjectListItem;

    private var hpBar_:StatusBar;

    private var spBar_:StatusBar;

    private var rpBar_:StatusBar;

    private var lineBreak_:LineBreakDesign;

    private var bestLevel_:SimpleText;

    private var nextClassQuest_:SimpleText;

    private var eGrid:EquippedGrid;

    private var iGrid:InventoryGrid;

    public function MyPlayerToolTip(accountName:String, charXML:XML, charStats:CharacterStats) {
        super(3552822, 1, 16777215, 1);
        this.factory = StaticInjectorContext.getInjector().getInstance(CharacterFactory);
        this.classes = StaticInjectorContext.getInjector().getInstance(ClassesModel);
        var objectType:int = int(charXML.ObjectType);
        var playerXML:XML = ObjectLibrary.xmlLibrary_[objectType];
        this.player_ = Player.fromPlayerXML(accountName, charXML);
        var char:CharacterClass = this.classes.getCharacterClass(this.player_.objectType_);
        var skin:CharacterSkin = char.skins.getSkin(charXML.Texture);
        this.player_.animatedChar_ = this.factory.makeCharacter(skin.template);
        this.playerPanel_ = new GameObjectListItem(11776947, true, this.player_);
        addChild(this.playerPanel_);
        this.hpBar_ = new StatusBar(176, 16, 14693428, 5526612, "HP");
        this.hpBar_.x = 6;
        this.hpBar_.y = 40;
        addChild(this.hpBar_);
        this.rpBar_ = new StatusBar(176, 16, 6325472, 5526612, "RP");
        this.rpBar_.x = 6;
        this.rpBar_.y = 64;
        addChild(this.rpBar_);
        this.eGrid = new EquippedGrid(null, this.player_.slotTypes_, this.player_);
        this.eGrid.x = 8;
        this.eGrid.y = 88;
        addChild(this.eGrid);
        this.eGrid.setItems(this.player_.equipment_);
        this.iGrid = new InventoryGrid(null, this.player_, GeneralConstants.NUM_EQUIPMENT_SLOTS);
        this.iGrid.x = 8;
        this.iGrid.y = 132;
        addChild(this.iGrid);
        this.iGrid.setItems(this.player_.equipment_);
        this.lineBreak_ = new LineBreakDesign(100, 1842204);
        this.lineBreak_.x = 6;
        this.lineBreak_.y = 228;
        addChild(this.lineBreak_);
        var numStars:int = charStats == null ? int(0) : int(charStats.numStars());
        this.bestLevel_ = new SimpleText(14, 6206769, false, 0, 0);
        this.bestLevel_.text = numStars + " of 5 Class Quests Completed\n" + "Best Level Achieved: " + (charStats != null ? charStats.bestLevel() : 0).toString() + "\n" + "Best Honor Achieved: " + (charStats != null ? charStats.bestHonor() : 0).toString();
        this.bestLevel_.updateMetrics();
        this.bestLevel_.filters = [new DropShadowFilter(0, 0, 0)];
        this.bestLevel_.x = 8;
        this.bestLevel_.y = height - 2;
        addChild(this.bestLevel_);
        var nextStarHonor:int = HonorUtil.nextStarHonor(charStats == null ? int(0) : int(charStats.bestHonor()), 0);
        if (nextStarHonor > 0) {
            this.nextClassQuest_ = new SimpleText(13, 16549442, false, 174, 0);
            this.nextClassQuest_.text = "Next Goal: Earn " + nextStarHonor + " Honor\n" + "  with a " + playerXML.@id;
            this.nextClassQuest_.updateMetrics();
            this.nextClassQuest_.filters = [new DropShadowFilter(0, 0, 0)];
            this.nextClassQuest_.x = 8;
            this.nextClassQuest_.y = height - 2;
            addChild(this.nextClassQuest_);
        }
    }

    override public function draw():void {
        this.hpBar_.draw(this.player_.hp_, this.player_.maxHP_, this.player_.maxHPBoost_, this.player_.maxHPMax_);
        this.rpBar_.draw(this.player_.rp_, this.player_.maxRP_, this.player_.maxRPBoost_, this.player_.maxRPMax_);
        this.lineBreak_.setWidthColor(width - 10, 1842204);
        super.draw();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/PlayerToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.GameObjectListItem;
import com.company.assembleegameclient.ui.GuildText;
import com.company.assembleegameclient.ui.RankText;
import com.company.assembleegameclient.ui.StatusBar;
import com.company.assembleegameclient.ui.panels.itemgrids.EquippedGrid;
import com.company.ui.SimpleText;

import flash.filters.DropShadowFilter;

public class PlayerToolTip extends ToolTip {


    public var player_:Player;

    private var playerPanel_:GameObjectListItem;

    private var rankText_:RankText;

    private var guildText_:GuildText;

    private var hpBar_:StatusBar;

    private var spBar_:StatusBar;

    private var rpBar_:StatusBar;

    private var clickMessage_:SimpleText;

    private var eGrid:EquippedGrid;

    public function PlayerToolTip(player:Player) {
        var yOffset:int;
        super(3552822, 0.5, 16777215, 1);
        this.player_ = player;
        this.playerPanel_ = new GameObjectListItem(11776947, true, this.player_);
        addChild(this.playerPanel_);
        yOffset = 34;
        this.rankText_ = new RankText(this.player_.numStars_, false, true);
        this.rankText_.x = 6;
        this.rankText_.y = yOffset;
        addChild(this.rankText_);
        yOffset = yOffset + 30;
        if (player.guildName_ != null && player.guildName_ != "") {
            this.guildText_ = new GuildText(this.player_.guildName_, this.player_.guildRank_, 136);
            this.guildText_.x = 6;
            this.guildText_.y = yOffset - 2;
            addChild(this.guildText_);
            yOffset = yOffset + 30;
        }
        this.hpBar_ = new StatusBar(176, 16, 14693428, 5526612, "HP");
        this.hpBar_.x = 6;
        this.hpBar_.y = yOffset;
        addChild(this.hpBar_);
        this.spBar_ = new StatusBar(176, 16, 16777215, 14693428, "SP");
        this.spBar_.x = 6;
        this.spBar_.y = yOffset;
        addChild(this.spBar_);
        yOffset = yOffset + 24;
        this.rpBar_ = new StatusBar(176, 16, 6325472, 5526612, "RP");
        this.rpBar_.x = 6;
        this.rpBar_.y = yOffset;
        addChild(this.rpBar_);
        yOffset = yOffset + 24;
        this.eGrid = new EquippedGrid(null, this.player_.slotTypes_, this.player_);
        this.eGrid.x = 8;
        this.eGrid.y = yOffset;
        addChild(this.eGrid);
        yOffset = yOffset + 52;
        this.clickMessage_ = new SimpleText(12, 11776947, false, 0, 0);
        this.clickMessage_.text = "(Click to open menu)";
        this.clickMessage_.updateMetrics();
        this.clickMessage_.filters = [new DropShadowFilter(0, 0, 0)];
        this.clickMessage_.x = width / 2 - this.clickMessage_.width / 2;
        this.clickMessage_.y = yOffset;
        addChild(this.clickMessage_);
        this.spBar_.visible = false;
    }

    override public function draw():void {
        this.spBar_.valueText_.textColor = 16777215;
        this.spBar_.boostText_.textColor = 16777215;
        this.spBar_.visible = this.player_.sp_ > 0;
        this.hpBar_.labelText_.visible = !(this.player_.sp_ > 0);
        this.hpBar_.valueText_.visible = !(this.player_.sp_ > 0);
        this.hpBar_.boostText_.visible = !(this.player_.sp_ > 0);

        this.spBar_.draw(this.player_.sp_, this.player_.maxSP_, this.player_.maxSPBoost_);
        this.hpBar_.draw(this.player_.hp_, this.player_.maxHP_, this.player_.maxHPBoost_);
        this.rpBar_.draw(this.player_.rp_, this.player_.maxRP_, this.player_.maxRPBoost_);
        this.eGrid.setItems(this.player_.equipment_);
        this.rankText_.draw(this.player_.numStars_);
        super.draw();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/TooltipHelper.as">
package com.company.assembleegameclient.ui.tooltip {
public class TooltipHelper {
    public static const DEFAULT_COLOR:String = "#FFFF8F";
    public static const BETTER_COLOR:uint = 65280;

    public static const WORSE_COLOR:uint = 16731726;

    public static const NO_DIFF_COLOR:uint = 16777103;

    public static const WIS_BONUS_COLOR:uint = 4219875;

    public static const UNTIERED_COLOR:uint = 9055202;

    public static const SET_COLOR:uint = 16750848;

    public static const LEGENDARY_COLOR:uint = 16776960;

    public static const SACRED_COLOR:uint = 0x6afffb;
    // Untiered Tiers
    public static const COMMON_COLOR:uint = 0x69747a;

    public static const UNCOMMON_COLOR:uint = 0x177e2b;

    public static const TARNISHED_COLOR:uint = 0x224a98;

    public static const ARTIFACT_COLOR:uint = 0x45c3ff;

    public static const ANCESTRAL_COLOR:uint = 0xbc4a9b;

    public static const VALIANT_COLOR:uint = 0xffd647;

    public static const RELIC_COLOR:uint = 0x73172D;

    public static const EXILED_COLOR:uint = 0xeb015f;

    public static const CELESTIAL_COLOR:uint = 0xd1d3ea;
    public function TooltipHelper() {
        super();
    }
    public static function getTextColor(val:Number) : uint
    {
        if(val < 0)
        {
            return WORSE_COLOR;
        }
        if(val > 0)
        {
            return BETTER_COLOR;
        }
        return NO_DIFF_COLOR;
    }

    public static function wrapInFontTag(text:String, color:String):String {
        var tagStr:String = "<font color=\"" + color + "\">" + text + "</font>";
        return tagStr;
    }

    public static function getFormattedString(value:Number):String {
        var formatted:Number = int(value * 1000) / 1000;
        return formatted.toString();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/TradeInventory.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.constants.InventoryOwnerTypes;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.tooltip.EquipmentToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import svera.untiered.constants.GeneralConstants;
import svera.untiered.messaging.impl.data.TradeItemData;

public class TradeInventory extends Sprite {

    private static const NO_CUT:Array = [0, 0, 0, 0];

    private static const cuts:Array = [[1, 0, 0, 1], NO_CUT, NO_CUT, [0, 1, 1, 0], [1, 0, 0, 0], NO_CUT, NO_CUT, [0, 1, 0, 0], [0, 0, 0, 1], NO_CUT, NO_CUT, [0, 0, 1, 0]];

    public static const CLICKITEMS_MESSAGE:int = 0;

    public static const NOTENOUGHSPACE_MESSAGE:int = 1;

    public static const TRADEACCEPTED_MESSAGE:int = 2;

    public static const TRADEWAITING_MESSAGE:int = 3;

    private static var tooltip_:ToolTip = null;


    public var gs_:GameSprite;

    public var playerName_:String;

    private var message_:int;

    private var nameText_:SimpleText;

    private var taglineText_:SimpleText;

    public var slots_:Vector.<TradeSlot>;

    public function TradeInventory(gs:GameSprite, playerName:String, items:Vector.<TradeItemData>, canSelect:Boolean) {
        var item:TradeItemData = null;
        var slot:TradeSlot = null;
        this.slots_ = new Vector.<TradeSlot>();
        super();
        this.gs_ = gs;
        this.playerName_ = playerName;
        this.nameText_ = new SimpleText(20, 11776947, false, 0, 0);
        this.nameText_.setBold(true);
        this.nameText_.x = 0;
        this.nameText_.y = 0;
        this.nameText_.text = this.playerName_;
        this.nameText_.updateMetrics();
        this.nameText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.nameText_);
        this.taglineText_ = new SimpleText(12, 11776947, false, 0, 0);
        this.taglineText_.x = 0;
        this.taglineText_.y = 22;
        this.taglineText_.text = "";
        this.taglineText_.updateMetrics();
        this.taglineText_.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(this.taglineText_);
        for (var i:int = 0; i < GeneralConstants.NUM_EQUIPMENT_SLOTS + GeneralConstants.NUM_INVENTORY_SLOTS; i++) {
            item = items[i];
             slot = new TradeSlot(item.itemType_, item.tradeable_, item.included_, item.slotType_, i - 3, cuts[i], i);
            slot.x = int(i % 4) * (Slot.WIDTH + 4);
            slot.y = int(i / 4) * (Slot.HEIGHT + 4) + 46;
            if (item.itemType_ != null) {
                slot.addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
                slot.addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
            }
            if (canSelect && item.tradeable_) {
                slot.addEventListener(MouseEvent.MOUSE_DOWN, this.onSlotClick);
            }
            this.slots_.push(slot);
            addChild(slot);
        }
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    public function getOffer():Vector.<Boolean> {
        var offer:Vector.<Boolean> = new Vector.<Boolean>();
        for (var i:int = 0; i < this.slots_.length; i++) {
            offer.push(this.slots_[i].included_);
        }
        return offer;
    }

    public function setOffer(offer:Vector.<Boolean>):void {
        for (var i:int = 0; i < this.slots_.length; i++) {
            this.slots_[i].setIncluded(offer[i]);
        }
    }

    public function isOffer(offer:Vector.<Boolean>):Boolean {
        for (var i:int = 0; i < this.slots_.length; i++) {
            if (offer[i] != this.slots_[i].included_) {
                return false;
            }
        }
        return true;
    }

    public function numIncluded():int {
        var num:int = 0;
        for (var i:int = 0; i < this.slots_.length; i++) {
            if (this.slots_[i].included_) {
                num++;
            }
        }
        return num;
    }

    public function numEmpty():int {
        var num:int = 0;
        for (var i:int = 4; i < this.slots_.length; i++) {
            if (this.slots_[i].itemType_ == null ) {
                num++;
            }
        }
        return num;
    }

    public function setMessage(message:int):void {
        switch (message) {
            case CLICKITEMS_MESSAGE:
                this.nameText_.setColor(11776947);
                this.taglineText_.setColor(11776947);
                this.taglineText_.text = "Click items you want to trade";
                this.taglineText_.updateMetrics();
                break;
            case NOTENOUGHSPACE_MESSAGE:
                this.nameText_.setColor(16711680);
                this.taglineText_.setColor(16711680);
                this.taglineText_.text = "Not enough space for trade!";
                this.taglineText_.updateMetrics();
                break;
            case TRADEACCEPTED_MESSAGE:
                this.nameText_.setColor(9022300);
                this.taglineText_.setColor(9022300);
                this.taglineText_.text = "Trade accepted!";
                this.taglineText_.updateMetrics();
                break;
            case TRADEWAITING_MESSAGE:
                this.nameText_.setColor(11776947);
                this.taglineText_.setColor(11776947);
                this.taglineText_.text = "Player is selecting items";
                this.taglineText_.updateMetrics();
        }
    }

    private function onRemovedFromStage(event:Event):void {
        this.removeTooltip();
    }

    private function onMouseOver(event:Event):void {
        var tradeSlot:TradeSlot = event.currentTarget as TradeSlot;
        this.setToolTip(new EquipmentToolTip(tradeSlot.itemType_, this.gs_.map.player_, -1, InventoryOwnerTypes.OTHER_PLAYER, tradeSlot.id));
    }

    private function onRollOut(event:Event):void {
        this.removeTooltip();
    }

    private function setToolTip(toolTip:ToolTip):void {
        this.removeTooltip();
        tooltip_ = toolTip;
        if (tooltip_ != null) {
            stage.addChild(tooltip_);
        }
    }

    private function removeTooltip():void {
        if (tooltip_ != null) {
            if (tooltip_.parent != null) {
                tooltip_.parent.removeChild(tooltip_);
            }
            tooltip_ = null;
        }
    }

    private function onSlotClick(event:MouseEvent):void {
        var slot:TradeSlot = event.currentTarget as TradeSlot;
        slot.setIncluded(!slot.included_);
        dispatchEvent(new Event(Event.CHANGE));
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/AnimatedChar.as">
package com.company.assembleegameclient.util {
import com.company.assembleegameclient.map.Camera;
import com.company.util.Trig;

import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Dictionary;

public class AnimatedChar {

    public static const RIGHT:int = 0;

    public static const LEFT:int = 1;

    public static const DOWN:int = 2;

    public static const UP:int = 3;

    public static const NUM_DIR:int = 4;

    public static const STAND:int = 0;

    public static const WALK:int = 1;

    public static const ATTACK:int = 2;

    public static const NUM_ACTION:int = 3;

    private static const SEC_TO_DIRS:Vector.<Vector.<int>> = new <Vector.<int>>[new <int>[LEFT, UP, DOWN], new <int>[UP, LEFT, DOWN], new <int>[UP, RIGHT, DOWN], new <int>[RIGHT, UP, DOWN], new <int>[RIGHT, DOWN], new <int>[DOWN, RIGHT], new <int>[DOWN, LEFT], new <int>[LEFT, DOWN]];

    private static const PIOVER4:Number = Math.PI / 4;


    public var origImage_:MaskedImage;

    private var width_:int;

    private var height_:int;

    private var firstDir_:int;

    private var dict_:Dictionary;

    public function AnimatedChar(image:MaskedImage, width:int, height:int, firstDir:int) {
        this.dict_ = new Dictionary();
        super();
        this.origImage_ = image;
        this.width_ = width;
        this.height_ = height;
        this.firstDir_ = firstDir;
        var classDict:Dictionary = new Dictionary();
        var frames:MaskedImageSet = new MaskedImageSet();
        frames.addFromMaskedImage(image, width, height);
        if (firstDir == RIGHT) {
            this.dict_[RIGHT] = this.loadDir(0, false, false, frames);
            this.dict_[LEFT] = this.loadDir(0, true, false, frames);
            if (frames.images_.length >= 14) {
                this.dict_[DOWN] = this.loadDir(7, false, true, frames);
                if (frames.images_.length >= 21) {
                    this.dict_[UP] = this.loadDir(14, false, true, frames);
                }
            }
        } else if (firstDir == DOWN) {
            this.dict_[DOWN] = this.loadDir(0, false, true, frames);
            if (frames.images_.length >= 14) {
                this.dict_[RIGHT] = this.loadDir(7, false, false, frames);
                this.dict_[LEFT] = this.loadDir(7, true, false, frames);
                if (frames.images_.length >= 21) {
                    this.dict_[UP] = this.loadDir(14, false, true, frames);
                }
            }
        } else {
            trace("ERROR: unsupported first dir: " + firstDir);
        }
    }

    public function getFirstDirImage():BitmapData {
        var bd:BitmapData = new BitmapData(this.width_ * 7, this.height_, true, 0);
        var actionDict:Dictionary = this.dict_[this.firstDir_];
        var vec:Vector.<MaskedImage> = actionDict[STAND];
        if (vec.length > 0) {
            bd.copyPixels(vec[0].image_, vec[0].image_.rect, new Point(0, 0));
        }
        vec = actionDict[WALK];
        if (vec.length > 0) {
            bd.copyPixels(vec[0].image_, vec[0].image_.rect, new Point(this.width_, 0));
        }
        if (vec.length > 1) {
            bd.copyPixels(vec[1].image_, vec[1].image_.rect, new Point(this.width_ * 2, 0));
        }
        vec = actionDict[ATTACK];
        if (vec.length > 0) {
            bd.copyPixels(vec[0].image_, vec[0].image_.rect, new Point(this.width_ * 4, 0));
        }
        if (vec.length > 1) {
            bd.copyPixels(vec[1].image_, new Rectangle(this.width_, 0, this.width_ * 2, this.height_), new Point(this.width_ * 5, 0));
        }
        return bd;
    }

    public function imageVec(dir:int, action:int):Vector.<MaskedImage> {
        return this.dict_[dir][action];
    }

    public function imageFromDir(dir:int, action:int, p:Number):MaskedImage {
        var texVec:Vector.<MaskedImage> = this.dict_[dir][action];
        p = Math.max(0, Math.min(0.99999, p));
        var i:int = p * texVec.length;
        return texVec[i];
    }

    public function imageFromAngle(angle:Number, action:int, p:Number):MaskedImage {
        var sec:int = int(angle / PIOVER4 + 4) % 8;
        var dirs:Vector.<int> = SEC_TO_DIRS[sec];
        var actionDict:Dictionary = this.dict_[dirs[0]];
        if (actionDict == null) {
            actionDict = this.dict_[dirs[1]];
            if (actionDict == null) {
                actionDict = this.dict_[dirs[2]];
            }
        }
        var texVec:Vector.<MaskedImage> = actionDict[action];
        p = Math.max(0, Math.min(0.99999, p));
        var i:int = p * texVec.length;
        return texVec[i];
    }

    public function imageFromFacing(facing:Number, camera:Camera, action:int, p:Number):MaskedImage {
        var ca:Number = Trig.boundToPI(facing - camera.angleRad_);
        var sec:int = int(ca / PIOVER4 + 4) % 8;
        var dirs:Vector.<int> = SEC_TO_DIRS[sec];
        var actionDict:Dictionary = this.dict_[dirs[0]];
        if (actionDict == null) {
            actionDict = this.dict_[dirs[1]];
            if (actionDict == null) {
                actionDict = this.dict_[dirs[2]];
            }
        }
        var texVec:Vector.<MaskedImage> = actionDict[action];
        p = Math.max(0, Math.min(0.99999, p));
        var i:int = p * texVec.length;
        return texVec[i];
    }

    private function loadDir(offset:int, mirror:Boolean, sym:Boolean, frames:MaskedImageSet):Dictionary {
        var attackVec:Vector.<MaskedImage>;
        var image:BitmapData = null;
        var mask:BitmapData = null;
        var dirDict:Dictionary = new Dictionary();
        var standImage:MaskedImage = frames.images_[offset + 0];
        var walk1Image:MaskedImage = frames.images_[offset + 1];
        var walk2Image:MaskedImage = frames.images_[offset + 2];
        if (walk2Image.amountTransparent() == 1) {
            walk2Image = null;
        }
        var attack1Image:MaskedImage = frames.images_[offset + 4];
        var attack2Image:MaskedImage = frames.images_[offset + 5];
        if (attack1Image.amountTransparent() == 1) {
            attack1Image = null;
        }
        if (attack2Image.amountTransparent() == 1) {
            attack2Image = null;
        }
        var swordBitImage:MaskedImage = frames.images_[offset + 6];
        if (attack2Image != null && swordBitImage.amountTransparent() != 1) {
            image = new BitmapData(this.width_ * 3, this.height_, true, 0);
            image.copyPixels(attack2Image.image_, new Rectangle(0, 0, this.width_, this.height_), new Point(this.width_, 0));
            image.copyPixels(swordBitImage.image_, new Rectangle(0, 0, this.width_, this.height_), new Point(this.width_ * 2, 0));
            mask = null;
            if (attack2Image.mask_ != null || swordBitImage.mask_ != null) {
                mask = new BitmapData(this.width_ * 3, this.height_, true, 0);
            }
            if (attack2Image.mask_ != null) {
                mask.copyPixels(attack2Image.mask_, new Rectangle(0, 0, this.width_, this.height_), new Point(this.width_, 0));
            }
            if (swordBitImage.mask_ != null) {
                mask.copyPixels(swordBitImage.mask_, new Rectangle(0, 0, this.width_, this.height_), new Point(this.width_ * 2, 0));
            }
            attack2Image = new MaskedImage(image, mask);
        }
        var standVec:Vector.<MaskedImage> = new Vector.<MaskedImage>();
        standVec.push(mirror ? standImage.mirror() : standImage);
        dirDict[STAND] = standVec;
        var walkVec:Vector.<MaskedImage> = new Vector.<MaskedImage>();
        walkVec.push(mirror ? walk1Image.mirror() : walk1Image);
        if (walk2Image != null) {
            walkVec.push(mirror ? walk2Image.mirror() : walk2Image);
        } else if (sym) {
            walkVec.push(!mirror ? walk1Image.mirror(7) : walk1Image);
        } else {
            walkVec.push(mirror ? standImage.mirror() : standImage);
        }
        dirDict[WALK] = walkVec;
        if (attack1Image == null && attack2Image == null) {
            attackVec = walkVec;
        } else {
            attackVec = new Vector.<MaskedImage>();
            if (attack1Image != null) {
                attackVec.push(mirror ? attack1Image.mirror() : attack1Image);
            }
            if (attack2Image != null) {
                attackVec.push(mirror ? attack2Image.mirror() : attack2Image);
            }
        }
        dirDict[ATTACK] = attackVec;
        return dirDict;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/GuildUtil.as">
package com.company.assembleegameclient.util {
import com.company.util.AssetLibrary;

import flash.display.BitmapData;

public class GuildUtil {

    public static const INITIATE:int = 0;

    public static const MEMBER:int = 10;

    public static const OFFICER:int = 20;

    public static const LEADER:int = 30;

    public static const FOUNDER:int = 40;

    public static const MAX_MEMBERS:int = 50;


    public function GuildUtil() {
        super();
    }

    public static function rankToString(rank:int):String {
        switch (rank) {
            case INITIATE:
                return "Initiate";
            case MEMBER:
                return "Member";
            case OFFICER:
                return "Officer";
            case LEADER:
                return "Leader";
            case FOUNDER:
                return "Founder";
            default:
                return "Unknown";
        }
    }

    public static function rankToIcon(rank:int, size:int):BitmapData {
        var icon:BitmapData = null;
        switch (rank) {
            case INITIATE:
                icon = AssetLibrary.getImageFromSet("lofiInterfaceBig", 20);
                break;
            case MEMBER:
                icon = AssetLibrary.getImageFromSet("lofiInterfaceBig", 19);
                break;
            case OFFICER:
                icon = AssetLibrary.getImageFromSet("lofiInterfaceBig", 18);
                break;
            case LEADER:
                icon = AssetLibrary.getImageFromSet("lofiInterfaceBig", 17);
                break;
            case FOUNDER:
                icon = AssetLibrary.getImageFromSet("lofiInterfaceBig", 16);
        }
        return TextureRedrawer.redraw(icon, size, true, 0, true);
    }

    public static function guildHonorIcon(size:int):BitmapData {
        var icon:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 0);
        return TextureRedrawer.redraw(icon, size, true, 0, true);
    }

    public static function allowedChange(authRank:int, oldRank:int, newRank:int):Boolean {
        if (oldRank == newRank) {
            return false;
        }
        if (authRank == FOUNDER && oldRank < FOUNDER && newRank < FOUNDER) {
            return true;
        }
        if (authRank == LEADER && oldRank < LEADER && newRank <= LEADER) {
            return true;
        }
        if (authRank == OFFICER && oldRank < OFFICER && newRank < OFFICER) {
            return true;
        }
        return false;
    }

    public static function promotedRank(rank:int):int {
        switch (rank) {
            case INITIATE:
                return MEMBER;
            case MEMBER:
                return OFFICER;
            case OFFICER:
                return LEADER;
            default:
                return FOUNDER;
        }
    }

    public static function canPromote(myRank:int, rank:int):Boolean {
        var newRank:int = promotedRank(rank);
        return allowedChange(myRank, rank, newRank);
    }

    public static function demotedRank(rank:int):int {
        switch (rank) {
            case OFFICER:
                return MEMBER;
            case LEADER:
                return OFFICER;
            case FOUNDER:
                return LEADER;
            default:
                return INITIATE;
        }
    }

    public static function canDemote(myRank:int, rank:int):Boolean {
        var newRank:int = demotedRank(rank);
        return allowedChange(myRank, rank, newRank);
    }

    public static function canRemove(myRank:int, rank:int):Boolean {
        return myRank >= OFFICER && rank < myRank;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/TileRedrawer.as">
package com.company.assembleegameclient.util {
import com.company.assembleegameclient.map.GroundLibrary;
import com.company.assembleegameclient.map.GroundProperties;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.map.Square;
import com.company.util.AssetLibrary;
import com.company.util.BitmapUtil;
import com.company.util.ImageSet;
import com.company.util.PointUtil;

import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

public class TileRedrawer {

    private static const rect0:Rectangle = new Rectangle(0, 0, 4, 4);

    private static const p0:Point = new Point(0, 0);

    private static const rect1:Rectangle = new Rectangle(4, 0, 4, 4);

    private static const p1:Point = new Point(4, 0);

    private static const rect2:Rectangle = new Rectangle(0, 4, 4, 4);

    private static const p2:Point = new Point(0, 4);

    private static const rect3:Rectangle = new Rectangle(4, 4, 4, 4);

    private static const p3:Point = new Point(4, 4);

    private static const INNER:int = 0;

    private static const SIDE0:int = 1;

    private static const SIDE1:int = 2;

    private static const OUTER:int = 3;

    private static const INNERP1:int = 4;

    private static const INNERP2:int = 5;

    private static const mlist_:Vector.<Vector.<ImageSet>> = getMasks();

    private static var cache_:Vector.<Object> = new <Object>[null, new Object()];

    private static const RECT01:Rectangle = new Rectangle(0, 0, 8, 4);

    private static const RECT13:Rectangle = new Rectangle(4, 0, 4, 8);

    private static const RECT23:Rectangle = new Rectangle(0, 4, 8, 4);

    private static const RECT02:Rectangle = new Rectangle(0, 0, 4, 8);

    private static const RECT0:Rectangle = new Rectangle(0, 0, 4, 4);

    private static const RECT1:Rectangle = new Rectangle(4, 0, 4, 4);

    private static const RECT2:Rectangle = new Rectangle(0, 4, 4, 4);

    private static const RECT3:Rectangle = new Rectangle(4, 4, 4, 4);

    private static const POINT0:Point = new Point(0, 0);

    private static const POINT1:Point = new Point(4, 0);

    private static const POINT2:Point = new Point(0, 4);

    private static const POINT3:Point = new Point(4, 4);


    public function TileRedrawer() {
        super();
    }

    public static function redraw(square:Square, origBackground:Boolean):BitmapData {
        var sig:ByteArray;
        var newBitmapData:BitmapData = null;
        if (square.tileType_ == 253) {
            sig = getCompositeSig(square);
        } else if (square.props_.hasEdge_) {
            sig = getEdgeSig(square);
        } else {
            sig = getSig(square);
        }
        if (sig == null) {
            return null;
        }
        var dict:Object = cache_[1];
        if (dict.hasOwnProperty(sig)) {
            return dict[sig];
        }
        if (square.tileType_ == 253) {
            newBitmapData = buildComposite(sig);
            dict[sig] = newBitmapData;
            return newBitmapData;
        }
        if (square.props_.hasEdge_) {
            newBitmapData = drawEdges(sig);
            dict[sig] = newBitmapData;
            return newBitmapData;
        }
        var redraw0:Boolean = false;
        var redraw1:Boolean = false;
        var redraw2:Boolean = false;
        var redraw3:Boolean = false;
        if (sig[1] != sig[4]) {
            redraw0 = true;
            redraw1 = true;
        }
        if (sig[3] != sig[4]) {
            redraw0 = true;
            redraw2 = true;
        }
        if (sig[5] != sig[4]) {
            redraw1 = true;
            redraw3 = true;
        }
        if (sig[7] != sig[4]) {
            redraw2 = true;
            redraw3 = true;
        }
        if (!redraw0 && sig[0] != sig[4]) {
            redraw0 = true;
        }
        if (!redraw1 && sig[2] != sig[4]) {
            redraw1 = true;
        }
        if (!redraw2 && sig[6] != sig[4]) {
            redraw2 = true;
        }
        if (!redraw3 && sig[8] != sig[4]) {
            redraw3 = true;
        }
        if (!redraw0 && !redraw1 && !redraw2 && !redraw3) {
            dict[sig] = null;
            return null;
        }
        var orig:BitmapData = GroundLibrary.getBitmapData(square.tileType_);
        if (origBackground) {
            newBitmapData = orig.clone();
        } else {
            newBitmapData = new BitmapData(orig.width, orig.height, true, 0);
        }
        if (redraw0) {
            redrawRect(newBitmapData, rect0, p0, mlist_[0], sig[4], sig[3], sig[0], sig[1]);
        }
        if (redraw1) {
            redrawRect(newBitmapData, rect1, p1, mlist_[1], sig[4], sig[1], sig[2], sig[5]);
        }
        if (redraw2) {
            redrawRect(newBitmapData, rect2, p2, mlist_[2], sig[4], sig[7], sig[6], sig[3]);
        }
        if (redraw3) {
            redrawRect(newBitmapData, rect3, p3, mlist_[3], sig[4], sig[5], sig[8], sig[7]);
        }
        dict[sig] = newBitmapData;
        return newBitmapData;
    }

    private static function redrawRect(bitmapData:BitmapData, rect:Rectangle, p:Point, masks:Vector.<ImageSet>, base:uint, n0:uint, n1:uint, n2:uint):void {
        var blend:BitmapData = null;
        var mask:BitmapData = null;
        if (base == n0 && base == n2) {
            mask = masks[OUTER].random();
            blend = GroundLibrary.getBitmapData(n1);
        } else if (base != n0 && base != n2) {
            if (n0 != n2) {
                bitmapData.copyPixels(GroundLibrary.getBitmapData(n0), rect, p, masks[INNERP1].random(), p0, true);
                bitmapData.copyPixels(GroundLibrary.getBitmapData(n2), rect, p, masks[INNERP2].random(), p0, true);
                return;
            }
            mask = masks[INNER].random();
            blend = GroundLibrary.getBitmapData(n0);
        } else if (base != n0) {
            mask = masks[SIDE0].random();
            blend = GroundLibrary.getBitmapData(n0);
        } else {
            mask = masks[SIDE1].random();
            blend = GroundLibrary.getBitmapData(n2);
        }
        bitmapData.copyPixels(blend, rect, p, mask, p0, true);
    }

    private static function getSig(square:Square):ByteArray {
        var x:int = 0;
        var n:Square = null;
        var sig:ByteArray = new ByteArray();
        var map:Map = square.map_;
        var baseType:uint = square.tileType_;
        for (var y:int = square.y_ - 1; y <= square.y_ + 1; y++) {
            for (x = square.x_ - 1; x <= square.x_ + 1; x++) {
                if (x < 0 || x >= map.width_ || y < 0 || y >= map.height_ || x == square.x_ && y == square.y_) {
                    sig.writeByte(baseType);
                } else {
                    n = map.squares_[x + y * map.width_];
                    if (n == null || n.props_.blendPriority_ <= square.props_.blendPriority_) {
                        sig.writeByte(baseType);
                    } else {
                        sig.writeByte(n.tileType_);
                    }
                }
            }
        }
        return sig;
    }

    private static function getMasks():Vector.<Vector.<ImageSet>> {
        var mlist:Vector.<Vector.<ImageSet>> = new Vector.<Vector.<ImageSet>>();
        addMasks(mlist, AssetLibrary.getImageSet("inner_mask"), AssetLibrary.getImageSet("sides_mask"), AssetLibrary.getImageSet("outer_mask"), AssetLibrary.getImageSet("innerP1_mask"), AssetLibrary.getImageSet("innerP2_mask"));
        return mlist;
    }

    private static function addMasks(mlist:Vector.<Vector.<ImageSet>>, inner:ImageSet, side:ImageSet, outer:ImageSet, innerP1:ImageSet, innerP2:ImageSet):void {
        var i:int = 0;
        for each(i in [-1, 0, 2, 1]) {
            mlist.push(new <ImageSet>[rotateImageSet(inner, i), rotateImageSet(side, i - 1), rotateImageSet(side, i), rotateImageSet(outer, i), rotateImageSet(innerP1, i), rotateImageSet(innerP2, i)]);
        }
    }

    private static function rotateImageSet(imageSet:ImageSet, clockwiseTurns:int):ImageSet {
        var bitmapData:BitmapData = null;
        var newImageSet:ImageSet = new ImageSet();
        for each(bitmapData in imageSet.images_) {
            newImageSet.add(BitmapUtil.rotateBitmapData(bitmapData, clockwiseTurns));
        }
        return newImageSet;
    }

    private static function getCompositeSig(square:Square):ByteArray {
        var n0:Square = null;
        var n2:Square = null;
        var n6:Square = null;
        var n8:Square = null;
        var sig:ByteArray = new ByteArray();
        sig.length = 4;
        var map:Map = square.map_;
        var x:int = square.x_;
        var y:int = square.y_;
        var n1:Square = map.lookupSquare(x, y - 1);
        var n3:Square = map.lookupSquare(x - 1, y);
        var n5:Square = map.lookupSquare(x + 1, y);
        var n7:Square = map.lookupSquare(x, y + 1);
        var p1:int = n1 != null ? int(n1.props_.compositePriority_) : int(-1);
        var p3:int = n3 != null ? int(n3.props_.compositePriority_) : int(-1);
        var p5:int = n5 != null ? int(n5.props_.compositePriority_) : int(-1);
        var p7:int = n7 != null ? int(n7.props_.compositePriority_) : int(-1);
        if (p1 < 0 && p3 < 0) {
            n0 = map.lookupSquare(x - 1, y - 1);
            sig[0] = n0 == null || n0.props_.compositePriority_ < 0 ? 255 : n0.tileType_;
        } else if (p1 < p3) {
            sig[0] = n3.tileType_;
        } else {
            sig[0] = n1.tileType_;
        }
        if (p1 < 0 && p5 < 0) {
            n2 = map.lookupSquare(x + 1, y - 1);
            sig[1] = n2 == null || n2.props_.compositePriority_ < 0 ? 255 : n2.tileType_;
        } else if (p1 < p5) {
            sig[1] = n5.tileType_;
        } else {
            sig[1] = n1.tileType_;
        }
        if (p3 < 0 && p7 < 0) {
            n6 = map.lookupSquare(x - 1, y + 1);
            sig[2] = n6 == null || n6.props_.compositePriority_ < 0 ? 255 : n6.tileType_;
        } else if (p3 < p7) {
            sig[2] = n7.tileType_;
        } else {
            sig[2] = n3.tileType_;
        }
        if (p5 < 0 && p7 < 0) {
            n8 = map.lookupSquare(x + 1, y + 1);
            sig[3] = n8 == null || n8.props_.compositePriority_ < 0 ? 255 : n8.tileType_;
        } else if (p5 < p7) {
            sig[3] = n7.tileType_;
        } else {
            sig[3] = n5.tileType_;
        }
        return sig;
    }

    private static function buildComposite(sig:ByteArray):BitmapData {
        var neighbor:BitmapData = null;
        var newBitmapData:BitmapData = new BitmapData(8, 8, false, 0);
        if (sig[0] != 255) {
            neighbor = GroundLibrary.getBitmapData(sig[0]);
            newBitmapData.copyPixels(neighbor, RECT0, POINT0);
        }
        if (sig[1] != 255) {
            neighbor = GroundLibrary.getBitmapData(sig[1]);
            newBitmapData.copyPixels(neighbor, RECT1, POINT1);
        }
        if (sig[2] != 255) {
            neighbor = GroundLibrary.getBitmapData(sig[2]);
            newBitmapData.copyPixels(neighbor, RECT2, POINT2);
        }
        if (sig[3] != 255) {
            neighbor = GroundLibrary.getBitmapData(sig[3]);
            newBitmapData.copyPixels(neighbor, RECT3, POINT3);
        }
        return newBitmapData;
    }

    private static function getEdgeSig(square:Square):ByteArray {
        var x:int = 0;
        var n:Square = null;
        var b:Boolean = false;
        var sig:ByteArray = new ByteArray();
        var map:Map = square.map_;
        var hasEdge:Boolean = false;
        var sameTypeEdgeMode:Boolean = square.props_.sameTypeEdgeMode_;
        for (var y:int = square.y_ - 1; y <= square.y_ + 1; y++) {
            for (x = square.x_ - 1; x <= square.x_ + 1; x++) {
                n = map.lookupSquare(x, y);
                if (x == square.x_ && y == square.y_) {
                    sig.writeByte(n.tileType_);
                } else {
                    if (sameTypeEdgeMode) {
                        b = n == null || n.tileType_ == square.tileType_;
                    } else {
                        b = n == null || n.tileType_ != 255;
                    }
                    sig.writeBoolean(b);
                    hasEdge = hasEdge || !b;
                }
            }
        }
        return hasEdge ? sig : null;
    }

    private static function drawEdges(sig:ByteArray):BitmapData {
        var orig:BitmapData = GroundLibrary.getBitmapData(sig[4]);
        var newBitmapData:BitmapData = orig.clone();
        var props:GroundProperties = GroundLibrary.propsLibrary_[sig[4]];
        var edges:Vector.<BitmapData> = props.getEdges();
        var innerCorners:Vector.<BitmapData> = props.getInnerCorners();
        for (var i:int = 1; i < 8; i = i + 2) {
            if (!sig[i]) {
                newBitmapData.copyPixels(edges[i], edges[i].rect, PointUtil.ORIGIN, null, null, true);
            }
        }
        if (edges[0] != null) {
            if (sig[3] && sig[1] && !sig[0]) {
                newBitmapData.copyPixels(edges[0], edges[0].rect, PointUtil.ORIGIN, null, null, true);
            }
            if (sig[1] && sig[5] && !sig[2]) {
                newBitmapData.copyPixels(edges[2], edges[2].rect, PointUtil.ORIGIN, null, null, true);
            }
            if (sig[5] && sig[7] && !sig[8]) {
                newBitmapData.copyPixels(edges[8], edges[8].rect, PointUtil.ORIGIN, null, null, true);
            }
            if (sig[3] && sig[7] && !sig[6]) {
                newBitmapData.copyPixels(edges[6], edges[6].rect, PointUtil.ORIGIN, null, null, true);
            }
        }
        if (innerCorners != null) {
            if (!sig[3] && !sig[1]) {
                newBitmapData.copyPixels(innerCorners[0], innerCorners[0].rect, PointUtil.ORIGIN, null, null, true);
            }
            if (!sig[1] && !sig[5]) {
                newBitmapData.copyPixels(innerCorners[2], innerCorners[2].rect, PointUtil.ORIGIN, null, null, true);
            }
            if (!sig[5] && !sig[7]) {
                newBitmapData.copyPixels(innerCorners[8], innerCorners[8].rect, PointUtil.ORIGIN, null, null, true);
            }
            if (!sig[3] && !sig[7]) {
                newBitmapData.copyPixels(innerCorners[6], innerCorners[6].rect, PointUtil.ORIGIN, null, null, true);
            }
        }
        return newBitmapData;
    }
}
}
</file>

<file path="src/com/company/util/GraphicsUtil.as">
package com.company.util {
import flash.display.CapsStyle;
import flash.display.GraphicsEndFill;
import flash.display.GraphicsPath;
import flash.display.GraphicsPathCommand;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.geom.Matrix;

public class GraphicsUtil {

    public static const END_FILL:GraphicsEndFill = new GraphicsEndFill();

    public static const QUAD_COMMANDS:Vector.<int> = new <int>[GraphicsPathCommand.MOVE_TO, GraphicsPathCommand.LINE_TO, GraphicsPathCommand.LINE_TO, GraphicsPathCommand.LINE_TO];

    public static const DEBUG_STROKE:GraphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, new GraphicsSolidFill(16711680));

    public static const END_STROKE:GraphicsStroke = new GraphicsStroke();

    private static const TWO_PI:Number = 2 * Math.PI;

    public static const ALL_CUTS:Array = [true, true, true, true];


    public function GraphicsUtil() {
        super();
    }

    public static function clearPath(graphicsPath:GraphicsPath):void {
        graphicsPath.commands.length = 0;
        graphicsPath.data.length = 0;
    }

    public static function getRectPath(x:int, y:int, width:int, height:int):GraphicsPath {
        return new GraphicsPath(QUAD_COMMANDS, new <Number>[x, y, x + width, y, x + width, y + height, x, y + height]);
    }

    public static function getGradientMatrix(width:Number, height:Number, rotation:Number = 0.0, tx:Number = 0.0, ty:Number = 0.0):Matrix {
        var m:Matrix = new Matrix();
        m.createGradientBox(width, height, rotation, tx, ty);
        return m;
    }
    public static function drawTriangle(x:int, y:int, width:int, height:int, up:Boolean, data:GraphicsPath):void {
        if(up) {
            data.moveTo(x + width, y + height);
            data.lineTo(x, y + height);
            data.lineTo(x + width/2, y);
        } else {
            data.moveTo(x, y);
            data.lineTo(x + width, y);
            data.lineTo(x + width/2, y + height);
        }
    }
    public static function drawRect(x:int, y:int, width:int, height:int, path:GraphicsPath):void {
        path.moveTo(x, y);
        path.lineTo(x + width, y);
        path.lineTo(x + width, y + height);
        path.lineTo(x, y + height);
    }

    public static function drawCircle(centerX:Number, centerY:Number, radius:Number, path:GraphicsPath, numPoints:int = 8):void {
        var th:Number = NaN;
        var thm:Number = NaN;
        var px:Number = NaN;
        var py:Number = NaN;
        var hx:Number = NaN;
        var hy:Number = NaN;
        var curve:Number = 1 + 1 / (numPoints * 1.75);
        path.moveTo(centerX + radius, centerY);
        for (var i:int = 1; i <= numPoints; i++) {
            th = TWO_PI * i / numPoints;
            thm = TWO_PI * (i - 0.5) / numPoints;
            px = centerX + radius * Math.cos(th);
            py = centerY + radius * Math.sin(th);
            hx = centerX + radius * curve * Math.cos(thm);
            hy = centerY + radius * curve * Math.sin(thm);
            path.curveTo(hx, hy, px, py);
        }
    }

    public static function drawCutEdgeRect(x:int, y:int, width:int, height:int, cutLen:int, cuts:Array, path:GraphicsPath):void {
        if (cuts[0] != 0) {
            path.moveTo(x, y + cutLen);
            path.lineTo(x + cutLen, y);
        } else {
            path.moveTo(x, y);
        }
        if (cuts[1] != 0) {
            path.lineTo(x + width - cutLen, y);
            path.lineTo(x + width, y + cutLen);
        } else {
            path.lineTo(x + width, y);
        }
        if (cuts[2] != 0) {
            path.lineTo(x + width, y + height - cutLen);
            path.lineTo(x + width - cutLen, y + height);
        } else {
            path.lineTo(x + width, y + height);
        }
        if (cuts[3] != 0) {
            path.lineTo(x + cutLen, y + height);
            path.lineTo(x, y + height - cutLen);
        } else {
            path.lineTo(x, y + height);
        }
        if (cuts[0] != 0) {
            path.lineTo(x, y + cutLen);
        } else {
            path.lineTo(x, y);
        }
    }

    public static function drawDiamond(x:Number, y:Number, radius:Number, path:GraphicsPath):void {
        path.moveTo(x, y - radius);
        path.lineTo(x + radius, y);
        path.lineTo(x, y + radius);
        path.lineTo(x - radius, y);
    }
    public static function drawUI(x:int, y:int, width:int, height:int, cornerRadius:int, corner:Array, data:GraphicsPath):void {
        if (corner[0] != 0) {
            data.moveTo(x, y + cornerRadius);
            data.lineTo(x + cornerRadius, y);
        } else {
            data.moveTo(x, y);
        }
        if (corner[1] != 0) {
            data.lineTo((x + width) - cornerRadius, y);
            data.lineTo(x + width, y + cornerRadius);
        } else {
            data.lineTo(x + width, y);
        }
        if (corner[2] != 0) {
            data.lineTo(x + width, (y + height) - cornerRadius);
            data.lineTo((x + width) - cornerRadius, y + height);
        } else {
            data.lineTo(x + width, y + height);
        }
        if (corner[3] != 0) {
            data.lineTo(x + cornerRadius, y + height);
            data.lineTo(x, (y + height) - cornerRadius);
        } else {
            data.lineTo(x, y + height);
        }
        if (corner[0] != 0) {
            data.lineTo(x, y + cornerRadius);
        } else {
            data.lineTo(x, y);
        }
    }
}
}
</file>

<file path="src/svera/lib/net/impl/MessageCenter.as">
package svera.lib.net.impl {
import org.swiftsuspenders.Injector;

import svera.lib.net.api.MessageMap;
import svera.lib.net.api.MessageMapping;
import svera.lib.net.api.MessageProvider;

public class MessageCenter implements MessageMap, MessageProvider {

    private static const MAX_ID:int = 256;


    private const maps:Vector.<MessageCenterMapping> = new Vector.<MessageCenterMapping>(MAX_ID, true);

    private const pools:Vector.<MessagePool> = new Vector.<MessagePool>(MAX_ID, true);

    private var injector:Injector;

    public function MessageCenter() {
        super();
    }

    public function setInjector(injector:Injector):MessageCenter {
        this.injector = injector;
        return this;
    }

    public function map(id:int):MessageMapping {
        return this.maps[id] = this.maps[id] || this.makeMapping(id);
    }

    public function unmap(id:int):void {
        this.pools[id] && this.pools[id].dispose();
        this.pools[id] = null;
        this.maps[id] = null;
    }
    public function unmapAll():void{
        for(var i:int = 0; i < pools.length; i++){
            if(pools[i]) {
                pools[i].dispose();
                pools[i] = null;
            }
            maps[i] = null;
        }
    }

    private function makeMapping(id:int):MessageCenterMapping {
        return new MessageCenterMapping().setInjector(this.injector).setID(id) as MessageCenterMapping;
    }

    public function require(id:int):Message {
        if(pools == null){
            //pools = new Vector.<MessagePool>(MAX_ID, true);
        }
        var pool:MessagePool = this.pools[id] = this.pools[id] || this.makePool(id);
        return pool.require();
    }

    private function makePool(id:uint):MessagePool {
        var mapping:MessageCenterMapping = this.maps[id];
        return Boolean(mapping) ? mapping.makePool() : null;
    }
}
}
</file>

<file path="src/svera/untiered/account/web/view/WebQuitMediator.as">
package svera.untiered.account.web.view {
import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;

//import flash.desktop.NativeApplication;
public class WebQuitMediator extends Mediator {


    [Inject]
    public var view:WebQuitDialog;

    [Inject]
    public var account:Account;

    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var closeDialog:CloseDialogsSignal;

    public function WebQuitMediator() {
        super();
    }

    override public function initialize():void {
        this.view.cancel.add(this.onDone);
        this.view.quit.add(this.onQuit);
    }

    override public function destroy():void {
        this.view.quit.remove(this.onQuit);
        this.view.cancel.remove(this.onDone);
    }

    private function onDone():void {
        this.closeDialog.dispatch();
    }

    private function onQuit():void {
        this.closeDialog.dispatch();
        //NativeApplication.nativeApplication.exit();
    }
}
}
</file>

<file path="src/svera/untiered/assets/EmbeddedData.as">
package svera.untiered.assets {
public class EmbeddedData {
    // Svera System
    [Embed(source="Xmls/Tiles_Shared.xml", mimeType="application/octet-stream")]
    private static const Environment_Ground:Class;
    [Embed(source="Xmls/Objects_Shared.xml", mimeType="application/octet-stream")]
    private static const Environment_Objects:Class;
    [Embed(source="Xmls/Objects_Tavern.xml", mimeType="application/octet-stream")]
    private static const Tavern_Objects:Class;
    [Embed(source="Xmls/Objects_Foundry.xml", mimeType="application/octet-stream")]
    private static const Objects_Foundry:Class;
    [Embed(source="Xmls/Tiles_Foundry.xml", mimeType="application/octet-stream")]
    private static const Tiles_Foundry:Class;
    [Embed(source="Xmls/Tiles_Tavern.xml", mimeType="application/octet-stream")]
    private static const Tiles_Tavern:Class;
    [Embed(source="Xmls/Containers.xml", mimeType="application/octet-stream")]
    private static const Containers:Class;

    [Embed(source="Xmls/Consumables_Artifact.xml", mimeType="application/octet-stream")]
    private static const Consumables_Artifact:Class;
    [Embed(source="Xmls/Consumables_Exiled.xml", mimeType="application/octet-stream")]
    private static const Consumables_Exiled:Class;
    [Embed(source="Xmls/Consumables_Valiant.xml", mimeType="application/octet-stream")]
    private static const Consumables_Valiant:Class;
    [Embed(source="Xmls/Consumables_StatMaxing.xml", mimeType="application/octet-stream")]
    private static const Consumables_StatMaxing:Class;

    [Embed(source="Xmls/Crafting_LuckyDips.xml", mimeType="application/octet-stream")]
    private static const Crafting_LuckyDips:Class;

    [Embed(source="Xmls/Equipment_Starter.xml", mimeType="application/octet-stream")]
    private static const Equipment_Starter:Class;
    [Embed(source="Xmls/Equipment_Artifact.xml", mimeType="application/octet-stream")]
    private static const Equipment_Artifact:Class;
    [Embed(source="Xmls/Equipment_Exiled.xml", mimeType="application/octet-stream")]
    private static const Equipment_Exiled:Class;
    [Embed(source="Xmls/Equipment_Valiant.xml", mimeType="application/octet-stream")]
    private static const Equipment_Valiant:Class;

    [Embed(source="Xmls/Utilities_PetStones.xml", mimeType="application/octet-stream")]
    private static const Utilities_PetStones:Class;
    [Embed(source="Xmls/Utilities_Valiant.xml", mimeType="application/octet-stream")]
    private static const Utilities_Valiant:Class;

    // Old System
    [Embed(source="Xmls/Players.xml", mimeType="application/octet-stream")]
    public static const Players:Class;
    [Embed(source="Xmls/Skins.xml", mimeType="application/octet-stream")]
    private static const Skins:Class;
    [Embed(source="Xmls/Dyes.xml", mimeType="application/octet-stream")]
    private static const Dyes:Class;
    [Embed(source="Xmls/Textiles.xml", mimeType="application/octet-stream")]
    private static const Textiles:Class;
    [Embed(source="Xmls/Regions.xml", mimeType="application/octet-stream")]
    private static const Regions:Class;


    public static const groundFiles:Array = [
        new Environment_Ground(),
        new Tiles_Foundry(),
        new Tiles_Tavern()
    ];
    public static const skinsXML:XML = XML(new Skins());
    public static const objectFiles:Array = [
        new Environment_Objects(),
        new Dyes(),
        new Textiles(),
        new Players(),
        new Objects_Foundry(),
        new Tavern_Objects(),
        new Containers(),
        new Equipment_Artifact(),
        new Equipment_Exiled(),
        new Equipment_Starter(),
        new Equipment_Valiant(),
        new Consumables_Artifact(),
        new Consumables_Exiled(),
        new Consumables_StatMaxing(),
        new Consumables_Valiant(),
        new Utilities_PetStones(),
        new Utilities_Valiant(),
        new Crafting_LuckyDips()
    ];
    public static const regionFiles:Array = [new Regions()];


    public function EmbeddedData() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/characters/deletion/view/ConfirmDeleteCharacterDialog.as">
package svera.untiered.characters.deletion.view {
import com.company.assembleegameclient.ui.dialogs.Dialog;

import flash.display.Sprite;
import flash.events.Event;

import org.osflash.signals.Signal;

public class ConfirmDeleteCharacterDialog extends Sprite {


    private const TEXT_TEMPLATE:String = "Are you really sure you want to delete ${NAME} the ${DISPLAYID}?";

    private const CANCEL_EVENT:String = Dialog.LEFT_BUTTON;

    private const DELETE_EVENT:String = Dialog.RIGHT_BUTTON;

    public var deleteCharacter:Signal;

    public var cancel:Signal;

    public function ConfirmDeleteCharacterDialog() {
        super();
        this.deleteCharacter = new Signal();
        this.cancel = new Signal();
    }

    public function setText(name:String, displayId:String):void {
        var text:String = this.TEXT_TEMPLATE.replace("${NAME}", name).replace("${DISPLAYID}", displayId);
        var dialog:Dialog = new Dialog(text, "Verify Deletion", "Cancel", "Delete");
        dialog.box_.x = this.stage.width / 2 - dialog.box_.width / 2;
        dialog.box_.y = this.stage.height / 2 - dialog.box_.height / 2;
        dialog.addEventListener(this.CANCEL_EVENT, this.onCancel);
        dialog.addEventListener(this.DELETE_EVENT, this.onDelete);
        addChild(dialog);
    }

    private function onCancel(event:Event):void {
        this.cancel.dispatch();
    }

    private function onDelete(event:Event):void {
        this.deleteCharacter.dispatch();
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/control/OpenReskinDialogCommand.as">
package svera.untiered.characters.reskin.control {
import flash.display.DisplayObject;

import svera.lib.framework.ICommand;

import svera.untiered.characters.reskin.view.ReskinCharacterView;
import svera.untiered.classes.model.CharacterSkins;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.classes.view.CharacterSkinListItem;
import svera.untiered.classes.view.CharacterSkinListItemFactory;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.dialogs.control.OpenDialogSignal;

public class OpenReskinDialogCommand implements ICommand {
    [Inject]
    public var openDialog:OpenDialogSignal;

    [Inject]
    public var player:PlayerModel;

    [Inject]
    public var model:ClassesModel;

    [Inject]
    public var factory:CharacterSkinListItemFactory;

    public function OpenReskinDialogCommand() {
        super();
    }

    public function execute():void {
        this.openDialog.dispatch(this.makeView());
    }

    private function makeView():ReskinCharacterView {
        var view:ReskinCharacterView = new ReskinCharacterView();
        view.setList(this.makeList());
        view.x = (GameClient.StageWidth - view.width) * 0.5;
        view.y = (600 - view.viewHeight) * 0.5;
        return view;
    }

    private function makeList():Vector.<CharacterSkinListItem> {
        var skins:CharacterSkins = this.getCharacterSkins();
        return this.factory.make(skins);
    }

    private function getCharacterSkins():CharacterSkins {
        return this.model.getSelected().skins;
    }
}
}
</file>

<file path="src/svera/untiered/characters/reskin/view/ReskinCharacterView.as">
package svera.untiered.characters.reskin.view {
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.display.CapsStyle;
import flash.display.DisplayObject;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.text.TextFormat;
import flash.text.TextFormatAlign;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.classes.view.CharacterSkinListItem;

import svera.untiered.classes.view.CharacterSkinListView;
import svera.untiered.util.components.DialogBackground;
import svera.untiered.util.graphics.ButtonLayoutHelper;

public class ReskinCharacterView extends Sprite {
    private static const CANCEL:String = "Cancel";
    private static const SELECT:String = "Select";
    private static const TITLE_TEXT:String = "Select a Skin";
    private static const MARGIN:int = 10;
    private static const DIALOG_WIDTH:int = CharacterSkinListView.WIDTH + MARGIN * 2;
    private static const BUTTON_WIDTH:int = 120;
    private static const BUTTON_FONT:int = 16;
    private static const BUTTONS_HEIGHT:int = 40;
    private static const TITLE_OFFSET:int = 27;

    private const background:DialogBackground = makeBackground();
    private const title:SimpleText = makeTitle();
    private const list:CharacterSkinListView = makeListView();
    private const cancel:TextButton = makeCancelButton();
    private const select:TextButton = makeSelectButton();
    public const cancelled:Signal = new NativeMappedSignal(cancel, MouseEvent.CLICK);
    public const selected:Signal = new NativeMappedSignal(select, MouseEvent.CLICK);
    public var viewHeight:int;

    public function ReskinCharacterView() {
        super();
    }

    private function makeBackground():DialogBackground {
        var background:DialogBackground = new DialogBackground();
        addChild(background);
        return background;
    }

    private function makeTitle():SimpleText {
        var text:SimpleText;
        text = new SimpleText(18, 11974326, false, DIALOG_WIDTH, 0);
        var format:TextFormat = text.defaultTextFormat;
        format.align = TextFormatAlign.CENTER;
        format.bold = true;
        text.defaultTextFormat = format;
        text.text = TITLE_TEXT;
        addChild(text);
        return text;
    }

    private function makeListView():CharacterSkinListView {
        var list:CharacterSkinListView = new CharacterSkinListView(null);
        list.x = MARGIN;
        list.y = MARGIN + TITLE_OFFSET;
        addChild(list);
        return list;
    }

    private function makeCancelButton():TextButton {
        var button:TextButton = new TextButton(BUTTON_FONT, CANCEL, BUTTON_WIDTH);
        addChild(button);
        return button;
    }

    private function makeSelectButton():TextButton {
        var button:TextButton = new TextButton(BUTTON_FONT, SELECT, BUTTON_WIDTH);
        addChild(button);
        return button;
    }

    public function setList(items:Vector.<CharacterSkinListItem>):void {
        this.list.setItems(items);
        this.getDialogHeight();
        this.resizeBackground();
        this.positionButtons();
    }

    private function getDialogHeight():void {
        this.viewHeight = Math.min(CharacterSkinListView.HEIGHT + MARGIN, this.list.getListHeight);
        this.viewHeight = this.viewHeight + (BUTTONS_HEIGHT + MARGIN * 2 + TITLE_OFFSET);
    }

    private function resizeBackground():void {
        this.background.draw(DIALOG_WIDTH, this.viewHeight);
        this.background.graphics.lineStyle(2, 5987163, 1, false, LineScaleMode.NONE, CapsStyle.NONE, JointStyle.BEVEL);
        this.background.graphics.moveTo(1, TITLE_OFFSET);
        this.background.graphics.lineTo(DIALOG_WIDTH - 1, TITLE_OFFSET);
    }

    private function positionButtons():void {
        var helper:ButtonLayoutHelper = new ButtonLayoutHelper();
        helper.layout(DIALOG_WIDTH, this.cancel, this.select);
        this.cancel.y = this.select.y = this.viewHeight - this.cancel.height - MARGIN;
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/ParseClassesXmlCommand.as">
package svera.untiered.classes.control {
import svera.lib.framework.ICommand;
import svera.untiered.assets.model.CharacterTemplate;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterClassStat;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;
import svera.untiered.classes.model.ClassesModel;

public class ParseClassesXmlCommand implements ICommand {
    public static const CLASSIC_NAME:String = "Classic";

    [Inject]
    public var data:XML;

    [Inject]
    public var classes:ClassesModel;

    public function ParseClassesXmlCommand() {
        super();
    }

    public function execute():void {
        var object:XML = null;
        var objects:XMLList = this.data.Object;
        for each(object in objects) {
            this.parseCharacterClass(object);
        }
    }

    private function parseCharacterClass(object:XML):void {
        var id:int = object.@type;
        var character:CharacterClass = this.classes.getCharacterClass(id);
        this.populateCharacter(character, object);
    }

    private function populateCharacter(character:CharacterClass, object:XML):void {
        var node:XML = null;
        character.id = object.@type;
        character.name = object.@id;
        character.description = object.Description;
        character.hitSound = object.HitSound;
        character.deathSound = object.DeathSound;
        character.bloodProb = object.BloodProb;
        character.slotTypes = this.parseIntList(object.SlotTypes);
        character.defaultEquipment = this.parseIntList(object.Equipment);
        character.hp = this.parseCharacterStat(object, "MaxHitPoints");
        character.sp = this.parseCharacterStat(object, "MaxShieldPoints");
        character.rp = this.parseCharacterStat(object, "MaxResourcePoints");
        character.attack = this.parseCharacterStat(object, "Attack");
        character.armor = this.parseCharacterStat(object, "Armor");
        character.speed = this.parseCharacterStat(object, "Speed");
        character.dexterity = this.parseCharacterStat(object, "Dexterity");
        character.hpRegeneration = this.parseCharacterStat(object, "HpRegen");
        character.mpRegeneration = this.parseCharacterStat(object, "MpRegen");
        character.skins.addSkin(this.makeDefaultSkin(object), true);
    }

    private function makeDefaultSkin(object:XML):CharacterSkin {
        var file:String = object.AnimatedTexture.File;
        var index:int = object.AnimatedTexture.Index;
        var skin:CharacterSkin = new CharacterSkin();
        skin.id = 0;
        skin.name = CLASSIC_NAME;
        skin.template = new CharacterTemplate(file, index);
        skin.setState(CharacterSkinState.OWNED);
        skin.setIsSelected(true);
        return skin;
    }

    private function parseCharacterStat(xml:XML, name:String):CharacterClassStat {
        var stat:CharacterClassStat;
        var main:XML = xml[name][0];
        stat = new CharacterClassStat();
        stat.initial = int(main.toString());
        stat.max = main.@max;
        return stat;
    }

    private function parseIntList(slotTypes:String):Vector.<int> {
        var source:Array = slotTypes.split(",");
        var count:int = source.length;
        var items:Vector.<int> = new Vector.<int>(count, true);
        for (var i:int = 0; i < count; i++) {
            items[i] = int(source[i]);
        }
        return items;
    }
}
}
</file>

<file path="src/svera/untiered/classes/control/ParseSkinsXmlCommand.as">
package svera.untiered.classes.control {
import com.company.assembleegameclient.parameters.Parameters;

import svera.lib.framework.ICommand;

import svera.untiered.assets.EmbeddedData;
import svera.untiered.assets.model.CharacterTemplate;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;

public class ParseSkinsXmlCommand implements ICommand {


    [Inject]
    public var data:XML;

    [Inject]
    public var model:ClassesModel;

    public function ParseSkinsXmlCommand() {
        super();
    }

    public function execute():void {
        var node:XML = EmbeddedData.skinsXML;
        var list:XMLList = node.children();
        for each(node in list) {
            this.parseNode(node);
        }
    }

    private function parseNode(xml:XML):void {
        var file:String;
        file = xml.AnimatedTexture.File;
        var index:int = xml.AnimatedTexture.Index;
        var skin:CharacterSkin = new CharacterSkin();
        skin.id = xml.@type;
        skin.name = xml.@id;
        skin.cost = xml.hasOwnProperty("Price") ? xml.Price : Parameters.CHARACTER_SKIN_PRICE;
        skin.template = new CharacterTemplate(file, index);
        var character:CharacterClass = this.model.getCharacterClass(xml.PlayerClassType);
        character.skins.addSkin(skin);
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinListItemMediator.as">
package svera.untiered.classes.view {
import svera.lib.framework.Mediator;

import svera.untiered.classes.control.BuyCharacterSkinSignal;
import svera.untiered.classes.control.FocusCharacterSkinSignal;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;

public class CharacterSkinListItemMediator extends Mediator {
    [Inject]
    public var view:CharacterSkinListItem;

    [Inject]
    public var model:ClassesModel;

    [Inject]
    public var buyCharacterSkin:BuyCharacterSkinSignal;

    [Inject]
    public var focusCharacterSkin:FocusCharacterSkinSignal;

    public function CharacterSkinListItemMediator() {
        super();
    }

    override public function initialize():void {
        view.selected.add(this.onSelected);
    }

    override public function destroy():void {
        this.view.selected.remove(this.onSelected);
        this.view.setModel(null);
    }

    private function onSelected(isSelected:Boolean):void {
        this.view.getModel().setIsSelected(isSelected);
    }
}
}
</file>

<file path="src/svera/untiered/lootBoxes/PopupWindowBackground.as">
package svera.untiered.lootBoxes {
import flash.display.CapsStyle;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;

import svera.untiered.util.graphics.BevelRect;
import svera.untiered.util.graphics.GraphicsHelper;

public class PopupWindowBackground extends Sprite {

    public static const HORIZONTAL_DIVISION:String = "HORIZONTAL_DIVISION";
    public static const VERTICAL_DIVISION:String = "VERTICAL_DIVISION";
    private static const BEVEL:int = 4;
    public static const TYPE_DEFAULT_GREY:int = 0;
    public static const TYPE_TRANSPARENT_WITH_HEADER:int = 1;
    public static const TYPE_TRANSPARENT_WITHOUT_HEADER:int = 2;
    public static const TYPE_DEFAULT_BLACK:int = 3;


    public function draw(_arg1:int, _arg2:int, _arg3:int = 0):void {
        var _local4:BevelRect = new BevelRect(_arg1, _arg2, BEVEL);
        var _local5:GraphicsHelper = new GraphicsHelper();
        graphics.lineStyle(1, 0xFFFFFF, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3);
        if (_arg3 == TYPE_TRANSPARENT_WITH_HEADER) {
            graphics.lineStyle(1, 0x131313, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3);
            graphics.beginFill(0x131313, 1);
            _local5.drawBevelRect(1, 1, new BevelRect(_arg1 - 2, 29, BEVEL), graphics);
            graphics.endFill();
            graphics.beginFill(0x131313, 1);
            graphics.drawRect(1, 15, _arg1 - 2, 15);
            graphics.endFill();
            graphics.lineStyle(2, 0x131313, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3);
            graphics.beginFill(0x131313, 0);
            _local5.drawBevelRect(0, 0, _local4, graphics);
            graphics.endFill();
        }
        else {
            if (_arg3 == TYPE_TRANSPARENT_WITHOUT_HEADER) {
                graphics.lineStyle(2, 0xFFFFFF, 1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3);
                graphics.beginFill(0x363636, 0);
                _local5.drawBevelRect(0, 0, _local4, graphics);
                graphics.endFill();
            }
            else {
                if (_arg3 == TYPE_DEFAULT_GREY) {
                    graphics.beginFill(0x363636);
                    _local5.drawBevelRect(0, 0, _local4, graphics);
                    graphics.endFill();
                }
                else {
                    if (_arg3 == TYPE_DEFAULT_BLACK) {
                        graphics.beginFill(0);
                        _local5.drawBevelRect(0, 0, _local4, graphics);
                        graphics.endFill();
                    }
                }
            }
        }
    }

    public function divide(_arg1:String, _arg2:int):void {
        if (_arg1 == HORIZONTAL_DIVISION) {
            this.divideHorizontally(_arg2);
        }
        else {
            if (_arg1 == VERTICAL_DIVISION) {
                this.divideVertically(_arg2);
            }
        }
    }

    private function divideHorizontally(_arg1:int):void {
        graphics.lineStyle();
        graphics.endFill();
        graphics.moveTo(1, _arg1);
        graphics.beginFill(0x666666, 1);
        graphics.drawRect(1, _arg1, width - 2, 2);
    }

    private function divideVertically(_arg1:int):void {
        graphics.lineStyle();
        graphics.moveTo(_arg1, 1);
        graphics.lineStyle(2, 0x666666);
        graphics.lineTo(_arg1, height - 1);
    }


}
}
</file>

<file path="src/svera/untiered/memMarket/tabs/MemMarketSellTab.as">
package svera.untiered.memMarket.tabs {
import com.company.assembleegameclient.account.ui.MarketInput;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.ui.dropdown.DropDown;
import com.company.assembleegameclient.util.Currency;

import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;


import svera.untiered.memMarket.content.MemMarketInventoryItem;
import svera.untiered.memMarket.content.MemMarketItem;
import svera.untiered.memMarket.content.MemMarketSellItem;
import svera.untiered.memMarket.signals.MemMarketAddSignal;
import svera.untiered.memMarket.signals.MemMarketMyOffersSignal;
import svera.untiered.memMarket.signals.MemMarketRemoveSignal;
import svera.untiered.memMarket.utils.DialogUtils;
import svera.untiered.memMarket.utils.SortUtils;
import svera.untiered.messaging.impl.data.MarketData;
import svera.untiered.messaging.impl.incoming.market.MarketAddResult;
import svera.untiered.messaging.impl.incoming.market.MarketMyOffersResult;
import svera.untiered.messaging.impl.incoming.market.MarketRemoveResult;

public class MemMarketSellTab extends MemMarketTab
{
    private static const SLOT_X_OFFSET:int = 33;
    private static const SLOT_Y_OFFSET:int = 109;

    private static const RESULT_X_OFFSET:int = 270;
    private static const RESULT_Y_OFFSET:int = 105;

    private static const ICON_X:int = 212;
    private static const ICON_Y:int = 356;

    private static const HONOR:String = "Honor";
    private static const TSAVORITE:String = "Tsavorite";
    private static const CURRENCY_CHOICES:Vector.<String> = new <String> /* List of available sell currencies */
    [
        HONOR,
        TSAVORITE
    ];

    private static const HOURS_3:String = "3 Hours";
    private static const HOURS_6:String = "6 Hours";
    private static const HOURS_12:String = "12 Hours";
    private static const HOURS_72:String = "72 Hours";
    private static const UPTIME_CHOICES:Vector.<String> = new <String> /* List of available uptime values */
    [
        HOURS_72
    ];

    /* Signals */
    public const addSignal_:MemMarketAddSignal = new MemMarketAddSignal();
    public const removeSignal_:MemMarketRemoveSignal = new MemMarketRemoveSignal();
    public const myOffersSignal_:MemMarketMyOffersSignal = new MemMarketMyOffersSignal();

    private var inventorySlots_:Vector.<MemMarketInventoryItem>;
    private var priceField_:MarketInput;
    //private var currencyChoice_:DropDown;
    //private var currencyHonor_:Bitmap;
    //private var currencyGold_:Bitmap;
    private var uptimeChoice_:DropDown;
    private var sellButton_:TextButton;
    private var shape_:Shape;
    private var resultMask_:Sprite;
    private var resultBackground_:Sprite;
    private var resultItems_:Vector.<MemMarketSellItem>;
    private var resultScroll_:Scrollbar;
    private var sortChoices_:DropDown;
    private var uptime_:int;
    private var slots_:Vector.<int>;
    private var price_:int;
    //private var selectedCurrency_:int;

    public function MemMarketSellTab(gameSprite:GameSprite)
    {
        super(gameSprite);

        /* Initialize signals */
        this.addSignal_.add(this.onAdd);
        this.removeSignal_.add(this.onRemove);
        this.myOffersSignal_.add(this.onMyOffers);

        this.inventorySlots_ = new Vector.<MemMarketInventoryItem>();
        for (var i:int = 4; i < this.gameSprite_.map.player_.equipment_.length; i++) /* Start at index 4 so we dont include equipment */
        {
            var item:MemMarketInventoryItem = new MemMarketInventoryItem(this.gameSprite_, this.gameSprite_.map.player_.equipment_[i], i);
            this.inventorySlots_.push(item);
        }

        var space:int = 0;
        var index:int = 0;
        for each (var o:MemMarketInventoryItem in this.inventorySlots_)
        {
            o.x = MemMarketItem.SLOT_WIDTH * int(index % 4) + SLOT_X_OFFSET;
            o.y = MemMarketItem.SLOT_HEIGHT * int(index / 4) + SLOT_Y_OFFSET + space;
            index++; /* Increase before we check spacing */
            if (index % 8 == 0) /* Add small space between each inventory */
            {
                space = 20;
            }
            addChild(o);
        }

        this.priceField_ = new MarketInput("", false, "");
        this.priceField_.inputText_.restrict = "0-9";
        this.priceField_.x = 13;
        this.priceField_.y = 304;
        addChild(this.priceField_);

        /*this.currencyChoice_ = new DropDown(CURRENCY_CHOICES, 133, 26, "Currency");
        this.currencyChoice_.x = 10;
        this.currencyChoice_.y = 368;
        this.currencyChoice_.setValue(FAME);
        this.currencyChoice_.addEventListener(Event.CHANGE, this.onCurrencyChanged);
        addChild(this.currencyChoice_);

        this.currencyHonor_ = new Bitmap(IconUtils.getHonorIcon(68));
        this.currencyHonor_.x = ICON_X;
        this.currencyHonor_.y = ICON_Y;
        this.currencyHonor_.visible = false;
        addChild(this.currencyHonor_);

        this.currencyGold_ = new Bitmap(IconUtils.getCoinIcon(68));
        this.currencyGold_.x = ICON_X;
        this.currencyGold_.y = ICON_Y;
        this.currencyGold_.visible = false;
        addChild(this.currencyGold_); */

        //this.updateIcon();

        this.uptimeChoice_ = new DropDown(UPTIME_CHOICES, 176, 26, "Uptime");
        this.uptimeChoice_.x = 10;
        this.uptimeChoice_.y = 368;
        this.uptimeChoice_.setValue(HOURS_72);
        this.uptimeChoice_.addEventListener(Event.CHANGE, this.onUptimeChanged);
        addChild(this.uptimeChoice_);

        this.uptime_ = this.getHours();

        this.sellButton_ = new TextButton(16, "Sell", 243);
        this.sellButton_.x = 10;
        this.sellButton_.y = 397;
        this.sellButton_.addEventListener(MouseEvent.CLICK, this.onSell);
        addChild(this.sellButton_);

        this.shape_ = new Shape();
        this.shape_.graphics.beginFill(0);
        this.shape_.graphics.drawRect(RESULT_X_OFFSET, RESULT_Y_OFFSET, 500, 415);
        this.shape_.graphics.endFill();
        this.resultMask_ = new Sprite();
        this.resultMask_.addChild(this.shape_);
        this.resultMask_.mask = this.shape_;
        addChild(this.resultMask_);
        this.resultBackground_ = new Sprite();
        this.resultMask_.addChild(this.resultBackground_);

        this.resultItems_= new Vector.<MemMarketSellItem>();

        this.sortChoices_ = new DropDown(SortUtils.SORT_CHOICES, 200, 26);
        this.sortChoices_.x = 597;
        this.sortChoices_.y = 71;
        this.sortChoices_.setValue(SortUtils.JUST_ADDED);
        this.sortChoices_.addEventListener(Event.CHANGE, this.onSortChoicesChanged);
        addChild(this.sortChoices_);

        this.gameSprite_.gsc_.marketMyOffers();
    }

    private function onSortChoicesChanged(event:Event) : void
    {
        this.sortOffers();
    }

    private function onSell(event:MouseEvent) : void
    {
        this.price_ = int(this.priceField_.text());
        if (this.price_ <= 0)
        {
            DialogUtils.makeSimpleDialog(this.gameSprite_, "Error", "Invalid price.");
            return;
        }

        this.slots_ = new Vector.<int>();
        for each (var i:MemMarketInventoryItem in this.inventorySlots_)
        {
            if (!i.selected_)
            {
                continue;
            }
            this.slots_.push(i.slot_);
        }

        if (this.slots_.length <= 0)
        {
            DialogUtils.makeSimpleDialog(this.gameSprite_, "Error", "You must select at least 1 item.");
            return;
        }

        /*switch (CURRENCY_CHOICES[this.currencyChoice_.getIndex()])
        {
            case FAME:
                this.selectedCurrency_ = Currency.HONOR;
                break;
            case GOLD:
                this.selectedCurrency_ = Currency.GOLD;
                break;
        } */

        DialogUtils.makeCallbackDialog(this.gameSprite_, "Verification", "Are you sure you want to sell these items?", "Yes", "No", this.onVerified);
    }

    private function onVerified(event:Event) : void
    {
        this.gameSprite_.gsc_.marketAdd(this.slots_, this.price_, Currency.HONOR, this.uptime_);
    }

    /*private function onCurrencyChanged(event:Event) : void
    {
        this.updateIcon();
    } */

    /*private function updateIcon() : void
    {
        switch (CURRENCY_CHOICES[this.currencyChoice_.getIndex()])
        {
            case FAME:
                this.currencyHonor_.visible = true;
                this.currencyGold_.visible = false;
                break;
            case GOLD:
                this.currencyHonor_.visible = false;
                this.currencyGold_.visible = true;
                break;
        }
    } */

    private function onUptimeChanged(event:Event) : void
    {
        this.uptime_ = this.getHours();
    }

    private function getHours() : int
    {
        var str:String = UPTIME_CHOICES[this.uptimeChoice_.getIndex()];
        var hours:int = int(str.split(' ')[0]); /* Pretty scuffed, but i didnt want to make a switch statement for this */
        return hours;
    }

    /* Adds and refresh all of our offers */
    private function onAdd(result:MarketAddResult) : void
    {
        if (result.code_ != -1)
        {
            this.slots_.length = 0;
            DialogUtils.makeSimpleDialog(this.gameSprite_, "Error", result.description_);
            return;
        }

        /* Reset sold inventory slots */
        for each (var i:MemMarketInventoryItem in this.inventorySlots_)
        {
            for each (var x:int in this.slots_)
            {
                if (i.slot_ == x)
                {
                    i.reset();
                }
            }
        }

        /* Reset slots */
        this.slots_.length = 0;

        /* Request our items back */
        this.gameSprite_.gsc_.marketMyOffers();

        DialogUtils.makeSimpleDialog(this.gameSprite_, "Success", result.description_);
    }

    /* This really only gets called when there's an error */
    private function onRemove(result:MarketRemoveResult) : void
    {
        if (result.description_ != "")
        {
            DialogUtils.makeSimpleDialog(this.gameSprite_, "Error", result.description_);
        }
    }

    /* Refresh all of our offers */
    private function onMyOffers(result:MarketMyOffersResult) : void
    {
        /* Remove old scrollbar */
        if (this.resultScroll_ != null)
        {
            this.resultScroll_.removeEventListener(Event.CHANGE, this.onResultScrollChanged);
            removeChild(this.resultScroll_);
            this.resultScroll_ = null;
        }

        this.clearPreviousResults();

        for each (var i:MarketData in result.results_)
        {
            var item:MemMarketSellItem = new MemMarketSellItem(this.gameSprite_, i);
            this.resultItems_.push(item);
        }

        this.sortOffers();

        for each (var o:MemMarketSellItem in this.resultItems_)
        {
            this.resultBackground_.addChild(o);
        }

        this.resultBackground_.y = 0; /* Reset height */
        if (this.resultBackground_.height > 436)
        {
            this.resultScroll_ = new Scrollbar(22, 415);
            this.resultScroll_.x = 774;
            this.resultScroll_.y = RESULT_Y_OFFSET;
            this.resultScroll_.setIndicatorSize(415, this.resultBackground_.height);
            this.resultScroll_.addEventListener(Event.CHANGE, this.onResultScrollChanged);
            addChild(this.resultScroll_);
        }
    }

    private function onResultScrollChanged(event:Event) : void
    {
        this.resultBackground_.y = -this.resultScroll_.pos() * (this.resultBackground_.height - 418);
    }

    private function clearPreviousResults() : void
    {
        for each (var i:MemMarketSellItem in this.resultItems_)
        {
            i.dispose();
            this.resultBackground_.removeChild(i);
            i = null;
        }
        this.resultItems_.length = 0;
    }

    private function sortOffers() : void
    {
        switch (SortUtils.SORT_CHOICES[this.sortChoices_.getIndex()])
        {
            case SortUtils.LOWEST_TO_HIGHEST:
                this.resultItems_.sort(SortUtils.lowestToHighest);
                break;
            case SortUtils.HIGHEST_TO_LOWEST:
                this.resultItems_.sort(SortUtils.highestToLowest);
                break;
            /*case SortUtils.FAME_TO_GOLD:
                this.resultItems_.sort(SortUtils.honorToGold);
                break;
            case SortUtils.GOLD_TO_FAME:
                this.resultItems_.sort(SortUtils.goldToHonor);
                break; */
            case SortUtils.JUST_ADDED:
                this.resultItems_.sort(SortUtils.justAdded);
                break;
            case SortUtils.ENDING_SOON:
                this.resultItems_.sort(SortUtils.endingSoon);
                break;
        }

        var index:int = 0;
        for each (var i:MemMarketSellItem in this.resultItems_)
        {
            i.x = MemMarketItem.OFFER_WIDTH * int(index % 5) + RESULT_X_OFFSET;
            i.y = MemMarketItem.OFFER_HEIGHT * int(index / 5) + RESULT_Y_OFFSET;
            index++;
        }
    }

    /* Clear */
    public override function dispose() : void
    {
        this.addSignal_.remove(this.onAdd);
        this.removeSignal_.remove(this.onRemove);
        this.myOffersSignal_.remove(this.onMyOffers);

        for each (var i:MemMarketInventoryItem in this.inventorySlots_)
        {
            i.dispose();
            i = null;
        }
        this.inventorySlots_.length = 0;
        this.inventorySlots_ = null;

        this.priceField_ = null;
        /*this.currencyChoice_.removeEventListener(Event.CHANGE, this.onCurrencyChanged);
        this.currencyChoice_ = null;
        this.currencyHonor_ = null;
        this.currencyGold_ = null; */
        this.uptimeChoice_.removeEventListener(Event.CHANGE, this.onUptimeChanged);
        this.uptimeChoice_ = null;
        this.sellButton_.removeEventListener(MouseEvent.CLICK, this.onSell);
        this.sellButton_ = null;

        this.shape_.parent.removeChild(this.shape_);
        this.shape_ = null;

        this.clearPreviousResults();
        this.resultItems_ = null;

        this.resultMask_.removeChild(this.resultBackground_);
        this.resultMask_ = null;
        this.resultBackground_ = null;

        if (this.resultScroll_ != null)
        {
            this.resultScroll_.removeEventListener(Event.CHANGE, this.onResultScrollChanged);
            this.resultScroll_ = null;
        }

        this.sortChoices_.removeEventListener(Event.CHANGE, this.onSortChoicesChanged);
        this.sortChoices_ = null;

        if (this.slots_ != null)
        {
            this.slots_.length = 0;
            this.slots_ = null;
        }

        super.dispose();
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/incoming/StorageUpdate.as">
package svera.untiered.messaging.impl.incoming {
import flash.utils.ByteArray;
import flash.utils.IDataInput;

import svera.untiered.itemdata.NewItemData;

public class StorageUpdate extends IncomingMessage {

    public var type_:int;
    public var size_:int;
    public var items_:Vector.<NewItemData>;

    public function StorageUpdate(id:uint, callback:Function) {
        this.items_ = new Vector.<NewItemData>();
        super(id, callback);
    }

    override public function parseFromInput(data:IDataInput):void {
        this.items_.length = 0;
        //TODO[ITEMDATA]
        /*this.type_ = data.readByte();
        this.size_ = data.readShort();
        for (var i:int = 0; i < this.size_; i++) {
            var update:NewItemData = new NewItemData();
            var len:Number = data.readShort();
            var statByteArray:ByteArray = new ByteArray();
            for(var j:Number = 0; i < len; i++) {
                statByteArray.writeByte(data.readUnsignedByte());
            }
            statByteArray.endian = "littleEndian";
            statByteArray.position = 0;
            //update = ItemData.loadFromData(statByteArray);
            this.items_.push(update);
        }*/
    }

    override public function toString():String {
        return "";
    }
}
}
</file>

<file path="src/svera/untiered/storage/mediator/GiftWindowMediator.as">
package svera.untiered.storage.mediator {
import svera.lib.framework.Mediator;


import svera.untiered.storage.GiftWindow;
import svera.untiered.storage.signals.GiftSlotUpdateSignal;
import svera.untiered.storage.signals.GiftUpdateSignal;

public class GiftWindowMediator extends Mediator {
    public function GiftWindowMediator() {
        super();
    }

    [Inject]
    public var view_:GiftWindow;
    [Inject]
    public var giftUpdate_:GiftUpdateSignal;
    [Inject]
    public var giftSlotUpdate_:GiftSlotUpdateSignal;

    public override function initialize():void {
        this.giftUpdate_.add(this.onVaultUpdate);
        this.giftSlotUpdate_.add(this.onVaultSlotUpdate);
    }

    public override function destroy():void {
        this.giftUpdate_.remove(this.onVaultUpdate);
        this.giftSlotUpdate_.remove(this.onVaultSlotUpdate);
    }

    private function onVaultUpdate(size:int, slots:Vector.<StorageSlotUpdateData>):void {
        this.view_.setContent(size, slots);
    }

    private function onVaultSlotUpdate(slot:int, inventory:int, itemData:int):void {
        this.view_.updateSlot(slot, inventory, itemData);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/NewCharacterMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.screens.CharacterSelectionAndNewsScreen;
import com.company.assembleegameclient.screens.NewCharacterScreen;

import flash.display.Sprite;

import svera.lib.framework.Mediator;

import svera.untiered.classes.model.ClassesModel;
import svera.untiered.classes.view.CharacterSkinView;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.HideTooltipsSignal;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.core.signals.ShowTooltipSignal;
import svera.untiered.core.signals.UpdateNewCharacterScreenSignal;
import svera.untiered.game.signals.PlayGameSignal;

public class NewCharacterMediator extends Mediator {
    [Inject]
    public var view:NewCharacterScreen;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var playGame:PlayGameSignal;

    [Inject]
    public var showTooltip:ShowTooltipSignal;

    [Inject]
    public var hideTooltips:HideTooltipsSignal;

    [Inject]
    public var updateNewCharacterScreen:UpdateNewCharacterScreenSignal;

    [Inject]
    public var classesModel:ClassesModel;

    public function NewCharacterMediator() {
        super();
    }

    override public function initialize():void {
        this.view.selected.add(this.onSelected);
        this.view.close.add(this.onClose);
        this.view.tooltip.add(this.onTooltip);
        this.updateNewCharacterScreen.add(this.onUpdate);
        this.view.initialize(this.playerModel);
    }

    private function onBuyCharacterPending(objectType:int):void {
        this.view.updateCurrencies(this.playerModel.getTsavorite(), this.playerModel.getMedallions(), this.playerModel.getHonor());
    }

    override public function destroy():void {
        this.view.selected.remove(this.onSelected);
        this.view.close.remove(this.onClose);
        this.view.tooltip.remove(this.onTooltip);
        this.updateNewCharacterScreen.remove(this.onUpdate);
    }

    private function onClose():void {
        this.setScreen.dispatch(new CharacterSelectionAndNewsScreen());
    }

    private function onSelected(objectType:int):void {
        this.classesModel.getCharacterClass(objectType).setIsSelected(true);
        this.setScreen.dispatch(new CharacterSkinView());
    }

    private function onTooltip(sprite:Sprite):void {
        if (sprite) {
            this.showTooltip.dispatch(sprite);
        } else {
            this.hideTooltips.dispatch();
        }
    }

    private function onUpdate():void {
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/TitleMediator.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.mapeditor.MapEditor;

import svera.lib.framework.Mediator;

import svera.untiered.account.core.Account;
import svera.untiered.account.core.signals.OpenAccountInfoSignal;
import svera.untiered.account.core.signals.OpenQuitDialogSignal;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.SetScreenSignal;
import svera.untiered.core.signals.SetScreenWithValidDataSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.legends.view.LegendsView;
import svera.untiered.ui.signals.EnterGameSignal;

public class TitleMediator extends Mediator {
    [Inject]
    public var view:TitleView;

    [Inject]
    public var account:Account;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var setScreen:SetScreenSignal;

    [Inject]
    public var setScreenWithValidData:SetScreenWithValidDataSignal;

    [Inject]
    public var enterGame:EnterGameSignal;

    [Inject]
    public var openAccountInfo:OpenAccountInfoSignal;

    [Inject]
    public var openQuitDialog:OpenQuitDialogSignal;

    [Inject]
    public var openDialog:OpenDialogSignal;

    public function TitleMediator() {
        super();
    }

    override public function initialize():void {
        this.view.initialize();
        this.view.playClicked.add(this.handleIntentionToPlay);
        this.view.legendsClicked.add(this.showLegendsScreen);
        this.view.editorClicked.add(this.showMapEditor);
        this.view.accountClicked.add(this.handleIntentionToReviewAccount);
        this.view.quitClicked.add(this.handleIntentionToQuitGame);
    }

    override public function destroy():void {
        this.view.playClicked.remove(this.handleIntentionToPlay);
        this.view.legendsClicked.remove(this.showLegendsScreen);
        this.view.editorClicked.remove(this.showMapEditor);
        this.view.accountClicked.remove(this.handleIntentionToReviewAccount);
        this.view.quitClicked.remove(this.handleIntentionToQuitGame);
        view.destroy();
    }

    private function handleIntentionToPlay():void {
        if (this.account.isRegistered()) {
            this.enterGame.dispatch();
        } else {
            this.openAccountInfo.dispatch(false);
        }
    }

    private function showLegendsScreen():void {
        this.setScreen.dispatch(new LegendsView());
    }

    private function showMapEditor():void {
        this.setScreen.dispatch(new MapEditor());
    }

    private function handleIntentionToReviewAccount():void {
        this.openAccountInfo.dispatch(false);
    }

    private function handleIntentionToQuitGame():void {
        this.openQuitDialog.dispatch(false);
    }
}
}
</file>

<file path="src/svera/untiered/util/components/LegacyBuyButton.as">
package svera.untiered.util.components {
import com.company.assembleegameclient.util.Currency;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.events.MouseEvent;

import svera.untiered.assets.services.IconFactory;
import svera.untiered.util.components.api.BuyButton;

public class LegacyBuyButton extends BuyButton {
    private static const BEVEL:int = 4;
    private static const PADDING:int = 5;
    public static const tsavorite:BitmapData = IconFactory.makeTsavorite();
    public static const medallions:BitmapData = IconFactory.makeMedallions();
    public static const honor:BitmapData = IconFactory.makeHonor();
    public static const guildHonor:BitmapData = IconFactory.makeGuildHonor();

    public var prefix:String;
    public var text:SimpleText;
    public var icon:Bitmap;
    public var price:int = -1;
    public var currency:int = -1;
    public var _width:int = -1;
    private const enabledFill:GraphicsSolidFill = new GraphicsSolidFill(16777215, 1);
    private const disabledFill:GraphicsSolidFill = new GraphicsSolidFill(8355711, 1);
    private const graphicsPath:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
    private const graphicsData:Vector.<IGraphicsData> = new <IGraphicsData>[enabledFill, graphicsPath, GraphicsUtil.END_FILL];

    public function LegacyBuyButton(prefix:String, size:int, price:int, currency:int) {
        super();
        this.prefix = prefix;
        this.text = new SimpleText(size, 3552822, false, 0, 0);
        this.text.setBold(true);
        addChild(this.text);
        this.icon = new Bitmap();
        addChild(this.icon);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
        this.setPrice(price, currency);
    }

    override public function setPrice(price:int, currency:int):void {
        if (this.price != price || this.currency != currency) {
            this.price = price;
            this.currency = currency;
            this.updateUI();
        }
    }

    override public function setEnabled(enabled:Boolean):void {
        if (enabled != mouseEnabled) {
            mouseEnabled = enabled;
            this.draw();
        }
    }

    override public function setWidth(value:int):void {
        this._width = value;
        this.updateUI();
    }

    private function updateUI():void {
        this.updateText();
        this.updateIcon();
        this.updateBackground();
        this.draw();
    }

    private function updateIcon():void {
        switch (this.currency) {
            case Currency.TSAVORITE:
                this.icon.bitmapData = tsavorite;
                break;
            case Currency.MEDALLIONS:
                this.icon.bitmapData = medallions;
                break;
            case Currency.HONOR:
                this.icon.bitmapData = honor;
                break;
            case Currency.GUILD_FAME:
                this.icon.bitmapData = guildHonor;
                break;
            default:
                this.icon.bitmapData = null;
        }
        this.updateIconPosition();
    }

    private function updateBackground():void {
        GraphicsUtil.clearPath(this.graphicsPath);
        GraphicsUtil.drawCutEdgeRect(0, 0, this.getWidth(), this.getHeight(), BEVEL, [1, 1, 1, 1], this.graphicsPath);
    }

    private function updateText():void {
        this.text.text = this.prefix + this.price.toString();
        this.text.updateMetrics();
        this.text.x = (this.getWidth() - this.icon.width - this.text.textWidth - PADDING) * 0.5;
        this.text.y = 1;
    }

    private function updateIconPosition():void {
        this.icon.x = this.text.x + this.text.textWidth + PADDING;
        this.icon.y = (this.getHeight() - this.icon.height) * 0.5;
    }

    private function onMouseOver(event:MouseEvent):void {
        this.enabledFill.color = 16768133;
        this.draw();
    }

    private function onRollOut(event:MouseEvent):void {
        this.enabledFill.color = 16777215;
        this.draw();
    }

    private function draw():void {
        this.graphicsData[0] = mouseEnabled ? this.enabledFill : this.disabledFill;
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData);
    }

    private function getWidth():int {
        return Math.max(this._width, this.text.width + this.icon.width + 3 * PADDING);
    }

    private function getHeight():int {
        return this.text.textHeight + 8;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/account/ui/unboxing/Frame2.as">
/**
 * Created by vooolox on 07-2-2016.
 */
package com.company.assembleegameclient.account.ui.unboxing {
import com.company.assembleegameclient.account.ui.*;


import com.company.assembleegameclient.ui.ClickableText;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.CapsStyle;
import flash.display.DisplayObject;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

public class Frame2 extends Sprite
{

    public function Frame2(_arg1:String, button1Text:String, _arg5:int = 288) {
        this.frameTextInputBoxes = new Vector.<TextInputField>();
        this.frameTextButtons_ = new Vector.<ClickableText>();
        this.primaryColorLight = new GraphicsSolidFill(0x220022, 1);
        this.primaryColorDark = new GraphicsSolidFill(0x444444, 1);
        this.outlineFill_ = new GraphicsSolidFill(0xFFFFFF, 1);
        this._graphicsStroke = new GraphicsStroke(1, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, this.outlineFill_);
        this.path1_ = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        this.path2_ = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        this.graphicsData_ = new <IGraphicsData>[primaryColorDark, path2_, GraphicsUtil.END_FILL, primaryColorLight, path1_, GraphicsUtil.END_FILL, _graphicsStroke, path2_, GraphicsUtil.END_STROKE];
        super();
        this.w_ = _arg5;
        this.frameTitle = new SimpleText(12, 0xFFFFFF, false, 0, 0);
        this.frameTitle.text = _arg1;
        this.frameTitle.updateMetrics();
        this.frameTitle.filters = [new DropShadowFilter(0, 0, 0)];
        this.frameTitle.x = 5;
        this.frameTitle.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addChild(this.frameTitle);
        this.Button1 = new ClickableText(18, true, button1Text);
        if (button1Text != "") {
            this.Button1.buttonMode = true;
            this.Button1.x = this.w_ / 2 - Button1.width / 2;
            addChild(this.Button1);
        }
        this.XButton = new TextButton(12, "X");
        this.XButton.x = this.w_ - this.XButton.width - 15;
        addChild(this.XButton);
        filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }
    public var frameTitle:SimpleText;
    public var Button1:ClickableText;
    public var XButton:TextButton;
    public var frameTextInputBoxes:Vector.<TextInputField>;
    public var frameTextButtons_:Vector.<ClickableText>;
    protected var w_:int = 288;
    protected var h_:int = 100;
    private var graphicsData_:Vector.<IGraphicsData>;
    private var primaryColorLight:GraphicsSolidFill;
    private var primaryColorDark:GraphicsSolidFill;
    private var outlineFill_:GraphicsSolidFill;
    private var _graphicsStroke:GraphicsStroke;
    private var path1_:GraphicsPath;
    private var path2_:GraphicsPath;


    public function addTextButton(_arg1:ClickableText):void
    {
        this.frameTextButtons_.push(_arg1);
        addChild(_arg1);
        _arg1.y = this.h_ - 66;
        _arg1.x = 17;
        this.h_ = this.h_ + 20;
    }

    public function addDisplayObject(_arg1:DisplayObject, _arg2:int = 8):void
    {
        addChild(_arg1);
        _arg1.y = this.h_ - 66;
        _arg1.x = _arg2;
        this.h_ = this.h_ + _arg1.height;
    }

    public function addLabel(_arg1:String):void
    {
        var _local2:SimpleText;
        _local2 = new SimpleText(12, 0xFFFFFF, false, 0, 0);
        _local2.text = _arg1;
        _local2.updateMetrics();
        _local2.filters = [new DropShadowFilter(0, 0, 0)];
        addChild(_local2);
        _local2.y = this.h_ - 66;
        _local2.x = 17;
        this.h_ = this.h_ + 20;
    }

    public function addHeaderText(_arg1:String):void {
        var _local2:SimpleText = new SimpleText(20, 0xB2B2B2, false, 0, 0);
        _local2.text = _arg1;
        _local2.setBold(true);
        _local2.updateMetrics();
        _local2.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addChild(_local2);
        _local2.y = this.h_ - 60;
        _local2.x = 15;
        this.h_ = this.h_ + 40;
    }


    public function offsetH(_arg1:int):void
    {
        this.h_ = this.h_ + _arg1;
    }

    public function setAllButtonsGray():void {
        var _local1:ClickableText;
        mouseEnabled = false;
        mouseChildren = false;
        for each (_local1 in this.frameTextButtons_)
        {
            _local1.setDefaultColor(0xB3B3B3);
        }
        this.Button1.setDefaultColor(0xB3B3B3);
    }


    public function draw():void {
        this.graphics.clear();
        GraphicsUtil.clearPath(this.path1_);
        GraphicsUtil.drawUI(-6, -6, this.w_, 20 + 12, 4, [1, 1, 0, 0], this.path1_);
        GraphicsUtil.clearPath(this.path2_);
        GraphicsUtil.drawUI(-6, -6, this.w_, this.h_, 4, [1, 1, 1, 1], this.path2_);
        this.Button1.y = this.h_ - 48;
        this.graphics.drawGraphicsData(this.graphicsData_);
    }

    public function onAddedToStage(_arg1:Event):void {
        this.draw();
        this.x = GameClient.HalfStageWidth - (this.w_ - 6) / 2;
        this.y = GameClient.HalfStageHeight - h_ / 2; //was height
        if (this.frameTextInputBoxes.length > 0) {
            stage.focus = this.frameTextInputBoxes[0].inputText_;
        }
    }

    private function onRemovedFromStage(_arg1:Event):void {
    }

}
}
</file>

<file path="src/com/company/assembleegameclient/appengine/SavedCharactersList.as">
package com.company.assembleegameclient.appengine {
import flash.events.Event;

import org.swiftsuspenders.Injector;

import svera.untiered.account.core.Account;
import svera.untiered.core.StaticInjectorContext;

public class SavedCharactersList extends Event {
    public static const SAVED_CHARS_LIST:String = "SAVED_CHARS_LIST";
    public static const AVAILABLE:String = "available";
    public static const UNAVAILABLE:String = "unavailable";
    public static const UNRESTRICTED:String = "unrestricted";

    private var origData_:String;
    private var charsXML_:XML;
    public var accountId_:int;
    public var nextCharId_:int;
    public var maxNumChars_:int;
    public var numChars_:int = 0;
    public var savedChars_:Vector.<SavedCharacter>;
    public var charStats_:Object;
    public var traitOne_:int = -1;
    public var traitTwo_:int = -1;
    public var traitThree_:int = -1;
    public var tsavorite_:int = 0;
    public var medallions_:int = 0;
    public var honor_:int = 0;
    public var numStars_:int = 0;
    public var guildName_:String;
    public var guildRank_:int;
    public var name_:String = null;
    public var news_:Vector.<SavedNewsItem>;
    private var account:Account;

    public function SavedCharactersList(data:XML) {
        var value:* = undefined;
        var account:Account = null;
        this.savedChars_ = new Vector.<SavedCharacter>();
        this.charStats_ = {};
        this.news_ = new Vector.<SavedNewsItem>();
        super(SAVED_CHARS_LIST);
        this.origData_ = data;
        this.charsXML_ = new XML(this.origData_);

        var accountXML:XML = XML(this.charsXML_.Account);

        this.parseUserData(accountXML);
        this.parseGuildData(accountXML);
        this.parseCharacterData();
        this.parseCharacterStatsData();
        this.parseNewsData();
        var injector:Injector = StaticInjectorContext.getInjector();
        if (injector) {
            account = injector.getInstance(Account);
            account.reportIntStat("BestLevel", this.bestOverallLevel());
            account.reportIntStat("BestHonor", this.bestOverallHonor());
            account.reportIntStat("NumStars", this.numStars_);
        }
    }

    public function getCharById(id:int):SavedCharacter {
        var savedChar:SavedCharacter = null;
        for each(savedChar in this.savedChars_) {
            if (savedChar.charId() == id) {
                return savedChar;
            }
        }
        return null;
    }

    private function parseUserData(accountXML:XML):void {
        this.accountId_ = accountXML.AccountId;
        this.name_ = accountXML.Name;
        this.tsavorite_ = int(accountXML.Stats.Tsavorite);
        this.medallions_ = int(accountXML.Stats.Medallions);
        this.honor_ = int(accountXML.Stats.Honor);
    }

    private function parseGuildData(accountXML:XML):void {
        var guildXML:XML = null;
        if (accountXML.hasOwnProperty("Guild")) {
            guildXML = XML(accountXML.Guild);
            this.guildName_ = guildXML.Name;
            this.guildRank_ = int(guildXML.Rank);
        }
    }

    private function parseCharacterData():void {
        var charXML:XML = null;
        this.nextCharId_ = int(this.charsXML_.@nextCharId);
        this.maxNumChars_ = int(this.charsXML_.@maxNumChars);
        for each(charXML in this.charsXML_.Char) {
            this.savedChars_.push(new SavedCharacter(charXML, this.name_));
            this.numChars_++;
        }
        this.savedChars_.sort(SavedCharacter.compare);
    }

    private function parseCharacterStatsData():void {
        var charStatsXML:XML = null;
        var type:int = 0;
        var charStats:CharacterStats = null;
        var statsXML:XML = XML(this.charsXML_.Account.Stats);
        for each(charStatsXML in statsXML.ClassStats) {
            type = int(charStatsXML.@objectType);
            charStats = new CharacterStats(charStatsXML);
            this.numStars_ = this.numStars_ + charStats.numStars();
            this.charStats_[type] = charStats;
        }
    }

    private function parseNewsData():void {
        var newsItemXML:XML = null;
        var newsXML:XML = XML(this.charsXML_.News);
        for each(newsItemXML in newsXML.Item) {
            this.news_.push(new SavedNewsItem(newsItemXML.Icon, newsItemXML.Title, newsItemXML.TagLine, newsItemXML.Link, int(newsItemXML.Date)));
        }
    }

    public function bestLevel(objectType:int):int {
        var charStats:CharacterStats = this.charStats_[objectType];
        return charStats == null ? int(0) : int(charStats.bestLevel());
    }

    public function bestOverallLevel():int {
        var charStats:CharacterStats = null;
        var bestLevel:int = 0;
        for each(charStats in this.charStats_) {
            if (charStats.bestLevel() > bestLevel) {
                bestLevel = charStats.bestLevel();
            }
        }
        return bestLevel;
    }

    public function bestHonor(objectType:int):int {
        var charStats:CharacterStats = this.charStats_[objectType];
        return charStats == null ? int(0) : int(charStats.bestHonor());
    }

    public function bestOverallHonor():int {
        var charStats:CharacterStats = null;
        var bestHonor:int = 0;
        for each(charStats in this.charStats_) {
            if (charStats.bestHonor() > bestHonor) {
                bestHonor = charStats.bestHonor();
            }
        }
        return bestHonor;
    }

    public function availableCharSlots():int {
        return this.maxNumChars_ - this.numChars_;
    }

    public function hasAvailableCharSlot():Boolean {
        return this.numChars_ < this.maxNumChars_;
    }

    override public function clone():Event {
        return new SavedCharactersList(this.charsXML_);
    }

    override public function toString():String {
        return "[" + " numChars: " + this.numChars_ + " maxNumChars: " + this.maxNumChars_ + " ]";
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/charrects/BuyCharacterRect.as">
package com.company.assembleegameclient.screens.charrects {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Graphics;
import flash.display.Shape;
import flash.filters.DropShadowFilter;

import svera.untiered.assets.services.IconFactory;
import svera.untiered.core.model.PlayerModel;

public class BuyCharacterRect extends CharacterRect {
    [Inject]
    public var model:PlayerModel;

    private var classNameText_:SimpleText;
    private var priceText_:SimpleText;
    private var currencyIcon_:Bitmap;

    public function BuyCharacterRect(model:PlayerModel) {
        super(2039583, 4342338);
        var icon:Shape = this.buildIcon();
        icon.x = this.width / 2 - icon.width / 2;
        icon.y = this.height / 2 - icon.height / 2;
        addChild(icon);
        makeContainer();
        this.classNameText_ = new SimpleText(12, 16777215, false, 0, 0);
        this.classNameText_.setBold(true);
        this.classNameText_.text = this.getOrdinalString(model.getMaxCharacters() + 1) + " Slot";
        this.classNameText_.updateMetrics();
        this.classNameText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.classNameText_.x = this.x + this.width / 2 - this.classNameText_.width / 2;
        this.classNameText_.y = this.y + this.height - this.classNameText_.height;
        selectContainer.addChild(this.classNameText_);
        var currencyBD_:BitmapData = IconFactory.makeHonor();
        this.currencyIcon_ = new Bitmap(currencyBD_);
        this.currencyIcon_.scaleX = this.currencyIcon_.scaleX * 0.5;
        this.currencyIcon_.scaleY = this.currencyIcon_.scaleY * 0.5;
        this.currencyIcon_.x = this.x;
        this.currencyIcon_.y = this.y;
        selectContainer.addChild(this.currencyIcon_);
        var hasFunds:Boolean = model.getHonor() >= Parameters.CHARACTER_SLOT_PRICE;
        this.priceText_ = new SimpleText(14, !hasFunds ? 15607334 : 0x5ed44c, false, 0, 0);
        this.priceText_.text = Parameters.CHARACTER_SLOT_PRICE.toString();
        this.priceText_.updateMetrics();
        this.priceText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.priceText_.x = this.width / 2 - this.priceText_.width / 2;
        this.priceText_.y = this.currencyIcon_.y - 2;
        selectContainer.addChild(this.priceText_);
    }

    private function buildIcon():Shape {
        var shape:Shape = new Shape();
        var g:Graphics = shape.graphics;
        g.beginFill(3880246);
        g.lineStyle(1, 4603457);
        g.drawCircle(19, 19, 19);
        g.lineStyle();
        g.endFill();
        g.beginFill(2039583);
        g.drawRect(11, 17, 16, 4);
        g.endFill();
        g.beginFill(2039583);
        g.drawRect(17, 11, 4, 16);
        g.endFill();
        return shape;
    }

    private function getOrdinalString(num:int):String {
        var str:String = num.toString();
        var ones:int = num % 10;
        var tens:int = int(num / 10) % 10;
        if (tens == 1) {
            str = str + "th";
        } else if (ones == 1) {
            str = str + "st";
        } else if (ones == 2) {
            str = str + "nd";
        } else if (ones == 3) {
            str = str + "rd";
        } else {
            str = str + "th";
        }
        return str;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/TitleMenuOption.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.ui.SimpleText;
import com.company.util.MoreColorUtil;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;
import flash.utils.getTimer;

import org.osflash.signals.Signal;

public class TitleMenuOption extends Sprite {
    protected static const OVER_COLOR_TRANSFORM:ColorTransform = new ColorTransform(1, 220 / 255, 133 / 255);

    public const clicked:Signal = new Signal();
    private var colorTransform:ColorTransform;
    private var size:int;
    private var textField:SimpleText;
    private var isPulse:Boolean;
    private var isBold:Boolean;
    public var active:Boolean;
    private var originalWidth:Number;
    private var originalHeight:Number;

    public function TitleMenuOption(text:String, size:int, pulse:Boolean, bold:Boolean = true) {
        super();
        this.size = size;
        this.setText(text);
        this.isPulse = pulse;
        this.isBold = bold;
        this.originalWidth = width;
        this.originalHeight = height;
        activate();
    }

    public function setText(text:String):void {
        name = text;
        if (this.textField) {
            removeChild(this.textField);
        }
        this.textField = new SimpleText(this.size, 16777215, false, 0, 0);
        this.textField.setBold(this.isBold);
        this.textField.text = isBold ? text.toLowerCase() : text;
        this.textField.updateMetrics();
        this.textField.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        addChild(this.textField);
    }

    public function activate():void {
        setColorTransform(null);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        addEventListener(MouseEvent.CLICK, this.onMouseClick);
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        this.active = true;
    }

    public function deactivate():void {
        var ct:ColorTransform = new ColorTransform();
        ct.color = 0x363636;
        this.setColorTransform(ct);
        removeEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        removeEventListener(MouseEvent.MOUSE_OUT, this.onMouseOut);
        removeEventListener(MouseEvent.CLICK, this.onMouseClick);
        removeEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        removeEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        this.active = false;
    }

    private function onAddedToStage(event:Event):void {
        if (this.isPulse) {
            addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
    }

    private function onRemovedFromStage(event:Event):void {
        if (this.isPulse) {
            removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        }
    }

    private function onEnterFrame(event:Event):void {
        var s:Number = 1.05 + 0.05 * Math.sin(getTimer() / 200);
        this.textField.scaleX = s;
        this.textField.scaleY = s;
        this.textField.x = this.originalWidth / 2 - this.textField.width / 2;
        this.textField.y = this.originalHeight / 2 - this.textField.height / 2;
    }

    public function setColorTransform(ct:ColorTransform):void {
        if (ct == this.colorTransform) {
            return;
        }
        this.colorTransform = ct;
        if (this.colorTransform == null) {
            this.textField.transform.colorTransform = MoreColorUtil.identity;
        } else {
            this.textField.transform.colorTransform = this.colorTransform;
        }
    }

    protected function onMouseOver(event:MouseEvent):void {
        this.setColorTransform(OVER_COLOR_TRANSFORM);
    }

    protected function onMouseOut(event:MouseEvent):void {
        this.setColorTransform(null);
    }

    protected function onMouseClick(event:MouseEvent):void {
        SoundEffectLibrary.play("button_click");
        this.clicked.dispatch();
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/guild/GuildPlayerList.as">
package com.company.assembleegameclient.ui.guild {
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.util.GuildUtil;
import com.company.ui.SimpleText;
import com.company.util.MoreObjectUtil;

import flash.display.Bitmap;
import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

import svera.untiered.account.core.Account;
import svera.untiered.appengine.api.AppEngineClient;
import svera.untiered.core.StaticInjectorContext;

public class GuildPlayerList extends Sprite {


    private var num_:int;

    private var offset_:int;

    private var myName_:String;

    private var myRank_:int;

    private var listClient_:AppEngineClient;

    private var loadingText_:SimpleText;

    private var titleText_:SimpleText;

    private var guildHonorText_:SimpleText;

    private var guildHonorIcon_:Bitmap;

    private var lines_:Shape;

    private var mainSprite_:Sprite;

    private var listSprite_:Sprite;

    private var openSlotsText_:SimpleText;

    private var scrollBar_:Scrollbar;

    public function GuildPlayerList(num:int, offset:int, myName:String = "", myRank:int = 0) {
        super();
        this.num_ = num;
        this.offset_ = offset;
        this.myName_ = myName;
        this.myRank_ = myRank;
        this.loadingText_ = new SimpleText(22, 11776947, false, 0, 0);
        this.loadingText_.setBold(true);
        this.loadingText_.text = "Loading...";
        this.loadingText_.useTextDimensions();
        this.loadingText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.loadingText_.x = GameClient.HalfStageWidth - this.loadingText_.width / 2;
        this.loadingText_.y = 600 / 2 - this.loadingText_.height / 2;
        addChild(this.loadingText_);
        var account:Account = StaticInjectorContext.getInjector().getInstance(Account);
        var params:Object = {
            "num": num,
            "offset": offset
        };
        MoreObjectUtil.addToObject(params, account.getCredentials());
        this.listClient_ = StaticInjectorContext.getInjector().getInstance(AppEngineClient);
        this.listClient_.setMaxRetries(2);
        this.listClient_.complete.addOnce(this.onComplete);
        this.listClient_.sendRequest("/guild/listMembers", params);
    }

    private function onComplete(isOK:Boolean, data:*):void {
        if (isOK) {
            this.onGenericData(data);
        } else {
            this.onTextError(data);
        }
    }

    private function onGenericData(data:String):void {
        this.build(XML(data));
    }

    private function onTextError(error:String):void {
        trace("error event: " + error);
    }

    private function build(guildXML:XML):void {
        var g:Graphics;
        var id:int;
        var memberXML:XML = null;
        var openSlots:int;
        var isMe:Boolean = false;
        var rank:int = 0;
        var listLine:MemberListLine = null;
        trace("guildXML: " + guildXML);
        removeChild(this.loadingText_);
        this.titleText_ = new SimpleText(32, 11776947, false, 0, 0);
        this.titleText_.setBold(true);
        this.titleText_.text = guildXML.@name;
        this.titleText_.useTextDimensions();
        this.titleText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.titleText_.y = 24;
        this.titleText_.x = stage.stageWidth / 2 - this.titleText_.width / 2;
        addChild(this.titleText_);
        this.guildHonorText_ = new SimpleText(22, 16777215, false, 0, 0);
        this.guildHonorText_.text = guildXML.CurrentHonor;
        this.guildHonorText_.useTextDimensions();
        this.guildHonorText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.guildHonorText_.x = 768 - this.guildHonorText_.width;
        this.guildHonorText_.y = 32 / 2 - this.guildHonorText_.height / 2;
        addChild(this.guildHonorText_);
        this.guildHonorIcon_ = new Bitmap(GuildUtil.guildHonorIcon(40));
        this.guildHonorIcon_.x = 760;
        this.guildHonorIcon_.y = 32 / 2 - this.guildHonorIcon_.height / 2;
        addChild(this.guildHonorIcon_);
        this.lines_ = new Shape();
        g = this.lines_.graphics;
        g.clear();
        g.lineStyle(2, 5526612);
        g.moveTo(0, 100);
        g.lineTo(stage.stageWidth, 100);
        g.lineStyle();
        addChild(this.lines_);
        this.mainSprite_ = new Sprite();
        this.mainSprite_.x = 10;
        this.mainSprite_.y = 110;
        var shape:Shape = new Shape();
        g = shape.graphics;
        g.beginFill(0);
        g.drawRect(0, 0, MemberListLine.WIDTH, 430);
        g.endFill();
        this.mainSprite_.addChild(shape);
        this.mainSprite_.mask = shape;
        addChild(this.mainSprite_);
        this.listSprite_ = new Sprite();
        id = 0;
        for each(memberXML in guildXML.Member) {
            isMe = this.myName_ == memberXML.Name;
            rank = memberXML.Rank;
            listLine = new MemberListLine(this.offset_ + id + 1, memberXML.Name, memberXML.Rank, memberXML.Honor, isMe, this.myRank_);
            listLine.y = id * MemberListLine.HEIGHT;
            this.listSprite_.addChild(listLine);
            id++;
        }
        openSlots = GuildUtil.MAX_MEMBERS - (this.offset_ + id);
        this.openSlotsText_ = new SimpleText(22, 11776947, false, 0, 0);
        this.openSlotsText_.text = openSlots + " open slots";
        this.openSlotsText_.useTextDimensions();
        this.openSlotsText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.openSlotsText_.x = MemberListLine.WIDTH / 2 - this.openSlotsText_.width / 2;
        this.openSlotsText_.y = id * MemberListLine.HEIGHT;
        this.listSprite_.addChild(this.openSlotsText_);
        this.mainSprite_.addChild(this.listSprite_);
        if (this.listSprite_.height > 400) {
            this.scrollBar_ = new Scrollbar(16, 400);
            this.scrollBar_.x = GameClient.StageWidth - this.scrollBar_.width - 4;
            this.scrollBar_.y = 104;
            this.scrollBar_.setIndicatorSize(400, this.listSprite_.height);
            this.scrollBar_.addEventListener(Event.CHANGE, this.onScrollBarChange);
            addChild(this.scrollBar_);
        }
    }

    private function onScrollBarChange(event:Event):void {
        this.listSprite_.y = -this.scrollBar_.pos() * (this.listSprite_.height - 400);
    }
}
}
</file>

<file path="src/svera/untiered/assets/services/IconFactory.as">
package svera.untiered.assets.services {
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.assembleegameclient.util.redrawers.GlowRedrawer;
import com.company.util.AssetLibrary;
import com.company.util.BitmapUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;

public class IconFactory {


    public function IconFactory() {
        super();
    }

    public static function makeTsavorite():BitmapData {
        var data:BitmapData = TextureRedrawer.resize(AssetLibrary.getImageFromSet("Currency_Icons16x16", 2), null, 32, true, 0, 0);
        return cropAndGlowIcon(data);
    }

    public static function makeMedallions():BitmapData {
        var data:BitmapData = TextureRedrawer.resize(AssetLibrary.getImageFromSet("Currency_Icons16x16", 1), null, 32, true, 0, 0);
        return cropAndGlowIcon(data);
    }

    public static function makeHonor():BitmapData {
        var data:BitmapData = TextureRedrawer.resize(AssetLibrary.getImageFromSet("Currency_Icons16x16", 0), null, 32, true, 0, 0);
        return cropAndGlowIcon(data);
    }

    public static function makeGuildHonor():BitmapData {
        var data:BitmapData = TextureRedrawer.resize(AssetLibrary.getImageFromSet("Currency_Icons16x16", 0), null, 32, true, 0, 0);
        return cropAndGlowIcon(data);
    }

    private static function cropAndGlowIcon(data:BitmapData):BitmapData {
        data = GlowRedrawer.outlineGlow(data, 4294967295);
        data = BitmapUtil.cropToBitmapData(data, 10, 10, data.width - 20, data.height - 20);
        return data;
    }

    public function makeIconBitmap(id:int):Bitmap {
        var iconBD:BitmapData = AssetLibrary.getImageFromSet("lofiInterfaceBig", id);
        iconBD = TextureRedrawer.redraw(iconBD, 320 / iconBD.width, true, 0);
        return new Bitmap(iconBD);
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/ClassDetailMediator.as">
package svera.untiered.classes.view {
import com.company.assembleegameclient.util.HonorUtil;

import flash.events.TimerEvent;
import flash.utils.Timer;

import svera.lib.framework.Mediator;

import svera.untiered.assets.model.Animation;
import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.classes.control.FocusCharacterSkinSignal;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.core.model.PlayerModel;

public class ClassDetailMediator extends Mediator {


    [Inject]
    public var view:ClassDetailView;

    [Inject]
    public var classesModel:ClassesModel;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var focusSet:FocusCharacterSkinSignal;

    [Inject]
    public var factory:CharacterFactory;

    private const skins:Object = new Object();

    private var character:CharacterClass;

    private var nextSkin:CharacterSkin;

    private const nextSkinTimer:Timer = new Timer(250, 1);

    public function ClassDetailMediator() {
        super();
    }

    override public function initialize():void {
        this.character = this.classesModel.getSelected();
        this.nextSkinTimer.addEventListener(TimerEvent.TIMER, this.delayedFocusSet);
        this.focusSet.add(this.onFocusSet);
        this.setCharacterData();
        this.onFocusSet();
    }

    override public function destroy():void {
        this.focusSet.remove(this.onFocusSet);
        this.nextSkinTimer.removeEventListener(TimerEvent.TIMER, this.delayedFocusSet);
        this.view.setWalkingAnimation(null);
        this.disposeAnimations();
    }

    private function setCharacterData():void {
        var honor:int = this.playerModel.charList.bestHonor(this.character.id);
        var stars:int = HonorUtil.numStars(honor);
        this.view.setData(this.character.name, this.character.description, stars, this.playerModel.charList.bestLevel(this.character.id), honor);
        var nextStarHonor:int = HonorUtil.nextStarHonor(honor, 0);
        this.view.setNextGoal(this.character.name, nextStarHonor);
        CharacterSkinView.positionStuff.dispatch();
    }

    private function onFocusSet(skin:CharacterSkin = null):void {
        this.nextSkin = skin || this.character.skins.getSelectedSkin();
        this.nextSkinTimer.start();
    }

    private function delayedFocusSet(e:TimerEvent):void {
        var animation:Animation = this.skins[this.nextSkin.id] = this.skins[this.nextSkin.id] || this.factory.makeWalkingIcon(this.nextSkin.template, 200);
        this.view.setWalkingAnimation(animation);
    }

    private function disposeAnimations():void {
        var id:* = null;
        var animation:Animation = null;
        for (id in this.skins) {
            animation = this.skins[id];
            animation.dispose();
            delete this.skins[id];
        }
    }
}
}
</file>

<file path="src/svera/untiered/constants/ItemConstants.as">
package svera.untiered.constants {
public class ItemConstants {
    public static const NO_ITEM:int = 0;
    public static const ALL_TYPE:int = 0;
    public static const SWORD_AXE_TYPE:int = 1;
    public static const DAGGER_TYPE:int = 2;
    public static const BOW_CROSSBOW_TYPE:int = 3;
    public static const MACE_LANCE_TYPE:int = 4;
    public static const SHIELD_OLD_TYPE:int = 5;
    public static const LEATHER_TYPE:int = 6;
    public static const PLATE_TYPE:int = 7;
    public static const STAFF_WAND_TYPE:int = 8;
    public static const RING_TYPE:int = 9;
    public static const POTION_TYPE:int = 10;
    public static const SPELL_TYPE:int = 11;
    public static const SEAL_TYPE:int = 12;
    public static const CLOAK_TYPE:int = 13;
    public static const ROBE_TYPE:int = 14;
    public static const GUN_TYPE:int = 15;
    public static const HELM_TYPE:int = 16;
    public static const CLAWS_GAUNTLET_TYPE:int = 17;
    public static const POISON_TYPE:int = 18;
    public static const SKULL_TYPE:int = 19;
    public static const TRAP_OLD_TYPE:int = 20;
    public static const DUAL_WIELD_TYPE:int = 21;
    public static const PRISM_TYPE:int = 22;
    public static const SCEPTER_TYPE:int = 23;
    public static const KATANA_SCYTHE_TYPE:int = 24;
    public static const CHAKRAM_TYPE:int = 25;
    public static const MASK_TYPE:int = 26
    public static const BALLOON_FRIEND_TYPE:int = 27
    public static const COUNTER_TYPE:int = 28
    public static const SACRIFICIAL_SPIRIT_TYPE:int = 29
    public static const PLANT_SHACKLE_TYPE:int = 30
    public static const FOCUS_MANA_TYPE:int = 31
    public static const LEECHING_VIGOR_TYPE:int = 32
    public static const CURSE_TYPE:int = 33
    public static const Z_DASH_TYPE:int = 34
    public static const MORALE_RAISE_TYPE:int = 35
    public static const SWEEP_TYPE:int = 36
    public static const LAST_STAND_TYPE:int = 37
    public static const REWARDING_BLOW_TYPE:int = 38
    public static const BOUNCE_TYPE:int = 39
    public static const DISTRACT_TYPE:int = 40
    public static const EMPOWER_ARROW_TYPE:int = 41
    public static const ARROW_SPLIT_TYPE:int = 42
    public static const TORCH_TYPE:int = 43
    public static const SPEED_TRIGGER_TYPE:int = 44
    public static const TROPHIE_RECOGNITION_TYPE:int = 45
    public static const TRAP_TYPE:int = 46
    public static const FEAR_MONGER_TYPE:int = 47
    public static const SERRATION_TYPE:int = 48
    public static const RALLY_TYPE:int = 49
    public static const ENHANCE_RANGE_TYPE:int = 50
    public static const ATTENTION_SEEK_TYPE:int = 51
    public static const SHIELD_TYPE:int = 52
    public static const INFLATE_POWER_TYPE:int = 53
    public static const AIRSTRIKE_TYPE:int = 54
    public static const EARTH_SHATTER_TYPE:int = 55


    public function ItemConstants() {
        super();
    }

    public static function itemTypeToName(itemType:int):String {
        switch (itemType) {
            case ALL_TYPE:
                return "Any";
            case SWORD_AXE_TYPE:
                return "Sword, Axe";
            case DAGGER_TYPE:
                return "Dagger";
            case BOW_CROSSBOW_TYPE:
                return "Bow, crossbow";
            case MACE_LANCE_TYPE:
                return "Mace, lance";
            case SHIELD_OLD_TYPE:
                return "Shield";
            case LEATHER_TYPE:
                return "Leather Armor";
            case PLATE_TYPE:
                return "Armor";
            case STAFF_WAND_TYPE:
                return "Staff, Wand";
            case RING_TYPE:
                return "Accessory";
            case POTION_TYPE:
                return "Potion";
            case SPELL_TYPE:
                return "Spell";
            case SEAL_TYPE:
                return "Holy Seal";
            case CLOAK_TYPE:
                return "Cloak";
            case ROBE_TYPE:
                return "Robe";
            case GUN_TYPE:
                return "Gun";
            case HELM_TYPE:
                return "Helm";
            case CLAWS_GAUNTLET_TYPE:
                return "Claws, Gauntlet";
            case POISON_TYPE:
                return "Poison";
            case SKULL_TYPE:
                return "Skull";
            case TRAP_OLD_TYPE:
                return "Trap";
            case DUAL_WIELD_TYPE:
                return "Orb";
            case PRISM_TYPE:
                return "Prism";
            case SCEPTER_TYPE:
                return "Scepter";
            case KATANA_SCYTHE_TYPE:
                return "Katana, Scythe";
            case CHAKRAM_TYPE:
                return "Chakram";
            case MASK_TYPE:
                return "Mask";
            case BALLOON_FRIEND_TYPE:
                return "Balloon-Friend";
            case COUNTER_TYPE:
                return "Counter";
            case SACRIFICIAL_SPIRIT_TYPE:
                return "Sacrificial-Spirit";
            case PLANT_SHACKLE_TYPE:
                return "Plant-Shackle";
            case FOCUS_MANA_TYPE:
                return "Focus-Mana";
            case LEECHING_VIGOR_TYPE:
                return "Leeching-Vigor";
            case CURSE_TYPE:
                return "Curse";
            case Z_DASH_TYPE:
                return "Z-Dash";
            case MORALE_RAISE_TYPE:
                return "Morale-Raise";
            case SWEEP_TYPE:
                return "Sweep";
            case LAST_STAND_TYPE:
                return "Last-Stand";
            case REWARDING_BLOW_TYPE:
                return "Rewarding-Blow";
            case BOUNCE_TYPE:
                return "Bounce";
            case DISTRACT_TYPE:
                return "Distract";
            case EMPOWER_ARROW_TYPE:
                return "Empower-Arrow";
            case ARROW_SPLIT_TYPE:
                return "Arrow-Split";
            case TORCH_TYPE:
                return "Torch";
            case SPEED_TRIGGER_TYPE:
                return "Speed-Trigger";
            case TROPHIE_RECOGNITION_TYPE:
                return "Trophie-Recognition";
            case TRAP_TYPE:
                return "Trap";
            case FEAR_MONGER_TYPE:
                return "Fear-Monger";
            case SERRATION_TYPE:
                return "Serration";
            case RALLY_TYPE:
                return "Rally";
            case ENHANCE_RANGE_TYPE:
                return "Enhance-Range";
            case ATTENTION_SEEK_TYPE:
                return "Attention-Seek";
            case SHIELD_TYPE:
                return "Shield";
            case INFLATE_POWER_TYPE:
                return "Inflate-Power";
            case AIRSTRIKE_TYPE:
                return "Airstrike";
            case EARTH_SHATTER_TYPE:
                return "Earth-Shatter";
            default:
                return "Invalid Type!";
        }
    }
}
}
</file>

<file path="src/svera/untiered/game/view/LootboxModalButton.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.lootBoxes.LootboxModal;
import svera.untiered.ui.UIUtils;

public class LootboxModalButton extends Sprite {

    public static const IMAGE_NAME:String = "Currency_Icons16x16";
    public static const IMAGE_ID:int = 5;

    private var bitmap:Bitmap;
    private var background:Sprite;
    private var lootBoxTexture:BitmapData;
    private var tooltip:TextToolTip;
    public var gs_:GameSprite;

    public function LootboxModalButton() {
        this.tooltip = new TextToolTip(0x363636, 0x000000, null, "Unbox the latest Lootboxes you've earned.", 200);
        super();
        mouseChildren = false;
        this.lootBoxTexture = TextureRedrawer.redraw(AssetLibrary.getImageFromSet(IMAGE_NAME, IMAGE_ID), 28, true, 0);
        this.background = UIUtils.makeHUDBackground(28, 27);
        this.bitmap = new Bitmap(this.lootBoxTexture);
        this.bitmap.x = -9;
        this.bitmap.y = -9;
        this.drawAsOpen();
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function drawAsOpen():void {
        addChild(this.background);
        addChild(this.bitmap);
    }

    public function onClick(_arg_1:MouseEvent):void {
       var _local_2:OpenDialogSignal = StaticInjectorContext.getInjector().getInstance(OpenDialogSignal);
       _local_2.dispatch(new LootboxModal());
       SoundEffectLibrary.play("button_click");
    }

    public function drawAsClosed():void {
        if (this.background && this.background.parent == this) {
            removeChild(this.background);
        }
        if (this.bitmap && this.bitmap.parent == this) {
            removeChild(this.bitmap);
        }
    }


}
}//package svera.untiered.game.view
</file>

<file path="src/svera/untiered/game/view/RaidLauncherButton.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.raidLauncher.RaidLauncherModal;
import svera.untiered.ui.UIUtils;

public class RaidLauncherButton extends Sprite {

    public static const IMAGE_NAME:String = "Currency_Icons16x16";
    public static const IMAGE_ID:int = 4;

    private var bitmap:Bitmap;
    private var background:Sprite;
    private var markShopTexture:BitmapData;
    private var tooltip:TextToolTip;
    public var gs_:GameSprite;

    public function RaidLauncherButton() {
        this.tooltip = new TextToolTip(0x363636, 0x660000, null, "Click to open raid launcher.", 200);
        super();
        mouseChildren = false;
        this.markShopTexture = TextureRedrawer.redraw(AssetLibrary.getImageFromSet(IMAGE_NAME, IMAGE_ID), 28, true, 0);
        this.background = UIUtils.makeHUDBackground(28, 27);
        this.bitmap = new Bitmap(this.markShopTexture);
        this.bitmap.x = -9;
        this.bitmap.y = -9;
        this.drawAsOpen();
        addEventListener(MouseEvent.CLICK, this.onClick);
    }

    public function drawAsOpen():void {
        addChild(this.background);
        addChild(this.bitmap);
    }

    public function onClick(_arg_1:MouseEvent):void {
        var _local_2:OpenDialogSignal = StaticInjectorContext.getInjector().getInstance(OpenDialogSignal);
        _local_2.dispatch(new RaidLauncherModal());
        SoundEffectLibrary.play("button_click");
    }

    public function drawAsClosed():void {
        if (this.background && this.background.parent == this) {
            removeChild(this.background);
        }
        if (this.bitmap && this.bitmap.parent == this) {
            removeChild(this.bitmap);
        }
    }


}
}//package svera.untiered.game.view
</file>

<file path="src/svera/untiered/legends/view/LegendsView.as">
package svera.untiered.legends.view {
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.ui.SimpleText;

import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;

import svera.untiered.legends.model.Legend;
import svera.untiered.legends.model.Timespan;
import svera.untiered.ui.view.components.ScreenBase;

public class LegendsView extends Sprite {
    public const timespanChanged:Signal = new Signal(Timespan);

    public const showDetail:Signal = new Signal(Legend);

    public const close:Signal = new Signal();

    private const items:Vector.<LegendListItem> = new Vector.<LegendListItem>(0);

    private const tabs:Object = {};

    private var title:SimpleText;

    private var loadingBanner:SimpleText;

    private var mainContainer:Sprite;

    private var closeButton:TitleMenuOption;

    private var scrollBar:Scrollbar;

    private var listContainer:Sprite;

    private var selectedTab:LegendsTab;

    private var legends:Vector.<Legend>;

    private var count:int;

    public function LegendsView() {
        super();
        this.makeScreenBase();
        this.makeTitleText();
        this.makeLoadingBanner();
        this.makeMainContainer();
        this.makeLines();
        this.makeScrollbar();
        this.makeTimespanTabs();
        this.makeCloseButton();
    }

    private function makeScreenBase():void {
        addChild(new ScreenBase());
    }

    private function makeTitleText():void {
        this.title = new SimpleText(32, 11776947, false, 0, 0);
        this.title.setBold(true);
        this.title.text = "Legends";
        this.title.updateMetrics();
        this.title.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.title.x = GameClient.HalfStageWidth - this.title.width / 2;
        this.title.y = 24;
        addChild(this.title);
    }

    private function makeLoadingBanner():void {
        this.loadingBanner = new SimpleText(22, 11776947, false, 0, 0);
        this.loadingBanner.setBold(true);
        this.loadingBanner.text = "Loading...";
        this.loadingBanner.useTextDimensions();
        this.loadingBanner.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.loadingBanner.x = GameClient.HalfStageWidth - this.loadingBanner.width / 2;
        this.loadingBanner.y = GameClient.HalfStageHeight - this.loadingBanner.height / 2;
        this.loadingBanner.visible = false;
        addChild(this.loadingBanner);
    }

    private function makeMainContainer():void {
        var shape:Shape = new Shape();
        var g:Graphics = shape.graphics;
        g.beginFill(0);
        g.drawRect(0, 0, LegendListItem.WIDTH, 430);
        g.endFill();
        this.mainContainer = new Sprite();
        this.mainContainer.x = 10;
        this.mainContainer.y = 110;
        this.mainContainer.addChild(shape);
        this.mainContainer.mask = shape;
        addChild(this.mainContainer);
    }


    private function makeLines():void {
        var lines:Shape = new Shape();
        addChild(lines);
        var g:Graphics = lines.graphics;
        g.lineStyle(2, 5526612);
        g.moveTo(0, 100);
        g.lineTo(GameClient.StageWidth, 100);
    }

    private function makeScrollbar():void {
        this.scrollBar = new Scrollbar(16, GameClient.StageHeight - 200);
        this.scrollBar.x = GameClient.StageWidth - this.scrollBar.width - 4;
        this.scrollBar.y = 104;
        addChild(this.scrollBar);
    }

    private function makeTimespanTabs():void {
        var timespans:Vector.<Timespan> = Timespan.TIMESPANS;
        var count:int = timespans.length;
        for (var i:int = 0; i < count; i++) {
            this.makeTab(timespans[i], i);
        }
    }

    private function makeTab(timespan:Timespan, i:int):LegendsTab {
        var tab:LegendsTab;
        tab = new LegendsTab(timespan);
        this.tabs[timespan.getId()] = tab;
        tab.x = 20 + i * 90;
        tab.y = 70;
        tab.selected.add(this.onTabSelected);
        addChild(tab);
        return tab;
    }

    private function onTabSelected(tab:LegendsTab):void {
        if (this.selectedTab != tab) {
            this.updateTabAndSelectTimespan(tab);
        }
    }

    private function updateTabAndSelectTimespan(tab:LegendsTab):void {
        this.updateTabs(tab);
        this.timespanChanged.dispatch(this.selectedTab.getTimespan());
    }

    private function updateTabs(selected:LegendsTab):void {
        this.selectedTab && this.selectedTab.setIsSelected(false);
        this.selectedTab = selected;
        this.selectedTab.setIsSelected(true);
    }

    private function makeCloseButton():void {
        this.closeButton = new TitleMenuOption("done", 36, false);
        this.closeButton.x = GameClient.HalfStageWidth - this.closeButton.width / 2;
        this.closeButton.y = GameClient.StageHeight - (600 - 524);
        addChild(this.closeButton);
        this.closeButton.addEventListener(MouseEvent.CLICK, this.onCloseClick);
    }

    private function onCloseClick(event:MouseEvent):void {
        this.close.dispatch();
    }

    public function clear():void {
        this.listContainer && this.clearLegendsList();
        this.listContainer = null;
        this.scrollBar.visible = false;
    }

    private function clearLegendsList():void {
        var item:LegendListItem = null;
        for each(item in this.items) {
            item.selected.remove(this.onItemSelected);
        }
        this.items.length = 0;
        this.mainContainer.removeChild(this.listContainer);
        this.listContainer = null;
    }

    public function setLegendsList(timespan:Timespan, legends:Vector.<Legend>):void {
        this.clear();
        this.updateTabs(this.tabs[timespan.getId()]);
        this.listContainer = new Sprite();
        this.legends = legends;
        this.count = legends.length;
        this.items.length = this.count;
        this.makeItemsFromLegends();
        this.mainContainer.addChild(this.listContainer);
        this.updateScrollbar();
    }

    private function makeItemsFromLegends():void {
        for (var i:int = 0; i < this.count; i++) {
            this.items[i] = this.makeItemFromLegend(i);
        }
    }

    private function makeItemFromLegend(index:int):LegendListItem {
        var legend:Legend = this.legends[index];
        legend.place = index + 1;
        var item:LegendListItem = new LegendListItem(legend);
        item.y = index * LegendListItem.HEIGHT;
        item.selected.add(this.onItemSelected);
        this.listContainer.addChild(item);
        return item;
    }

    private function updateScrollbar():void {
        if (this.listContainer.height > GameClient.StageHeight - 200) {
            this.scrollBar.visible = true;
            this.scrollBar.setIndicatorSize(GameClient.StageHeight - 200, this.listContainer.height);
            this.scrollBar.addEventListener(Event.CHANGE, this.onScrollBarChange);
            this.positionScrollbarToDisplayFocussedLegend();
        } else {
            this.scrollBar.removeEventListener(Event.CHANGE, this.onScrollBarChange);
            this.scrollBar.visible = false;
        }
    }

    private function positionScrollbarToDisplayFocussedLegend():void {
        var index:int = 0;
        var position:int = 0;
        var legend:Legend = this.getLegendFocus();
        if (legend) {
            index = this.legends.indexOf(legend);
            position = (index + 0.5) * LegendListItem.HEIGHT;
            this.scrollBar.setPos((position - 200) / (this.listContainer.height - GameClient.StageHeight - 200));
        }
    }

    private function getLegendFocus():Legend {
        var focus:Legend = null;
        var legend:Legend = null;
        for each(legend in this.legends) {
            if (legend.isFocus) {
                focus = legend;
                break;
            }
        }
        return focus;
    }

    private function onItemSelected(legend:Legend):void {
        this.showDetail.dispatch(legend);
    }

    private function onScrollBarChange(event:Event):void {
        this.listContainer.y = -this.scrollBar.pos() * (this.listContainer.height - GameClient.StageHeight - 200);
    }

    public function showLoading():void {
        this.loadingBanner.visible = true;
    }

    public function hideLoading():void {
        this.loadingBanner.visible = false;
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/content/MemMarketInventoryItem.as">
package svera.untiered.memMarket.content {
import com.company.assembleegameclient.game.GameSprite;

import flash.events.MouseEvent;

import svera.untiered.itemdata.NewItemData;

import svera.untiered.memMarket.utils.ItemUtils;
import svera.untiered.memMarket.utils.TintUtils;

public class MemMarketInventoryItem extends MemMarketItem
{
    public var slot_:int;
    public var selected_:Boolean;

    public function MemMarketInventoryItem(gameSprite:GameSprite, item:NewItemData, slot:int)
    {
        super(gameSprite, SLOT_WIDTH, SLOT_HEIGHT, 80, item.ObjectType, null, item);

        this.slot_ = slot;

        if (this.itemType_ != 0)
        {
            if (ItemUtils.isBanned(this.itemType_)) /* Apply red tint on banned items */
            {
                TintUtils.addTint(this.shape_, 0x5C1D1D, 0.4);
            }
            else
            {
                addEventListener(MouseEvent.CLICK, this.onClick);
            }
        }
    }

    private function onClick(event:MouseEvent) : void
    {
        this.selected_ = !this.selected_;
        if (this.selected_)
        {
            TintUtils.addTint(this.shape_, 0xFFB63F, 0.4);
        }
        else
        {
            TintUtils.removeTint(this.shape_);
        }
    }

    public function reset() : void
    {
        this.itemType_ = -1;
        this.selected_ = false;
        TintUtils.removeTint(this.shape_);
        removeEventListener(MouseEvent.CLICK, this.onClick);
        removeChild(this.icon_);
        this.icon_ = null;
        if (this.toolTip_ != null)
        {
            this.toolTip_.parent.removeChild(this.toolTip_);
            this.toolTip_ = null;
        }
        this.removeListeners();
    }

    /* Clear */
    public override function dispose() : void
    {
        removeEventListener(MouseEvent.CLICK, this.onClick);
        super.dispose();
    }
}
}
</file>

<file path="src/svera/untiered/memMarket/content/MemMarketItem.as">
package svera.untiered.memMarket.content {
import com.company.assembleegameclient.constants.InventoryOwnerTypes;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.ui.tooltip.EquipmentToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.MouseEvent;

import svera.untiered.itemdata.NewItemData;

import svera.untiered.messaging.impl.data.MarketData;

public class MemMarketItem extends Sprite {
    /* Offers */
    public static const OFFER_WIDTH:int = 100;
    public static const OFFER_HEIGHT:int = 83;

    /* Inventory slots */
    public static const SLOT_WIDTH:int = 50;
    public static const SLOT_HEIGHT:int = 50;

    public var gameSprite_:GameSprite;
    public var itemType_:int;
    public var id_:int;
    public var data_:MarketData;
    public var shape_:Shape;
    public var icon_:Bitmap;
    private var tagContainer_:Sprite;
    private var count_:int;
    private var itemLabel_:SimpleText;
    public var toolTip_:ToolTip;
    public var itemData:NewItemData;

    /* Provides the base features for a Market item */
    public function MemMarketItem(gameSprite:GameSprite, width:int, height:int, iconSize:int, itemType:int, data:MarketData, item:NewItemData = null) {
        this.gameSprite_ = gameSprite;
        this.itemType_ = itemType;
        this.id_ = data == null ? -1 : data.id_;
        this.data_ = data;
        if (item == null)
            this.itemData = data == null ? NewItemData.TempCreate(itemType) : NewItemData.FromByteArray(data.itemData_);
        else
            this.itemData = item;

        /* Draw background */
        this.shape_ = new Shape();
        drawRoundRectAsFill(this.shape_.graphics, 0, 0, width, height, 5);
        addChild(this.shape_);

        if (this.itemType_ != -1) {
            this.icon_ = new Bitmap(ObjectLibrary.getRedrawnTextureFromType(this.itemType_, iconSize, true));
            this.icon_.x = -3; /* If we do negative 3 it centers the item */
            this.icon_.y = -3;
            addChild(this.icon_);

            addEventListener(MouseEvent.MOUSE_OVER, this.onOver);
            addEventListener(MouseEvent.MOUSE_OUT, this.onOut);
        }
    }

    protected function removeListeners():void {
        removeEventListener(MouseEvent.MOUSE_OVER, this.onOver);
        removeEventListener(MouseEvent.MOUSE_OUT, this.onOut);
    }

    /* Mouse over */
    private function onOver(event:MouseEvent):void {
        this.toolTip_ = new EquipmentToolTip(this.itemData, this.gameSprite_.map.player_, -1, InventoryOwnerTypes.NPC);
        this.gameSprite_.addChild(this.toolTip_); /* Add it to the overlay, adding it to the Shape makes it have a wrong position */
        this.icon_.alpha = 0.7;
    }

    /* Mouse out */
    private function onOut(event:MouseEvent):void {
        this.toolTip_.parent.removeChild(this.toolTip_);
        this.toolTip_ = null;
        this.icon_.alpha = 1.0;
    }

    /* Clear */
    public function dispose():void {
        this.gameSprite_ = null;
        this.shape_ = null;
        this.icon_ = null;

        if (this.toolTip_ != null) {
            this.toolTip_.parent.removeChild(this.toolTip_);
            this.toolTip_ = null;
        }

        this.removeListeners();

        /* Remove all children */
        for (var i:int = numChildren - 1; i >= 0; i--) {
            removeChildAt(i);
        }
    }

    /* Taken from https://stackoverflow.com/a/25118121 */

    /* Used to draw rectangles with rounded edges */
    public static function drawRoundRectAsFill(graphics:Graphics, x:Number, y:Number, w:Number, h:Number, radius:Number, lineColor:uint = 0x676767, fillColor:uint = 0x454545, lineThickness:Number = 1, lineAlpha:Number = 1, fillAlpha:Number = 1):void {
        graphics.lineStyle(0, 0, 0);
        graphics.beginFill(lineColor, lineAlpha);
        graphics.drawRoundRect(x, y, w, h, 2 * radius, 2 * radius);
        graphics.drawRoundRect(x + lineThickness, y + lineThickness, w - 2 * lineThickness, h - 2 * lineThickness, 2 * radius - 2 * lineThickness, 2 * radius - 2 * lineThickness);
        graphics.endFill();
        graphics.beginFill(fillColor, fillAlpha);
        graphics.drawRoundRect(x + lineThickness, y + lineThickness, w - 2 * lineThickness, h - 2 * lineThickness, 2 * radius - 2 * lineThickness, 2 * radius - 2 * lineThickness);
        graphics.endFill();
    }

    public function UpdateCounter():void {
        if (!this.tagContainer_) {
            this.tagContainer_ = new Sprite();
            addChild(this.tagContainer_);
        }

        if (!this.itemLabel_) {
            this.itemLabel_ = new SimpleText(12, 0xFFFFFF, false);
            this.tagContainer_.addChild(this.itemLabel_);
        }

        this.count_++;

        this.itemLabel_.text = this.count_.toString();
        this.itemLabel_.filters = [];
        this.itemLabel_.x = 50 - this.itemLabel_.width;
        this.itemLabel_.y = 50 / 2 + 5;
    }

    public function CreateLabel():void {
        this.count_ = 0;

        if (!this.tagContainer_) {
            this.tagContainer_ = new Sprite();
            addChild(this.tagContainer_);
        }

        if (!this.itemLabel_) {
            this.itemLabel_ = new SimpleText(12, 16777215, false);
            this.tagContainer_.addChild(this.itemLabel_);
        }

        this.itemLabel_.text = "0";
        this.itemLabel_.x = 50 - this.itemLabel_.width;
        this.itemLabel_.y = 50 / 2 + 5;

    }
}
}
</file>

<file path="src/svera/untiered/memMarket/tabs/MemMarketBuyTab.as">
package svera.untiered.memMarket.tabs {
import com.company.assembleegameclient.account.ui.MarketInput;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.ui.dropdown.DropDown;
import com.company.util.KeyCodes;

import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;

import mx.utils.StringUtil;

import svera.untiered.memMarket.content.MemMarketBuyItem;
import svera.untiered.memMarket.content.MemMarketItem;
import svera.untiered.memMarket.signals.MemMarketBuySignal;
import svera.untiered.memMarket.signals.MemMarketSearchSignal;
import svera.untiered.memMarket.utils.DialogUtils;
import svera.untiered.memMarket.utils.ItemUtils;
import svera.untiered.memMarket.utils.SortUtils;
import svera.untiered.messaging.impl.data.MarketData;
import svera.untiered.messaging.impl.incoming.market.MarketBuyResult;
import svera.untiered.messaging.impl.incoming.market.MarketSearchResult;

///TODO fix these
///Listing counter gets reset when search items get removed

public class MemMarketBuyTab extends MemMarketTab {
    private static const SEARCH_X_OFFSET:int = 4;
    private static const SEARCH_Y_OFFSET:int = 170;
    private static const SEARCH_ITEM_SIZE:int = 50;

    private static const RESULT_X_OFFSET:int = 270;
    private static const RESULT_Y_OFFSET:int = 105;

    /* Signals */
    public const buySignal_:MemMarketBuySignal = new MemMarketBuySignal();
    public const searchSignal_:MemMarketSearchSignal = new MemMarketSearchSignal();

    private var searchField_:MarketInput;
    private var shape_:Shape;
    private var searchMask_:Sprite;
    private var searchBackground:Sprite;
    private var searchItems:Vector.<MemMarketItem>;
    private var searchScroll:Scrollbar;

    private var resultMask_:Sprite;
    private var resultBackground_:Sprite;
    private var resultItems_:Vector.<MemMarketBuyItem>;
    private var resultScroll_:Scrollbar;

    private var sortChoices_:DropDown;
    private var tierSortChoices_:DropDown;
    private var statSortChoices_:DropDown;
    private var itemTypeSortChoices_:DropDown;

    private var first_:Boolean = true;

    public function MemMarketBuyTab(gameSprite:GameSprite) {
        super(gameSprite);

        /* Initialize signals */
        this.buySignal_.add(this.onBuy);
        this.searchSignal_.add(this.onSearch);

        this.searchField_ = new MarketInput("Search", false, "");
        this.searchField_.x = SEARCH_X_OFFSET + 9;
        this.searchField_.y = 101;
        this.searchField_.addEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
        addChild(this.searchField_);

        this.shape_ = new Shape();
        this.shape_.graphics.beginFill(0);
        this.shape_.graphics.drawRect(SEARCH_X_OFFSET, SEARCH_Y_OFFSET, 250, 350);
        this.shape_.graphics.endFill();
        this.searchMask_ = new Sprite();
        this.searchMask_.addChild(this.shape_);
        this.searchMask_.mask = this.shape_;
        addChild(this.searchMask_);
        this.searchBackground = new Sprite();
        this.searchMask_.addChild(this.searchBackground);

        this.searchItems = new Vector.<MemMarketItem>();

        this.shape_ = new Shape();
        this.shape_.graphics.beginFill(0);
        this.shape_.graphics.drawRect(RESULT_X_OFFSET, RESULT_Y_OFFSET, 500, 415);
        this.shape_.graphics.endFill();
        this.resultMask_ = new Sprite();
        this.resultMask_.addChild(this.shape_);
        this.resultMask_.mask = this.shape_;
        addChild(this.resultMask_);
        this.resultBackground_ = new Sprite();
        this.resultMask_.addChild(this.resultBackground_);

        this.resultItems_ = new Vector.<MemMarketBuyItem>();

        this.sortChoices_ = new DropDown(SortUtils.SORT_CHOICES, 200, 26);
        this.sortChoices_.x = 597;
        this.sortChoices_.y = 71;
        this.sortChoices_.setValue(SortUtils.LOWEST_TO_HIGHEST);
        this.sortChoices_.addEventListener(Event.CHANGE, this.onSortChoicesChanged);
        addChild(this.sortChoices_);

        this.tierSortChoices_ = new DropDown(SortUtils.TIER_SORT_CHOICES, 100, 26);
        this.tierSortChoices_.x = 500;
        this.tierSortChoices_.y = 71;
        this.tierSortChoices_.setValue(SortUtils.ALLTIERS);
        this.tierSortChoices_.addEventListener(Event.CHANGE, this.onTierChoice);
        addChild(this.tierSortChoices_);

        this.statSortChoices_ = new DropDown(SortUtils.STAT_SORT_CHOICES, 100, 26);
        this.statSortChoices_.x = 403;
        this.statSortChoices_.y = 71;
        this.statSortChoices_.setValue(SortUtils.ALLSTATS);
        this.statSortChoices_.addEventListener(Event.CHANGE, this.onStatChoice);
        addChild(this.statSortChoices_);

        this.itemTypeSortChoices_ = new DropDown(SortUtils.ITEMTYPE_SORT_CHOICES, 100, 26);
        this.itemTypeSortChoices_.x = 306;
        this.itemTypeSortChoices_.y = 71;
        this.itemTypeSortChoices_.setValue(SortUtils.ALLITEMTYPES);
        this.itemTypeSortChoices_.addEventListener(Event.CHANGE, this.onItemTypeChoice);
        addChild(this.itemTypeSortChoices_);

        this.searchItemsFunc(true);

        this.gameSprite_.gsc_.marketAll();
    }

    private function onSortChoicesChanged(event:Event):void {
        this.sortOffers();
    }

    private function onKeyUp(event:KeyboardEvent):void {
        if (event.keyCode == KeyCodes.ENTER) {
            this.searchItemsFunc();
        }
    }


    private function onSearchClick(event:MouseEvent):void {
        var item:MemMarketItem = event.currentTarget as MemMarketItem;
        this.gameSprite_.gsc_.marketSearch(item.itemType_);
    }

    private function onSearchScrollChanged(event:Event):void {
        this.searchBackground.y = -this.searchScroll.pos() * (this.searchBackground.height - 356);
    }

    /* Clear previous results */
    private function clearPreviousResults(result:Boolean):void {
        if (result) {
            for each (var i:MemMarketBuyItem in this.resultItems_) {
                i.dispose();
                this.resultBackground_.removeChild(i);
                i = null;
            }
            this.resultItems_.length = 0;
        } else {
            for each (var o:MemMarketItem in this.searchItems) {
                o.removeEventListener(MouseEvent.CLICK, this.onSearchClick);
                o.dispose();
                this.searchBackground.removeChild(o);
                o = null;
            }
            this.searchItems.length = 0;
        }
    }

    /* Removes an offer from resultItems and sorts */
    private function removeOffer(id:int):void {
        var index:int = 0;
        for each (var o:MemMarketBuyItem in this.resultItems_) {
            if (o.id_ == id) /* Item matched, remove */
            {
                this.resultItems_.splice(index, 1);
                o.dispose();
                o.parent.removeChild(o);
                o = null;
                break; /* No need to continue the loop after we got what we looked for */
            }
            index++;
        }

        this.sortOffers();
    }

    /* Sorts and positions offers */
    private function sortOffers():void {
        switch (SortUtils.SORT_CHOICES[this.sortChoices_.getIndex()]) {
            case SortUtils.LOWEST_TO_HIGHEST:
                this.resultItems_.sort(SortUtils.lowestToHighest);
                break;
            case SortUtils.HIGHEST_TO_LOWEST:
                this.resultItems_.sort(SortUtils.highestToLowest);
                break;
                /*case SortUtils.FAME_TO_GOLD:
                    this.resultItems_.sort(SortUtils.honorToGold);
                    break;
                case SortUtils.GOLD_TO_FAME:
                    this.resultItems_.sort(SortUtils.goldToHonor);
                    break; */
            case SortUtils.JUST_ADDED:
                this.resultItems_.sort(SortUtils.justAdded);
                break;
            case SortUtils.ENDING_SOON:
                this.resultItems_.sort(SortUtils.endingSoon);
                break;
        }

        var index:int = 0;
        for each (var i:MemMarketBuyItem in this.resultItems_) {
            i.x = MemMarketItem.OFFER_WIDTH * int(index % 5) + RESULT_X_OFFSET;
            i.y = MemMarketItem.OFFER_HEIGHT * int(index / 5) + RESULT_Y_OFFSET;
            index++;
        }
    }

    private function searchItemsFunc(first:Boolean = false):void {
        /* Remove old scrollbar */
        if (this.searchScroll != null) {
            this.searchScroll.removeEventListener(Event.CHANGE, this.onSearchScrollChanged);
            removeChild(this.searchScroll);
            this.searchScroll = null;
        }

        if (!StringUtil.trim(this.searchField_.text()) && !first && !StringUtil.trim(this.searchField_.text()) == "") /* Clear results if empty */
        {
            this.clearPreviousResults(false);
            return;
        }

        this.clearPreviousResults(false);

        var index:int = 0;
        var itemType:int

        for each (var i:String in ObjectLibrary.idToType_) {
            if (i.indexOf(this.searchField_.text().toLowerCase()) >= 0) {
                itemType = ObjectLibrary.idToType_[i];

                if (ItemUtils.isBanned(itemType) || ObjectLibrary.xmlLibrary_[itemType].TierType == "Stat") /* Skip on banned items */
                {
                    continue;
                }

                if (!TierSort(ObjectLibrary.xmlLibrary_[itemType])) {
                    continue;
                }
                if (!StatSort(ObjectLibrary.xmlLibrary_[itemType])) {
                    continue;
                }

                if (!ItemTypeSort(ObjectLibrary.xmlLibrary_[itemType])) {
                    continue;
                }

                var item:MemMarketItem = new MemMarketItem(this.gameSprite_, SEARCH_ITEM_SIZE, SEARCH_ITEM_SIZE, 80, ObjectLibrary.idToType_[i], null);
                item.x = SEARCH_ITEM_SIZE * int(index % 5) + SEARCH_X_OFFSET;
                item.y = SEARCH_ITEM_SIZE * int(index / 5) + SEARCH_Y_OFFSET;
                item.addEventListener(MouseEvent.CLICK, this.onSearchClick);
                item.CreateLabel();
                this.searchItems.push(item);
                index++;
            }
        }


        for each (var x:MemMarketItem in this.searchItems) /* Draw our results */
        {
            this.searchBackground.addChild(x);
        }

        this.searchBackground.y = 0; /* Reset height */
        if (this.searchBackground.height > 350) {
            this.searchScroll = new Scrollbar(6, 350);
            this.searchScroll.x = 258;
            this.searchScroll.y = SEARCH_Y_OFFSET;
            this.searchScroll.setIndicatorSize(350, this.searchBackground.height);
            this.searchScroll.addEventListener(Event.CHANGE, this.onSearchScrollChanged);
            addChild(this.searchScroll);
        }
    }

    private function TierSort(xml:XML):Boolean {
        if (xml.hasOwnProperty("TierType")) {
            switch (SortUtils.TIER_SORT_CHOICES[this.tierSortChoices_.getIndex()]) {
                case SortUtils.ALLTIERS:
                    return true;
                case SortUtils.TARNISHED:
                    if (String(xml.TierType).match(/Tarnished$/i)) {
                        return true;
                    }
                    break;
                case SortUtils.ARTIFACT:
                    if (String(xml.TierType).match(/Artifact$/i)) {
                        return true;
                    }
                    break;
                case SortUtils.VALIANT:
                    if (String(xml.TierType).match(/Valiant$/i)) {
                        return true;
                    }
                    break;
                case SortUtils.RELIC:
                    if (String(xml.TierType).match(/Relic$/i)) {
                        return true;
                    }
                    break;
                case SortUtils.EXILED:
                    if (String(xml.TierType).match(/Exiled$/i)) {
                        return true;
                    }
                    break;
            }
        }
        return false;
    }

    private function StatSort(xml:XML):Boolean {
        var value:String = "";
        if (!xml.hasOwnProperty("ActivateOnEquip")) {
            switch (SortUtils.STAT_SORT_CHOICES[this.statSortChoices_.getIndex()]) {
                case SortUtils.ALLSTATS:
                    return true;
            }
        }
        for each (value in xml.ActivateOnEquip.@stat) {
            switch (SortUtils.STAT_SORT_CHOICES[this.statSortChoices_.getIndex()]) {
                case SortUtils.ALLSTATS:
                    return true;
                case SortUtils.HP:
                    if (int(value) == 0) {
                        return true;
                    }
                    break;
                case SortUtils.MP:
                    if (int(value) == 3) {
                        return true;
                    }
                    break;
                case SortUtils.ATK:
                    if (int(value) == 20) {
                        return true;
                    }
                    break;
                case SortUtils.DEF:
                    if (int(value) == 21) {
                        return true;
                    }
                    break;
                case SortUtils.SPD:
                    if (int(value) == 22) {
                        return true;
                    }
                    break;
                case SortUtils.VIT:
                    if (int(value) == 26) {
                        return true;
                    }
                    break;
                case SortUtils.WIS:
                    if (int(value) == 27) {
                        return true;
                    }
                    break;
                case SortUtils.DEX:
                    if (int(value) == 28) {
                        return true;
                    }
                    break;
                case SortUtils.FRT:
                    if (int(value) == 102) {
                        return true;
                    }
                    break;
                case SortUtils.MGT:
                    if (int(value) == 112) {
                        return true;
                    }
                    break;
                case SortUtils.LCK:
                    if (int(value) == 114) {
                        return true;
                    }
                    break;
                case SortUtils.RES:
                    if (int(value) == 121) {
                        return true;
                    }
                    break;
                case SortUtils.PRT:
                    if (int(value) == 122) {
                        return true;
                    }
                    break;
            }
        }
        return false;
    }

    private function ItemTypeSort(xml:XML):Boolean {
        var value:String = "";
        for each (value in xml.SlotType) {
            switch (SortUtils.ITEMTYPE_SORT_CHOICES[this.itemTypeSortChoices_.getIndex()]) {
                case SortUtils.ALLITEMTYPES:
                    return true;
                case SortUtils.SWORD:
                    if (int(value) == 1) {
                        return true;
                    }
                    break;
                case SortUtils.DAGGER:
                    if (int(value) == 2) {
                        return true;
                    }
                    break;
                case SortUtils.BOW:
                    if (int(value) == 3) {
                        return true;
                    }
                    break;
                case SortUtils.WAND:
                    if (int(value) == 8) {
                        return true;
                    }
                    break;
                case SortUtils.STAFF:
                    if (int(value) == 17) {
                        return true;
                    }
                    break;
                case SortUtils.KATANA:
                    if (int(value) == 24) {
                        return true;
                    }
                    break;
                case SortUtils.LANCE:
                    if (int(value) == 29) {
                        return true;
                    }
                    break;
                case SortUtils.BLADES:
                    if (int(value) == 34) {
                        return true;
                    }
                    break;
                case SortUtils.LIGHTARMOR:
                    if (int(value) == 14) {
                        return true;
                    }
                    break;
                case SortUtils.MEDIUMARMOR:
                    if (int(value) == 6) {
                        return true;
                    }
                    break;
                case SortUtils.HEAVYARMOR:
                    if (int(value) == 7) {
                        return true;
                    }
                    break;
                case SortUtils.TOME:
                    if (int(value) == 4) {
                        return true;
                    }
                    break;
                case SortUtils.SHIELD:
                    if (int(value) == 5) {
                        return true;
                    }
                    break;
                case SortUtils.SPELL:
                    if (int(value) == 11) {
                        return true;
                    }
                    break;
                case SortUtils.SEAL:
                    if (int(value) == 12) {
                        return true;
                    }
                    break;
                case SortUtils.CLOAK:
                    if (int(value) == 13) {
                        return true;
                    }
                    break;
                case SortUtils.QUIVER:
                    if (int(value) == 15) {
                        return true;
                    }
                    break;
                case SortUtils.HELMET:
                    if (int(value) == 16) {
                        return true;
                    }
                    break;
                case SortUtils.POISON:
                    if (int(value) == 18) {
                        return true;
                    }
                    break;
                case SortUtils.SKULL:
                    if (int(value) == 19) {
                        return true;
                    }
                    break;
                case SortUtils.TRAP:
                    if (int(value) == 20) {
                        return true;
                    }
                    break;
                case SortUtils.ORB:
                    if (int(value) == 21) {
                        return true;
                    }
                    break;
                case SortUtils.PRISM:
                    if (int(value) == 22) {
                        return true;
                    }
                    break;
                case SortUtils.SCEPTER:
                    if (int(value) == 23) {
                        return true;
                    }
                    break;
                case SortUtils.SHURIKEN:
                    if (int(value) == 25) {
                        return true;
                    }
                    break;
                case SortUtils.SHEATH:
                    if (int(value) == 27) {
                        return true;
                    }
                    break;
                case SortUtils.BANNER:
                    if (int(value) == 28) {
                        return true;
                    }
                    break;
                case SortUtils.SIPHON:
                    if (int(value) == 30) {
                        return true;
                    }
                    break;
                case SortUtils.CHARM:
                    if (int(value) == 32) {
                        return true;
                    }
                    break;
                case SortUtils.DICE:
                    if (int(value) == 33) {
                        return true;
                    }
                    break;
                case SortUtils.JACKET:
                    if (int(value) == 35) {
                        return true;
                    }
                    break;
                case SortUtils.TALISMAN:
                    if (int(value) == 36) {
                        return true;
                    }
                    break;
                case SortUtils.ACCESSORY:
                    if (int(value) == 9) {
                        return true;
                    }
                    break;
                case SortUtils.INGREDIENT:
                    if (int(value) == 37) {
                        return true;
                    }
                    break;
                case SortUtils.UTILITY:
                    if (int(value) == 38) {
                        return true;
                    }
                    break;
                case SortUtils.CAPSULE:
                    if (int(value) == 39) {
                        return true;
                    }
                    break;
            }
        }
        return false;
    }

    private function refreshOffers():void {
        for each (var o:MemMarketBuyItem in this.resultItems_) {
            o.updateButton();
        }
    }

    /* Buy and refresh offers */
    private function onBuy(result:MarketBuyResult):void {
        if (result.code_ != -1) {
            DialogUtils.makeSimpleDialog(this.gameSprite_, "Error", result.description_);
            return;
        }

        this.removeOffer(result.offerId_);
        this.refreshOffers();

        DialogUtils.makeSimpleDialog(this.gameSprite_, "Success", result.description_);
    }

    /* Refresh and add found offers */
    private function onSearch(result:MarketSearchResult):void {
        if (result.description_ != "") {
            this.clearPreviousResults(true);
            DialogUtils.makeSimpleDialog(this.gameSprite_, "Error", result.description_);
            return;
        }

        /* Remove old scrollbar */
        if (this.resultScroll_ != null) {
            this.resultScroll_.removeEventListener(Event.CHANGE, this.onResultScrollChanged);
            removeChild(this.resultScroll_);
            this.resultScroll_ = null;
        }

        this.clearPreviousResults(true);

        for each (var i:MarketData in result.results_) {
            var item:MemMarketBuyItem = new MemMarketBuyItem(this.gameSprite_, i);
            this.resultItems_.push(item);

            //could be pretty slow when theres lots of items to loop through
            if (this.first_) {
                for each(var marketItem:MemMarketItem in this.searchItems) {
                    if (marketItem.itemType_ == i.itemType_) {
                        marketItem.UpdateCounter();
                    }
                }
            }
        }
        this.first_ = false;

        this.sortOffers();


        for each (var o:MemMarketBuyItem in this.resultItems_) {
            this.resultBackground_.addChild(o);
        }

        this.resultBackground_.y = 0; /* Reset height */
        if (this.resultBackground_.height > 436) {
            this.resultScroll_ = new Scrollbar(22, 415);
            this.resultScroll_.x = 774;
            this.resultScroll_.y = RESULT_Y_OFFSET;
            this.resultScroll_.setIndicatorSize(415, this.resultBackground_.height);
            this.resultScroll_.addEventListener(Event.CHANGE, this.onResultScrollChanged);
            addChild(this.resultScroll_);
        }
    }

    private function onResultScrollChanged(event:Event):void {
        this.resultBackground_.y = -this.resultScroll_.pos() * (this.resultBackground_.height - 418);
    }

    /* Clear */
    public override function dispose():void {
        this.buySignal_.remove(this.onBuy);
        this.searchSignal_.remove(this.onSearch);

        this.searchField_.removeEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
        this.searchField_ = null;

        this.shape_.parent.removeChild(this.shape_);
        this.shape_ = null;

        this.clearPreviousResults(false);
        this.searchItems = null;
        this.searchMask_.removeChild(this.searchBackground);
        this.searchMask_ = null;
        this.searchBackground = null;

        if (this.searchScroll != null) {
            this.searchScroll.removeEventListener(Event.CHANGE, this.onSearchScrollChanged);
            this.searchScroll = null;
        }

        this.clearPreviousResults(true);
        this.resultItems_ = null;

        this.resultMask_.removeChild(this.resultBackground_);
        this.resultMask_ = null;
        this.resultBackground_ = null;

        if (this.resultScroll_ != null) {
            this.resultScroll_.removeEventListener(Event.CHANGE, this.onResultScrollChanged);
            this.resultScroll_ = null;
        }

        this.sortChoices_.removeEventListener(Event.CHANGE, this.onSortChoicesChanged);
        this.sortChoices_ = null;

        this.tierSortChoices_.removeEventListener(Event.CHANGE, this.onTierChoice);
        this.tierSortChoices_ = null;

        this.statSortChoices_.removeEventListener(Event.CHANGE, this.onStatChoice);
        this.statSortChoices_ = null;

        this.itemTypeSortChoices_.removeEventListener(Event.CHANGE, this.onItemTypeChoice);
        this.itemTypeSortChoices_ = null;

        super.dispose();
    }

    private function onTierChoice(event:Event):void {
        this.searchItemsFunc();
        //searchItemsFunc(false);
        //tierSort();
    }

    private function onStatChoice(event:Event):void {
        this.searchItemsFunc();
        //searchItemsFunc(false);
        //tierSort();
    }

    private function onItemTypeChoice(event:Event):void {
        this.searchItemsFunc();
        //searchItemsFunc(false);
        //tierSort();
    }

}
}
</file>

<file path="src/svera/untiered/raidLauncher/RaidLauncherModal.as">
package svera.untiered.raidLauncher {
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;
import flash.text.TextFormatAlign;

import svera.untiered.account.core.view.EmptyFrame;
import svera.untiered.core.StaticInjectorContext;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.lootBoxes.PopupWindowBackground;

public class RaidLauncherModal extends EmptyFrame {
    public static const MODAL_WIDTH:int = 440;
    public static const MODAL_HEIGHT:int = 500;

    [Embed(source="RaidLauncher_backgroundImageEmbed.png")]
    public static var backgroundImageEmbed:Class;
    [Embed(source="Raid1_launchFlag.png")]
    public static var raid1launchFlagEmbed:Class;
    [Embed(source="Raid2_launchFlag.png")]
    public static var raid2launchFlagEmbed:Class;
    [Embed(source="Raid3_launchFlag.png")]
    public static var raid3launchFlagEmbed:Class;
    public static var modalWidth:int = MODAL_WIDTH;
    public static var modalHeight:int = MODAL_HEIGHT;

    public var launchButton:TextButton;
    public var launchButton2:TextButton;
    public var launchButton3:TextButton;

    public function RaidLauncherModal() {
        modalWidth = MODAL_WIDTH;
        modalHeight = MODAL_HEIGHT;
        super(modalWidth, modalHeight);
        this.setCloseButton(true);
        this.setTitle("Choose a raid to launch", true);
        closeButton.addEventListener(MouseEvent.CLICK, this.onCloseButtonClicked);
    }

    public static function getText(_arg1:String, _arg2:int, _arg3:int, _arg4:Boolean):SimpleText {
        var _local5:SimpleText = new SimpleText(18, 0xFFFFFF, false, RaidLauncherModal.modalWidth - TEXT_MARGIN * 2 - 10);
        _local5.setBold(true);
        _local5.setText(_arg1)
        _local5.wordWrap = true;
        _local5.multiline = true;
        _local5.autoSize = TextFieldAutoSize.CENTER;
        _local5.setAlignment(TextFormatAlign.CENTER);
        _local5.filters = [new DropShadowFilter(0, 0, 0)];
        _local5.x = _arg2;
        _local5.y = _arg3;
        return _local5;
    }

    public function onCloseButtonClicked(e:Event):void {
        var _local1:CloseDialogsSignal = StaticInjectorContext.getInjector().getInstance(CloseDialogsSignal);
        closeButton.removeEventListener(MouseEvent.CLICK, this.onCloseButtonClicked);
        _local1.dispatch();
    }

    public function onClick(_arg1:MouseEvent):void {
    }

    override protected function makeModalBackground():Sprite {
        var _local1:Sprite = new Sprite();
        var _local2:DisplayObject = new Bitmap(new backgroundImageEmbed().bitmapData);
        _local2.width = modalWidth + 1;
        _local2.height = modalHeight - 25;
        _local2.y = 27;
        _local2.alpha = 1.00;
        var _local3:DisplayObject = new Bitmap(new raid1launchFlagEmbed().bitmapData);
        _local3.width = 440;
        _local3.height = 80;
        _local3.y = 30;
        _local3.alpha = 1.00;
        var _local5:DisplayObject = new Bitmap(new raid2launchFlagEmbed().bitmapData);
        _local5.width = 440;
        _local5.height = 80;
        _local5.y = 150;
        _local5.alpha = 1;
        var _local6:DisplayObject = new Bitmap(new raid3launchFlagEmbed().bitmapData);
        _local6.width = 330;
        _local6.height = 80;
        _local6.y = 270;
        _local6.alpha = 1;
        var _local4:PopupWindowBackground = new PopupWindowBackground();
        _local4.draw(modalWidth, modalHeight, PopupWindowBackground.TYPE_TRANSPARENT_WITH_HEADER);
        _local1.addChild(_local2);
        _local1.addChild(_local3);
        _local1.addChild(_local4);
        _local1.addChild(_local5);
        _local1.addChild(_local6);
        this.launchButton = new TextButton(12, "Launch");
        this.launchButton.y = 118;
        this.launchButton.x = this.launchButton.x + 10;
        this.launchButton.setEnabled(true);
        _local1.addChild(this.launchButton);

        this.launchButton2 = new TextButton(12, "Launch");
        this.launchButton2.y = 236;
        this.launchButton2.x = this.launchButton2.x + 10;
        this.launchButton2.setEnabled(true);
        _local1.addChild(this.launchButton2);

        this.launchButton3 = new TextButton(12, "Launch");
        this.launchButton3.y = 354;
        this.launchButton3.x = this.launchButton3.x + 10;
        this.launchButton3.setEnabled(true);
        _local1.addChild(this.launchButton3);
        return _local1;
    }

    private function onMouseClick(e:MouseEvent):void {
        SoundEffectLibrary.play("button_click");
    }

    override public function onCloseClick(_arg1:MouseEvent):void {
        SoundEffectLibrary.play("button_click");
    }
}
}
</file>

<file path="src/svera/untiered/traits/TraitsGUI.as">
package svera.untiered.traits {

import com.company.assembleegameclient.background.Background;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.ui.SimpleText;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.text.TextField;
import flash.text.TextFieldAutoSize;
import flash.text.TextFormat;
import flash.text.TextFormatAlign;

import org.swiftsuspenders.Injector;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.game.model.GameInitData;
import svera.untiered.game.signals.PlayGameSignal;

public class TraitsGUI extends Sprite {

    [Inject]
    public var model:PlayerModel;
    [Inject]
    public var play:PlayGameSignal;
    [Embed(source="Bricks.png")]
    private static var bricksSource:Class;

    /* initializing the list of assets we're using, there are three buttons to choose from so there's three vars. */
    public var awakeningIcons:Vector.<Bitmap> = new Vector.<Bitmap>;
    public var relicIcons:Vector.<Bitmap> = new Vector.<Bitmap>;
    public var backgroundIcons:Vector.<Bitmap> = new Vector.<Bitmap>;

    /* you cannot use BitmapAssets as buttons, so I made Sprite containers for each type of trait. */
    private var container:Sprite = new Sprite();
    private var containerTwo:Sprite = new Sprite();
    private var containerThree:Sprite = new Sprite();

    /* initializing the values for each trait */
    private var typeOne:int;
    private var typeTwo:int;
    private var typeThree:int;

    /* initializing header text and a select button for when you're done. */
    private var awakeningTitleText_:TextField;
    private var relicTitleText_:TextField;
    private var backgroundTitleText_:TextField;
    private var selectButton_:TextButton;

    /* adding desc. text, these will change depending on which trait is selected. */
    private var awakeningText:SimpleText;
    private var relicText:SimpleText;
    private var backgroundText:SimpleText;
    private var bg:background = new background();

    public function TraitsGUI() {
        /* sets the default value of the trait type to zero. */
        this.typeOne = 0;
        this.typeTwo = 0;
        this.typeThree = 0;

        var h:Number = 0;
        var w:Number = 0;
        var l:Bitmap;
        var vertical:Sprite = new Sprite();
        while (h < GameClient.STAGE.fullScreenHeight) {
            l = new Bitmap(new bricksSource().bitmapData);
            l.y = h;
            vertical.addChild(l);
            h += l.height;
        }
        var bgVert:BitmapData = new BitmapData(vertical.width, vertical.height, false);
        bgVert.draw(vertical);

        while(w < GameClient.STAGE.fullScreenWidth) {
            l = new Bitmap(bgVert);
            l.x = w;
            addChild(l);
            w += l.width;
        }

        /* makes a transparent background behind the UI. */
        graphics.clear();
        graphics.beginFill(0x1a1622, 0.8);
        graphics.drawRect(0, 0, GameClient.StageWidth, GameClient.StageHeight);
        graphics.endFill();

        /* a BitmapAsset for the background, the .png has the runes circles, the details on the corners of the screen, the header and the description overlay. */
        bg.x = (GameClient.StageWidth - bg.width) / 2;
        addChild(bg);

/*
        /!* creates a line near the top of the screen above the background. *!/
        graphics.lineStyle(2, 6184542);
        graphics.moveTo(0, 100);
        graphics.lineTo(GameClient.StageWidth, 100);
        graphics.lineStyle();
*/

        /* adds the containers for the assets on screen */
        addChild(this.container);
        addChild(this.containerTwo);
        addChild(this.containerThree);

        /* adds header text and a select button to close out of the GUI */
        var txt0:TextField = new TextField();
        txt0.autoSize = TextFieldAutoSize.CENTER;
        txt0.textColor = 11776947;
        var txt1:TextField = new TextField();
        txt1.autoSize = TextFieldAutoSize.CENTER;
        txt1.textColor = 11776947;
        var txt2:TextField = new TextField();
        txt2.autoSize = TextFieldAutoSize.CENTER;
        txt2.textColor = 11776947;
        var newFormat:TextFormat = new TextFormat();
        newFormat.size = 28;
        newFormat.bold = true;
        newFormat.align = TextFormatAlign.CENTER;
        txt0.defaultTextFormat = newFormat;
        txt1.defaultTextFormat = newFormat;
        txt2.defaultTextFormat = newFormat;
        this.awakeningTitleText_ = txt0;
        this.awakeningTitleText_.text = "Awakening";
        this.awakeningTitleText_.x = bg.x + 147  - this.awakeningTitleText_.width / 2;
        this.awakeningTitleText_.y = 16;
        addChild(this.awakeningTitleText_);
        this.relicTitleText_ = txt1;
        this.relicTitleText_.text = "Relic";
        this.relicTitleText_.x = GameClient.HalfStageWidth - this.relicTitleText_.width / 2;
        this.relicTitleText_.y = 16;
        addChild(this.relicTitleText_);
        this.backgroundTitleText_ = txt2;
        this.backgroundTitleText_.text = "Background";
        this.backgroundTitleText_.x = bg.x + 654 - this.backgroundTitleText_.width / 2;
        this.backgroundTitleText_.y = 16;
        addChild(this.backgroundTitleText_);
        this.selectButton_ = new TextButton(18, "Select", 120);
        this.selectButton_.x = GameClient.HalfStageWidth - selectButton_.width * 0.5;
        this.selectButton_.y = GameClient.StageHeight - (600 - 561);
        addChild(this.selectButton_);

        /* when the select button is selected, it will call a function that removes the GUI */
        this.selectButton_.addEventListener(MouseEvent.CLICK, onClose);

        /* calls the functions where the vectors and desc. text is handled */
        this.addIcons();
        this.addDesc();
    }

    public function onClose(param1:MouseEvent):void {
        /* efficient way to remove the GUI from the screen. */
        var game:GameInitData = new GameInitData();
        var injector:Injector = StaticInjectorContext.getInjector();
        this.model = injector.getInstance(PlayerModel);
        this.play = injector.getInstance(PlayGameSignal);
        game.createCharacter = true;
        game.charId = this.model.getNextCharId();
        game.traits = [typeOne, typeTwo, typeThree];
        game.isNewGame = true;
        stage.focus = null;
        parent.removeChild(this);
        this.play.dispatch(game);
    }

    public function addDesc():void {
        /* initializes the text on screen. I am using BaseSimpleText because you can utilize html tags to make segments bold and unbold. */
        this.awakeningText = new SimpleText(14, 0xffffff, false, 213, 201);
        this.relicText = new SimpleText(14, 0xffffff, false, 213, 201);
        this.backgroundText = new SimpleText(14, 0xffffff, false, 213, 201);

        /* sets the position of the text. */
        this.awakeningText.multiline = true;
        this.awakeningText.wordWrap = true;
        this.awakeningText.x = bg.x + 40;
        this.awakeningText.y = 309;
        this.relicText.multiline = true;
        this.relicText.wordWrap = true;
        this.relicText.x = bg.x + 294;
        this.relicText.y = 309;
        this.backgroundText.multiline = true;
        this.backgroundText.wordWrap = true;
        this.backgroundText.x = bg.x + 548;
        this.backgroundText.y = 309;

        /* uses <b> tags to make text bold. set the default values to the first runes description text on screen. */
        this.awakeningText.htmlText = "<b>Swift Stride:</b> \n - Movement Speed Multiplier x1.15 \n - Proficient with short range weapons \n - Reduced effectiveness to paralyzing effects";
        this.relicText.htmlText = "<b>Defenseless:</b> \n - Gain physical resistance based on your hp when not wearing armor.";
        this.backgroundText.htmlText = "<b>Acolyte:</b> \n - Primary stat [INT] \n - Secondary stat [HP]";

        /* adds the text on screen. */
        addChild(this.awakeningText);
        addChild(this.relicText);
        addChild(this.backgroundText);
    }

    public function addIcons():void {
        /* the []'s set each value on the icon's list, this is initializing each one being used */
        var SwiftStride:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 0);
        SwiftStride = TextureRedrawer.redraw(SwiftStride, 320, true, 0);
        var ElementalWard:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 43);
        ElementalWard = TextureRedrawer.redraw(ElementalWard, 320, true, 0);
        var Brave:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 24);
        Brave = TextureRedrawer.redraw(Brave, 320, true, 0);
        var LethalElegance:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 97);
        LethalElegance = TextureRedrawer.redraw(LethalElegance, 320, true, 0);
        var AgileDuelist:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 2);
        AgileDuelist = TextureRedrawer.redraw(AgileDuelist, 320, true, 0);
        var HalfBreed:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 42);
        HalfBreed = TextureRedrawer.redraw(HalfBreed, 320, true, 0);
        var Seer:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 59);
        Seer = TextureRedrawer.redraw(Seer, 320, true, 0);
        var VoidTouched:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 1);
        VoidTouched = TextureRedrawer.redraw(VoidTouched, 320, true, 0);
        var Thaumaturge:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 40);
        Thaumaturge = TextureRedrawer.redraw(Thaumaturge, 320, true, 0);
        var ResilientAvenger:BitmapData = AssetLibrary.getImageFromSet("StarterGear", 27);
        ResilientAvenger = TextureRedrawer.redraw(ResilientAvenger, 320, true, 0);
        this.awakeningIcons[0] = new Bitmap(SwiftStride);
        this.awakeningIcons[1] = new Bitmap(ElementalWard);
        this.awakeningIcons[2] = new Bitmap(Brave);
        this.awakeningIcons[3] = new Bitmap(LethalElegance);
        this.awakeningIcons[4] = new Bitmap(AgileDuelist);
        this.awakeningIcons[5] = new Bitmap(HalfBreed);
        this.awakeningIcons[6] = new Bitmap(Seer);
        this.awakeningIcons[7] = new Bitmap(VoidTouched);
        this.awakeningIcons[8] = new Bitmap(Thaumaturge);
        this.awakeningIcons[9] = new Bitmap(ResilientAvenger);

        var Defenseless:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Defenseless = TextureRedrawer.redraw(Defenseless, 320, true, 0);
        var Mithridatism:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Mithridatism = TextureRedrawer.redraw(Mithridatism, 320, true, 0);
        var Healthy:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Healthy = TextureRedrawer.redraw(Healthy, 320, true, 0);
        var Absorption:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Absorption = TextureRedrawer.redraw(Absorption, 320, true, 0);
        var Scope:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Scope = TextureRedrawer.redraw(Scope, 320, true, 0);
        var Dexterous:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Dexterous = TextureRedrawer.redraw(Dexterous, 320, true, 0);
        var Holy:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Holy = TextureRedrawer.redraw(Holy, 320, true, 0);
        var Incombustible:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Incombustible = TextureRedrawer.redraw(Incombustible, 320, true, 0);
        var RazorSharp:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        RazorSharp = TextureRedrawer.redraw(RazorSharp, 320, true, 0);
        this.relicIcons[0] = new Bitmap(Defenseless);
        this.relicIcons[1] = new Bitmap(Mithridatism);
        this.relicIcons[2] = new Bitmap(Healthy);
        this.relicIcons[3] = new Bitmap(Absorption);
        this.relicIcons[4] = new Bitmap(Scope);
        this.relicIcons[5] = new Bitmap(Dexterous);
        this.relicIcons[6] = new Bitmap(Holy);
        this.relicIcons[7] = new Bitmap(Incombustible);
        this.relicIcons[8] = new Bitmap(RazorSharp);

        var Acolyte:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Acolyte = TextureRedrawer.redraw(Acolyte, 320, true, 0);
        var Charlatan:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Charlatan = TextureRedrawer.redraw(Charlatan, 320, true, 0);
        var Criminal:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Criminal = TextureRedrawer.redraw(Criminal, 320, true, 0);
        var Entertainer:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Entertainer = TextureRedrawer.redraw(Entertainer, 320, true, 0);
        var Hero:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Hero = TextureRedrawer.redraw(Hero, 320, true, 0);
        var Artisan:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Artisan = TextureRedrawer.redraw(Artisan, 320, true, 0);
        var Noble:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Noble = TextureRedrawer.redraw(Noble, 320, true, 0);
        var Outlander:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Outlander = TextureRedrawer.redraw(Outlander, 320, true, 0);
        var Sage:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Sage = TextureRedrawer.redraw(Sage, 320, true, 0);
        var Soldier:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Soldier = TextureRedrawer.redraw(Soldier, 320, true, 0);
        var Urchin:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        Urchin = TextureRedrawer.redraw(Urchin, 320, true, 0);
        this.backgroundIcons[0] = new Bitmap(Acolyte);
        this.backgroundIcons[1] = new Bitmap(Charlatan);
        this.backgroundIcons[2] = new Bitmap(Criminal);
        this.backgroundIcons[3] = new Bitmap(Entertainer);
        this.backgroundIcons[4] = new Bitmap(Hero);
        this.backgroundIcons[5] = new Bitmap(Artisan);
        this.backgroundIcons[6] = new Bitmap(Noble);
        this.backgroundIcons[7] = new Bitmap(Outlander);
        this.backgroundIcons[8] = new Bitmap(Sage);
        this.backgroundIcons[9] = new Bitmap(Soldier);
        this.backgroundIcons[10] = new Bitmap(Urchin);

        /* this argument basioally says, this value equals 0, if it is below five, it will call the function and increase the value by one until it'd be above or equal to 10.
        the function will allow each value of the asset (starting from 0) to be on screen. */
        for (var a:int = 0; a < 10; a++) {
            this.awakeningIcons.push(this.awakeningIcons[a]);
        }
        for (a = 0; a < 9; a++) {
            this.relicIcons.push(this.relicIcons[a]);
        }
        for (a = 0; a < 11; a++) {
            this.backgroundIcons.push(this.backgroundIcons[a]);
        }

        /* same as the last function, but this time it will make sure each rune icon is in these set positions */
        for (var b:int = 0; b < 10; b++) {
            this.awakeningIcons[b].x = bg.x + 145 - this.awakeningIcons[b].width / 2;
            this.awakeningIcons[b].y = 170.5 - this.awakeningIcons[b].height / 2;
        }
        for (b = 0; b < 9; b++) {
            this.relicIcons[b].x = GameClient.HalfStageWidth - this.relicIcons[b].width / 2;
            this.relicIcons[b].y = 170.5 - this.relicIcons[b].height / 2;
        }
        for (b = 0; b < 11; b++) {
            this.backgroundIcons[b].x = bg.x + 655 - this.backgroundIcons[b].width / 2;
            this.backgroundIcons[b].y = 170.5 - this.backgroundIcons[b].height / 2;
        }

        /* this makes it so if the container holding the assets is clicked, it will call a function.
        if you want to attach parameters to the function called, this is how it should be written:

        this.container.addEventListener(MouseEvent.CLICK, function(e:MouseEvent) : void { upd(); });
        this.containerTwo.addEventListener(MouseEvent.CLICK, function(e:MouseEvent) : void { upd2(); }); */
        this.container.addEventListener(MouseEvent.CLICK, f1);
        this.containerTwo.addEventListener(MouseEvent.CLICK, f2);
        this.containerThree.addEventListener(MouseEvent.CLICK, f3);
        this.container.addEventListener(MouseEvent.RIGHT_CLICK, b1);
        this.containerTwo.addEventListener(MouseEvent.RIGHT_CLICK, b2);
        this.containerThree.addEventListener(MouseEvent.RIGHT_CLICK, b3);

        /* this will add the sprite container to add the first asset of each type to itself */
        this.container.addChild(this.awakeningIcons[0]);
        this.containerTwo.addChild(this.relicIcons[0]);
        this.containerThree.addChild(this.backgroundIcons[0]);
    }

    private function f1(event:Event):void {
        /* increases the trait type by one */
        this.typeOne++;

        /* removes and replaces the asset, for example: if you were on the first trait (0), it would increase to the second trait (1), and remove the one behind it (0), hence the this.typeOne - 1. */
        this.container.removeChild(this.awakeningIcons[this.typeOne - 1]);
        this.container.addChild(this.awakeningIcons[this.typeOne]);

        /* calls a function to update the text */
        this.updateText();
    }

    private function b1(event:Event):void {
        /* decrease the trait type by one */
        this.typeOne--;

        /* removes and replaces the asset, for example: if you were on the first trait (0), it would increase to the second trait (9), and remove the one behind it (0), hence the this.typeOne - 1. */
        this.container.removeChild(this.awakeningIcons[this.typeOne + 1]);
        if (this.typeOne < 0) this.typeOne = 9;
        this.container.addChild(this.awakeningIcons[this.typeOne]);

        /* calls a function to update the text */
        this.updateText();
    }

    /* this function does the exact same thing, but for the second trait slot. */
    private function f2(event:Event):void {
        this.typeTwo++;
        this.containerTwo.removeChild(this.relicIcons[this.typeTwo - 1]);
        this.containerTwo.addChild(this.relicIcons[this.typeTwo]);
        this.updateText();
    }

    private function b2(event:Event):void {
        this.typeTwo--;
        this.containerTwo.removeChild(this.relicIcons[this.typeTwo + 1]);
        if (this.typeTwo < 0) this.typeTwo = 8;
        this.containerTwo.addChild(this.relicIcons[this.typeTwo]);
        this.updateText();
    }

    /* this function does the exact same thing, but for the second trait slot. */
    private function f3(event:Event):void {
        this.typeThree++;
        this.containerThree.removeChild(this.backgroundIcons[this.typeThree - 1]);
        this.containerThree.addChild(this.backgroundIcons[this.typeThree]);
        this.updateText();
    }

    private function b3(event:Event):void {
        this.typeThree--;
        this.containerThree.removeChild(this.backgroundIcons[this.typeThree + 1]);
        if (this.typeThree < 0) this.typeThree = 10;
        this.containerThree.addChild(this.backgroundIcons[this.typeThree]);
        this.updateText();
    }

    private function updateText():void {
        /* is the equivalent to saying if (this.typeOne == value), change the text to this. switches are the most efficient way of going about repeatable things with multiple values (like this). */
        switch (this.typeOne) {
            case -1:
                /* there should only be 9 awakenings to choose from, so if it goes below the 1st awakening, it will set it's text to the last awakening and change it's type back to the highest value */
                this.awakeningText.htmlText = "<b>Resilient Avenger:</b> \n - If you reach 0 hp, you regain 1 hp instead of becoming downed \n - When you land a critical hit with a small or short ranged weapon, deal additional damage based on your attack";
                this.typeOne = 9;
                break;
            case 0:
                this.awakeningText.htmlText = "<b>Swift Stride:</b> \n - Movement Speed Multiplier x1.15 \n - Proficient with Short range weapons \n - Reduced effectiveness to paralyzing effects";
                break;
            case 1:
                this.awakeningText.htmlText = "<b>Elemental Ward:</b> \n - Gained resistance to all elemental damage";
                break;
            case 2:
                this.awakeningText.htmlText = "<b>Brave:</b> \n - Proficient with Small range weapons \n - Reduced effectiveness to paralyzing effects";
                break;
            case 3:
                this.awakeningText.htmlText = "<b>Lethal Elegance:</b> \n - Proficient with Medium range weapons \n - Improved Light armor effectiveness";
                break;
            case 4:
                this.awakeningText.htmlText = "<b>Agile Duelist:</b> \n - Proficient with Long range weapons \n - Improved Light and Medium armor effectiveness";
                break;
            case 5:
                this.awakeningText.htmlText = "<b>Half Breed:</b> \n - Movement Speed Multiplier x0.75 \n - Proficient with Short range weapons \n - Gain a chance to not be affected by paralyzing effects \n - Reduced effectiveness to Light damage";
                break;
            case 6:
                this.awakeningText.htmlText = "<b>Seer:</b> \n - Movement Speed Multiplier x1.15 \n - Proficient with Long range weapons \n - Improved Light armor effectiveness \n - Reduced effectiveness to paralyzing effects";
                break;
            case 7:
                this.awakeningText.htmlText = "<b>Void Touched:</b> \n - Movement Speed Multiplier x0.75 \n - Gain a chance to not be affected by terrify - Attacks with minmax damage gain an effect, the damage will roll twice, if the initial damage was lower than 50% of the maximum damage \n - Reduced effectiveness to void damage";
                break;
            case 8:
                this.awakeningText.htmlText = "<b>Thaumaturge:</b> \n - Movement Speed Multiplier x0.75 \n - Gain additional INT and RP \n - Reduced effectiveness to electric damage";
                break;
            case 9:
                this.awakeningText.htmlText = "<b>Resilient Avenger:</b> \n - If you reach 0 hp, you regain 1 hp instead of becoming downed \n - When you land a critical hit with a small or short ranged weapon, deal additional damage based on your attack";
                break;
            case 10:
                /* there should only be 9 awakenings to choose from, so if it goes past the 9th awakening, it will set it's text to the first awakening and change it's type back to it's default value */
                this.awakeningText.htmlText = "<b>Swift Stride:</b> \n - Movement Speed Multiplier x1.15 \n - Proficient with short range weapons \n - Reduced effectiveness to paralyzing effects";
                this.typeOne = 0;
                break;
        }

        /* same function for the second trait slot. */
        switch (this.typeTwo) {
            case -1:
                this.relicText.htmlText = "<b>Razor Sharp:</b> \n - Return a portion of the damage taken back at the attacker.";
                this.typeTwo = 8;
                break;
            case 0:
                this.relicText.htmlText = "<b>Defenseless:</b> \n - Gain physical resistance based on your hp when not wearing armor.";
                break;
            case 1:
                this.relicText.htmlText = "<b>Mithridatism:</b> \n - Take only half the damage from poisons.";
                break;
            case 2:
                this.relicText.htmlText = "<b>Healthy:</b> \n - Healing effect multiplier x1.3.";
                break;
            case 3:
                this.relicText.htmlText = "<b>Absorption:</b> \n - Gained magic resistance.";
                break;
            case 4:
                this.relicText.htmlText = "<b>Scope:</b> \n - Gain ranged weapon bonus damage.";
                break;
            case 5:
                this.relicText.htmlText = "<b>Dexterous:</b> \n - Weapon damage scales with dexterity instead of magic damage or physical damage.";
                break;
            case 6:
                this.relicText.htmlText = "<b>Holy:</b> \n - Gain additional Light damage.";
                break;
            case 7:
                this.relicText.htmlText = "<b>Incombustible:</b> \n - Take only half the damage from fire.";
                break;
            case 8:
                this.relicText.htmlText = "<b>Razor Sharp:</b> \n - Return a portion of the damage taken back at the attacker.";
                break;
            case 9:
                this.relicText.htmlText = "<b>Defenseless:</b> \n - Gain physical resistance based on your hp when not wearing armor.";
                this.typeTwo = 0;
                break;
        }

        /* same function for the second trait slot. */
        switch (this.typeThree) {
            case -1:
                this.backgroundText.htmlText = "<b>Urchin:</b> \n - Primary stat [DEX] \n - Secondary stat [SPD]";
                this.typeThree = 10;
                break;
            case 0:
                this.backgroundText.htmlText = "<b>Acolyte:</b> \n - Primary stat [INT] \n - Secondary stat [HP]";
                break;
            case 1:
                this.backgroundText.htmlText = "<b>Charlatan:</b> \n - Primary stat [DEX] \n - Secondary stat [DEX]";
                break;
            case 2:
                this.backgroundText.htmlText = "<b>Criminal:</b> \n - Primary stat [INT] \n - Secondary stat [SPD]";
                break;
            case 3:
                this.backgroundText.htmlText = "<b>Entertainer:</b> \n - Primary stat [SPD] \n - Secondary stat [RP]";
                break;
            case 4:
                this.backgroundText.htmlText = "<b>Hero:</b> \n - Primary stat [VIG] \n - Secondary stat [HP]";
                break;
            case 5:
                this.backgroundText.htmlText = "<b>Artisan:</b> \n - Primary stat [INT] \n - Secondary stat [INT]";
                break;
            case 6:
                this.backgroundText.htmlText = "<b>Noble:</b> \n - Primary stat [RP] \n - Secondary stat [INT]";
                break;
            case 7:
                this.backgroundText.htmlText = "<b>Outlander:</b> \n - Primary stat [DEX] \n - Secondary stat [HP]";
                break;
            case 8:
                this.backgroundText.htmlText = "<b>Sage:</b> \n - Primary stat [RP] \n - Secondary stat [RP]";
                break;
            case 9:
                this.backgroundText.htmlText = "<b>Soldier:</b> \n - Primary stat [DEX] \n - Secondary stat [PHYS OR MAG](HIGHEST STAT)";
                break;
            case 10:
                this.backgroundText.htmlText = "<b>Urchin:</b> \n - Primary stat [DEX] \n - Secondary stat [SPD]";
                break;
            case 11:
                this.backgroundText.htmlText = "<b>Acolyte:</b> \n - Primary stat [INT] \n - Secondary stat [HP]";
                this.typeThree = 0;
                break;
        }

        /* BaseSimpleText has a function called updateMetrics which is really convenient for updating text after certain properties change (e.g: typeOne and typeTwo). */
        this.awakeningText.updateMetrics();
        this.relicText.updateMetrics();
        this.backgroundText.updateMetrics();
    }
}
}
</file>

<file path="src/svera/untiered/ui/UIUtils.as">
package svera.untiered.ui {
import flash.display.Sprite;
import flash.display.StageQuality;

public class UIUtils {

    private static const NOTIFICATION_BACKGROUND_WIDTH:Number = 95;

    private static const NOTIFICATION_BACKGROUND_HEIGHT:Number = 25;

    private static const NOTIFICATION_BACKGROUND_ALPHA:Number = 0.4;

    private static const NOTIFICATION_BACKGROUND_COLOR:Number = 0;

    public static const NOTIFICATION_SPACE:uint = 28;


    public static function makeStaticHUDBackground():Sprite {
        var _local1:Number = NOTIFICATION_BACKGROUND_WIDTH;
        var _local2:Number = NOTIFICATION_BACKGROUND_HEIGHT;
        return makeHUDBackground(_local1, _local2);
    }

    public static function makeHUDBackground(_arg1:Number, _arg2:Number):Sprite {
        var _local3:Sprite = new Sprite();
        return drawHUDBackground(_local3, _arg1, _arg2);
    }

    private static function drawHUDBackground(_arg1:Sprite, _arg2:Number, _arg3:Number):Sprite {
        _arg1.graphics.beginFill(NOTIFICATION_BACKGROUND_COLOR, NOTIFICATION_BACKGROUND_ALPHA);
        _arg1.graphics.drawRoundRect(0, 0, _arg2, _arg3, 12, 12);
        _arg1.graphics.endFill();
        return _arg1;
    }
    public function UIUtils() {
        super();
    }

    public static function returnHudNotificationBackground():Sprite {
        var background:Sprite = new Sprite();
        background.graphics.beginFill(NOTIFICATION_BACKGROUND_COLOR, NOTIFICATION_BACKGROUND_ALPHA);
        background.graphics.drawRoundRect(0, 0, NOTIFICATION_BACKGROUND_WIDTH, NOTIFICATION_BACKGROUND_HEIGHT, 12, 12);
        background.graphics.endFill();
        return background;
    }

    public static function toggleQuality(hq:Boolean):void {
        if (GameClient.STAGE != null) {
            GameClient.STAGE.quality = hq ? StageQuality.HIGH : StageQuality.LOW;
        }
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/components/ScreenBase.as">
package svera.untiered.ui.view.components {
import com.company.assembleegameclient.ui.SoundIcon;

import flash.display.Sprite;
import flash.events.Event;

import mx.core.BitmapAsset;

public class ScreenBase extends Sprite {
    private static var currBackground:BitmapAsset = new DefaultBackground();

    public function ScreenBase(newBackground:int = 0) {
        ChangeBackground(newBackground);
        addChild(new SoundIcon());
        GameClient.STAGE.addEventListener(Event.RESIZE, OnResize, false, 0, true);
        OnResize(null);
    }

    public function OnResize(e:Event):void {
        currBackground.width = GameClient.StageWidth;
        currBackground.height = GameClient.StageHeight;
    }

    private function ChangeBackground(newBackground:int = 0):void {
        if (contains(currBackground))
            removeChild(currBackground);
        switch (newBackground) {
            case 0:
                currBackground = new DefaultBackground();
                break;
            case 1:
                currBackground = new HomescreenBackground();
                break;
            case 2:
                currBackground = new CharSelectionBackground();
                    
                break;
        }
        addChild(currBackground);
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/StatMetersView.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.StatusBar;

import flash.display.Shape;
import flash.display.Sprite;

public class StatMetersView extends Sprite {

    private var expBar_:StatusBar;

    private var honorBar:StatusBar;

    private var hpBar_:StatusBar;

    private var spBar_:StatusBar;

    private var rpBar_:StatusBar;

    private var levelMask:Shape;
    private var content:Sprite;

    public function StatMetersView() {
        this.levelMask = new Shape();
        this.content = new Sprite();
        this.content.graphics.clear();
        this.content.graphics.beginFill(0, 0);
        this.content.graphics.drawRect(0, 0, 22, 22);
        this.content.graphics.endFill();
        this.levelMask.graphics.clear();
        this.levelMask.graphics.beginFill(0, 0);
        this.levelMask.graphics.drawRect(0, 0, 22, 22);
        this.levelMask.graphics.endFill();

        this.content.mask = this.levelMask;
        this.content.addChild(this.levelMask);

        super();
        this.expBar_ = new StatusBar(72, 20, 5931045, 5526612, "Lvl X");
        this.honorBar = new StatusBar(72, 20, 14835456, 5526612, "Honor");
        this.hpBar_ = new StatusBar(245, 20, 14693428, 5526612, "HP");
        this.spBar_ = new StatusBar(245, 20, 16777215, 14693428, "SP");
        this.rpBar_ = new StatusBar(245, 20, 6325472, 5526612, "RP");
        this.hpBar_.x = 0;
        this.hpBar_.y = 0;
        this.spBar_.x = this.hpBar_.x;
        this.spBar_.y = this.hpBar_.y;
        this.rpBar_.x = this.spBar_.x;
        this.rpBar_.y = 21;
        this.expBar_.x = -72 - 1.5; // Idk some magic 2, without it its missaligned
        this.expBar_.y = this.rpBar_.y;
        this.spBar_.visible = false;
        this.expBar_.visible = true;
        this.honorBar.visible = false;
        addChild(this.expBar_);
        addChild(this.honorBar);
        addChild(this.hpBar_);
        addChild(this.spBar_);
        addChild(this.rpBar_);
        addChild(this.content);
    }

    public function update(player:Player):void {
        var lvlText:String = player.level_.toString();
        if (lvlText != this.expBar_.labelText_.text) {
            this.expBar_.labelText_.text = lvlText;
            this.expBar_.labelText_.updateMetrics();
            this.expBar_.labelText_.x = this.content.width / 2 - this.expBar_.labelText_.width / 2;
            this.expBar_.labelText_.y = this.content.height / 2 - this.expBar_.labelText_.height / 2;
            content.addChild(this.expBar_.labelText_);
        }
        if (player.level_ != 100) {
            if (!this.expBar_.visible) {
                this.expBar_.visible = true;
                this.honorBar.visible = false;
            }
            this.content.y = this.expBar_.y - 3;
            this.content.x = this.expBar_.x - 24;
            this.expBar_.valueText_.setSize(10);
            this.expBar_.valueText_.y = this.expBar_.height / 2 - this.expBar_.valueText_.height / 2;
            this.expBar_.boostText_.setSize(10);
            this.expBar_.boostText_.y = this.expBar_.valueText_.y;
            this.expBar_.draw(player.exp_, player.nextLevelExp_, 0);
        } else {
            if (!this.honorBar.visible) {
                this.honorBar.visible = true;
                this.expBar_.visible = false;
            }
            this.honorBar.draw(player.charHonor, player.nextClassQuestHonor, 0);
        }
        this.spBar_.valueText_.textColor = 16777215;
        this.spBar_.boostText_.textColor = 16777215;
        this.spBar_.visible = player.sp_ > 0;
        this.spBar_.labelText_.y = this.spBar_.height / 2 - this.spBar_.labelText_.height / 2;
        this.spBar_.valueText_.y = this.spBar_.height / 2 - this.spBar_.valueText_.height / 2;
        this.spBar_.boostText_.y = this.spBar_.height / 2 - this.spBar_.valueText_.height / 2;

        this.hpBar_.labelText_.visible = !(player.sp_ > 0);
        this.hpBar_.valueText_.visible = !(player.sp_ > 0);
        this.hpBar_.boostText_.visible = !(player.sp_ > 0);
        this.hpBar_.labelText_.y = this.hpBar_.height / 2 - this.hpBar_.labelText_.height / 2;
        this.hpBar_.valueText_.y = this.hpBar_.height / 2 - this.hpBar_.valueText_.height / 2;
        this.hpBar_.boostText_.y = this.hpBar_.height / 2 - this.hpBar_.boostText_.height / 2;

        this.rpBar_.labelText_.y = this.rpBar_.height / 2 - this.rpBar_.labelText_.height / 2;
        this.rpBar_.valueText_.y = this.rpBar_.height / 2 - this.rpBar_.valueText_.height / 2;
        this.rpBar_.boostText_.y = this.rpBar_.height / 2 - this.rpBar_.boostText_.height / 2;

        this.spBar_.draw(player.sp_, player.maxSP_, player.maxSPBoost_, player.maxSPMax_);
        this.hpBar_.draw(player.hp_, player.maxHP_, player.maxHPBoost_, player.maxHPMax_);
        this.rpBar_.draw(player.rp_, player.maxRP_, player.maxRPBoost_, player.maxRPMax_);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/GiftChest.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.GiftChestPanel;
import com.company.assembleegameclient.ui.panels.Panel;

import svera.untiered.itemdata.NewItemData;


public class GiftChest extends GameObject implements IInteractiveObject {

    public function GiftChest(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }


    public function setContainer(size:int, slots:Vector.<NewItemData>):void {
        this.equipment_ = new Vector.<NewItemData>(size);

        for (var i:int = 0; i < size; i++) {
            this.equipment_[i] = slots[i];
        }
    }

    public function getPanel(gs:GameSprite):Panel {
        return new GiftChestPanel(this, gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/VaultChest.as">
package com.company.assembleegameclient.objects {

import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.panels.VaultChestPanel;

import svera.untiered.itemdata.NewItemData;

public class VaultChest extends GameObject implements IInteractiveObject {

    public function VaultChest(objectXML:XML) {
        super(objectXML);
        isInteractive_ = true;
    }

    public function setContainer(size:int, slots:Vector.<NewItemData>):void {
        this.equipment_ = new Vector.<NewItemData>(size);

        for (var i:int = 0; i < size; i++) {
            this.equipment_[i] = slots[i];
        }
    }

    public function getPanel(gs:GameSprite):Panel {
        return new VaultChestPanel(this, gs);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/parameters/Parameters.as">
package com.company.assembleegameclient.parameters {
import com.company.util.KeyCodes;

import flash.display.DisplayObject;
import flash.events.Event;
import flash.net.SharedObject;
import flash.utils.Dictionary;

public class Parameters {
    public static var root:DisplayObject;

    public static const BUILD_VERSION:String = "0.0.1";
    public static const SERVER_ADDRESS:String = "127.0.0.1";
    public static const GAME_PORT:int = 2050;
    public static const APP_PORT:int = 8080;

    public static const SERVER_CHAT_NAME:String = "";
    public static const CLIENT_CHAT_NAME:String = "*Client*";
    public static const ERROR_CHAT_NAME:String = "*Error*";
    public static const HELP_CHAT_NAME:String = "*Help*";
    public static const GUILD_CHAT_NAME:String = "*Guild*";

    public static const FELLOW_GUILD_COLOR:uint = 10944349;
    public static const NAME_COLOUR:uint = 16572160;

    public static const GUILD_CREATION_PRICE:int = 1000;
    public static const CHARACTER_SLOT_PRICE:int = 2000;
    public static const CHARACTER_SKIN_PRICE:int = 1000;
    public static const VAULT_SLOT_PRICE:int = 1000;

    public static const MAX_SINK_LEVEL:Number = 18;
    public static const PLAYER_ROTATE_SPEED:Number = 0.003;
    public static const BREATH_THRESH:int = 20;

    public static const NEXUS_GAMEID:int = -1;
    public static const REALM_GAMEID:int = -2;
    public static const GUILD_GAMEID:int = -3;
    public static const EDITOR_GAMEID:int = -4;

    public static var data_:Object = null;
    public static var GPURenderError:Boolean = false;
    public static var GPURenderFrame:Boolean = false;

    private static var savedOptions_:SharedObject = null;
    private static var keyNames_:Dictionary = new Dictionary();

    public function Parameters() {
        super();
    }

    public static function appServerAddress():String {
        return "http://" + SERVER_ADDRESS + ":" + APP_PORT;
    }

    public static function load():void {
        try {
            savedOptions_ = SharedObject.getLocal("OWSettings", "/");
            data_ = savedOptions_.data;
        } catch (error:Error) {
            trace("WARNING: unable to save settings");
            data_ = {};
        }
        setDefaults();
        save();
    }

    public static function save():void {
        try {
            if (savedOptions_ != null) {
                savedOptions_.flush();
            }
        } catch (error:Error) {
        }
    }

    private static function setDefaultKey(keyName:String, key:uint):void {
        if (!data_.hasOwnProperty(keyName)) {
            data_[keyName] = key;
        }
        keyNames_[keyName] = true;
    }

    public static function setKey(keyName:String, key:uint):void {
        var otherKeyName:* = null;
        for (otherKeyName in keyNames_) {
            if (data_[otherKeyName] == key) {
                data_[otherKeyName] = KeyCodes.UNSET;
            }
        }
        data_[keyName] = key;
    }

    private static function setDefault(keyName:String, value:*):void {
        if (!data_.hasOwnProperty(keyName)) {
            data_[keyName] = value;
        }
    }

    public static function isGpuRender():Boolean {
        return !GPURenderError && data_.GPURender;
    }

    public static function clearGpuRenderEvent(event:Event):void {
        clearGpuRender();
    }

    public static function clearGpuRender():void {
        GPURenderError = true;
    }

    public static function setDefaults():void {
        setDefaultKey("moveLeft", KeyCodes.A);
        setDefaultKey("moveRight", KeyCodes.D);
        setDefaultKey("moveUp", KeyCodes.W);
        setDefaultKey("moveDown", KeyCodes.S);
        setDefaultKey("rotateLeft", KeyCodes.Q);
        setDefaultKey("rotateRight", KeyCodes.E);
        setDefaultKey("ability1", KeyCodes.F1);
        setDefaultKey("ability2", KeyCodes.F2);
        setDefaultKey("ability3", KeyCodes.F3);
        setDefaultKey("interact", KeyCodes.SHIFT);
        setDefaultKey("useEquipInvSlot1", KeyCodes.NUMBER_1);
        setDefaultKey("useEquipInvSlot2", KeyCodes.NUMBER_2);
        setDefaultKey("useEquipInvSlot3", KeyCodes.NUMBER_3);
        setDefaultKey("useEquipInvSlot4", KeyCodes.NUMBER_4);
        setDefaultKey("useEquipInvSlot5", KeyCodes.NUMBER_5);
        setDefaultKey("useEquipInvSlot6", KeyCodes.NUMBER_6);
        setDefaultKey("useEquipInvSlot7", KeyCodes.NUMBER_7);
        setDefaultKey("useEquipInvSlot8", KeyCodes.NUMBER_8);
        setDefaultKey("escapeToNexus", KeyCodes.R);
        setDefaultKey("escapeToNexus2", KeyCodes.F5);
        setDefaultKey("autofireToggle", KeyCodes.B);
        setDefaultKey("inventoryToggle", KeyCodes.I);
        setDefaultKey("scrollChatUp", KeyCodes.PAGE_UP);
        setDefaultKey("scrollChatDown", KeyCodes.PAGE_DOWN);
        setDefaultKey("miniMapZoomOut", KeyCodes.MINUS);
        setDefaultKey("miniMapZoomIn", KeyCodes.EQUAL);
        setDefaultKey("resetToDefaultCameraAngle", KeyCodes.Z);
        setDefaultKey("togglePerformanceStats", KeyCodes.UNSET);
        setDefaultKey("options", KeyCodes.O);
        setDefaultKey("toggleCentering", KeyCodes.X);
        setDefaultKey("chat", KeyCodes.ENTER);
        setDefaultKey("chatCommand", KeyCodes.SLASH);
        setDefaultKey("tell", KeyCodes.TAB);
        setDefaultKey("guildChat", KeyCodes.G);
        setDefaultKey("useHealthPotion", KeyCodes.F);
        setDefaultKey("useMagicPotion", KeyCodes.V);
        setDefaultKey("toggleFullscreenMode", KeyCodes.UNSET);



        setDefault("playerObjectType", 782);

        setDefault("charIdUseMap", {});
        setDefault("playMusic", true);
        setDefault("playSFX", true);
        setDefault("playPewPew", true);
        setDefault("centerOnPlayer", true);
        setDefault("preferredServer", null);

        setDefault("bindSlot1", 5);
        setDefault("bindSlot2", 6);
        setDefault("bindSlot3", 7);
        setDefault("bindSlot4", 8);
        setDefault("bindSlot5", 9);
        setDefault("bindSlot6", 10);
        setDefault("bindSlot7", 11);
        setDefault("bindSlot8", 12);

        setDefault("cameraAngle", 0);
        setDefault("defaultCameraAngle", 0);
        setDefault("showQuestPortraits", true);
        setDefault("allowRotation", true);
        setDefault("drawShadows", true);
        setDefault("textBubbles", true);
        setDefault("showTradePopup", true);
        setDefault("showGuildInvitePopup", true);
        setDefault("GPURender", true);
        setDefault("particles", true);
        setDefault("hpBars", true);
        setDefault("quality", true);
        setDefault("cursor", "4");
        setDefault("mScale", 1);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/charrects/CharacterRect.as">
package com.company.assembleegameclient.screens.charrects {
import flash.display.Bitmap;
import flash.display.Graphics;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.MouseEvent;

public class CharacterRect extends Sprite {
    public static const WIDTH:int = 96;
    public static const HEIGHT:int = 123;

    private var color_:uint;
    private var overColor_:uint;
    private var box_:Shape;
    public var selectContainer:Sprite;
    [Embed(source="CharacterRectBg.png")]
    public static var charBg:Class;
    private var bg:Bitmap = new Bitmap(new charBg().bitmapData);

    public function CharacterRect(color:uint, overColor:uint) {
        super();
        this.color_ = color;
        this.overColor_ = overColor;
        this.box_ = new Shape();
        //this.drawBox(false);
        //addChild(this.box_);
        addChild(bg);
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
    }

    protected function onMouseOver(event:MouseEvent):void {
        this.drawBox(true);
    }

    protected function onRollOut(event:MouseEvent):void {
        this.drawBox(false);
    }

    private function drawBox(over:Boolean):void {
        var g:Graphics = this.box_.graphics;
        g.clear();
        g.beginFill(over ? this.overColor_ : this.color_, over ? 1 : 0);
        g.drawRect(0, 0, WIDTH, HEIGHT);
        g.endFill();
    }

    public function makeContainer():void {
        this.selectContainer = new Sprite();
        this.selectContainer.mouseChildren = false;
        this.selectContainer.buttonMode = true;
        this.selectContainer.graphics.beginFill(16711935, 0);
        this.selectContainer.graphics.drawRect(0, 0, WIDTH, HEIGHT);
        addChild(this.selectContainer);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/charrects/CreateNewCharacterRect.as">
package com.company.assembleegameclient.screens.charrects {
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.util.AnimatedChar;
import com.company.ui.SimpleText;
import com.company.util.BitmapUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;

import svera.untiered.core.model.PlayerModel;

public class CreateNewCharacterRect extends CharacterRect {
    private var bitmap_:Bitmap;

    private var classNameText_:SimpleText;

    private var taglineIcon_:Sprite;

    private var taglineText_:SimpleText;

    public function CreateNewCharacterRect(model:PlayerModel) {
        super(5526612, 7829367);
        makeContainer();
        var playerXML:XML = ObjectLibrary.playerChars_[int(ObjectLibrary.playerChars_.length * Math.random())];
        var bd:BitmapData = SavedCharacter.getImage(null, playerXML, AnimatedChar.RIGHT, AnimatedChar.STAND, 0, false, true);
        bd = BitmapUtil.cropToBitmapData(bd, 0, 0, bd.width, bd.height);
        this.bitmap_ = new Bitmap();
        this.bitmap_.bitmapData = bd;
        this.bitmap_.scaleX = this.bitmap_.scaleX * 0.5;
        this.bitmap_.scaleY = this.bitmap_.scaleY * 0.5;
        this.bitmap_.x = this.width / 2 - this.bitmap_.width / 2;
        this.bitmap_.y = this.height / 2 - this.bitmap_.height / 2 + 3;
        selectContainer.addChild(this.bitmap_);
        this.classNameText_ = new SimpleText(12, 16777215, false, 0, 0);
        this.classNameText_.setBold(true);
        this.classNameText_.text = "New Character";
        this.classNameText_.updateMetrics();
        this.classNameText_.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.classNameText_.x = this.x + this.width / 2 - this.classNameText_.width / 2;
        this.classNameText_.y = this.y + this.height - this.classNameText_.height;
        selectContainer.addChild(this.classNameText_);
        /*if(model.getNumStars() != HonorUtil.maxStars())
        {
           this.taglineIcon_ = new StarGraphic();
           this.taglineIcon_.transform.colorTransform = new ColorTransform(179 / 255,179 / 255,179 / 255);
           this.taglineIcon_.scaleX = 1.2;
           this.taglineIcon_.scaleY = 1.2;
           this.taglineIcon_.x = 58;
           this.taglineIcon_.y = 26;
           this.taglineIcon_.filters = [new DropShadowFilter(0,0,0)];
           selectContainer.addChild(this.taglineIcon_);
           this.taglineText_ = new SimpleText(14,11776947,false,0,0);
           this.taglineText_.text = HonorUtil.maxStars() - model.getNumStars() + " Class quests not yet completed";
           this.taglineText_.updateMetrics();
           this.taglineText_.filters = [new DropShadowFilter(0,0,0,1,8,8)];
           this.taglineText_.x = 58 + this.taglineIcon_.width + 2;
           this.taglineText_.y = 24;
           selectContainer.addChild(this.taglineText_);
        }*/
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/options/Options.as">
package com.company.assembleegameclient.ui.options {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.sound.Music;
import com.company.assembleegameclient.sound.SFX;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.ScreenGraphic;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.Point;
import flash.text.TextFieldAutoSize;
import flash.ui.Mouse;
import flash.ui.MouseCursor;
import flash.ui.MouseCursorData;

import svera.untiered.ui.UIUtils;

public class Options extends Sprite {
    private static const CONTROLS_TAB:String = "Controls";
    private static const HOTKEYS_TAB:String = "Hot Keys";
    private static const CHAT_TAB:String = "Chat";
    private static const GRAPHICS_TAB:String = "Graphics";
    private static const SOUND_TAB:String = "Sound";
    private static const TABS:Vector.<String> = new <String>[CONTROLS_TAB, HOTKEYS_TAB, CHAT_TAB, GRAPHICS_TAB, SOUND_TAB];

    private static var registeredCursors:Vector.<String> = new <String>[];

    private var gs_:GameSprite;
    private var title_:SimpleText;
    private var continueButton_:TitleMenuOption;
    private var resetToDefaultsButton_:TitleMenuOption;
    private var homeButton_:TitleMenuOption;
    private var tabs_:Vector.<OptionsTabTitle>;
    private var selected_:OptionsTabTitle = null;
    private var options_:Vector.<Sprite>;
    private var optionIndex_:int = 0;

    public function Options(gs:GameSprite) {
        var tab:OptionsTabTitle = null;
        this.tabs_ = new Vector.<OptionsTabTitle>();
        this.options_ = new Vector.<Sprite>();
        super();
        this.gs_ = gs;
        graphics.clear();
        graphics.beginFill(2829099, 0.8);
        graphics.drawRect(0, 0, GameClient.StageWidth, GameClient.StageHeight);
        graphics.endFill();
        graphics.lineStyle(1, 6184542);
        graphics.moveTo(0, 100);
        graphics.lineTo(GameClient.StageWidth, 100);
        graphics.lineStyle();
        this.title_ = new SimpleText(36, 16777215, false, GameClient.StageWidth, 0);
        this.title_.setBold(true);
        this.title_.htmlText = "<p align=\"center\">Options</p>";
        this.title_.autoSize = TextFieldAutoSize.CENTER;
        this.title_.filters = [new DropShadowFilter(0, 0, 0)];
        this.title_.updateMetrics();
        this.title_.x = GameClient.StageWidth / 2 - this.title_.width / 2;
        this.title_.y = 8;
        addChild(this.title_);
        this.continueButton_ = new TitleMenuOption("continue", 36, false);
        this.continueButton_.addEventListener(MouseEvent.CLICK, this.onContinueClick);
        addChild(this.continueButton_);
        this.resetToDefaultsButton_ = new TitleMenuOption("reset to defaults", 22, false);
        this.resetToDefaultsButton_.addEventListener(MouseEvent.CLICK, this.onResetToDefaultsClick);
        addChild(this.resetToDefaultsButton_);
        this.homeButton_ = new TitleMenuOption("back to home", 22, false);
        this.homeButton_.addEventListener(MouseEvent.CLICK, this.onHomeClick);
        addChild(this.homeButton_);
        var xOffset:int = 14 + (GameClient.HalfStageWidth - 108 * TABS.length / 2);
        for (var i:int = 0; i < TABS.length; i++) {
            tab = new OptionsTabTitle(TABS[i]);
            tab.x = xOffset;
            tab.y = 70;
            addChild(tab);
            tab.addEventListener(MouseEvent.CLICK, this.onTabClick);
            this.tabs_.push(tab);
            xOffset = xOffset + 108;
        }
        addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
    }

    private function onContinueClick(event:MouseEvent):void {
        this.close();
    }

    private function onResetToDefaultsClick(event:MouseEvent):void {
        var option:Option = null;
        for (var i:int = 0; i < this.options_.length; i++) {
            option = this.options_[i] as Option;
            if (option != null) {
                delete Parameters.data_[option.paramName_];
            }
        }
        Parameters.setDefaults();
        Parameters.save();
        this.refresh();
    }

    private function onHomeClick(event:MouseEvent):void {
        this.close();
        this.gs_.closed.dispatch();
    }

    private function onTabClick(event:MouseEvent):void {
        var tab:OptionsTabTitle = event.target as OptionsTabTitle;
        this.setSelected(tab);
    }

    private function setSelected(tab:OptionsTabTitle):void {
        if (tab == this.selected_) {
            return;
        }
        if (this.selected_ != null) {
            this.selected_.setSelected(false);
        }
        this.selected_ = tab;
        this.selected_.setSelected(true);
        this.removeOptions();
        switch (this.selected_.text_) {
            case CONTROLS_TAB:
                this.addControlsOptions();
                break;
            case HOTKEYS_TAB:
                this.addHotKeysOptions();
                break;
            case CHAT_TAB:
                this.addChatOptions();
                break;
            case GRAPHICS_TAB:
                this.addGraphicsOptions();
                break;
            case SOUND_TAB:
                this.addSoundOptions();
                break;
        }
    }

    private function onResize(event:Event):void {
        this.continueButton_.x = GameClient.HalfStageWidth - this.continueButton_.width * 0.5;
        this.continueButton_.y = GameClient.StageHeight - (600 - 520);
        this.resetToDefaultsButton_.x = continueButton_.x - 300;
        this.resetToDefaultsButton_.y = GameClient.StageHeight - (600 - 532);
        this.homeButton_.x = continueButton_.x + 300;
        this.homeButton_.y = resetToDefaultsButton_.y;
        var xOffset:int = 14 + (GameClient.HalfStageWidth - 108 * TABS.length / 2);
        var tab:OptionsTabTitle = null;
        for (var i:int = 0; i < TABS.length; i++) {
            tab = tabs_[i];
            tab.x = xOffset;
            tab.y = 70;
            xOffset = xOffset + 108;
        }
    }

    private function onAddedToStage(event:Event):void {
        onResize(null);
        this.setSelected(this.tabs_[0]);
        GameClient.STAGE.addEventListener(Event.RESIZE, onResize, false, 1, true);
        stage.addEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown, false, 1, true);
        stage.addEventListener(KeyboardEvent.KEY_UP, this.onKeyUp, false, 1, true);
    }

    private function onRemovedFromStage(event:Event):void {
        stage.removeEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown, false);
        stage.removeEventListener(KeyboardEvent.KEY_UP, this.onKeyUp, false);
    }

    private function onKeyDown(event:KeyboardEvent):void {
        if (event.keyCode == Parameters.data_.options) {
            this.close();
        }
        event.stopImmediatePropagation();
    }

    private function close():void {
        stage.focus = null;
        parent.removeChild(this);
    }

    private function onKeyUp(event:KeyboardEvent):void {
        event.stopImmediatePropagation();
    }

    private function removeOptions():void {
        var option:Sprite = null;
        for each(option in this.options_) {
            removeChild(option);
        }
        this.options_.length = 0;
        this.optionIndex_ = 0;
    }

    private function addControlsOptions():void {
        this.addOption(new KeyMapper("moveUp", "Move Up", "Key to will move character up"));
        this.addOption(new KeyMapper("moveLeft", "Move Left", "Key to will move character to the left"));
        this.addOption(new KeyMapper("moveDown", "Move Down", "Key to will move character down"));
        this.addOption(new KeyMapper("moveRight", "Move Right", "Key to will move character to the right"));
        this.addOption(new ChoiceOption("allowRotation", new <String>["On", "Off"], [true, false], "Allow Camera Rotation", "Toggles whether to allow for camera rotation", this.onAllowRotationChange));
        this.addOption(new KeyMapper("rotateLeft", "Rotate Left", "Key to will rotate the camera to the left", !Parameters.data_.allowRotation));
        this.addOption(new KeyMapper("rotateRight", "Rotate Right", "Key to will rotate the camera to the right", !Parameters.data_.allowRotation));
        this.addOption(new KeyMapper("ability1", "Use Ability 1", "This key will activate your first ability"));
        this.addOption(new KeyMapper("ability2", "Use Ability 2", "This key will activate your second ability"));
        this.addOption(new KeyMapper("ability3", "Use Ability 3", "This key will activate your third ability"));
        this.addOption(new KeyMapper("autofireToggle", "Autofire Toggle", "This key will toggle autofire"));
        this.addOption(new KeyMapper("inventoryToggle", "Inventory Toggle", "This key will toggle your inventory"));
        this.addOption(new KeyMapper("resetToDefaultCameraAngle", "Reset To Default Camera Angle", "This key will reset the camera angle to the default " + "position"));
        this.addOption(new KeyMapper("togglePerformanceStats", "Toggle Performance Stats", "This key will toggle a display of fps and memory usage"));
        this.addOption(new KeyMapper("toggleCentering", "Toggle Centering of Player", "This key will toggle the position between centered and " + "offset"));
        this.addOption(new KeyMapper("interact", "Interact/Buy", "This key will allow you to enter a portal or buy an item"));
    }

    private function onAllowRotationChange():void {
        var keyMapper:KeyMapper = null;
        for (var i:int = 0; i < this.options_.length; i++) {
            keyMapper = this.options_[i] as KeyMapper;
            if (keyMapper != null) {
                if (keyMapper.paramName_ == "rotateLeft" || keyMapper.paramName_ == "rotateRight") {
                    keyMapper.setDisabled(!Parameters.data_.allowRotation);
                }
            }
        }
    }

    private function addHotKeysOptions():void {
        this.addOption(new KeyMapper("useHealthPotion", "Use Health Potion", "This key will use health potions if available"));
        this.addOption(new KeyMapper("useMagicPotion", "Use Magic Potion", "This key will use magic potions if available"));
        this.addOption(new KeyMapper("useEquipInvSlot1", "Use/Equip Inventory Slot 1", "Use/Equip item in inventory slot 1"));
        this.addOption(new KeyMapper("useEquipInvSlot2", "Use/Equip Inventory Slot 2", "Use/Equip item in inventory slot 2"));
        this.addOption(new KeyMapper("useEquipInvSlot3", "Use/Equip Inventory Slot 3", "Use/Equip item in inventory slot 3"));
        this.addOption(new KeyMapper("useEquipInvSlot4", "Use/Equip Inventory Slot 4", "Use/Equip item in inventory slot 4"));
        this.addOption(new KeyMapper("useEquipInvSlot5", "Use/Equip Inventory Slot 5", "Use/Equip item in inventory slot 5"));
        this.addOption(new KeyMapper("useEquipInvSlot6", "Use/Equip Inventory Slot 6", "Use/Equip item in inventory slot 6"));
        this.addOption(new KeyMapper("useEquipInvSlot7", "Use/Equip Inventory Slot 7", "Use/Equip item in inventory slot 7"));
        this.addOption(new KeyMapper("useEquipInvSlot8", "Use/Equip Inventory Slot 8", "Use/Equip item in inventory slot 8"));
        this.addOption(new KeyMapper("miniMapZoomIn", "Mini-Map Zoom In", "This key will zoom in the minimap"));
        this.addOption(new KeyMapper("miniMapZoomOut", "Mini-Map Zoom Out", "This key will zoom out the minimap"));
        this.addOption(new KeyMapper("escapeToNexus", "Escape To Nexus", "This key will instantly escape you to the Nexus"));
        this.addOption(new KeyMapper("options", "Show Options", "This key will bring up the options screen"));
        this.addOption(new KeyMapper("switchTabs", "Switch Tabs", "This key will switch from available tabs"));
        this.addOption(new KeyMapper("toggleFullscreenMode", "Toggle Fullscreen", "This toggles whether to go fullscreen or not"));
    }

    private function addChatOptions():void {
        this.addOption(new KeyMapper("chat", "Activate Chat", "This key will bring up the chat input box"));
        this.addOption(new KeyMapper("chatCommand", "Start Chat Command", "This key will bring up the chat with a \'/\' prepended to " + "allow for commands such as /who, /ignore, etc."));
        this.addOption(new KeyMapper("tell", "Begin Tell", "This key will bring up a tell (private message) in the chat" + " input box"));
        this.addOption(new KeyMapper("guildChat", "Begin Guild Chat", "This key will bring up a guild chat in the chat" + " input box"));
        this.addOption(new KeyMapper("scrollChatUp", "Scroll Chat Up", "This key will scroll up to older messages in the chat " + "buffer"));
        this.addOption(new KeyMapper("scrollChatDown", "Scroll Chat Down", "This key will scroll down to newer messages in the chat " + "buffer"));
    }

    private function addGraphicsOptions():void {
        this.addOption(new ChoiceOption("defaultCameraAngle", new <String>["45°", "0°"], [7 * Math.PI / 4, 0], "Default Camera Angle", "This toggles the default camera angle", onDefaultCameraAngleChange));
        this.addOption(new ChoiceOption("centerOnPlayer", new <String>["On", "Off"], [true, false], "Center On Player", "This toggles whether the player is centered or offset", null));
        this.addOption(new ChoiceOption("showQuestPortraits", new <String>["On", "Off"], [true, false], "Show Quest Portraits", "This toggles whether quest portraits are displayed", this.onShowQuestPortraitsChange));
        this.addOption(new ChoiceOption("drawShadows", new <String>["On", "Off"], [true, false], "Draw Shadows", "This toggles whether to draw shadows", null));
        this.addOption(new ChoiceOption("textBubbles", new <String>["On", "Off"], [true, false], "Draw Text Bubbles", "This toggles whether to draw text bubbles", null));
        this.addOption(new ChoiceOption("showTradePopup", new <String>["On", "Off"], [true, false], "Show Trade Request Panel", "This toggles whether to show trade requests in the lower-right panel or just in chat.", null));
        this.addOption(new ChoiceOption("showGuildInvitePopup", new <String>["On", "Off"], [true, false], "Show Guild Invite Panel", "This toggles whether to show guild invites in the lower-right panel or just in chat.", null));
        this.addOption(new ChoiceOption("particles", new <String>["On", "Off"], [true, false], "Particles", "If enabled, particles which are not necessary for gameplay are rendered (e.g. hit/death particles).", null));
        this.addOption(new ChoiceOption("hpBars", new <String>["On", "Off"], [true, false], "Health Bars", "Enabling this will render health bars below entities.", null));
        this.addOption(new ChoiceOption("quality", new <String>["High", "Low"], [true, false], "Quality", "Enabling this will render UI elements at higher/lower quality.", onQualityToggle));
        this.addOption(new ChoiceOption("cursor", new <String>[
                    "OS", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"],
                [MouseCursor.AUTO, "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"], "Cursor", "Changing this will give you a new mouse cursor.", refreshCursor));

        if (!Parameters.GPURenderError) {
            this.addOption(new ChoiceOption("GPURender", new <String>["On", "Off"], [true, false], "Hardware Acceleration", "Enables Hardware Acceleration if your system supports it", null));
        }
    }

    public static function refreshCursor():void {
        var cursorData:MouseCursorData;
        var bitmapData:Vector.<BitmapData>;
        if (!(Parameters.data_.cursor == MouseCursor.AUTO) && registeredCursors.indexOf(Parameters.data_.cursor) == -1) {
            cursorData = new MouseCursorData();
            cursorData.hotSpot = new Point(15, 15);
            bitmapData = new Vector.<BitmapData>(1, true);
            bitmapData[0] = AssetLibrary.getImageFromSet("cursorsEmbed", int(Parameters.data_.cursor));
            cursorData.data = bitmapData;
            Mouse.registerCursor(Parameters.data_.cursor, cursorData);
            registeredCursors.push(Parameters.data_.cursor);
        }
        Mouse.cursor = Parameters.data_.cursor;
    }

    private static function onQualityToggle():void {
        UIUtils.toggleQuality(Parameters.data_.quality);
    }

    private static function onDefaultCameraAngleChange():void {
        Parameters.data_.cameraAngle = Parameters.data_.defaultCameraAngle;
        Parameters.save();
    }

    private function onShowQuestPortraitsChange():void {
        if (this.gs_ != null && this.gs_.map != null && this.gs_.map.partyOverlay_ != null && this.gs_.map.partyOverlay_.questArrow_ != null) {
            this.gs_.map.partyOverlay_.questArrow_.refreshToolTip();
        }
    }

    private function addSoundOptions():void {
        this.addOption(new ChoiceOption("playMusic", new <String>["On", "Off"], [true, false], "Play Music", "This toggles whether music is played", this.onPlayMusicChange));
        this.addOption(new Sprite());
        this.addOption(new ChoiceOption("playSFX", new <String>["On", "Off"], [true, false], "Play Sound Effects", "This toggles whether sound effects are played", this.onPlaySoundEffectsChange));
        this.addOption(new Sprite());
        this.addOption(new ChoiceOption("playPewPew", new <String>["On", "Off"], [true, false], "Play Weapon Sounds", "This toggles whether weapon sounds are played", null));
    }

    private function onPlayMusicChange():void {
        Music.setPlayMusic(Parameters.data_.playMusic);
    }

    private function onPlaySoundEffectsChange():void {
        SFX.setPlaySFX(Parameters.data_.playSFX);
    }

    private function addOption(option:Sprite):void {
        option.x = GameClient.HalfStageWidth - (optionIndex_ % 2 == 0 ? -20 : 300) ;
        option.y = int(this.optionIndex_ / 2) * 44 + 122;
        addChild(option);
        option.addEventListener(Event.CHANGE, this.onChange);
        this.options_.push(option);
        this.optionIndex_++;
    }

    private function onChange(event:Event):void {
        this.refresh();
    }

    private function refresh():void {
        var option:Option = null;
        for (var i:int = 0; i < this.options_.length; i++) {
            option = this.options_[i] as Option;
            if (option != null) {
                option.refresh();
            }
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/BindTile.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.filters.DropShadowFilter;

import svera.untiered.itemdata.NewItemData;

public class BindTile extends ItemTile {
    public var hotKey:String;

    private var hotKeyBMP:Bitmap;

    public function BindTile(id:int, parentGrid:ItemGrid) {
        super(id, parentGrid);
    }

    public function addTileNumber(tileNumber:int):void {
        this.hotKey = String.fromCharCode(Parameters.data_["useEquipInvSlot" + String(tileNumber)]);
        this.buildHotKeyBMP();
    }

    public function buildHotKeyBMP():void {
        var tempText:SimpleText = new SimpleText(12, 0x5b4c96, false, 0, 0);
        tempText.text = hotKey;
        tempText.setBold(true);
        tempText.updateMetrics();
        var bmpData:BitmapData = new BitmapData(20, 20, true, 0);
        bmpData.draw(tempText);
        this.hotKeyBMP = new Bitmap(bmpData);
        this.hotKeyBMP.x = 0 - 2;
        this.hotKeyBMP.y = 0 - 3;
        hotKeyBMP.filters = [new DropShadowFilter(0, 0, 0, 1.0, 1.5, 1.5, 255)];
        addChild(hotKeyBMP);
    }

    override public function setItemSprite(newItemSprite:ItemTileSprite):void {
        super.setItemSprite(newItemSprite);
        newItemSprite.setDim(false);
    }

    override public function setItem(itemId:NewItemData):Boolean {
        var changed:Boolean = super.setItem(itemId);
        return changed;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/ItemTileSprite.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.ui.tooltip.TooltipHelper;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.filters.ColorMatrixFilter;
import flash.geom.Matrix;

import svera.untiered.constants.ItemConstants;
import svera.untiered.itemdata.NewItemData;
import svera.untiered.itemdata.TierHelper;

public class ItemTileSprite extends Sprite {

    protected static const DIM_FILTER:Array = [new ColorMatrixFilter([0.4, 0, 0, 0, 0, 0, 0.4, 0, 0, 0, 0, 0, 0.4, 0, 0, 0, 0, 0, 1, 0])];

    private static const DOSE_MATRIX:Matrix = new Matrix(1, 0, 0, 1, 10, 5);

    public var itemData:NewItemData;
    public var tierText:SimpleText;

    public var itemBitmap:Bitmap;

    public function ItemTileSprite() {
        super();
        this.itemBitmap = new Bitmap();
        tierText = new SimpleText(12, 0xFFFFFF);
        addChild(this.itemBitmap);
        addChild(tierText);
        this.itemData = null;
    }

    public function setDim(dim:Boolean):void {
        filters = dim ? DIM_FILTER : null;
    }

    public function setType(newItem:NewItemData):void {
        itemData = newItem;

        if (itemData == null) {
            visible = false;
            return;
        }

        var texture:BitmapData = ObjectLibrary.getRedrawnTextureFromType(itemData.ObjectType, 80, true);

        if (itemData.Doses > 0) {
            texture = texture.clone();
            var tempText:SimpleText = new SimpleText(12, 16777215, false, 0, 0);
            tempText.text = String(itemData.Doses);
            tempText.updateMetrics();
            texture.draw(tempText, DOSE_MATRIX);
        }

        if (tierText.visible = TierHelper.setTierText(tierText, itemData.TierType)) {
            tierText.x = 12;
            tierText.y = 12;
        }

        itemBitmap.bitmapData = texture;
        itemBitmap.x = -texture.width / 2;
        itemBitmap.y = -texture.height / 2;
        visible = true;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/TradeSlot.as">
package com.company.assembleegameclient.ui {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;
import com.company.util.MoreColorUtil;
import com.company.util.SpriteUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.CapsStyle;
import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.GraphicsStroke;
import flash.display.IGraphicsData;
import flash.display.JointStyle;
import flash.display.LineScaleMode;
import flash.display.Shape;
import flash.geom.Matrix;
import flash.geom.Point;

import svera.untiered.itemdata.NewItemData;

public class TradeSlot extends Slot {

    private static const DOSE_MATRIX:Matrix = function ():Matrix {
        var m:* = new Matrix();
        m.translate(10, 5);
        return m;
    }();


    public var id:uint;

    public var itemType_:NewItemData;

    public var tradeable_:Boolean;

    public var included_:Boolean;

    public var itemBitmap_:Bitmap;

    public var overlay_:Shape;

    private var overlayFill_:GraphicsSolidFill;

    private var lineStyle_:GraphicsStroke;

    private var overlayPath_:GraphicsPath;

    private var graphicsData_:Vector.<IGraphicsData>;

    public function TradeSlot(itemType:NewItemData, tradeable:Boolean, included:Boolean, type:int, hotkey:int, cuts:Array, id:uint) {
        var texture:BitmapData = null;
        var eqXML:XML = null;
        var offset:Point = null;
        var tempText:SimpleText = null;
        this.overlayFill_ = new GraphicsSolidFill(16711310, 1);
        this.lineStyle_ = new GraphicsStroke(2, false, LineScaleMode.NORMAL, CapsStyle.NONE, JointStyle.ROUND, 3, this.overlayFill_);
        this.overlayPath_ = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());
        this.graphicsData_ = new <IGraphicsData>[this.lineStyle_, this.overlayPath_, GraphicsUtil.END_STROKE];
        super(type, hotkey, cuts);
        this.id = id;
        this.itemType_ = itemType;
        this.tradeable_ = tradeable;
        this.included_ = included;
        if (this.itemType_.ObjectType != -1) {
            SpriteUtil.safeRemoveChild(this, backgroundImage_);
            texture = ObjectLibrary.getRedrawnTextureFromType(this.itemType_.ObjectType, 80, true);
            eqXML = ObjectLibrary.xmlLibrary_[this.itemType_];
            if (eqXML.hasOwnProperty("Doses")) {
                texture = texture.clone();
                tempText = new SimpleText(12, 16777215, false, 0, 0);
                tempText.text = String(eqXML.Doses);
                tempText.updateMetrics();
                texture.draw(tempText, DOSE_MATRIX);
            }
            offset = offsets(this.itemType_.ObjectType, type_, false);
            this.itemBitmap_ = new Bitmap(texture);
            this.itemBitmap_.x = WIDTH / 2 - this.itemBitmap_.width / 2 + offset.x;
            this.itemBitmap_.y = HEIGHT / 2 - this.itemBitmap_.height / 2 + offset.y;
            SpriteUtil.safeAddChild(this, this.itemBitmap_);
        }
        if (!this.tradeable_) {
            transform.colorTransform = MoreColorUtil.veryDarkCT;
        }
        this.overlay_ = this.getOverlay();
        addChild(this.overlay_);
        this.setIncluded(included);
    }

    public function setIncluded(included:Boolean):void {
        this.included_ = included;
        this.overlay_.visible = this.included_;
        if (this.included_) {
            fill_.color = 16764247;
        } else {
            fill_.color = 5526612;
        }
        drawBackground();
    }

    private function getOverlay():Shape {
        var shape:Shape = new Shape();
        GraphicsUtil.clearPath(this.overlayPath_);
        GraphicsUtil.drawCutEdgeRect(0, 0, WIDTH, HEIGHT, 4, cuts_, this.overlayPath_);
        shape.graphics.drawGraphicsData(this.graphicsData_);
        return shape;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/ConditionEffect.as">
package com.company.assembleegameclient.util {
import com.company.assembleegameclient.util.redrawers.GlowRedrawer;
import com.company.util.AssetLibrary;
import com.company.util.PointUtil;

import flash.display.BitmapData;
import flash.filters.BitmapFilterQuality;
import flash.filters.GlowFilter;
import flash.geom.Matrix;

public class ConditionEffect {
    public static const NOTHING:uint = 0;
    public static const DEAD:uint = 1;
    public static const MUTE:uint = 2;
    public static const DEFICIENT:uint = 3;
    public static const SLUGGISH:uint = 4;
    public static const NAUSEA:uint = 5;
    public static const EXHAUST:uint = 6;
    public static const STUNNED:uint = 7;
    public static const BLIND:uint = 8;
    public static const HALLUCINATING:uint = 9;
    public static const DRUNK:uint = 10;
    public static const DISORIENT:uint = 11;
    public static const STUN_IMMUNE:uint = 12;
    public static const INVISIBLE:uint = 13;
    public static const BIND:uint = 14;
    public static const SWIFT:uint = 15;
    public static const HEMORRHAGE:uint = 16;
    public static const VULNERABLE_IMMUNE:uint = 17;
    public static const REGENERATE:uint = 18;
    public static const STRENGTHEN:uint = 19;
    public static const FURY:uint = 20;
    public static const PAUSED:uint = 21;
    public static const CRIPPLE:uint = 22;
    public static const CRIPPLE_IMMUNE:uint = 23;
    public static const IMMORTAL:uint = 24;
    public static const INVULNERABLE:uint = 25;
    public static const HARDEN:uint = 26;
    public static const VULNERABLE:uint = 27;
    public static const HEXED:uint = 28;
    public static const NINJA_SPEEDY:uint = 29;
    public static const CONCUSS:uint = 30;
    public static const NEARSIGHT:uint = 31;
    public static const SLUGGISH_IMMUNE:uint = 32;
    public static const EXHAUST_IMMUNE:uint = 33;
    public static const BIND_IMMUNE:uint = 34;
    public static const TERRIFY:uint = 35;
    public static const TERRIFY_IMMUNE:uint = 36;
    public static const SWIFTNESS:uint = 37;
    public static const FRAGILE:uint = 38;
    public static const FRAGILE_IMMUNE:uint = 39;
    public static const HP_BOOST:uint = 40;
    public static const MP_BOOST:uint = 41;
    public static const ATT_BOOST:uint = 42;
    public static const DEF_BOOST:uint = 43;
    public static const SPD_BOOST:uint = 44;
    public static const DEX_BOOST:uint = 45;
    public static const VIT_BOOST:uint = 46;
    public static const WIS_BOOST:uint = 47;
    public static const CD_BOOST:uint = 48;
    public static const CC_BOOST:uint = 49;
    public static const RES_BOOST:uint = 50;
    public static const SH_BOOST:uint = 51;
    public static const HIDDEN:uint = 52;
    public static const MUTED:int = 53;
    public static const INTELLIGENCE:int = 54;
    public static const PRECISION:int = 55;
    public static const DISABLE:int = 56;
    public static const CHARGE:int = 57;
    public static const WITHER:int = 58;
    public static const GRASPOFZOL:int = 59;
    public static const SAMURAIBERSERK:int = 60;
    public static const TRIBESWARCRY:int = 61;
    public static const RELENTLESS:int = 62;
    public static const VENGEANCE:int = 63;
    public static const MANARECOVERY:int = 64;
    public static const ALLIANCE:int = 65;
    public static const HEALTHRECOVERY:int = 66;
    public static const DEFICIENT_IMMUNE:uint = 67;
    public static const HEMORRHAGE_IMMUNE:uint = 68;
    public static const AAMBITION:uint = 69;
    public static const UNTOUCHABLE:uint = 70;
    public static const FROZENRESOLVE:uint = 71;
    public static const BMEFFECT:uint = 72;
    public static const WARMEDUP:uint = 73;
    public static const KARMASHONOR:uint = 74;
    public static const ONEFORTHETEAM:uint = 75;
    public static const TSUNAMISFURY:uint = 76;
    public static const DOWNED:uint = 77;

    public static const GROUND_DAMAGE:uint = 99;
    public static const SIZE:uint = 100;

// batch 1
    public static const DEAD_BIT:uint = 1 << DEAD - 1;
    public static const MUTE_BIT:uint = 1 << MUTE - 1;
    public static const DEFICIENT_BIT:uint = 1 << DEFICIENT - 1;
    public static const SLUGGISH_BIT:uint = 1 << SLUGGISH - 1;
    public static const NAUSEA_BIT:uint = 1 << NAUSEA - 1;
    public static const EXHAUST_BIT:uint = 1 << EXHAUST - 1;
    public static const STUNNED_BIT:uint = 1 << STUNNED - 1;
    public static const BLIND_BIT:uint = 1 << BLIND - 1;
    public static const HALLUCINATING_BIT:uint = 1 << HALLUCINATING - 1;
    public static const DRUNK_BIT:uint = 1 << DRUNK - 1;
    public static const DISORIENT_BIT:uint = 1 << DISORIENT - 1;
    public static const STUN_IMMUNE_BIT:uint = 1 << STUN_IMMUNE - 1;
    public static const INVISIBLE_BIT:uint = 1 << INVISIBLE - 1;
    public static const BIND_BIT:uint = 1 << BIND - 1;
    public static const SWIFT_BIT:uint = 1 << SWIFT - 1;
    public static const HEMORRHAGE_BIT:uint = 1 << HEMORRHAGE - 1;
    public static const VULNERABLE_IMMUNE_BIT:uint = 1 << VULNERABLE_IMMUNE - 1;
    public static const REGENERATE_BIT:uint = 1 << REGENERATE - 1;
    public static const STRENGTHEN_BIT:uint = 1 << STRENGTHEN - 1;
    public static const FURY_BIT:uint = 1 << FURY - 1;
    public static const PAUSED_BIT:uint = 1 << PAUSED - 1;
    public static const CRIPPLE_BIT:uint = 1 << CRIPPLE - 1;
    public static const CRIPPLE_IMMUNE_BIT:uint = 1 << CRIPPLE_IMMUNE - 1;
    public static const IMMORTAL_BIT:uint = 1 << IMMORTAL - 1;
    public static const INVULNERABLE_BIT:uint = 1 << INVULNERABLE - 1;
    public static const HARDEN_BIT:uint = 1 << HARDEN - 1;
    public static const VULNERABLE_BIT:uint = 1 << VULNERABLE - 1;
    public static const HEXED_BIT:uint = 1 << HEXED - 1;
    public static const NINJA_SPEEDY_BIT:uint = 1 << NINJA_SPEEDY - 1;
    public static const CONCUSS_BIT:uint = 1 << CONCUSS - 1;
    public static const NEARSIGHT_BIT:uint = 1 << NEARSIGHT - 1;
    public static const SLUGGISH_IMMUNE_BIT:uint = 1 << SLUGGISH_IMMUNE - 1;

    // batch 2
    public static const EXHAUST_IMMUNE_BIT:uint = 1 << EXHAUST_IMMUNE - FIRST_BATCH_THREASHOLD;
    public static const BIND_IMMUNE_BIT:uint = 1 << BIND_IMMUNE - FIRST_BATCH_THREASHOLD;
    public static const TERRIFY_BIT:uint = 1 << TERRIFY - FIRST_BATCH_THREASHOLD;
    public static const TERRIFY_IMMUNE_BIT:uint = 1 << TERRIFY_IMMUNE - FIRST_BATCH_THREASHOLD;
    public static const SWIFTNESS_BIT:uint = 1 << SWIFTNESS - FIRST_BATCH_THREASHOLD;
    public static const FRAGILE_BIT:uint = 1 << FRAGILE - FIRST_BATCH_THREASHOLD;
    public static const FRAGILE_IMMUNE_BIT:uint = 1 << FRAGILE_IMMUNE - FIRST_BATCH_THREASHOLD;
    public static const HP_BOOST_BIT:uint = 1 << HP_BOOST - FIRST_BATCH_THREASHOLD;
    public static const MP_BOOST_BIT:uint = 1 << MP_BOOST - FIRST_BATCH_THREASHOLD;
    public static const ATT_BOOST_BIT:uint = 1 << ATT_BOOST - FIRST_BATCH_THREASHOLD;
    public static const DEF_BOOST_BIT:uint = 1 << DEF_BOOST - FIRST_BATCH_THREASHOLD;
    public static const SPD_BOOST_BIT:uint = 1 << SPD_BOOST - FIRST_BATCH_THREASHOLD;
    public static const DEX_BOOST_BIT:uint = 1 << DEX_BOOST - FIRST_BATCH_THREASHOLD;
    public static const VIT_BOOST_BIT:uint = 1 << VIT_BOOST - FIRST_BATCH_THREASHOLD;
    public static const WIS_BOOST_BIT:uint = 1 << WIS_BOOST - FIRST_BATCH_THREASHOLD;
    public static const CD_BOOST_BIT:uint = 1 << CD_BOOST - FIRST_BATCH_THREASHOLD;
    public static const CC_BOOST_BIT:uint = 1 << CC_BOOST - FIRST_BATCH_THREASHOLD;
    public static const RES_BOOST_BIT:uint = 1 << RES_BOOST - FIRST_BATCH_THREASHOLD;
    public static const SH_BOOST_BIT:uint = 1 << SH_BOOST - FIRST_BATCH_THREASHOLD;
    public static const HIDDEN_BIT:uint = 1 << HIDDEN - FIRST_BATCH_THREASHOLD;
    public static const MUTED_BIT:int = 1 << MUTED - FIRST_BATCH_THREASHOLD;
    public static const INTELLIGENCE_BIT:int = 1 << INTELLIGENCE - FIRST_BATCH_THREASHOLD;
    public static const PRECISION_BIT:int = 1 << PRECISION - FIRST_BATCH_THREASHOLD;
    public static const DISABLE_BIT:int = 1 << DISABLE - FIRST_BATCH_THREASHOLD;
    public static const CHARGE_BIT:int = 1 << CHARGE - FIRST_BATCH_THREASHOLD;
    public static const WITHER_BIT:int = 1 << WITHER - FIRST_BATCH_THREASHOLD;
    public static const GRASPOFZOL_BIT:int = 1 << GRASPOFZOL - FIRST_BATCH_THREASHOLD;
    public static const SAMURAIBERSERK_BIT:int = 1 << SAMURAIBERSERK - FIRST_BATCH_THREASHOLD;
    public static const TRIBESWARCRY_BIT:int = 1 << TRIBESWARCRY - FIRST_BATCH_THREASHOLD;
    public static const RELENTLESS_BIT:int = 1 << RELENTLESS - FIRST_BATCH_THREASHOLD;
    public static const VENGEANCE_BIT:int = 1 << VENGEANCE - FIRST_BATCH_THREASHOLD;

    // batch 3
    public static const MANARECOVERY_BIT:int = 1 << MANARECOVERY - SECOND_BATCH_THREASHOLD;
    public static const ALLIANCE_BIT:int = 1 << ALLIANCE - SECOND_BATCH_THREASHOLD;
    public static const HEALTHRECOVERY_BIT:int = 1 << HEALTHRECOVERY - SECOND_BATCH_THREASHOLD;
    public static const DEFICIENT_IMMUNE_BIT:uint = 1 << DEFICIENT_IMMUNE - SECOND_BATCH_THREASHOLD;
    public static const HEMORRHAGE_IMMUNE_BIT:uint = 1 << HEMORRHAGE_IMMUNE - SECOND_BATCH_THREASHOLD;
    public static const AAMBITION_BIT:uint = 1 << AAMBITION - SECOND_BATCH_THREASHOLD;
    public static const UNTOUCHABLE_BIT:uint = 1 << UNTOUCHABLE - SECOND_BATCH_THREASHOLD;
    public static const FROZENRESOLVE_BIT:uint = 1 << FROZENRESOLVE - SECOND_BATCH_THREASHOLD;
    public static const BMEFFECT_BIT:uint = 1 << BMEFFECT - SECOND_BATCH_THREASHOLD;
    public static const WARMEDUP_BIT:uint = 1 << WARMEDUP - SECOND_BATCH_THREASHOLD;
    public static const KARMASHONOR_BIT:uint = 1 << KARMASHONOR - SECOND_BATCH_THREASHOLD;
    public static const ONEFORTHETEAM_BIT:uint = 1 << ONEFORTHETEAM - SECOND_BATCH_THREASHOLD;
    public static const TSUNAMISFURY_BIT:uint = 1 << TSUNAMISFURY - SECOND_BATCH_THREASHOLD;
    public static const DOWNED_BIT:uint = 1 << DOWNED - SECOND_BATCH_THREASHOLD;

    // other stuff
    public static const MAP_FILTER_BITMASK:uint = DRUNK_BIT | BLIND_BIT | PAUSED_BIT;
    public static const PROJ_NOHIT_BITMASK:uint = IMMORTAL_BIT | CRIPPLE_BIT | PAUSED_BIT;

    // misc
    public static const CE_FIRST_BATCH:uint = 0;
    public static const CE_SECOND_BATCH:uint = 1;
    public static const CE_THIRD_BATCH:uint = 2;
    public static const FIRST_BATCH_THREASHOLD:uint = 32;
    public static const SECOND_BATCH_THREASHOLD:uint = 64;
    public static const THIRD_BATCH_THREASHOLD:uint = 96;
    private static const GLOW_FILTER:GlowFilter = new GlowFilter(0, 0.3, 6, 6, 2, BitmapFilterQuality.LOW, false, false);

    public static var effects_:Vector.<ConditionEffect> =
            new <ConditionEffect>[
                new ConditionEffect("", 0, null),//Nothing Effect
                new ConditionEffect("Dead", DEAD_BIT, null),
                new ConditionEffect("Mute", MUTE_BIT, [0], true, "StatusIcons16x16"),
                new ConditionEffect("Deficient", DEFICIENT_BIT, [1], true, "StatusIcons16x16"),
                new ConditionEffect("Sluggish", SLUGGISH_BIT, [2], true, "StatusIcons16x16"),
                new ConditionEffect("Nausea", NAUSEA_BIT, [3], true, "StatusIcons16x16"),
                new ConditionEffect("Exhaust", EXHAUST_BIT, [4], true, "StatusIcons16x16"),
                new ConditionEffect("Stunned", STUNNED_BIT, [5], true, "StatusIcons16x16"),
                new ConditionEffect("Blind", BLIND_BIT, [41]),
                new ConditionEffect("Hallucinating", HALLUCINATING_BIT, [42]),
                new ConditionEffect("Drunk", DRUNK_BIT, [43]),
                new ConditionEffect("Disorient", DISORIENT_BIT, [6], true, "StatusIcons16x16"),
                new ConditionEffect("Stun Immune", STUN_IMMUNE_BIT, null),
                new ConditionEffect("Invisible", INVISIBLE_BIT, [7], true, "StatusIcons16x16"),
                new ConditionEffect("Bind", BIND_BIT, [8], true, "StatusIcons16x16"),
                new ConditionEffect("Swift", SWIFT_BIT, [9], true, "StatusIcons16x16"),
                new ConditionEffect("Hemorrhage", HEMORRHAGE_BIT, [10], true, "StatusIcons16x16"),
                new ConditionEffect("Vulnerable Immune", VULNERABLE_IMMUNE_BIT, null),
                new ConditionEffect("Regenerate", REGENERATE_BIT, [11], true, "StatusIcons16x16"),
                new ConditionEffect("Strengthen", STRENGTHEN_BIT, [12], true, "StatusIcons16x16"),
                new ConditionEffect("Fury", FURY_BIT, [13], true, "StatusIcons16x16"),
                new ConditionEffect("Paused", PAUSED_BIT, null),
                new ConditionEffect("Cripple", CRIPPLE_BIT, [14], true, "StatusIcons16x16"),
                new ConditionEffect("Cripple Immune", CRIPPLE_IMMUNE_BIT, null),
                new ConditionEffect("Immortal", IMMORTAL_BIT, null),
                new ConditionEffect("Invulnerable", INVULNERABLE_BIT, [16], true, "StatusIcons16x16"),
                new ConditionEffect("Harden", HARDEN_BIT, [17], true, "StatusIcons16x16"),
                new ConditionEffect("Vulnerable", VULNERABLE_BIT, [18], true, "StatusIcons16x16"),
                new ConditionEffect("Hexed", HEXED_BIT, [42]),
                new ConditionEffect("Ninja Speedy", NINJA_SPEEDY_BIT, [9], true, "StatusIcons16x16"),
                new ConditionEffect("Concuss", CONCUSS_BIT, [19], true, "StatusIcons16x16"),
                new ConditionEffect("Nearsight", NEARSIGHT_BIT, [20], true, "StatusIcons16x16"),
                new ConditionEffect("Sluggish Immune", SLUGGISH_IMMUNE_BIT, null),
                new ConditionEffect("Deficient Immune", DEFICIENT_IMMUNE_BIT, null),
                new ConditionEffect("Hemorrhage Immune", HEMORRHAGE_IMMUNE_BIT, null),
                new ConditionEffect("Exhaust Immune", EXHAUST_IMMUNE_BIT, null),
                new ConditionEffect("Bind Immune", BIND_IMMUNE_BIT, null),
                new ConditionEffect("Terrify", TERRIFY_BIT, [21], true, "StatusIcons16x16"),
                new ConditionEffect("Terrify Immune", TERRIFY_IMMUNE_BIT, null),
                new ConditionEffect("Swiftness", SWIFTNESS_BIT, [72]),
                new ConditionEffect("Fragile", FRAGILE_BIT, [22], true, "StatusIcons16x16"),
                new ConditionEffect("Fragile Immune", FRAGILE_IMMUNE_BIT, null),
                new ConditionEffect("HP Boost", HP_BOOST_BIT, [64], true, "StatusIcons16x16"),
                new ConditionEffect("MP Boost", MP_BOOST_BIT, [65], true, "StatusIcons16x16"),
                new ConditionEffect("Attack Boost", ATT_BOOST_BIT, [66], true, "StatusIcons16x16"),
                new ConditionEffect("Damage Reduction Boost", DEF_BOOST_BIT, [67], true, "StatusIcons16x16"),
                new ConditionEffect("Speed Boost", SPD_BOOST_BIT, [68], true, "StatusIcons16x16"),
                new ConditionEffect("Vigor Boost", VIT_BOOST_BIT, [70], true, "StatusIcons16x16"),
                new ConditionEffect("Intellect Boost", WIS_BOOST_BIT, [71], true, "StatusIcons16x16"),
                new ConditionEffect("Dexterity Boost", DEX_BOOST_BIT, [69], true, "StatusIcons16x16"),
                new ConditionEffect("Critical Damage Boost", CD_BOOST_BIT, [72], true, "StatusIcons16x16"),
                new ConditionEffect("Critical Chance Boost", CC_BOOST_BIT, [73], true, "StatusIcons16x16"),
                new ConditionEffect("Restoration Boost", RES_BOOST_BIT, [74], true, "StatusIcons16x16"),
                new ConditionEffect("Overshield Boost", SH_BOOST_BIT, [75], true, "StatusIcons16x16"),
                new ConditionEffect("Hidden", HIDDEN_BIT, [27], true),
                new ConditionEffect("Muted", MUTED_BIT, [21], true),
                new ConditionEffect("Intelligence", INTELLIGENCE_BIT, [23], true, "StatusIcons16x16"),
                new ConditionEffect("Precision", PRECISION_BIT, [24], true, "StatusIcons16x16"),
                new ConditionEffect("Disable", DISABLE_BIT, [25], true, "StatusIcons16x16"),
                new ConditionEffect("Charge", CHARGE_BIT, [26], true, "StatusIcons16x16"),
                new ConditionEffect("Wither", WITHER_BIT, [27], true, "StatusIcons16x16"),
                new ConditionEffect("Samurai Berserk", SAMURAIBERSERK_BIT, [50], true, "StatusIcons16x16"),
                new ConditionEffect("Tribe's Warcry", TRIBESWARCRY_BIT, [24], true, "StatusIcons16x16"),
                new ConditionEffect("GraspofZol", GRASPOFZOL_BIT, [64]),
                new ConditionEffect("Relentless", RELENTLESS_BIT, [67]),
                new ConditionEffect("Vengeance", VENGEANCE_BIT, [68]),
                new ConditionEffect("ManaRecovery", MANARECOVERY_BIT, [69]),
                new ConditionEffect("Alliance", ALLIANCE_BIT, [70]),
                new ConditionEffect("HealthRecovery", HEALTHRECOVERY_BIT, [71]),
                new ConditionEffect("AAmbition", AAMBITION_BIT, null),
                new ConditionEffect("Untouchable", UNTOUCHABLE_BIT, null),
                new ConditionEffect("Frozen Resolve", FROZENRESOLVE_BIT, [17], true, "StatusIcons16x16"),
                new ConditionEffect("BladeMaster Effect", BMEFFECT_BIT, [9], true, "StatusIcons16x16"),
                new ConditionEffect("Warmed Up", WARMEDUP_BIT, null),
                new ConditionEffect("Karma's Honor", KARMASHONOR_BIT, null),
                new ConditionEffect("One for the Team", ONEFORTHETEAM_BIT, null),
                new ConditionEffect("Tsunami's Fury", TSUNAMISFURY_BIT, null),
                new ConditionEffect("Downed", DOWNED_BIT, null)
            ];

    private static var conditionEffectFromName_:Object = null;
    private static var effectIconCache:Object = null;
    private static var bitToIcon_:Object = null;
    private static var bitToIcon2_:Object = null;
    private static var bitToIcon3_:Object = null;

    public var name_:String;
    public var bit_:uint;
    public var iconOffsets_:Array;
    public var localizationKey_:String;
    public var icon16Bit_:Boolean;
    public var imageSet_:String;

    public function ConditionEffect(name:String, bit:uint, iconOffsets:Array, icon16Bit:Boolean = false, _imageSet:String = null) {
        name_ = name;
        bit_ = bit;
        iconOffsets_ = iconOffsets;
        localizationKey_ = name;
        icon16Bit_ = icon16Bit;
        imageSet_ = _imageSet;
    }
    public static function getConditionEffectFromName(name:String):uint {
        var ce:uint = 0;
        if (conditionEffectFromName_ == null) {
            conditionEffectFromName_ = {};
            for (ce = 0; ce < effects_.length; ce++) {
                conditionEffectFromName_[effects_[ce].name_] = ce;
            }
        }
        return conditionEffectFromName_[name];
    }

    public static function getConditionEffectIcons(condition:uint, icons:Vector.<BitmapData>, index:int):void {
        var newCondition:uint = 0;
        var bit:uint = 0;
        var iconList:Vector.<BitmapData> = null;
        while (condition != 0) {
            newCondition = condition & condition - 1;
            bit = condition ^ newCondition;
            iconList = getIconsFromBit(bit);
            if (iconList != null) {
                icons.push(iconList[index % iconList.length]);
            }
            condition = newCondition;
        }
    }

    public static function getConditionEffectIcons2(condition:uint, icons:Vector.<BitmapData>, index:int):void {
        var newCondition:uint;
        var bit:uint;
        var iconList:Vector.<BitmapData>;
        while (condition != 0) {
            newCondition = condition & condition - 1;
            bit = condition ^ newCondition;
            iconList = getIconsFromBit2(bit);
            if (iconList != null) {
                icons.push(iconList[(index % iconList.length)]);
            }
            condition = newCondition;
        }
    }
    public static function getConditionEffectIcons3(condition:uint, icons:Vector.<BitmapData>, index:int):void {
        var newCondition:uint;
        var bit:uint;
        var iconList:Vector.<BitmapData>;
        while (condition != 0) {
            newCondition = condition & condition - 1;
            bit = condition ^ newCondition;
            iconList = getIconsFromBit3(bit);
            if (iconList != null) {
                icons.push(iconList[(index % iconList.length)]);
            }
            condition = newCondition;
        }
    }
    private static function getIconsFromBit(bit:uint):Vector.<BitmapData> {
        var drawMatrix:Matrix;
        var ce:uint;
        var icons:Vector.<BitmapData>;
        var i:int;
        var icon:BitmapData;
        var defaultMatrix:Matrix;
        if (bitToIcon_ == null) {
            bitToIcon_ = [];
            drawMatrix = new Matrix();
            drawMatrix.translate(4, 4);
            defaultMatrix = new Matrix();
            defaultMatrix.translate(1, 1);
            ce = 0;
            for (ce = 0; ce < effects_.length; ce++) {
                icons = null;
                if (effects_[ce].iconOffsets_ != null) {
                    icons = new Vector.<BitmapData>();
                    i = 0;
                    for (i = 0; i < effects_[ce].iconOffsets_.length; i++) {
                        if(effects_[ce].imageSet_ != null) {
                            icon = new BitmapData(18, 18, true, 0);
                            icon.draw(AssetLibrary.getImageFromSet(effects_[ce].imageSet_, effects_[ce].iconOffsets_[i]), defaultMatrix);
                        } else {
                            icon = new BitmapData(16, 16, true, 0);
                            icon.draw(AssetLibrary.getImageFromSet("lofiInterface2", effects_[ce].iconOffsets_[i]), drawMatrix);
                        }
                        icon = GlowRedrawer.outlineGlow(icon, 0xFFFFFFFF);
                        icon.applyFilter(icon, icon.rect, PointUtil.ORIGIN, GLOW_FILTER);
                        icons.push(icon);
                    }
                }
                bitToIcon_[effects_[ce].bit_] = icons;
            }
        }
        return bitToIcon_[bit];
    }

    private static function getIconsFromBit2(bit:uint):Vector.<BitmapData> {
        var icons:Vector.<BitmapData>;
        var ce:BitmapData;
        var drawMatrix:Matrix;
        var i:Matrix;
        var icon:uint;
        var defaultMatrix:int;
        if (bitToIcon2_ == null) {
            bitToIcon2_ = [];
            icons = new Vector.<BitmapData>();
            drawMatrix = new Matrix();
            drawMatrix.translate(4, 4);
            i = new Matrix();
            i.translate(1, 1);
            icon = 32;
            while (icon < 64) {
                icons = null;
                if (effects_[icon].iconOffsets_ != null) {
                    icons = new Vector.<BitmapData>();
                    defaultMatrix = 0;
                    while (defaultMatrix < effects_[icon].iconOffsets_.length) {
                        if (effects_[icon].icon16Bit_) {
                            ce = new BitmapData(18, 18, true, 0);
                            if(effects_[icon].imageSet_ != null)
                                ce.draw(AssetLibrary.getImageFromSet(effects_[icon].imageSet_, effects_[icon].iconOffsets_[i]), i);
                            else
                                ce.draw(AssetLibrary.getImageFromSet("lofiInterfaceBig", effects_[icon].iconOffsets_[i]), i);
                        }
                        else {
                            ce = new BitmapData(16, 16, true, 0);
                            ce.draw(AssetLibrary.getImageFromSet("lofiInterface2", effects_[icon].iconOffsets_[defaultMatrix]), drawMatrix);
                        }
                        ce = GlowRedrawer.outlineGlow(ce, 0xFFFFFFFF);
                        ce.applyFilter(ce, ce.rect, PointUtil.ORIGIN, GLOW_FILTER);
                        icons.push(ce);
                        defaultMatrix++;
                    }
                }
                bitToIcon2_[effects_[icon].bit_] = icons;
                icon++;
            }
        }
        if (bitToIcon2_ != null && bitToIcon2_[bit] != null) {
            return bitToIcon2_[bit];
        }
        return null;
    }

    private static function getIconsFromBit3(bit:uint):Vector.<BitmapData> {
        var drawMatrix:Vector.<BitmapData>;
        var ce:BitmapData;
        var icons:Matrix;
        var i:Matrix;
        var icon:uint;
        var defaultMatrix:int;
        if (bitToIcon3_ == null) {
            bitToIcon3_ = [];
            drawMatrix = new Vector.<BitmapData>();
            icons = new Matrix();
            icons.translate(4, 4);
            i = new Matrix();
            i.translate(1, 1);
            icon = 64;
            while (icon < effects_.length) {
                drawMatrix = null;
                if (effects_[icon].iconOffsets_ != null) {
                    drawMatrix = new Vector.<BitmapData>();
                    defaultMatrix = 0;
                    while (defaultMatrix < effects_[icon].iconOffsets_.length) {
                        if (effects_[icon].icon16Bit_) {
                            ce = new BitmapData(18, 18, true, 0);
                            if(effects_[icon].imageSet_ != null)
                                ce.draw(AssetLibrary.getImageFromSet(effects_[icon].imageSet_, effects_[icon].iconOffsets_[defaultMatrix]), i);
                            else
                                ce.draw(AssetLibrary.getImageFromSet("lofiInterfaceBig", effects_[icon].iconOffsets_[defaultMatrix]), i);
                        }
                        else {
                            ce = new BitmapData(16, 16, true, 0);
                            ce.draw(AssetLibrary.getImageFromSet("lofiInterface2", effects_[icon].iconOffsets_[defaultMatrix]), icons);
                        }
                        ce = GlowRedrawer.outlineGlow(ce, 0xFFFFFFFF);
                        ce.applyFilter(ce, ce.rect, PointUtil.ORIGIN, GLOW_FILTER);
                        drawMatrix.push(ce);
                        defaultMatrix++;
                    }
                }
                bitToIcon3_[effects_[icon].bit_] = drawMatrix;
                icon++;
            }
        }
        if (!(bitToIcon3_ == null) && !(bitToIcon3_[bit] == null)) {
            return bitToIcon3_[bit];
        }
        return null;
    }
}
}
</file>

<file path="src/svera/untiered/account/core/view/EmptyFrame.as">
package svera.untiered.account.core.view {
import com.company.assembleegameclient.ui.TextButton;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;
import flash.text.TextFormatAlign;

import org.osflash.signals.Signal;

public class EmptyFrame extends Sprite {
    public static const TEXT_MARGIN:int = 20;

    protected var modalWidth:Number;
    protected var modalHeight:Number;
    protected var closeButton:TextButton;
    protected var background:Sprite;
    protected var backgroundContainer:Sprite;
    protected var title:SimpleText;
    protected var desc:SimpleText;

    public function EmptyFrame(_arg1:int = 288, _arg2:int = 150, _arg3:String = "") {
        this.modalWidth = _arg1;
        this.modalHeight = _arg2;
        x = GameClient.HalfStageWidth - this.modalWidth / 2;
        y = GameClient.HalfStageHeight - this.modalHeight / 2;
        if (_arg3 != "") {
            this.setTitle(_arg3, true);
        }
        if (this.background == null) {
            this.backgroundContainer = new Sprite();
            this.background = this.makeModalBackground();
            this.backgroundContainer.addChild(this.background);
            addChild(this.backgroundContainer);
        }
        if (_arg3 != "") {
            this.setTitle(_arg3, true);
        }
    }

    private function onRemovedFromStage(_arg1:Event):void {
        removeEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        if (this.closeButton != null) {
            this.closeButton.removeEventListener(MouseEvent.CLICK, this.onCloseClick);
        }
    }

    public function setTitle(_arg1:String, _arg2:Boolean):void {
        if (!(this.title == null) && !(this.title.parent == null)) {
            removeChild(this.title);
        }
        if (_arg1 != null) {
            this.title = this.getText(_arg1, TEXT_MARGIN, 5, _arg2);
            addChild(this.title);
        } else {
            this.title = null;
        }
    }

    public function setDesc(_arg1:String, _arg2:Boolean):void {
        if (_arg1 != null) {
            if (!(this.desc == null) && !(this.desc.parent == null)) {
                removeChild(this.desc);
            }
            this.desc = this.getText(_arg1, TEXT_MARGIN, 50, _arg2);
            addChild(this.desc);
        }
    }

    public function setCloseButton(_arg1:Boolean):void {
        if (this.closeButton == null && _arg1) {
            this.closeButton = new TextButton(24,"X",30);
            this.closeButton.addEventListener(MouseEvent.CLICK, this.onCloseClick);
            addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
            addChild(this.closeButton);
        } else if (this.closeButton != null && !_arg1) {
            removeChild(this.closeButton);
            this.closeButton = null;
        }
    }

    protected function getText(text:String, x_:int, y_:int, _arg4:Boolean):SimpleText {
        var simpleText:SimpleText = new SimpleText(18, 0xFFFFFF, false,modalWidth - TEXT_MARGIN * 2 - 10);

        simpleText.setBold(true);
        simpleText.setText(text);
        simpleText.wordWrap = true;
        simpleText.multiline = true;
        simpleText.autoSize = TextFieldAutoSize.CENTER;
        simpleText.setAlignment(TextFormatAlign.CENTER);
        simpleText.filters = [new DropShadowFilter(0, 0, 0)];
        simpleText.x = x_;
        simpleText.y = y_;
        return simpleText;
    }

    protected function makeModalBackground():Sprite {
        x = GameClient.HalfStageWidth - this.modalWidth / 2;
        y = GameClient.HalfStageHeight - this.modalHeight / 2;
        var bg:Sprite = new Sprite();
        bg.graphics.beginFill(3552822);
        bg.graphics.drawRect(0, 0, modalWidth, modalHeight);
/*        if (this.title != null) {
            _local1.divide(PopupWindowBackground.HORIZONTAL_DIVISION, 30);
        }*/
        return bg;
    }

    public function onCloseClick(_arg1:MouseEvent):void {
        parent.removeChild(this);
    }
}
}
</file>

<file path="src/svera/untiered/game/view/CurrencyDisplay.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.ui.SimpleText;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;

public class CurrencyDisplay extends Sprite {

    private static const FONT_SIZE:int = 18;


    private var tsavoriteText_:SimpleText;

    private var medallionsText_:SimpleText;

    private var honorText_:SimpleText;

    private var tsavoriteIcon_:Bitmap;

    private var medallionsIcon_:Bitmap;

    private var honorIcon_:Bitmap;

    private var tsavorite_:int = -1;

    private var medallions_:int = -1;

    private var honor_:int = -1;

    private var gs:GameSprite;

    public function CurrencyDisplay(gs:GameSprite = null) {
        super();
        this.gs = gs;
        this.tsavoriteText_ = new SimpleText(FONT_SIZE, 16777215, false, 0, 0);
        this.tsavoriteText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        addChild(this.tsavoriteText_);
        var tsavoriteBD:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 2);
        tsavoriteBD = TextureRedrawer.redraw(tsavoriteBD, 40, true, 0);
        this.tsavoriteIcon_ = new Bitmap(tsavoriteBD);
        addChild(this.tsavoriteIcon_);
        this.medallionsText_ = new SimpleText(FONT_SIZE, 16777215, false, 0, 0);
        this.medallionsText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        addChild(this.medallionsText_);
        var medallionsBD:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 1);
        medallionsBD = TextureRedrawer.redraw(medallionsBD, 40, true, 0);
        this.medallionsIcon_ = new Bitmap(medallionsBD);
        addChild(this.medallionsIcon_);
        this.honorText_ = new SimpleText(FONT_SIZE, 16777215, false, 0, 0);
        this.honorText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        addChild(this.honorText_);
        var honorBD:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 0);
        honorBD = TextureRedrawer.redraw(honorBD, 40, true, 0);
        this.honorIcon_ = new Bitmap(honorBD);
        addChild(this.honorIcon_);
        this.draw(0, 0, 0, 0);
        mouseEnabled = false;
        doubleClickEnabled = false;
    }

    public function draw(tsavorite:int, medallions:int, honor:int, compact:Boolean = false):void {
        if (tsavorite == this.tsavorite_ && medallions == this.medallions_ && honor == this.honor_) {
            return;
        }
        this.tsavorite_ = tsavorite;
        this.tsavoriteIcon_.x = -this.tsavoriteIcon_.width;
        this.tsavoriteText_.text = this.tsavorite_.toString();
        this.tsavoriteText_.updateMetrics();
        this.tsavoriteText_.x = this.tsavoriteIcon_.x - this.tsavoriteText_.width + 8;
        this.tsavoriteText_.y = this.tsavoriteIcon_.height / 2 - this.tsavoriteText_.height / 2;
        this.medallions_ = medallions;
        this.medallionsIcon_.x = this.tsavoriteText_.x - medallionsIcon_.width;
        this.medallionsText_.text = this.medallions_.toString();
        this.medallionsText_.updateMetrics();
        this.medallionsText_.x = this.medallionsIcon_.x - this.medallionsText_.width + 8;
        this.medallionsText_.y = tsavoriteText_.y;
        if (compact) {
            this.honor_ = honor;
            this.honorText_.text = this.honor_.toString();
            this.honorText_.updateMetrics();
            this.honorText_.x = this.tsavoriteText_.x;
            this.honorText_.y =  -this.honorText_.height / 2 + this.honorIcon_.height;
            this.honorIcon_.x = this.honorText_.x + honorIcon_.width;
            this.honorIcon_.y = honorIcon_.height/ 2;
        } else {
            this.honor_ = honor;
            this.honorText_.text = this.honor_.toString();
            this.honorText_.updateMetrics();
            this.honorIcon_.x = this.medallionsText_.x - honorIcon_.width;
            this.honorText_.x = this.honorIcon_.x - this.honorText_.width + 8;
            this.honorText_.y = this.honorIcon_.height / 2 - this.honorText_.height / 2;
        }
    }
}
}
</file>

<file path="src/svera/untiered/legends/model/Legend.as">
package svera.untiered.legends.model {
import flash.display.BitmapData;

import svera.untiered.honor.model.HonorVO;
import svera.untiered.itemdata.NewItemData;

public class Legend implements HonorVO {


    public var isOwnLegend:Boolean;

    public var place:int;

    public var accountId:int;

    public var charId:int;

    public var name:String;

    public var totalHonor:int;

    public var equipmentSlots:Vector.<int>;

    public var equipment:Vector.<NewItemData>;

    public var character:BitmapData;

    public var isFocus:Boolean;

    public function Legend() {
        super();
    }

    public function getAccountId():int {
        return this.accountId;
    }

    public function getCharacterId():int {
        return this.charId;
    }
}
}
</file>

<file path="src/svera/untiered/legends/model/LegendFactory.as">
package svera.untiered.legends.model {
import com.company.util.ConversionUtil;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.itemdata.NewItemData;

public class LegendFactory {


    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var classesModel:ClassesModel;

    [Inject]
    public var factory:CharacterFactory;

    private var ownAccountId:int;

    private var legends:Vector.<Legend>;

    public function LegendFactory() {
        super();
    }

    public function makeLegends(xml:XML):Vector.<Legend> {
        this.ownAccountId = this.playerModel.getAccountId();
        this.legends = new Vector.<Legend>(0);
        this.makeLegendsFromList(xml.HonorListElem, false);
        //this.makeLegendsFromList(xml.MyHonorListElem,true);
        return this.legends;
    }

    private function makeLegendsFromList(list:XMLList, isFocus:Boolean):void {
        var node:XML = null;
        var legend:Legend = null;
        for each(node in list) {
            if (!this.legendsContains(node)) {
                legend = this.makeLegend(node);
                legend.isOwnLegend = node.@accountId == this.ownAccountId;
                legend.isFocus = isFocus;
                this.legends.push(legend);
            }
        }
    }

    private function legendsContains(node:XML):Boolean {
        var legend:Legend = null;
        for each(legend in this.legends) {
            if (legend.accountId == node.@accountId && legend.charId == node.@charId) {
                return true;
            }
        }
        return false;
    }

    public function makeLegend(xml:XML):Legend {
        var type:int = xml.ObjectType;
        var skinType:int = xml.Texture;
        var character:CharacterClass = this.classesModel.getCharacterClass(type);
        var skin:CharacterSkin = character.skins.getSkin(skinType);
        var texture1:int = Boolean(xml.hasOwnProperty("Tex1")) ? int(xml.Tex1) : int(0);
        var texture2:int = Boolean(xml.hasOwnProperty("Tex2")) ? int(xml.Tex2) : int(0);
        var legend:Legend = new Legend();
        legend.accountId = xml.@accountId;
        legend.charId = xml.@charId;
        legend.name = xml.Name;
        legend.totalHonor = xml.TotalHonor;
        legend.character = this.factory.makeIcon(skin.template, 100, texture1, texture2);
        legend.equipmentSlots = character.slotTypes;
        legend.equipment = NewItemData.fromPlayerXML(xml.Equipment);
        return legend;
    }
}
}
</file>

<file path="src/svera/untiered/legends/view/LegendListItem.as">
package svera.untiered.legends.view {
import com.company.assembleegameclient.ui.Slot;
import com.company.assembleegameclient.ui.panels.itemgrids.EquippedGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.InteractiveItemTile;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.ui.SimpleText;
import com.company.util.AssetLibrary;
import com.company.util.IIterator;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;

import svera.untiered.legends.model.Legend;

public class LegendListItem extends Sprite {

    public static const WIDTH:int = 756;

    public static const HEIGHT:int = 56;


    public const selected:Signal = new Signal(Legend);

    private var legend:Legend;

    private var placeText:SimpleText;

    private var characterBitmap:Bitmap;

    private var nameText:SimpleText;

    private var inventoryGrid:EquippedGrid;

    private var totalHonorText:SimpleText;

    private var honorIcon:Bitmap;

    private var isOver:Boolean;

    public function LegendListItem(legend:Legend) {
        super();
        this.legend = legend;
        this.makePlaceText();
        this.makeCharacterBitmap();
        this.makeNameText();
        this.makeInventory();
        this.makeTotalHonor();
        this.makeHonorIcon();
        this.addMouseListeners();
        this.draw();
    }

    public function getLegend():Legend {
        return this.legend;
    }

    private function makePlaceText():void {
        this.placeText = new SimpleText(22, this.getTextColor(), false, 0, 0);
        this.placeText.setBold(this.legend.place != -1);
        this.placeText.text = this.legend.place == -1 ? "---" : this.legend.place.toString() + ".";
        this.placeText.useTextDimensions();
        this.placeText.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.placeText.x = 82 - this.placeText.width;
        this.placeText.y = HEIGHT / 2 - this.placeText.height / 2;
        addChild(this.placeText);
    }

    private function makeCharacterBitmap():void {
        this.characterBitmap = new Bitmap(this.legend.character);
        this.characterBitmap.x = 104;
        this.characterBitmap.y = HEIGHT / 2 - this.characterBitmap.height / 2 - 2;
        addChild(this.characterBitmap);
    }

    private function makeNameText():void {
        this.nameText = new SimpleText(22, this.getTextColor(), false, 0, 0);
        this.nameText.setBold(true);
        this.nameText.text = this.legend.name;
        this.nameText.useTextDimensions();
        this.nameText.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.nameText.x = 170;
        this.nameText.y = HEIGHT / 2 - this.nameText.height / 2;
        addChild(this.nameText);
    }

    private function makeInventory():void {
        var interactiveItemTileIterator:InteractiveItemTile = null;
        this.inventoryGrid = new EquippedGrid(null, this.legend.equipmentSlots, null);
        var iterator:IIterator = this.inventoryGrid.createInteractiveItemTileIterator();
        while (iterator.hasNext()) {
            interactiveItemTileIterator = InteractiveItemTile(iterator.next());
            interactiveItemTileIterator.setInteractive(false);
        }
        this.inventoryGrid.setItems(this.legend.equipment, this.legend.equipment.length);
        this.inventoryGrid.x = 400;
        this.inventoryGrid.y = HEIGHT / 2 - Slot.HEIGHT / 2;
        addChild(this.inventoryGrid);
    }

    private function makeTotalHonor():void {
        this.totalHonorText = new SimpleText(22, this.getTextColor(), false, 0, 0);
        this.totalHonorText.setBold(true);
        this.totalHonorText.text = this.legend.totalHonor.toString();
        this.totalHonorText.useTextDimensions();
        this.totalHonorText.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        this.totalHonorText.x = 660 - this.totalHonorText.width;
        this.totalHonorText.y = HEIGHT / 2 - this.totalHonorText.height / 2;
        addChild(this.totalHonorText);
    }

    private function makeHonorIcon():void {
        var honorBD:BitmapData = AssetLibrary.getImageFromSet("Currency_Icons16x16", 0);
        this.honorIcon = new Bitmap(TextureRedrawer.redraw(honorBD, 40, true, 0));
        this.honorIcon.x = 652;
        this.honorIcon.y = HEIGHT / 2 - this.honorIcon.height / 2;
        addChild(this.honorIcon);
    }

    private function getTextColor():uint {
        var textColor:uint;
        if (this.legend.isOwnLegend) {
            textColor = 16564761;
        } else if (this.legend.place == 1) {
            textColor = 16646031;
        } else {
            textColor = 16777215;
        }
        return textColor;
    }

    private function addMouseListeners():void {
        addEventListener(MouseEvent.MOUSE_OVER, this.onMouseOver, false, 0, true);
        addEventListener(MouseEvent.ROLL_OUT, this.onRollOut, false, 0, true);
        addEventListener(MouseEvent.CLICK, this.onClick, false, 0, true);
    }

    private function onMouseOver(event:MouseEvent):void {
        this.isOver = true;
        this.draw();
    }

    private function onRollOut(event:MouseEvent):void {
        this.isOver = false;
        this.draw();
    }

    private function onClick(event:MouseEvent):void {
        this.selected.dispatch(this.legend);
    }

    private function draw():void {
        graphics.clear();
        graphics.beginFill(0, this.isOver ? 0.4 : 0.001);
        graphics.drawRect(0, 0, WIDTH, HEIGHT);
        graphics.endFill();
    }
}
}
</file>

<file path="src/svera/untiered/lootBoxes/LootboxModal.as">
package svera.untiered.lootBoxes {
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.TextButton;
import com.company.assembleegameclient.util.Currency;
import com.company.ui.SimpleText;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.filters.GlowFilter;
import flash.geom.ColorTransform;

import svera.untiered.account.core.view.EmptyFrame;
import svera.untiered.core.StaticInjectorContext;
import svera.untiered.dialogs.control.CloseDialogsSignal;
import svera.untiered.game.model.GameModel;
import svera.untiered.game.view.LootboxesDisplay;
import svera.untiered.util.components.LegacyBuyButton;

public class LootboxModal extends EmptyFrame {
    public static const MODAL_WIDTH:int = 490;
    public static const MODAL_HEIGHT:int = 540;
    private static const OVER_COLOR_TRANSFORM:ColorTransform = new ColorTransform(1, 220 / 0xFF, 133 / 0xFF);
    private static const DROP_SHADOW_FILTER:DropShadowFilter = new DropShadowFilter(0, 0, 0);
    private static const GLOW_FILTER:GlowFilter = new GlowFilter(0xFF0000, 1, 11, 5);
    private static const filterWithGlow:Array = [DROP_SHADOW_FILTER, GLOW_FILTER];
    private static const filterNoGlow:Array = [DROP_SHADOW_FILTER];

    [Embed(source="LootboxBackground_ImageEmbed.png")]
    public static var backgroundImageEmbed:Class;
    public static var modalWidth:int = MODAL_WIDTH;//440
    public static var modalHeight:int = MODAL_HEIGHT;//400

    public var lootboxDisplay_:LootboxesDisplay;
    [Embed(source="LockerLootbox_ImageEmbed.png")]
    private var LockerLootbox_ImageEmbed:Class;
    private var Lootbox_Image1:Bitmap;
    [Embed(source="EventLootbox_ImageEmbed.png")]
    private var EventLootbox_ImageEmbed:Class;
    private var Lootbox_Image2:Bitmap;
    [Embed(source="GoldLootbox_ImageEmbed.png")]
    private var GoldLootbox_ImageEmbed:Class;
    private var Lootbox_Image3:Bitmap;
    [Embed(source="EliteLootbox_ImageEmbed.png")]
    private var EliteLootbox_ImageEmbed:Class;
    private var Lootbox_Image4:Bitmap;
    [Embed(source="PremiumLootbox_ImageEmbed.png")]
    private var PremiumLootbox_ImageEmbed:Class;
    private var Lootbox_Image5:Bitmap;

    private var Lootbox1Title:SimpleText;
    private var Lootbox2Title:SimpleText;
    private var Lootbox3Title:SimpleText;
    private var Lootbox4Title:SimpleText;
    private var Lootbox5Title:SimpleText;

    public var Lootbox1Amount:LegacyBuyButton;
    public var Lootbox2Amount:TextButton;
    public var Lootbox3Amount:TextButton;
    public var Lootbox4Amount:LegacyBuyButton;
    public var Lootbox5Amount:LegacyBuyButton;

    public function LootboxModal() {
        modalWidth = MODAL_WIDTH;
        modalHeight = MODAL_HEIGHT;
        super(modalWidth, modalHeight);
        this.setCloseButton(true);
        this.setTitle("Lootboxes", true);
        addEventListener(Event.ADDED_TO_STAGE, this.onAdded);
        addEventListener(Event.REMOVED_FROM_STAGE, this.destroy);
        closeButton.addEventListener(MouseEvent.CLICK, this.onCloseButtonClicked);
    }

    public function onCloseButtonClicked(e:Event):void {
        var _local1:CloseDialogsSignal = StaticInjectorContext.getInjector().getInstance(CloseDialogsSignal);
        _local1.dispatch();
        closeButton.removeEventListener(MouseEvent.CLICK, this.onCloseButtonClicked);
    }

    private function onAdded(_arg1:Event):void {
    }


    private function destroy(_arg1:Event):void {
        removeEventListener(Event.ADDED_TO_STAGE, this.onAdded);
        removeEventListener(Event.REMOVED_FROM_STAGE, this.destroy);
    }

    private function onArrowHover(_arg1:MouseEvent):void {
        _arg1.currentTarget.transform.colorTransform = OVER_COLOR_TRANSFORM;
    }

    private function onArrowHoverOut(_arg1:MouseEvent):void {
        _arg1.currentTarget.transform.colorTransform = MoreColorUtil.identity;
    }


    override protected function makeModalBackground():Sprite {
        var _local1:Sprite = new Sprite();
        var _local2:DisplayObject = new backgroundImageEmbed();
        _local2.width = modalWidth + 1;
        _local2.height = modalHeight - 25;
        _local2.y = 27;
        _local2.alpha = 1.00;
        var additive:int = 89;

        this.Lootbox_Image1 = new Bitmap(new LockerLootbox_ImageEmbed().bitmapData);
        this.Lootbox_Image1.y = 100;
        this.Lootbox_Image1.x = 22;
        Lootbox_Image1.width = 21 * 4;
        Lootbox_Image1.height = 18 * 4;
        Lootbox_Image1.filters = [new DropShadowFilter(0, 0, 0xFF0044, 1, 12, 12, 1.5)]; // Locker LootBox

        this.Lootbox_Image2 = new Bitmap(new EventLootbox_ImageEmbed().bitmapData);
        this.Lootbox_Image2.y = 100;
        this.Lootbox_Image2.x = this.Lootbox_Image1.x + additive;
        Lootbox_Image2.width = 21 * 4;
        Lootbox_Image2.height = 18 * 4;
        Lootbox_Image2.filters = [new DropShadowFilter(0, 0, 0x00FF21, 1, 12, 12, 1.5)]; // Event LootBox

        this.Lootbox_Image3 = new Bitmap(new GoldLootbox_ImageEmbed().bitmapData);
        this.Lootbox_Image3.y = 100;
        this.Lootbox_Image3.x = this.Lootbox_Image2.x + additive;
        Lootbox_Image3.width = 21 * 4;
        Lootbox_Image3.height = 18 * 4;
        Lootbox_Image3.filters = [new DropShadowFilter(0, 0, 0xF7AA22, 1, 12, 12, 1.5)]; // Gold LootBox

        this.Lootbox_Image4 = new Bitmap(new EliteLootbox_ImageEmbed().bitmapData);
        this.Lootbox_Image4.y = 100;
        this.Lootbox_Image4.x = this.Lootbox_Image3.x + additive;
        Lootbox_Image4.width = 21 * 4;
        Lootbox_Image4.height = 18 * 4;
        Lootbox_Image4.filters = [new DropShadowFilter(0, 0, 0xA80013, 1, 12, 12, 1.5)]; // Elite LootBox

        this.Lootbox_Image5 = new Bitmap(new PremiumLootbox_ImageEmbed().bitmapData);
        this.Lootbox_Image5.y = 100;
        this.Lootbox_Image5.x = this.Lootbox_Image4.x + additive;
        Lootbox_Image5.width = 21 * 4;
        Lootbox_Image5.height = 18 * 4;
        Lootbox_Image5.filters = [new DropShadowFilter(0, 0, 0x00FFF6, 1, 12, 12, 1.5)]; // Premium LootBox

        this.Lootbox1Title = new SimpleText(10, 0xFF0044, false, 0).setBold(true);
        this.Lootbox1Title.setText("Legendary Box");
        this.Lootbox1Title.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.Lootbox1Title.x = this.Lootbox_Image1.x + 2;
        this.Lootbox1Title.y = this.Lootbox_Image1.y - 20;

        this.Lootbox1Amount = new LegacyBuyButton("", 12, 750000, Currency.HONOR);
        this.Lootbox1Amount.x = this.Lootbox_Image1.x;
        this.Lootbox1Amount.y = this.Lootbox_Image1.y + 80;
        this.Lootbox1Amount.setEnabled(true);

        this.Lootbox2Title = new SimpleText(10, 0x00FF21, false, 0).setBold(true);
        this.Lootbox2Title.setText("Event Lootbox");
        this.Lootbox2Title.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.Lootbox2Title.x = this.Lootbox_Image2.x + 5;
        this.Lootbox2Title.y = this.Lootbox_Image2.y - 20;

        this.Lootbox2Amount = new TextButton(12, "Unbox");
        this.Lootbox2Amount.x = this.Lootbox_Image2.x + 17;
        this.Lootbox2Amount.y = this.Lootbox1Amount.y;
        this.Lootbox2Amount.setEnabled(true);

        this.Lootbox3Title = new SimpleText(10, 0xF7AA22, false, 0).setBold(true);
        this.Lootbox3Title.setText("Gold Lootbox");
        this.Lootbox3Title.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.Lootbox3Title.x = this.Lootbox_Image3.x + 6;
        this.Lootbox3Title.y = this.Lootbox_Image3.y - 20;

        this.Lootbox3Amount = new TextButton(12, "Unbox");
        this.Lootbox3Amount.x = this.Lootbox_Image3.x + 15;
        this.Lootbox3Amount.y = this.Lootbox1Amount.y;
        this.Lootbox3Amount.setEnabled(true);

        this.Lootbox4Title = new SimpleText(10, 0xA80013, false, 0).setBold(true);
        this.Lootbox4Title.setText("Elite Lootbox");
        this.Lootbox4Title.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.Lootbox4Title.x = this.Lootbox_Image4.x + 8;
        this.Lootbox4Title.y = this.Lootbox_Image4.y - 20;

        this.Lootbox4Amount = new LegacyBuyButton("", 12, 5000, Currency.HONOR);
        this.Lootbox4Amount.x = this.Lootbox_Image4.x + 6;
        this.Lootbox4Amount.y = this.Lootbox1Amount.y;
        this.Lootbox4Amount.setEnabled(true);

        this.Lootbox5Title = new SimpleText(10, 0x00FFF6, false, 0).setBold(true);
        this.Lootbox5Title.setText("Premium Lootbox");
        this.Lootbox5Title.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.Lootbox5Title.x = this.Lootbox_Image5.x - 3;
        this.Lootbox5Title.y = this.Lootbox_Image5.y - 20;

        this.Lootbox5Amount = new LegacyBuyButton("", 12, 5000, Currency.TSAVORITE);
        this.Lootbox5Amount.x = this.Lootbox_Image5.x + 4;
        this.Lootbox5Amount.y = this.Lootbox_Image5.y + 80;
        this.Lootbox5Amount.setEnabled(true);

        var _local4:PopupWindowBackground = new PopupWindowBackground();
        _local4.draw(modalWidth, modalHeight, PopupWindowBackground.TYPE_TRANSPARENT_WITH_HEADER);
        _local1.addChild(_local2);
        _local1.addChild(_local4);
        _local1.addChild(this.Lootbox_Image1);
        _local1.addChild(this.Lootbox_Image2);
        _local1.addChild(this.Lootbox_Image3);
        _local1.addChild(this.Lootbox_Image4);
        _local1.addChild(this.Lootbox_Image5);
        _local1.addChild(this.Lootbox1Title);
        _local1.addChild(this.Lootbox2Title);
        _local1.addChild(this.Lootbox3Title);
        _local1.addChild(this.Lootbox4Title);
        _local1.addChild(this.Lootbox5Title);
        _local1.addChild(this.Lootbox1Amount);
        _local1.addChild(this.Lootbox2Amount);
        _local1.addChild(this.Lootbox3Amount);
        _local1.addChild(this.Lootbox4Amount);
        _local1.addChild(this.Lootbox5Amount);
        this.lootboxDisplay_ = new LootboxesDisplay(null);


        this.lootboxDisplay_.lootbox2Icon.x = Lootbox_Image2.x + 2;
        this.lootboxDisplay_.lootbox2Icon.y = Lootbox_Image2.y + 100;
        this.lootboxDisplay_.lootbox2Text.x = Lootbox_Image2.x + 33;
        this.lootboxDisplay_.lootbox2Text.y = Lootbox_Image2.y + 110;

        this.lootboxDisplay_.lootbox3Icon.x = Lootbox_Image3.x + 2;
        this.lootboxDisplay_.lootbox3Icon.y = this.lootboxDisplay_.lootbox2Icon.y;
        this.lootboxDisplay_.lootbox3Text.x = Lootbox_Image3.x + 33;
        this.lootboxDisplay_.lootbox3Text.y = this.lootboxDisplay_.lootbox2Text.y;

        this.lootboxDisplay_.lootbox4Icon.x = Lootbox_Image4.x + 2;
        this.lootboxDisplay_.lootbox4Icon.y = this.lootboxDisplay_.lootbox2Icon.y;
        this.lootboxDisplay_.lootbox4Text.x = Lootbox_Image4.x + 33;
        this.lootboxDisplay_.lootbox4Text.y = this.lootboxDisplay_.lootbox2Text.y;

        _local1.addChild(this.lootboxDisplay_);
        var _local_3:Player = StaticInjectorContext.getInjector().getInstance(GameModel).player;
        if (_local_3 != null) {
            this.lootboxDisplay_.draw(_local_3.eventLootbox_, _local_3.goldLootbox_, _local_3.eliteLootbox_);
        }
        //_local1.addChild(_local5);
        return _local1;
    }

    private function onMouseClick(e:MouseEvent):void {
        SoundEffectLibrary.play("button_click");
    }

    override public function onCloseClick(_arg1:MouseEvent):void {
        SoundEffectLibrary.play("button_click");
    }


}
}
</file>

<file path="src/svera/untiered/storage/GiftContent.as">
package svera.untiered.storage {
import com.company.assembleegameclient.objects.GiftChest;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.ui.panels.itemgrids.ContainerGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.InteractiveItemTile;
import com.company.util.SpriteUtil;

import flash.display.Sprite;

import svera.untiered.itemdata.NewItemData;

import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.storage.components.StorageSortTab;

public class GiftContent extends Sprite {

    private var owner_:GiftChest;
    private var player_:Player;

    private var containerGrid_:ContainerGrid;

    private var scrollBar_:Scrollbar;

    private var curSort_:String;

    public function GiftContent(owner:GiftChest, player:Player) {
        this.owner_ = owner;
        this.player_ = player;

        GameServerConnection.instance.storageRequest(owner.objectId_);

        this.scrollBar_ = new Scrollbar(15, StorageUtil.CONTENT_HEIGHT);

        graphics.beginFill(0);
        graphics.drawRect(0, 0, StorageUtil.CONTENT_WIDTH, StorageUtil.CONTENT_HEIGHT);
        graphics.endFill();
    }


    private var content_:Vector.<NewItemData>;

    public function initialize(size:int, content:Vector.<NewItemData>):void {
        if (this.containerGrid_ != null) {
            SpriteUtil.safeRemoveChild(this, this.containerGrid_);
        }

        this.content_ = content;
        this.containerGrid_ = new ContainerGrid(this.owner_, this.player_, size, 8, true);

        var inventory:Vector.<NewItemData> = content;

        this.containerGrid_.setItems(inventory);
        this.containerGrid_.x = 10;
        this.containerGrid_.y = 10;
        // add scroll wheel here

        SpriteUtil.safeAddChild(this, this.containerGrid_);
    }

    public function updateSlot(slot:int, inventory:NewItemData):void {
        this.containerGrid_.setItem(slot, inventory);
    }

    public function sortBy(sort:String):void {
        if (this.curSort_ == sort) {
            return;
        }

        this.curSort_ = sort;
        this.filterSlotsBySlotType(StorageSortTab.getSortArray(this.curSort_));
    }

    public function filterSlotsBySlotType(types:Array):void {
        while (this.containerGrid_.numChildren > 0) {
            this.containerGrid_.removeChildAt(0);
        }

        var slotCount:int = 0;
        for each(var tile:InteractiveItemTile in this.containerGrid_.items) {
            var slotType:int = ObjectLibrary.getSlotTypeFromItemData(tile.getItemData());

            if (types.indexOf(slotType) > -1 || types.length == 0) {
                this.containerGrid_.addToGrid(tile, 8, slotCount);
                slotCount++;
            }
        }
    }

}
}
</file>

<file path="src/svera/untiered/storage/mediator/VaultWindowMediator.as">
package svera.untiered.storage.mediator {
import svera.lib.framework.Mediator;

import svera.untiered.itemdata.NewItemData;

import svera.untiered.storage.VaultWindow;
import svera.untiered.storage.signals.VaultSlotUpdateSignal;
import svera.untiered.storage.signals.VaultUpdateSignal;

public class VaultWindowMediator extends Mediator {
    public function VaultWindowMediator() {
        super();
    }

    [Inject]
    public var view_:VaultWindow;
    [Inject]
    public var vaultUpdateSignal_:VaultUpdateSignal;
    [Inject]
    public var vaultSlotUpdateSignal_:VaultSlotUpdateSignal;

    public override function initialize():void {
        this.vaultUpdateSignal_.add(this.onVaultUpdate);
        this.vaultSlotUpdateSignal_.add(this.onVaultSlotUpdate);
    }

    public override function destroy():void {
        this.vaultUpdateSignal_.remove(this.onVaultUpdate);
        this.vaultSlotUpdateSignal_.remove(this.onVaultSlotUpdate);
    }

    private function onVaultUpdate(size:int, slots:Vector.<NewItemData>):void {
        this.view_.setContent(size, slots);
    }

    private function onVaultSlotUpdate(slot:int, inventory:NewItemData):void {
        this.view_.updateSlot(slot, inventory);
    }
}
}
</file>

<file path="src/svera/untiered/storage/VaultWindow.as">
package svera.untiered.storage {

import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.objects.VaultChest;

import flash.display.Sprite;
import flash.events.MouseEvent;

import svera.untiered.itemdata.NewItemData;

import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.storage.components.StorageSortTab;
import svera.untiered.storage.components.VaultUpgradeButton;

public class VaultWindow extends Sprite {
    private var contentView_:VaultContent;

    private var upgradeButton_:VaultUpgradeButton;

    private var sortCategories_:Vector.<StorageSortTab>;

    private var owner_:VaultChest;

    public function VaultWindow(owner:VaultChest, player:Player) {

        this.owner_ = owner;

        this.sortCategories_ = StorageUtil.makeStorageSortCategories();

        for (var i:int = 0; i < this.sortCategories_.length; i++) {
            var sorter:StorageSortTab = this.sortCategories_[i];

            sorter.x = 5;
            sorter.y = StorageUtil.TOP_PAD + (StorageSortTab.SIZE + 5) * i;
            sorter.addEventListener(MouseEvent.CLICK, this.onSort);

            this.addChild(sorter);
        }

        this.contentView_ = new VaultContent(this.owner_, player);
        this.contentView_.x = StorageUtil.LEFT_PAD;
        this.contentView_.y = StorageUtil.TOP_PAD;
        addChild(this.contentView_);

        this.upgradeButton_ = new VaultUpgradeButton();
        this.upgradeButton_.x = StorageUtil.LEFT_PAD + (StorageUtil.CONTENT_WIDTH - this.upgradeButton_.width) / 2;
        this.upgradeButton_.y = StorageUtil.CONTENT_HEIGHT + StorageUtil.TOP_PAD + 10;
        addChild(this.upgradeButton_);

        this.upgradeButton_.addEventListener(MouseEvent.CLICK, this.onUpgradeClick);

        graphics.clear();
        graphics.beginFill(0x262626);
        graphics.drawRect(0, 0, StorageUtil.WINDOW_SIZE, StorageUtil.WINDOW_SIZE);
        graphics.endFill();
    }

    private function onUpgradeClick(e:MouseEvent):void {
        // do some verification
        GameServerConnection.instance.vaultUpgrade(this.owner_.objectId_);
    }

    public function setContent(size:int, slots:Vector.<NewItemData>):void {
        this.owner_.setContainer(size, slots);
        this.contentView_.initialize(size, slots);
        this.upgradeButton_.setPurchaseInfo(size);
    }

    public function updateSlot(slot:int, inventory:NewItemData):void {
        this.owner_.equipment_[slot] = inventory;
        this.contentView_.updateSlot(slot, inventory);
    }


    private function onSort(e:MouseEvent):void {
        var caller:StorageSortTab = e.currentTarget as StorageSortTab;
        if (caller == null) {
            return;
        }

        caller.select();
        if (caller.isSelected()) {
            this.contentView_.sortBy(caller.filter_);
        }

        for each(var sorter:StorageSortTab in this.sortCategories_) {
            if (sorter.filter_ == caller.filter_) {
                continue;
            }
            sorter.unselect();
        }
    }

    public function dispose():void {
        this.sortCategories_.length = 0;
        this.sortCategories_ = null;
        this.contentView_.dispose();
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/TitleView.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.constants.ScreenTypes;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.screens.AccountScreen;
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;

import svera.untiered.ui.view.components.ScreenBase;

public class TitleView extends Sprite {
    private static const COPYRIGHT:String = "© Svera Network 2022";


    public var playClicked:Signal;
    public var legendsClicked:Signal;
    public var editorClicked:Signal;
    public var accountClicked:Signal;
    public var quitClicked:Signal;

    private var playButton:TitleMenuOption;
    private var legendsButton:TitleMenuOption;
    private var editorButton:TitleMenuOption;
    private var accountButton:TitleMenuOption;
    private var quitButton:TitleMenuOption;

    private var versionText:SimpleText;
    private var copyrightText:SimpleText;

    public function TitleView() {
        super();
        addChild(new ScreenBase(1));
        addChild(new AccountScreen());
        this.makeChildren();
    }

    private function makeChildren():void {
        this.playButton = new TitleMenuOption(ScreenTypes.PLAY, 18, false, false);
        this.playClicked = this.playButton.clicked;
        this.addChild(this.playButton);
        this.legendsButton = new TitleMenuOption(ScreenTypes.LEGENDS, 18, false, false);
        this.legendsClicked = this.legendsButton.clicked;
        this.addChild(this.legendsButton);
        this.editorButton = new TitleMenuOption(ScreenTypes.EDITOR, 18, false, false);
        this.editorClicked = this.editorButton.clicked;
        this.addChild(editorButton);
        this.accountButton = new TitleMenuOption(ScreenTypes.ACCOUNT, 18, false, false);
        this.accountClicked = this.accountButton.clicked;
        this.addChild(this.accountButton);
        this.quitButton = new TitleMenuOption("Quit Game", 18, false, false);
        this.quitClicked = this.quitButton.clicked;
        this.addChild(this.quitButton);
        this.versionText = new SimpleText(12, 8355711, false, 0, 0);
        this.versionText.filters = [new DropShadowFilter(0, 0, 0)];
        this.addChild(this.versionText);
        this.copyrightText = new SimpleText(12, 8355711, false, 0, 0);
        this.copyrightText.text = COPYRIGHT;
        this.copyrightText.updateMetrics();
        this.copyrightText.filters = [new DropShadowFilter(0, 0, 0)];
        this.addChild(this.copyrightText);
    }

    public function initialize():void {
        this.updateVersionText();
        positionButtons(null);
        GameClient.STAGE.addEventListener(Event.RESIZE, positionButtons, false, 0, true);
    }

    public function destroy():void {
        GameClient.STAGE.removeEventListener(Event.RESIZE, positionButtons);
    }

    private function updateVersionText():void {
        this.versionText.htmlText = "V" + Parameters.BUILD_VERSION;
        this.versionText.updateMetrics();
    }

    private function positionButtons(e:Event):void {
        this.playButton.x = GameClient.STAGE.width / 2 - this.playButton.width / 2;
        this.playButton.y = GameClient.STAGE.height / 2 + this.playButton.height * 2;
        this.legendsButton.x = GameClient.STAGE.width / 2 - this.legendsButton.width / 2;
        this.legendsButton.y = this.playButton.y + this.legendsButton.height + 18;
        this.editorButton.x = GameClient.STAGE.width / 2 - this.editorButton.width / 2;
        this.editorButton.y = this.legendsButton.y + this.editorButton.height + 18;
        this.accountButton.x = GameClient.STAGE.width / 2 - this.accountButton.width / 2;
        this.accountButton.y = this.editorButton.y + this.accountButton.height + 18;
        this.quitButton.x = GameClient.STAGE.width / 2 - this.quitButton.width / 2;
        this.quitButton.y = this.accountButton.y + this.quitButton.height + 18;
        this.versionText.x = GameClient.STAGE.width - this.versionText.width - this.versionText.height / 2;
        this.versionText.y = GameClient.STAGE.height - this.versionText.height - this.versionText.height / 2;
        this.copyrightText.x = GameClient.STAGE.width - this.copyrightText.width - this.copyrightText.height / 2;
        this.copyrightText.y = GameClient.STAGE.height - this.versionText.height - this.copyrightText.height - this.copyrightText.height / 2;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Merchant.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.constants.InventoryOwnerTypes;
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.ui.tooltip.EquipmentToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.ui.SimpleText;
import com.company.util.IntPoint;
import com.gskinner.motion.GTween;
import com.gskinner.motion.easing.Sine;

import flash.display.BitmapData;
import flash.geom.ColorTransform;
import flash.geom.Matrix;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.game.model.AddSpeechBalloonVO;
import svera.untiered.game.signals.AddSpeechBalloonSignal;
import svera.untiered.itemdata.NewItemData;

public class Merchant extends SellableObject implements IInteractiveObject {

    private static const NONE_MESSAGE:int = 0;

    private static const NEW_MESSAGE:int = 1;

    private static const MINS_LEFT_MESSAGE:int = 2;

    private static const ITEMS_LEFT_MESSAGE:int = 3;

    private static const DISCOUNT_MESSAGE:int = 4;

    private static const T:Number = 1;

    private static const DOSE_MATRIX:Matrix = function ():Matrix {
        var m:* = new Matrix();
        m.translate(10, 5);
        return m;
    }();


    public var merchandiseType_:NewItemData = null;

    public var count_:int = -1;

    public var minsLeft_:int = -1;

    public var discount_:int = 0;

    public var merchandiseTexture_:BitmapData = null;

    public var untilNextMessage_:int = 0;

    public var alpha_:Number = 1.0;

    private var addSpeechBalloon:AddSpeechBalloonSignal;

    private var firstUpdate_:Boolean = true;

    private var messageIndex_:int = 0;

    private var ct_:ColorTransform;

    public function Merchant(objectXML:XML) {
        this.ct_ = new ColorTransform(1, 1, 1, 1);
        this.addSpeechBalloon = StaticInjectorContext.getInjector().getInstance(AddSpeechBalloonSignal);
        super(objectXML);
        isInteractive_ = true;
    }

    override public function setPrice(price:int):void {
        super.setPrice(price);
        this.untilNextMessage_ = 0;
    }

    override public function setRankReq(rankReq:int):void {
        super.setRankReq(rankReq);
        this.untilNextMessage_ = 0;
    }

    override public function addTo(map:Map, x:Number, y:Number):Boolean {
        if (!super.addTo(map, x, y)) {
            return false;
        }
        map.merchLookup_[new IntPoint(x_, y_)] = this;
        return true;
    }

    override public function removeFromMap():void {
        var p:IntPoint = new IntPoint(x_, y_);
        if (map_.merchLookup_[p] == this) {
            map_.merchLookup_[p] = null;
        }
        super.removeFromMap();
    }

    public function getSpeechBalloon(message:int):AddSpeechBalloonVO {
        var text:String = null;
        var backColor:uint = 0;
        var outlineColor:uint = 0;
        var textColor:uint = 0;
        switch (message) {
            case NEW_MESSAGE:
                text = "New!";
                backColor = 15132390;
                outlineColor = 16777215;
                textColor = 5931045;
                break;
            case MINS_LEFT_MESSAGE:
                if (this.minsLeft_ == 0) {
                    text = "Going soon!";
                } else if (this.minsLeft_ == 1) {
                    text = "Going in 1 min!";
                } else {
                    text = "Going in " + this.minsLeft_ + " mins!";
                }
                backColor = 5973542;
                outlineColor = 16549442;
                textColor = 16549442;
                break;
            case ITEMS_LEFT_MESSAGE:
                text = this.count_ + " left!";
                backColor = 5973542;
                outlineColor = 16549442;
                textColor = 16549442;
                break;
            case DISCOUNT_MESSAGE:
                text = this.discount_ + "% off!";
                backColor = 6324275;
                outlineColor = 16777103;
                textColor = 16777103;
                break;
            default:
                return null;
        }
        return new AddSpeechBalloonVO(this, text, backColor, 1, outlineColor, 1, textColor, 6, true, false);
    }

    override public function update(time:int, dt:int):Boolean {
        var tween0:GTween = null;
        var tween1:GTween = null;
        super.update(time, dt);
        if (this.firstUpdate_) {
            if (this.minsLeft_ == 2147483647) {
                this.alpha_ = 0;
                new GTween(this, 0.5 * T, {"alpha_": 1});
                tween1 = new GTween(this, 0.5 * T, {"size_": 150}, {"ease": Sine.easeOut});
                tween1.nextTween = new GTween(this, 0.5 * T, {"size_": 100}, {"ease": Sine.easeIn});
                tween1.nextTween.paused = true;
            }
            this.firstUpdate_ = false;
        }
        this.untilNextMessage_ = this.untilNextMessage_ - dt;
        if (this.untilNextMessage_ > 0) {
            return true;
        }
        this.untilNextMessage_ = 5000;
        var messages:Vector.<int> = new Vector.<int>();
        if (this.minsLeft_ == 2147483647) {
            messages.push(NEW_MESSAGE);
        } else if (this.minsLeft_ >= 0 && this.minsLeft_ <= 5) {
            messages.push(MINS_LEFT_MESSAGE);
        }
        if (this.count_ >= 1 && this.count_ <= 2) {
            messages.push(ITEMS_LEFT_MESSAGE);
        }
        if (this.discount_ > 0) {
            messages.push(DISCOUNT_MESSAGE);
        }
        if (messages.length == 0) {
            return true;
        }
        this.messageIndex_ = ++this.messageIndex_ % messages.length;
        var message:int = messages[this.messageIndex_];
        this.addSpeechBalloon.dispatch(this.getSpeechBalloon(message));
        return true;
    }

    override public function soldObjectName():String {
        return ObjectLibrary.typeToDisplayId_[this.merchandiseType_];
    }

    override public function soldObjectInternalName():String {
        var objectXML:XML = ObjectLibrary.xmlLibrary_[this.merchandiseType_];
        return objectXML.@id.toString();
    }

    override public function getTooltip():ToolTip {
        var toolTip:ToolTip = new EquipmentToolTip(this.merchandiseType_, map_.player_, -1, InventoryOwnerTypes.NPC);
        return toolTip;
    }

    override public function getIcon():BitmapData {
        var tempText:SimpleText = null;
        var texture:BitmapData = ObjectLibrary.getRedrawnTextureFromType(this.merchandiseType_.ObjectType, 80, true);
        if (merchandiseType_.Doses) {
            texture = texture.clone();
            tempText = new SimpleText(12, 16777215, false, 0, 0);
            tempText.text = String(merchandiseType_.Doses);
            tempText.updateMetrics();
            texture.draw(tempText, DOSE_MATRIX);
        }
        return texture;
    }

    public function getTex1Id(defaultTexId:int):int {
        var objXML:XML = ObjectLibrary.xmlLibrary_[this.merchandiseType_];
        if (objXML == null) {
            return defaultTexId;
        }
        if (objXML.Activate == "Dye" && objXML.hasOwnProperty("Tex1")) {
            return int(objXML.Tex1);
        }
        return defaultTexId;
    }

    public function getTex2Id(defaultTexId:int):int {
        var objXML:XML = ObjectLibrary.xmlLibrary_[this.merchandiseType_];
        if (objXML == null) {
            return defaultTexId;
        }
        if (objXML.Activate == "Dye" && objXML.hasOwnProperty("Tex2")) {
            return int(objXML.Tex2);
        }
        return defaultTexId;
    }

    override protected function getTexture(camera:Camera, time:int):BitmapData {
        if (this.alpha_ == 1 && size_ == 100) {
            return this.merchandiseTexture_;
        }
        var tempTexture:BitmapData = ObjectLibrary.getRedrawnTextureFromType(this.merchandiseType_.ObjectType, size_, false, false);
        if (this.alpha_ != 1) {
            this.ct_.alphaMultiplier = this.alpha_;
            tempTexture.colorTransform(tempTexture.rect, this.ct_);
        }
        return tempTexture;
    }

    public function setMerchandiseType(merchandiseType:NewItemData):void {
        this.merchandiseType_ = merchandiseType;
        this.merchandiseTexture_ = ObjectLibrary.getRedrawnTextureFromType(this.merchandiseType_.ObjectType, 100, false);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/CharacterBox.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.appengine.CharacterStats;
import com.company.assembleegameclient.appengine.SavedCharacter;
import com.company.assembleegameclient.screens.charrects.CharacterRect;
import com.company.assembleegameclient.ui.tooltip.ClassToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.assembleegameclient.util.AnimatedChar;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;
import com.company.untiered.graphics.StarGraphic;

import flash.display.Bitmap;
import flash.display.DisplayObject;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;
import flash.text.TextFieldAutoSize;
import flash.ui.Keyboard;
import flash.utils.getTimer;

import org.osflash.signals.natives.NativeSignal;

import svera.untiered.core.model.PlayerModel;

public class CharacterBox extends Sprite {
    public static const DELETE_CHAR:String = "DELETE_CHAR";
    public static const ENTER_NAME:String = "ENTER_NAME";
    private static const fullCT:ColorTransform = new ColorTransform(0.8, 0.8, 0.8);
    private static const emptyCT:ColorTransform = new ColorTransform(0.2, 0.2, 0.2);
    private static const doneCT:ColorTransform = new ColorTransform(0.87, 0.62, 0);

    public var playerXML_:XML = null;
    public var charStats_:CharacterStats;
    public var model:PlayerModel;
    private var graphicContainer_:Sprite;
    private var bitmap_:Bitmap;
    private var classNameText_:SimpleText;
    private var cost:int = 0;
    private var lock_:Bitmap;
    public var characterSelectClicked_:NativeSignal;
    public const POSE_TIME:int = 600;
    public var poseStart_:int = -2147483648;
    public var poseDir_:int;
    public var poseAction_:int;

    private var bg:Bitmap = new Bitmap(new CharacterRect.charBg().bitmapData);
    private var graphic_:Sprite = new Sprite();

    public function CharacterBox(playerXML:XML, charStats:CharacterStats, model:PlayerModel) {
        var stars:Sprite;
        super();
        this.model = model;
        this.playerXML_ = playerXML;
        this.charStats_ = charStats;
        this.graphicContainer_ = new Sprite();
        graphic_.graphics.beginBitmapFill(bg.bitmapData, null, false);
        graphic_.graphics.drawRect(0,0, bg.width, bg.height);
        graphic_.graphics.endFill();
        addChild(this.graphicContainer_);
        this.graphicContainer_.addChild(this.graphic_);
        this.characterSelectClicked_ = new NativeSignal(this.graphicContainer_, MouseEvent.CLICK, MouseEvent);
        this.bitmap_ = new Bitmap(null);
        this.setImage(AnimatedChar.DOWN, AnimatedChar.STAND, 0);
        this.graphic_.addChild(this.bitmap_);
        this.classNameText_ = new SimpleText(14, 16777215, false, 0, 0);
        this.classNameText_.setBold(true);
        this.classNameText_.htmlText = "<p align=\"center\">" + this.playerXML_.@id + "</p>";
        this.classNameText_.autoSize = TextFieldAutoSize.CENTER;
        this.classNameText_.updateMetrics();
        this.classNameText_.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4)];
        this.graphic_.addChild(this.classNameText_);
        stars = this.getStars(HonorUtil.numStars(model.getBestHonor(this.objectType())), HonorUtil.STARS.length);
        stars.y = 10;
        stars.x = this.graphic_.width / 2 - stars.width / 2;
        stars.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4)];
        this.graphicContainer_.addChild(stars);
        this.classNameText_.y = graphic_.height - this.classNameText_.actualHeight_;
    }

    public function objectType():int {
        return int(this.playerXML_.@type);
    }

    public function getTooltip():ToolTip {
        return new ClassToolTip(this.playerXML_, this.model, this.charStats_);
    }

    public function setOver(over:Boolean):void {
        if (over) {
            transform.colorTransform = new ColorTransform(1.2, 1.2, 1.2);
        } else {
            transform.colorTransform = new ColorTransform(1, 1, 1);
        }
    }

    private function onKeyDown(e:KeyboardEvent):void {
        if (e.charCode == Keyboard.ENTER) {
            dispatchEvent(new Event(ENTER_NAME));
            e.stopPropagation();
        }
    }

    private function onDeleteClick(event:MouseEvent):void {
        dispatchEvent(new Event(DELETE_CHAR));
        event.stopPropagation();
    }

    private function onEnterFrame(event:Event):void {
        var p:Number = NaN;
        var time:int = getTimer();
        if (time < this.poseStart_ + this.POSE_TIME) {
            p = (time - this.poseStart_) / this.POSE_TIME;
            this.setImage(this.poseDir_, this.poseAction_, p);
        } else {
            this.setImage(AnimatedChar.DOWN, AnimatedChar.STAND, 0);
            if (Math.random() < 0.005) {
                this.poseStart_ = time;
                this.poseDir_ = Math.random() > 0.5 ? int(AnimatedChar.LEFT) : int(AnimatedChar.RIGHT);
                this.poseAction_ = AnimatedChar.ATTACK;
            }
        }
    }

    private function setImage(dir:int, action:int, p:Number):void {
        this.bitmap_.bitmapData = SavedCharacter.getImage(null, this.playerXML_, dir, action, p, false, false);
        this.bitmap_.x = this.graphic_.width / 2 - this.bitmap_.bitmapData.width / 2;
    }

    private function getStars(full:int, total:int):Sprite {
        var star:Sprite = null;
        var stars:Sprite = new Sprite();
        var i:int = 0;
        for (var xOffset:int = 0; i < full;) {
            star = new StarGraphic();
            star.x = xOffset;
            star.transform.colorTransform = fullCT;
            stars.addChild(star);
            xOffset = xOffset + star.width;
            i++;
        }
        while (i < total) {
            star = new StarGraphic();
            star.x = xOffset;
            star.transform.colorTransform = emptyCT;
            stars.addChild(star);
            xOffset = xOffset + star.width;
            i++;
        }
        return stars;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/BindGrid.as">
package com.company.assembleegameclient.ui.panels.itemgrids {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.BindTile;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.ItemTile;

import flash.events.MouseEvent;

import svera.untiered.itemdata.NewItemData;

public class BindGrid extends ItemGrid {
    private var tiles:Vector.<BindTile>;

    private var numSlots_:int;
    private var noCuts_:Boolean;
    public var bindToGrid:InventoryGrid

    public function BindGrid(gridOwner:GameObject, currentPlayer:Player, grid:InventoryGrid, indexoffset:int = 5) {
        super(gridOwner, currentPlayer, 0, null, 2);

        bindToGrid = grid;
        numSlots_ = 8;
        this.noCuts_ = false;
        indexOffset = indexoffset;
        tiles = new Vector.<BindTile>(8, true);
        var tile:BindTile = null;
        for (var i:int = 0; i < numSlots_; i++) {
            tile = new BindTile(i, this);
            addToGrid(tile, 2, i);
            tile.addTileNumber(i + 1);
            this.tiles[i] = tile;
        }
    }

    public override function addToGrid(tile:ItemTile, numRows:uint, tileIndex:uint):void {
        tile.drawBackground(NO_CUT);
        tile.addEventListener(MouseEvent.ROLL_OVER, this.onTileHover);
        tile.y = int(tileIndex / 4) * (ItemTile.HEIGHT + 1);
        tile.x = int(tileIndex % 4) * (ItemTile.WIDTH + 1);
        addChild(tile);
    }

    override public function setItems(items:Vector.<NewItemData>, itemIndexOffset:int = 0):void {
        var numItems:int = 0;
        var i:int = 0;
        var refresh:Boolean = false;
        //var inv:InventoryGrid = bindToGrid;
        if (items) {
            numItems = items.length;
            for (i = 0; i < this.numSlots_; i++) {
                if (i + indexOffset < numItems) {
                    if (this.tiles[i].setItem(items[i + indexOffset])) {
                        refresh = true;
                    }
                } else {
                    if (this.tiles[i].setItem(null)) {
                        refresh = true;
                    }
                }
            }
            if (refresh) {
                refreshTooltip();
            }
        }
    }

    public function setItem(slot:int, itemId:NewItemData):void {
        if (slot >= this.tiles.length || slot < 0) {
            return;
        }
        this.tiles[slot].setItem(itemId);
    }

    public function get items():Vector.<BindTile> {
        return this.tiles;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/InventoryGrid.as">
package com.company.assembleegameclient.ui.panels.itemgrids {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.InventoryTile;

import svera.untiered.itemdata.NewItemData;

public class InventoryGrid extends ItemGrid {


    private const NUM_SLOTS:uint = 24;

    public var tiles:Vector.<InventoryTile>;

    public function InventoryGrid(gridOwner:GameObject, currentPlayer:Player, itemIndexOffset:int = 0) {
        var tile:InventoryTile = null;
        super(gridOwner, currentPlayer, itemIndexOffset);
        this.tiles = new Vector.<InventoryTile>(this.NUM_SLOTS);
        padding = 1;
        for (var i:int = 0; i < this.NUM_SLOTS; i++) {
            tile = new InventoryTile(i + indexOffset, this, interactive);
            addToGrid(tile, 6, i);
            this.tiles[i] = tile;
            if (i < 8)
                tile.addTileNumber(i + 1);
        }
    }

    override public function setItems(items:Vector.<NewItemData>, itemIndexOffset:int = 0):void {
        var numItems:int = 0;
        var i:int = 0;
        var refresh:Boolean = false;
        if (items) {
            numItems = items.length;
            for (i = 0; i < this.NUM_SLOTS; i++) {
                if (i + indexOffset < numItems) {
                    if (this.tiles[i].setItem(items[i + indexOffset])) {
                        refresh = true;
                    }
                } else {
                    if (this.tiles[i].setItem(null)) {
                        refresh = true;
                    }
                }
            }
            if (refresh) {
                refreshTooltip();
            }
        }
    }
}
}
</file>

<file path="src/svera/untiered/assets/EmbeddedAssets.as">
package svera.untiered.assets {
public class EmbeddedAssets {
    // Svera System
    // Logo
    [Embed(source="splash_logo.png")]
    public static var SplashLogo:Class;
    // Particles
    [Embed(source="Entities/Player/Player_Particles.png")]
    public static var Player_Particles:Class;
    // Icons
    [Embed(source="Interface/Currency/Currency_Icons8x8.png")]
    public static var Currency_Icons8x8:Class;
    [Embed(source="Interface/Currency/Currency_Icons16x16.png")]
    public static var Currency_Icons16x16:Class;
    [Embed(source="Interface/StatusIcons/StatusIcons16x16.png")]
    public static var StatusIcons16x16:Class;
    [Embed(source="Interface/StatusIcons/StatusIcons18x18.png")]
    public static var StatusIcons18x18:Class;
    // Characters
    [Embed(source="Entities/Player/Pets16x16.png")]
    public static var Pets16x16:Class;
    // Environment

    [Embed(source="Environment/customobjects16x16.png")]
    public static var customobjects16x16:Class;
    [Embed(source="Environment/Foundry/Foundry_Environment8x8.png")]
    public static var Foundry_Environment8x8:Class;
    [Embed(source="Environment/Foundry/Foundry_Environment16x16.png")]
    public static var Foundry_Environment16x16:Class;
    [Embed(source="Environment/Foundry/Foundry_Environment32x32.png")]
    public static var Foundry_Environment32x32:Class;
    [Embed(source="Environment/Tavern/Tavern_Environment8x8.png")]
    public static var Tavern_Environment8x8:Class;
    [Embed(source="Environment/Vault/Vault_Environment8x8.png")]
    public static var Vault_Environment8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_NotSpecific8x8.png")]
    public static var Overworld_Environment_NotSpecific8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_FearedShallows8x8.png")]
    public static var Overworld_Environment_FearedShallows8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_FearedShallows16x16.png")]
    public static var Overworld_Environment_FearedShallows16x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_FearedShallows32x32.png")]
    public static var Overworld_Environment_FearedShallows32x32:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_GarnetWoods8x8.png")]
    public static var Overworld_Environment_GarnetWoods8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_GarnetWoods8x16.png")]
    public static var Overworld_Environment_GarnetWoods8x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_GarnetWoods16x16.png")]
    public static var Overworld_Environment_GarnetWoods16x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_GarnetWoods32x32.png")]
    public static var Overworld_Environment_GarnetWoods32x32:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_SandstoneValley8x8.png")]
    public static var Overworld_Environment_SandstoneValley8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_SandstoneValley16x8.png")]
    public static var Overworld_Environment_SandstoneValley16x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_SandstoneValley16x16.png")]
    public static var Overworld_Environment_SandstoneValley16x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_SandstoneValley32x32.png")]
    public static var Overworld_Environment_SandstoneValley32x32:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_Feltare8x8.png")]
    public static var Overworld_Environment_Feltare8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_Feltare16x16.png")]
    public static var Overworld_Environment_Feltare16x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_Feltare32x32.png")]
    public static var Overworld_Environment_Feltare32x32:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_AshenValley8x8.png")]
    public static var Overworld_Environment_AshenValley8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_AshenValley16x16.png")]
    public static var Overworld_Environment_AshenValley16x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_DroughtsPath8x8.png")]
    public static var Overworld_Environment_DroughtsPath8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_DroughtsPath16x16.png")]
    public static var Overworld_Environment_DroughtsPath16x16:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_Nidavellir8x8.png")]
    public static var Overworld_Environment_Nidavellir8x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_Nidavellir16x8.png")]
    public static var Overworld_Environment_Nidavellir16x8:Class;
    [Embed(source="Environment/Overworld/Overworld_Environment_Nidavellir16x16.png")]
    public static var Overworld_Environment_Nidavellir16x16:Class;
    // Equipment
    [Embed(source="Items/Godly/GodlyMiscellaneous.png")]
    public static var GodlyMiscellaneous:Class;
    [Embed(source="Items/Godly/GodlyAbilities.png")]
    public static var GodlyAbilities:Class;
    [Embed(source="Items/Godly/GodlyAccessories.png")]
    public static var GodlyAccessories:Class;
    [Embed(source="Items/Godly/GodlyArmor.png")]
    public static var GodlyArmor:Class;
    [Embed(source="Items/Godly/GodlyProjectiles.png")]
    public static var GodlyProjectiles:Class;
    [Embed(source="Items/Godly/GodlyWeapons.png")]
    public static var GodlyWeapons:Class;

    [Embed(source="Items/GodSlayer/GodSlayerWeapons.png")]
    public static var GodSlayerWeapons:Class;
    [Embed(source="Items/GodSlayer/GodSlayerAbilities.png")]
    public static var GodSlayerAbilities:Class;
    [Embed(source="Items/GodSlayer/GodSlayerAccessories.png")]
    public static var GodSlayerAccessories:Class;
    [Embed(source="Items/GodSlayer/GodSlayerArmor.png")]
    public static var GodSlayerArmor:Class;
    [Embed(source="Items/GodSlayer/GodSlayerProjectiles.png")]
    public static var GodSlayerProjectiles:Class;

    [Embed(source="Items/Legendary/LegendaryWeapons.png")]
    public static var LegendaryWeapons:Class;
    [Embed(source="Items/Legendary/LegendaryAbilities.png")]
    public static var LegendaryAbilities:Class;
    [Embed(source="Items/Legendary/LegendaryAccessories.png")]
    public static var LegendaryAccessories:Class;
    [Embed(source="Items/Legendary/LegendaryArmor.png")]
    public static var LegendaryArmor:Class;
    [Embed(source="Items/Legendary/LegendaryProjectiles.png")]
    public static var LegendaryProjectiles:Class;

    [Embed(source="Items/Sacred/Sacred.png")]
    public static var Sacred:Class;
    [Embed(source="Items/Sacred/SacredWeapons.png")]
    public static var SacredWeapons:Class;
    [Embed(source="Items/Sacred/SacredAbilities.png")]
    public static var SacredAbilities:Class;
    [Embed(source="Items/Sacred/SacredAccessories.png")]
    public static var SacredAccessories:Class;
    [Embed(source="Items/Sacred/SacredArmor.png")]
    public static var SacredArmor:Class;
    [Embed(source="Items/Sacred/SacredProjectiles.png")]
    public static var SacredProjectiles:Class;
    [Embed(source="Items/Sacred/SacredProjs.png")]
    public static var SacredProjs:Class;


    [Embed(source="Items/StarterGear.png")]
    public static var StarterGear:Class;

    [Embed(source="Items/Artifact/ArtifactAbilities.png")]
    public static var ArtifactAbilities:Class;
    [Embed(source="Items/Artifact/ArtifactAbilityCharacters8x8.png")]
    public static var ArtifactAbilityCharacters8x8:Class;
    [Embed(source="Items/Artifact/ArtifactAbilityCharacters16x16.png")]
    public static var ArtifactAbilityCharacters16x16:Class;
    [Embed(source="Items/Artifact/ArtifactAbilityEntities.png")]
    public static var ArtifactAbilityEntities:Class;
    [Embed(source="Items/Artifact/ArtifactAbilityEntities16x16.png")]
    public static var ArtifactAbilityEntities16x16:Class;
    [Embed(source="Items/Artifact/ArtifactAbilityProjectiles.png")]
    public static var ArtifactAbilityProjectiles:Class;
    [Embed(source="Items/Artifact/ArtifactAccessories.png")]
    public static var ArtifactAccessories:Class;
    [Embed(source="Items/Artifact/ArtifactArmor.png")]
    public static var ArtifactArmor:Class;
    [Embed(source="Items/Artifact/ArtifactWeapons.png")]
    public static var ArtifactWeapons:Class;
    [Embed(source="Items/Artifact/ArtifactWeaponsProjectiles.png")]
    public static var ArtifactWeaponsProjectiles:Class;

    [Embed(source="Items/Valiant/ValiantAbilities.png")]
    public static var ValiantAbilities:Class;
    [Embed(source="Items/Valiant/ValiantAbilityCharacters.png")]
    public static var ValiantAbilityCharacters:Class;
    [Embed(source="Items/Valiant/ValiantAbilityEntities16x16.png")]
    public static var ValiantAbilityEntities16x16:Class;
    [Embed(source="Items/Valiant/ValiantAbilityProjectiles.png")]
    public static var ValiantAbilityProjectiles:Class;
    [Embed(source="Items/Valiant/ValiantAccessories.png")]
    public static var ValiantAccessories:Class;
    [Embed(source="Items/Valiant/ValiantArmor.png")]
    public static var ValiantArmor:Class;
    [Embed(source="Items/Valiant/ValiantWeapons.png")]
    public static var ValiantWeapons:Class;
    [Embed(source="Items/Valiant/ValiantWeaponsProjectiles.png")]
    public static var ValiantWeaponsProjectiles:Class;
    // Crafting, Consumables, Ingredients
    [Embed(source="Items/Consumables/Consumables_Maxing8x8.png")]
    public static var Consumables_Maxing8x8:Class;
    [Embed(source="Items/Consumables/Consumables_Tokens8x8.png")]
    public static var Consumables_Tokens8x8:Class;
    [Embed(source="Items/Consumables/Consumables_Upgrades8x8.png")]
    public static var Consumables_Upgrades8x8:Class;

    [Embed(source="Items/Utilities/Utilities_Artifact8x8.png")]
    public static var Utilities_Artifact8x8:Class;
    [Embed(source="Items/Utilities/Utilities_PetStones8x8.png")]
    public static var Utilities_PetStones8x8:Class;
    [Embed(source="Items/Utilities/Utilities_Valiant8x8.png")]
    public static var Utilities_Valiant8x8:Class;

    [Embed(source="Items/Crafting/Crafting_Capsules8x8.png")]
    public static var Crafting_Capsules8x8:Class;
    [Embed(source="Items/Crafting/Crafting_Ingredients8x8.png")]
    public static var Crafting_Ingredients8x8:Class;
    [Embed(source="Items/Crafting/Crafting_LuckyDips.png")]
    public static var Crafting_LuckyDips:Class;
    // Interactables
    [Embed(source="Entities/Containers/DroppedContainers8x8.png")]
    public static var DroppedContainers8x8:Class;
    [Embed(source="Entities/Containers/Foundry_Containers16x16.png")]
    public static var Foundry_Containers16x16:Class;

    [Embed(source="Portals/Foundry_Portals16x16.png")]
    public static var Foundry_Portals16x16:Class;
    [Embed(source="Portals/Foundry_Portals32x32.png")]
    public static var Foundry_Portals32x32:Class;

    [Embed(source="Entities/Stations/Foundry_Stations16x16.png")]
    public static var Foundry_Stations16x16:Class;
    [Embed(source="Entities/Stations/Foundry_Stations32x32.png")]
    public static var Foundry_Stations32x32:Class;
    [Embed(source="Entities/Stations/Marketplace_Stations16x16.png")]
    public static var Marketplace_Stations16x16:Class;
    // Old System
    [Embed(source="Xmls/Particles.xml", mimeType="application/octet-stream")]
    public static var particles:Class;
    [Embed(source="lofiInterface.png")]
    public static var lofiInterface:Class;
    [Embed(source="lofiInterfaceBig.png")]
    public static var lofiInterfaceBig:Class;
    [Embed(source="lofiInterface2.png")]
    public static var lofiInterface2:Class;
    [Embed(source="lofiParts.png")]
    public static var lofiParts:Class;
    [Embed(source="Entities/Player/Players.png")]
    public static var Players:Class;
    [Embed(source="Entities/Player/PlayersMask.png")]
    public static var playersMask:Class;
    [Embed(source="Entities/Player/playersSkins.png")]
    public static var playersSkins:Class;
    [Embed(source="Entities/Player/playersSkinsMask.png")]
    public static var playersSkinsMask:Class;

    [Embed(source="stars.png")]
    public static var stars:Class;
    [Embed(source="Entities/Player/textile4x4.png")]
    public static var textile4x4:Class;
    [Embed(source="Entities/Player/textile5x5.png")]
    public static var textile5x5:Class;
    [Embed(source="Entities/Player/Textiles8x8.png")]
    public static var Textiles8x8:Class;
    [Embed(source="Entities/Player/textile9x9.png")]
    public static var textile9x9:Class;
    [Embed(source="Entities/Player/textile10x10.png")]
    public static var textile10x10:Class;
    [Embed(source="innerMask.png")]
    public static var innerMask:Class;
    [Embed(source="sidesMask.png")]
    public static var sidesMask:Class;
    [Embed(source="outerMask.png")]
    public static var outerMask:Class;
    [Embed(source="innerP1Mask.png")]
    public static var innerP1Mask:Class;
    [Embed(source="innerP2Mask.png")]
    public static var innerP2Mask:Class;
    [Embed(source="cursors.png")]
    public static var cursors:Class;
    //models

    [Embed(source="Models/crate.dat", mimeType="application/octet-stream")]
    private static var crate:Class;
    [Embed(source="Models/cube.dat", mimeType="application/octet-stream")]
    private static var cube:Class;
    [Embed(source="Models/bigcube.dat", mimeType="application/octet-stream")]
    private static var bigcube:Class;
    [Embed(source="Models/icosahedron.dat", mimeType="application/octet-stream")]
    private static var icosahedron:Class;
    [Embed(source="Models/octahedron.dat", mimeType="application/octet-stream")]
    private static var octahedron:Class;
    [Embed(source="Models/pyramid.dat", mimeType="application/octet-stream")]
    private static var pyramid:Class;
    [Embed(source="Models/tetrahedron.dat", mimeType="application/octet-stream")]
    private static var tetrahedron:Class;
    [Embed(source="Models/dodecahedron.dat", mimeType="application/octet-stream")]
    private static var dodecahedron:Class;
    [Embed(source="Models/pillar.dat", mimeType="application/octet-stream")]
    private static var pillar:Class;
    [Embed(source="Models/brokenPillar.dat", mimeType="application/octet-stream")]
    private static var brokenPillar:Class;
    [Embed(source="Models/tower.dat", mimeType="application/octet-stream")]
    private static var tower:Class;
    [Embed(source="Models/obelisk.dat", mimeType="application/octet-stream")]
    private static var obelisk:Class;
    [Embed(source="Models/table.dat", mimeType="application/octet-stream")]
    private static var table:Class;
    [Embed(source="Models/tableEdge.dat", mimeType="application/octet-stream")]
    private static var tableEdge:Class;
    [Embed(source="Models/sign.dat", mimeType="application/octet-stream")]
    private static var sign:Class;
    [Embed(source="Models/web.dat", mimeType="application/octet-stream")]
    private static var web:Class;

    public static var models_:Object = {
        "Crate": new crate(),
        "Cube": new cube(),
        "Big Cube": new bigcube(),
        "Ico": new icosahedron(),
        "Octa": new octahedron(),
        "Pyramid": new pyramid(),
        "Tetra": new tetrahedron(),
        "Dodec": new dodecahedron(),
        "Pillar": new pillar(),
        "Broken Pillar": new brokenPillar(),
        "Tower": new tower(),
        "Obelisk": new obelisk(),
        "Table": new table(),
        "Table Edge": new tableEdge(),
        "Sign": new sign(),
        "Web": new web()
    };


    public function EmbeddedAssets() {
        super();
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinListItemFactory.as">
package svera.untiered.classes.view {
import com.company.assembleegameclient.util.Currency;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;

import svera.untiered.assets.model.Animation;

import svera.untiered.assets.services.CharacterFactory;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkins;
import svera.untiered.util.components.LegacyBuyButton;

public class CharacterSkinListItemFactory {
    [Inject]
    public var characters:CharacterFactory;

    public function CharacterSkinListItemFactory() {
        super();
    }

    public function make(skins:CharacterSkins):Vector.<CharacterSkinListItem> {
        var count:int;
        count = skins.getCount();
        var items:Vector.<CharacterSkinListItem> = new Vector.<CharacterSkinListItem>(count, true);
        for (var i:int = 0; i < count; i++) {
            var charSkinTile:CharacterSkinListItem = makeCharacterSkinTile(skins.getSkinAt(i));
            items[i] = charSkinTile;
            charSkinTile.index = i;
        }
        return items;
    }

    private function makeCharacterSkinTile(model:CharacterSkin):CharacterSkinListItem {
        var view:CharacterSkinListItem = new CharacterSkinListItem();

        view.setSkin(makeIcon(model));
        view.setModel(model);
        view.setLockIcon(AssetLibrary.getImageFromSet("lofiInterface2", 5));
        return view;
    }


    private function makeIcon(model:CharacterSkin):Animation {
        var data:Animation = characters.makeWalkingIcon(model.template, 100);
        return data;
    }
}
}
</file>

<file path="src/svera/untiered/game/view/components/StatsView.as">
package svera.untiered.game.view.components {
import com.company.assembleegameclient.objects.Player;

import flash.display.Sprite;

import mx.utils.StringUtil;

import svera.untiered.game.model.StatModel;

public class StatsView extends Sprite {

    public static const ATTACK:int = 0;
    public static const ARMOR:int = 1;
    public static const SPEED:int = 2;
    public static const DEXTERITY:int = 3;
    public static const VIGOR:int = 4;
    public static const INTELLECT:int = 5;
    public static const OVERSHIELDMAX:int = 6;
    public static const OVERSHIELDDELAY:int = 7;
    public static const OVERSHIELDRECHARGERATE:int = 8;
    public static const RESILIENCE:int = 9;
    public static const PHYSICALRESIST:int = 10;
    public static const MAGICRESIST:int = 11;
    public static const ELEMENTALRESIST:int = 12;
    public static const FIRERESIST:int = 13;
    public static const WATERRESIST:int = 14;
    public static const WINDRESIST:int = 15;
    public static const ELECTRICRESIST:int = 16;
    public static const EARTHRESIST:int = 17;
    public static const ICERESIST:int = 18;
    public static const VOIDRESIST:int = 19;
    public static const LIGHTRESIST:int = 20;
    public static const BLASTRESIST:int = 21;
    public static const STRENGTH:int = 22;
    public static const PHYSICALDMG:int = 23;
    public static const MAGICALDMG:int = 24;
    public static const FIREDMG:int = 25;
    public static const WATERDMG:int = 26;
    public static const WINDDMG:int = 27;
    public static const ELECTRICDMG:int = 28;
    public static const EARTHDMG:int = 29;
    public static const ICEDMG:int = 30;
    public static const VOIDDMG:int = 31;
    public static const LIGHTDMG:int = 32;
    public static const BLASTDMG:int = 33;
    public static const ABILITYPWR:int = 34;
    public static const CRITICALCHANCE:int = 35;
    public static const CRITICALDAMAGE:int = 36;
    public static const ABILITYCRITCHANCE:int = 37;
    public static const ABILITYCRITDAMAGE:int = 38;
    public static const EVASION:int = 39;
    public static const LUCK:int = 40;
    public static const TENACITY:int = 41;
    public static const ABILITYCOOLDOWN:int = 42;
    public static const DOWNDURATION:int = 43;
    public static const POWER:int = 44;
    public static const DASHCOOLDOWN:int = 45;
    public static const DASHWINDOW:int = 46;


    private static const statsModel:Array = [new StatModel("ATT", "Attack", "This stat increases the amount of damage done.", true),
        new StatModel("ARM", "Armor", "This stat decreases the amount of damage taken.", false),
        new StatModel("SPD", "Speed", "This stat increases the speed at which the character moves.", true),
        new StatModel("DEX", "Dexterity", "This stat increases the speed at which the character attacks.", true),
        new StatModel("VIG", "Vigor", "This stat increases the speed at which hit points are recovered.", true),
        new StatModel("INT", "Intellect", "This stat increases the speed at which resource points are recovered.", true),
        // Overshield Related
        new StatModel("OSM", "OvershieldMax","Overshield Capacity"), // Overshield Capacity
        new StatModel("OSD", "OvershieldDelay","Delay before overshield recharges"), // Delay before overshield recharges
        new StatModel("OSRR", "OvershieldRechargeRate","How fast overshield recharges"), // How fast overshield recharges
        // Resistance Related
        new StatModel("RSL","Resilience", "Physical, Magical, and Elemental Resistance in one. (Only Increased with stat points)"), // Physical, Magical, and Elemental Resistance in one. (Only Increased with stat points)
        new StatModel("PHYR","PhysicalResist", "Physical Resistance"), // Physical Resistance
        new StatModel("MGCR","MagicResist", "Magic Resistance"), // Magic Resistance
        new StatModel("ELMR","ElementalResist", "Elemental Resistance"), // Elemental Resistance
        new StatModel("FRER","FireResist", "Fire Damage"), // Fire Damage
        new StatModel("WTRR","WaterResist", "Water Damage"), // Water Damage
        new StatModel("WNDR","WindResist", "Wind Damage"), // Wind Damage
        new StatModel("ELCR","ElectricResist", "Electric Damage"), // Electric Damage
        new StatModel("ERTR","EarthResist", "Earth Damage"), // Earth Damage
        new StatModel("ICER","IceResist", "Ice Damage"), // Ice Damage
        new StatModel("VDR","VoidResist", "Void Damage"), // Void Damage
        new StatModel("LGHR","LightResist", "Light Damage"), // Light Damage
        new StatModel("BLSR","BlastResist", "Blast Resistance"), // Blast Resistance

        // Damage related
        new StatModel("STR","Strength", "Physical, Magical, and Elemental Damage in one. (Only Increased with stat points)"), // Physical, Magical, and Elemental Damage in one. (Only Increased with stat points)
        new StatModel("PHYD","PhysicalDMG", "Physical Damage"), // Physical Damage
        new StatModel("MGCD","MagicalDMG", "Magical Damage"), // Magical Damage
        new StatModel("FRD","FireDMG", "Fire Damage"), // Fire Damage
        new StatModel("WTRD","WaterDMG", "Water Damage"), // Water Damage
        new StatModel("WNDD","WindDMG", "Wind Damage"), // Wind Damage
        new StatModel("ELCD","ElectricDMG", "Electric Damage"), // Electric Damage
        new StatModel("ERTD","EarthDMG", "Earth Damage"), // Earth Damage
        new StatModel("ICED","IceDMG", "Ice Damage"), // Ice Damage
        new StatModel("VDD","VoidDMG", "Void Damage"), // Void Damage
        new StatModel("LGHD","LightDMG", "Light Damage"), // Light Damage
        new StatModel("BLSD","BlastDMG", "Blast Damage"), // Blast Damage
        new StatModel("ABLP","AbilityPWR", "Ability Power"), // Ability Power
        new StatModel("CRCH","CriticalChance", "Crit Chance"), // Crit Chance
        new StatModel("CRIT","CriticalDamage", "Crit Damage"), // Crit Damage
        new StatModel("ABLC","AbilityCritChance", "Ability Crit Chance"), // Ability Crit Chance
        new StatModel("ABLCD","AbilityCritDamage", "Ability Crit Damage"), // Ability Crit Damage

        // Character Related
        new StatModel("EVA","Evasion", "Chance to dodge incoming damage"), // Chance to dodge incoming damage
        new StatModel("LCK","Luck", "Droprate(maybe only modifies higher tier droprate SC+)"), // Droprate(maybe only modifies higher tier droprate SC+)
        new StatModel("TEN","Tenacity", "Reduce effectiveness of debuffs"), // Reduce effectiveness of debuffs
        new StatModel("ABLCD","AbilityCooldown", "Ability Cooldown"), // Ability Cooldown
        new StatModel("DWND","DownDuration", "Characters go down and can be helped up, if they don't get help or are alone they die."), // Characters go down and can be helped up, if they don't get help or are alone they die.
        new StatModel("PWR","Power", "Characters Calculated Power based on stat maxed."), // Characters Calculated Power based on stat maxed.

        // Dash Related
        new StatModel("DCD","DashCooldown", "Roll Cooldown Reduction"), // Roll Cooldown Reduction
        new StatModel("DW","DashWindow", "Roll Invulnerability Window") // Roll Invulnerability Window
    ];


    public var w_:int;
    public var h_:int;
    public var stats_:Vector.<StatView>;
    public var containerSprite:Sprite;

    public function StatsView(w:int, h:int) {
        var i:int;
        var statModel:StatModel = null;
        var stat:StatView = null;
        this.stats_ = new Vector.<StatView>();
        this.containerSprite = new Sprite();
        super();
        this.w_ = w;
        this.h_ = h;
        for (i = 0; i < statsModel.length; i++) {
            statModel = statsModel[i];

            trace(StringUtil.substitute("    public static const {0}:int = {1};\n", statModel.abbreviation.toUpperCase(), i));
            stat = new StatView(statModel.name, statModel.abbreviation, statModel.description, statModel.redOnZero);
            stat.x = (i % 2) * (w_ + 4);
            stat.y = int(i / 2) * stat.height;
            this.containerSprite.addChild(stat);
            this.stats_.push(stat);
        }
        addChild(this.containerSprite);
    }

    public function draw(go:Player):void {
        if (go != null) {
            this.stats_[ATTACK].draw(go.attack_, go.attackBoost_, go.attackMax_);
            this.stats_[ARMOR].draw(go.armor_, go.armorBoost_, go.armorMax_);
            this.stats_[SPEED].draw(go.speed_, go.speedBoost_, go.speedMax_);
            this.stats_[DEXTERITY].draw(go.dexterity_, go.dexterityBoost_, go.dexterityMax_);
            this.stats_[VIGOR].draw(go.vigor_, go.vigorBoost_, go.vigorMax_);
            this.stats_[INTELLECT].draw(go.intellect, go.intelligenceBoost_, go.intelligenceMax_);
            //stats_[
            stats_[RESILIENCE].draw(go.Resilience, 0, 0);
            stats_[PHYSICALRESIST].draw(go.PhysicalResist, 0, 0);
            stats_[MAGICRESIST].draw(go.MagicResist, 0, 0);
            stats_[ELEMENTALRESIST].draw(go.ElementalResist, 0, 0);
            stats_[FIRERESIST].draw(go.FireResist, 0, 0);
            stats_[WATERRESIST].draw(go.WaterResist, 0, 0);
            stats_[WINDRESIST].draw(go.WindResist, 0, 0);
            stats_[ELECTRICRESIST].draw(go.ElectricResist, 0, 0);
            stats_[EARTHRESIST].draw(go.EarthResist, 0, 0);
            stats_[ICERESIST].draw(go.IceResist, 0, 0);
            stats_[VOIDRESIST].draw(go.VoidResist, 0, 0);
            stats_[LIGHTRESIST].draw(go.LightResist, 0, 0);
            stats_[BLASTRESIST].draw(go.BlastResist, 0, 0);

            stats_[STRENGTH].draw(go.Strength, 0, 0);
            stats_[PHYSICALDMG].draw(go.PhysicalDMG, 0, 0);
            stats_[MAGICALDMG].draw(go.MagicalDMG, 0, 0);
            stats_[FIREDMG].draw(go.FireDMG, 0, 0);
            stats_[WATERDMG].draw(go.WaterDMG, 0, 0);
            stats_[WINDDMG].draw(go.WindDMG, 0, 0);
            stats_[ELECTRICDMG].draw(go.ElectricDMG, 0, 0);
            stats_[EARTHDMG].draw(go.EarthDMG, 0, 0);
            stats_[ICEDMG].draw(go.IceDMG, 0, 0);
            stats_[VOIDDMG].draw(go.VoidDMG, 0, 0);
            stats_[LIGHTDMG].draw(go.LightDMG, 0, 0);
            stats_[BLASTDMG].draw(go.BlastDMG, 0, 0);
            stats_[ABILITYPWR].draw(go.AbilityPWR, 0, 0);
            stats_[CRITICALCHANCE].draw(go.CriticalChance, 0, 0);
            stats_[CRITICALDAMAGE].draw(go.CriticalDamage, 0, 0);
            stats_[ABILITYCRITCHANCE].draw(go.AbilityCritChance, 0, 0);
            stats_[ABILITYCRITDAMAGE].draw(go.AbilityCritDamage, 0, 0);

            stats_[EVASION].draw(go.Evasion,0,0);
            stats_[LUCK].draw(go.Luck,0,0);
            stats_[TENACITY].draw(go.Tenacity,0,0);
            stats_[ABILITYCOOLDOWN].draw(go.AbilityCooldown,0,0);
            stats_[DOWNDURATION].draw(go.DownDuration,0,0);
            stats_[POWER].draw(go.Power,0,0);

            stats_[DASHCOOLDOWN].draw(go.DashCooldown, 0, 0);
            stats_[DASHWINDOW].draw(go.DashWindow, 0, 0);
        }
        this.containerSprite.x = 30 + (191 - this.containerSprite.width) * 0.5;
    }
}
}
</file>

<file path="src/svera/untiered/game/view/LootboxesDisplay.as">
package svera.untiered.game.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.ui.SimpleText;
import com.company.util.AssetLibrary;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;

import org.osflash.signals.Signal;

public class LootboxesDisplay extends Sprite {

    private static const FONT_SIZE:int = 18;
    public static const IMAGE_NAME:String = "ValiantWeapons";
    public static const IMAGE_ID:int = 16;

    public var lootbox2Text:SimpleText;
    public var lootbox3Text:SimpleText;
    public var lootbox4Text:SimpleText;
    public var lootbox2Icon:Bitmap;
    public var lootbox3Icon:Bitmap;
    public var lootbox4Icon:Bitmap;
    private var lootBox2_:int = -1;
    private var lootBox3_:int = -1;
    private var lootBox4_:int = -1;
    private var gs:GameSprite;
    public var openAccountDialog:Signal;

    public function LootboxesDisplay(_arg_1:GameSprite = null) {
        this.openAccountDialog = new Signal();
        super();
        this.gs = _arg_1;

        this.lootbox2Text = this.makeTextField();
        addChild(this.lootbox2Text);
        var _local_6:BitmapData = AssetLibrary.getImageFromSet(IMAGE_NAME, 0); //TODO: Before 459
        _local_6 = TextureRedrawer.redraw(_local_6, 40, true, 0)
        this.lootbox2Icon = new Bitmap(_local_6);
        addChild(this.lootbox2Icon);

        this.lootbox3Text = this.makeTextField();
        addChild(this.lootbox3Text);
        var _local_7:BitmapData = AssetLibrary.getImageFromSet(IMAGE_NAME, 18);
        _local_7 = TextureRedrawer.redraw(_local_7, 40, true, 0);
        this.lootbox3Icon = new Bitmap(_local_7);
        addChild(this.lootbox3Icon);

        this.lootbox4Text = this.makeTextField();
        addChild(this.lootbox4Text);
        var _local_8:BitmapData = AssetLibrary.getImageFromSet(IMAGE_NAME, 19);
        _local_8 = TextureRedrawer.redraw(_local_8, 40, true, 0);
        this.lootbox4Icon = new Bitmap(_local_8);
        addChild(this.lootbox4Icon);


        this.draw(0, 0, 0);
        mouseEnabled = true;
        doubleClickEnabled = true;
        addEventListener(MouseEvent.DOUBLE_CLICK, this.onDoubleClick, false, 0, true);
    }

    private function onDoubleClick(_arg_1:MouseEvent):void {
        if (!this.gs || this.gs.isNexus_ || Parameters.data_.clickForTsavorite) {
            this.openAccountDialog.dispatch();
        }
    }

    public function makeTextField(_arg_1:uint = 0xFFFFFF):SimpleText {
        var _local_2:SimpleText = new SimpleText(FONT_SIZE, _arg_1, false, 0, 16);
        _local_2.filters = [new DropShadowFilter(0, 0, 0, 1, 4, 4, 2)];
        return _local_2;
    }

    public function draw(_arg_1:int, _arg_2:int, _arg_3:int):void {
        this.lootBox2_ = _arg_1;
        this.lootBox3_ = _arg_2;
        this.lootBox4_ = _arg_3;
        this.lootbox2Text.setText(this.lootBox2_.toString());
        this.lootbox3Text.setText(this.lootBox3_.toString());
        this.lootbox4Text.setText(this.lootBox4_.toString());
    }


}
}//package svera.untiered.game.view
</file>

<file path="src/svera/untiered/storage/VaultContent.as">
package svera.untiered.storage {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.objects.VaultChest;
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.assembleegameclient.ui.panels.itemgrids.ContainerGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.InteractiveItemTile;
import com.company.util.SpriteUtil;

import flash.display.Sprite;

import svera.untiered.itemdata.NewItemData;

import svera.untiered.messaging.impl.GameServerConnection;

import svera.untiered.storage.components.StorageSortTab;

public class VaultContent extends Sprite {
    private var vaultGrid_:ContainerGrid;

    private var scrollBar_:Scrollbar;

    private var owner_:VaultChest;
    private var player_:Player;

    private var curSort_:String;

    public function VaultContent(owner:VaultChest, player:Player) {
        this.owner_ = owner;
        this.player_ = player;

        GameServerConnection.instance.storageRequest(owner.objectId_);

        this.scrollBar_ = new Scrollbar(15, StorageUtil.CONTENT_HEIGHT);

        graphics.beginFill(0);
        graphics.drawRect(0, 0, StorageUtil.CONTENT_WIDTH, StorageUtil.CONTENT_HEIGHT);
        graphics.endFill();
    }

    private var content_:Vector.<NewItemData>;

    public function initialize(size:int, content:Vector.<NewItemData>):void {
        if (this.vaultGrid_ != null) {
            SpriteUtil.safeRemoveChild(this, this.vaultGrid_);
        }

        this.content_ = content;
        this.vaultGrid_ = new ContainerGrid(this.owner_, this.player_, size, 8, true);

        this.vaultGrid_.setItems(content);
        this.vaultGrid_.x = 10;
        this.vaultGrid_.y = 10;
        // add scroll wheel here

        SpriteUtil.safeAddChild(this, this.vaultGrid_);
    }

    public function updateSlot(slot:int, inventory:NewItemData):void {
        this.vaultGrid_.setItem(slot, inventory);
    }

    public function sortBy(sort:String):void {
        if (this.curSort_ == sort) {
            return;
        }

        this.curSort_ = sort;
        this.filterSlotsBySlotType(StorageSortTab.getSortArray(this.curSort_));
    }

    public function filterSlotsBySlotType(types:Array):void {
        while (this.vaultGrid_.numChildren > 0) {
            this.vaultGrid_.removeChildAt(0);
        }

        var slotCount:int = 0;
        for each(var tile:InteractiveItemTile in this.vaultGrid_.items) {
            var slotType:int = ObjectLibrary.getSlotTypeFromItemData(tile.getItemData());

            if (types.indexOf(slotType) > -1 || types.length == 0) {
                this.vaultGrid_.addToGrid(tile, 8, slotCount);
                slotCount++;
            }
        }
    }

    public function dispose():void {
        removeChild(this.vaultGrid_);
        this.vaultGrid_ = null;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/Projectile.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.engine3d.Point3D;
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.map.Square;
import com.company.assembleegameclient.objects.particles.HitEffect;
import com.company.assembleegameclient.objects.particles.SparkParticle;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.util.BloodComposition;
import com.company.assembleegameclient.util.FreeList;
import com.company.assembleegameclient.util.RandomUtil;
import com.company.util.GraphicsUtil;
import com.company.util.Trig;

import flash.display.BitmapData;
import flash.display.GradientType;
import flash.display.GraphicsGradientFill;
import flash.display.GraphicsPath;
import flash.display.IGraphicsData;
import flash.geom.Matrix;
import flash.geom.Point;
import flash.geom.Vector3D;
import flash.utils.Dictionary;

import svera.untiered.itemdata.ProjectileData;

public class Projectile extends BasicObject {
    public static var nextFakeBulletId_:int = 0;

    public var props_:ObjectProperties;
    public var containerProps_:ObjectProperties;
    public var projProps_:ProjectileProperties;
    public var texture_:BitmapData;
    public var bulletId_:int;
    public var ownerId_:int;
    public var containerType_:int;
    public var bulletType_:uint;
    public var damagesEnemies_:Boolean;
    public var damagesPlayers_:Boolean;
    public var damage_:int;
    public var sound_:String;
    public var startX_:Number;
    public var startY_:Number;
    public var startTime_:int;
    public var angle_:Number = 0;
    public var multiHitDict_:Dictionary;
    public var p_:Point3D;
    private var staticPoint_:Point;
    private var staticVector3D_:Vector3D;
    protected var shadowGradientFill_:GraphicsGradientFill;
    protected var shadowPath_:GraphicsPath;

    public function Projectile() {
        this.p_ = new Point3D(100);
        this.staticPoint_ = new Point();
        this.staticVector3D_ = new Vector3D();
        this.shadowGradientFill_ = new GraphicsGradientFill(GradientType.RADIAL, [0, 0], [0.5, 0], null, new Matrix());
        this.shadowPath_ = new GraphicsPath(GraphicsUtil.QUAD_COMMANDS, new Vector.<Number>());
        super();
    }

    public function reset(containerType:int, bulletType:int, ownerId:int, bulletId:int, angle:Number, startTime:int):void {
        var size:Number;
        clear();
        this.containerType_ = containerType;
        this.bulletType_ = bulletType;
        this.bulletId_ = bulletId;
        this.ownerId_ = ownerId;
        this.angle_ = Trig.boundToPI(angle);
        this.startTime_ = startTime;
        objectId_ = getNextFakeObjectId();
        z_ = 0.5;
        this.containerProps_ = ObjectLibrary.propsLibrary_[this.containerType_];
        this.projProps_ = this.containerProps_.projectiles_[bulletType];
        this.props_ = ObjectLibrary.getPropsFromId(this.projProps_.objectId_);
        hasShadow_ = this.props_.shadowSize_ > 0;
        var textureData:TextureData = ObjectLibrary.typeToTextureData_[this.props_.type_];
        this.texture_ = textureData.getTexture(objectId_);
        this.damagesPlayers_ = this.containerProps_.isEnemy_;
        this.damagesEnemies_ = !this.damagesPlayers_;
        this.sound_ = this.containerProps_.oldSound_;
        this.multiHitDict_ = this.projProps_.multiHit_ ? new Dictionary() : null;
        if (this.projProps_.size_ >= 0) {
            size = this.projProps_.size_;
        } else {
            size = ObjectLibrary.getSizeFromType(this.containerType_);
        }
        this.p_.setSize(8 * (size / 100));
        this.damage_ = 0;
    }
    public function reset2(containerType:int, bulletType:int, ownerId:int, bulletId:int, angle:Number, startTime:int):void {
        var size:Number;
        clear();
        this.containerType_ = containerType;
        this.bulletType_ = bulletType;
        this.bulletId_ = bulletId;
        this.ownerId_ = ownerId;
        this.angle_ = Trig.boundToPI(angle);
        this.startTime_ = startTime;
        objectId_ = getNextFakeObjectId();
        z_ = 0.5;
        this.containerProps_ = ObjectLibrary.propsLibrary_[this.containerType_];
        this.projProps_ = this.containerProps_.projectiles_[bulletType];
        this.props_ = ObjectLibrary.getPropsFromId(this.projProps_.objectId_);
        hasShadow_ = this.props_.shadowSize_ > 0;
        var textureData:TextureData = ObjectLibrary.typeToTextureData_[this.props_.type_];
        this.texture_ = textureData.getTexture(objectId_);
        this.damagesPlayers_ = this.containerProps_.isEnemy_;
        this.damagesEnemies_ = !this.damagesPlayers_;
        this.sound_ = this.containerProps_.oldSound_;
        this.multiHitDict_ = this.projProps_.multiHit_ ? new Dictionary() : null;
        if (this.projProps_.size_ >= 0) {
            size = this.projProps_.size_;
        } else {
            size = ObjectLibrary.getSizeFromType(this.containerType_);
        }
        this.p_.setSize(8 * (size / 100));
        this.damage_ = 0;
    }

    public function setDamage(damage:int):void {
        this.damage_ = damage;
    }

    override public function addTo(map:Map, x:Number, y:Number):Boolean {
        var player:Player = null;
        this.startX_ = x;
        this.startY_ = y;
        if (!super.addTo(map, x, y)) {
            return false;
        }
        if (!this.containerProps_.flying_ && square_.sink_) {
            if (square_.obj_ && square_.obj_.props_.protectFromSink_) {
                z_ = 0.5;
            } else {
                z_ = 0.1;
            }
        } else {
            player = map.goDict_[this.ownerId_] as Player;
            if (player != null && player.sinkLevel_ > 0) {
                z_ = 0.5 - 0.4 * (player.sinkLevel_ / Parameters.MAX_SINK_LEVEL);
            }
        }
        return true;
    }

    public function moveTo(x:Number, y:Number):Boolean {
        var square:Square = map_.getSquare(x, y);
        if (square == null) {
            return false;
        }
        x_ = x;
        y_ = y;
        square_ = square;
        return true;
    }

    override public function removeFromMap():void {
        super.removeFromMap();
        this.multiHitDict_ = null;
        FreeList.deleteObject(this);
    }

    private function positionAt(elapsed:int, p:Point):void {
        var periodFactor:Number = NaN;
        var amplitudeFactor:Number = NaN;
        var theta:Number = NaN;
        var t:Number = NaN;
        var x:Number = NaN;
        var y:Number = NaN;
        var sin:Number = NaN;
        var cos:Number = NaN;
        var halfway:Number = NaN;
        var deflection:Number = NaN;
        p.x = this.startX_;
        p.y = this.startY_;

        var speed:Number = this.projProps_.speed_;
        if (this.projProps_.accelerate_) {
            speed *= Number(elapsed) / this.projProps_.lifetime_;
        }

        if (this.projProps_.decelerate_) {
            speed *= 2 - Number(elapsed) / this.projProps_.lifetime_;
        }

        var dist:Number = elapsed * (speed / 10000);
        var phase:Number = this.bulletId_ % 2 == 0 ? Number(0) : Number(Math.PI);
        if (this.projProps_.wavy_) {
            periodFactor = 6 * Math.PI;
            amplitudeFactor = Math.PI / 64;
            theta = this.angle_ + amplitudeFactor * Math.sin(phase + periodFactor * elapsed / 1000);
            p.x = p.x + dist * Math.cos(theta);
            p.y = p.y + dist * Math.sin(theta);
        } else if (this.projProps_.parametric_) {
            t = elapsed / this.projProps_.lifetime_ * 2 * Math.PI;
            x = Math.sin(t) * (Boolean(this.bulletId_ % 2) ? 1 : -1);
            y = Math.sin(2 * t) * (this.bulletId_ % 4 < 2 ? 1 : -1);
            sin = Math.sin(this.angle_);
            cos = Math.cos(this.angle_);
            p.x = p.x + (x * cos - y * sin) * this.projProps_.magnitude_;
            p.y = p.y + (x * sin + y * cos) * this.projProps_.magnitude_;
        } else {
            if (this.projProps_.boomerang_) {
                halfway = this.projProps_.lifetime_ * (this.projProps_.speed_ / 10000) / 2;
                if (dist > halfway) {
                    dist = halfway - (dist - halfway);
                }
            }
            p.x = p.x + dist * Math.cos(this.angle_);
            p.y = p.y + dist * Math.sin(this.angle_);
            if (this.projProps_.amplitude_ != 0) {
                deflection = this.projProps_.amplitude_ * Math.sin(phase + elapsed / this.projProps_.lifetime_ * this.projProps_.frequency_ * 2 * Math.PI);
                p.x = p.x + deflection * Math.cos(this.angle_ + Math.PI / 2);
                p.y = p.y + deflection * Math.sin(this.angle_ + Math.PI / 2);
            }
        }
    }

    override public function update(time:int, dt:int):Boolean {
        var colors:Vector.<uint> = null;
        var player:Player = null;
        var isPlayer:Boolean = false;
        var isTargetAnEnemy:Boolean = false;
        var sendMessage:Boolean = false;
        var d:int = 0;
        var elapsed:int = time - this.startTime_;
        if (elapsed > this.projProps_.lifetime_) {
            return false;
        }
        var p:Point = this.staticPoint_;
        this.positionAt(elapsed, p);
        if (!this.moveTo(p.x, p.y) || square_.tileType_ == 255) {
            if (this.damagesPlayers_) {
                map_.gs_.gsc_.squareHit(time, this.bulletId_);
            } else if (square_.obj_ != null) {
                if (Parameters.data_.particles) {
                    colors = BloodComposition.getColors(this.texture_);
                    map_.addObj(new HitEffect(colors, 100, 3, this.angle_, this.projProps_.speed_), p.x, p.y);
                }
            }
            return false;
        }
        if (square_.obj_ != null && (!square_.obj_.props_.isEnemy_ || !this.damagesEnemies_) && (square_.obj_.props_.enemyOccupySquare_ || !this.projProps_.passesCover_ && square_.obj_.props_.occupySquare_)) {
            if (this.damagesPlayers_) {
                map_.gs_.gsc_.squareHit(time, this.bulletId_);
            } else {
                if (Parameters.data_.particles) {
                    colors = BloodComposition.getColors(this.texture_);
                    map_.addObj(new HitEffect(colors, 100, 3, this.angle_, this.projProps_.speed_), p.x, p.y);
                }
            }
            return false;
        }

        var targets:Vector.<GameObject> = this.getHit(p.x, p.y);
        if (targets.length > 0) {
            var target:GameObject;
            for each (target in targets) {
                player = map_.player_;
                isPlayer = player != null;
                isTargetAnEnemy = target.props_.isEnemy_;
                sendMessage = isPlayer && (this.damagesPlayers_ || isTargetAnEnemy && this.ownerId_ == player.objectId_);
                if (sendMessage) {
                    d = GameObject.damageWithDefense(this.damage_, target.armor_, this.projProps_.armorPiercing_, target.condition_);
                    if (target == player) {
                        map_.gs_.gsc_.playerHit(this.bulletId_);
                        target.damage(d, this.projProps_.effects_, this);
                    } else if (target.props_.isEnemy_) {
                        map_.gs_.gsc_.enemyHit(time, this.bulletId_, target.objectId_);
                        target.damage(d, this.projProps_.effects_, this);
                    }
                }
                if (this.projProps_.multiHit_) {
                    this.multiHitDict_[target] = true;
                } else {
                    return false;
                }
            }
        }
        return true;
    }

    public function getHit(pX:Number, pY:Number):Vector.<GameObject> {
        var go:GameObject = null;
        var xDiff:Number = NaN;
        var yDiff:Number = NaN;
        var dist:Number = NaN;
        var minDist:Number = Number.MAX_VALUE;
        var minGO:GameObject = null;
        var gos:Vector.<GameObject> = new Vector.<GameObject>();

        if (damagesEnemies_) {
            for each(go in map_.hittable_) {
                xDiff = go.x_ > pX ? Number(go.x_ - pX) : Number(pX - go.x_);
                yDiff = go.y_ > pY ? Number(go.y_ - pY) : Number(pY - go.y_);
                if (xDiff <= GameObject.HITBOX_RADIUS && yDiff <= GameObject.HITBOX_RADIUS) {
                    if (!(this.projProps_.multiHit_ && this.multiHitDict_[go] != null)) {
                        if (this.projProps_.multiHit_)
                            gos.push(go);
                        else {
                            dist = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
                            if (dist < minDist) {
                                minDist = dist;
                                gos.length = 0;
                                gos.push(go);
                            }
                        }
                    }
                }
            }
        } else if (damagesPlayers_) {
            go = map_.player_;
            if (go.isTargetable()) {
                xDiff = go.x_ > pX ? Number(go.x_ - pX) : Number(pX - go.x_);
                yDiff = go.y_ > pY ? Number(go.y_ - pY) : Number(pY - go.y_);
                if (!(xDiff > GameObject.HITBOX_RADIUS || yDiff > GameObject.HITBOX_RADIUS)) {
                    if (!(this.projProps_.multiHit_ && this.multiHitDict_[go] != null)) {
                        gos.push(go);
                    }
                }
            }
        }
        return gos;
    }

    override public function draw(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var texture:BitmapData = this.texture_;

        var r:Number = this.props_.rotation_ == 0 ? Number(0) : Number(time / this.props_.rotation_);
        this.staticVector3D_.x = x_;
        this.staticVector3D_.y = y_;
        this.staticVector3D_.z = z_;
        this.p_.draw(graphicsData, this.staticVector3D_, this.angle_ - camera.angleRad_ + this.props_.angleCorrection_ + r, camera.wToS_, camera, texture);
        if (this.projProps_.particleTrail_ && Parameters.data_.particles) {
            map_.addObj(new SparkParticle(100, 16711935, 600, 0.5, RandomUtil.plusMinus(3), RandomUtil.plusMinus(3)), x_, y_);
            map_.addObj(new SparkParticle(100, 16711935, 600, 0.5, RandomUtil.plusMinus(3), RandomUtil.plusMinus(3)), x_, y_);
            map_.addObj(new SparkParticle(100, 16711935, 600, 0.5, RandomUtil.plusMinus(3), RandomUtil.plusMinus(3)), x_, y_);
        }
    }

    override public function drawShadow(graphicsData:Vector.<IGraphicsData>, camera:Camera, time:int):void {
        var s:Number = this.props_.shadowSize_ / 400;
        var w:Number = 30 * s;
        var h:Number = 15 * s;
        this.shadowGradientFill_.matrix.createGradientBox(w * 2, h * 2, 0, posS_[0] - w, posS_[1] - h);
        graphicsData.push(this.shadowGradientFill_);
        this.shadowPath_.data.length = 0;
        this.shadowPath_.data.push(posS_[0] - w, posS_[1] - h, posS_[0] + w, posS_[1] - h, posS_[0] + w, posS_[1] + h, posS_[0] - w, posS_[1] + h);
        graphicsData.push(this.shadowPath_);
        graphicsData.push(GraphicsUtil.END_FILL);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/EquippedGrid.as">
package com.company.assembleegameclient.ui.panels.itemgrids {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.EquipmentTile;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.ItemTile;
import com.company.util.ArrayIterator;
import com.company.util.IIterator;

import flash.events.MouseEvent;

import svera.lib.util.VectorAS3Util;
import svera.untiered.itemdata.NewItemData;

public class EquippedGrid extends ItemGrid {


    private const NUM_SLOTS:uint = 5;

    private var tiles:Vector.<EquipmentTile>;

    public function EquippedGrid(gridOwner:GameObject, invTypes:Vector.<int>, currentPlayer:Player, itemIndexOffset:int = 0) {
        var tile:EquipmentTile = null;
        super(gridOwner, currentPlayer, itemIndexOffset);
        this.tiles = new Vector.<EquipmentTile>(this.NUM_SLOTS);
        for (var i:int = 0; i < this.NUM_SLOTS; i++) {
            tile = new EquipmentTile(i, this, interactive);
            addToGrid(tile, 1, i);
            tile.setType(invTypes[i]);
            this.tiles[i] = tile;
        }
    }

    public override function addToGrid(tile:ItemTile, numRows:uint, tileIndex:uint):void {
        tile.drawBackground(ItemGrid.CutsByNum[numRows][tileIndex]);
        tile.addEventListener(MouseEvent.ROLL_OVER, this.onTileHover);
        tile.y = int(tileIndex / 5) * (ItemTile.HEIGHT + 3);
        tile.x = int(tileIndex % 5) * (ItemTile.WIDTH + 3);
        addChild(tile);
    }

    public function createInteractiveItemTileIterator():IIterator {
        return new ArrayIterator(VectorAS3Util.toArray(this.tiles));
    }

    override public function setItems(items:Vector.<NewItemData>, itemIndexOffset:int = 0):void {
        var numItems:int = 0;
        var i:int = 0;
        var refresh:Boolean = false;
        if (items) {
            numItems = items.length;
            for (i = 0; i < this.tiles.length; i++) {
                if (i + itemIndexOffset < numItems) {
                    if (this.tiles[i].setItem(items[i + itemIndexOffset])) {
                        refresh = true;
                    }
                } else {
                    if (this.tiles[i].setItem(null)) {
                        refresh = true;
                    }
                }
                this.tiles[i].updateDim(curPlayer);
            }

            if (refresh) {
                refreshTooltip();
            }
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/util/AssetLoader.as">
package com.company.assembleegameclient.util {
import com.company.assembleegameclient.engine3d.Model3D;
import com.company.assembleegameclient.map.GroundLibrary;
import com.company.assembleegameclient.map.RegionLibrary;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.particles.ParticleLibrary;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.options.Options;
import com.company.util.AssetLibrary;

import flash.display.BitmapData;
import flash.utils.ByteArray;

import svera.untiered.assets.EmbeddedAssets;
import svera.untiered.assets.EmbeddedData;

public class AssetLoader {


    public function AssetLoader() {
        super();
    }

    public function load():void {
        this.addImages();
        this.addAnimatedCharacters();
        this.addSoundEffects();
        this.parse3DModels();
        this.parseParticleEffects();
        this.parseGroundFiles();
        this.parseObjectFiles();
        this.parseRegionFiles();
        Parameters.load();
        Options.refreshCursor();
    }

    private function addImages():void {
        // Svera System
        // Logo
        AssetLibrary.addImage("SplashLogo", new EmbeddedAssets.SplashLogo().bitmapData);
        // Particles
        AssetLibrary.addImageSet("Player_Particles", new EmbeddedAssets.Player_Particles().bitmapData, 16, 16);
        // Icons
        AssetLibrary.addImageSet("Currency_Icons8x8", new EmbeddedAssets.Currency_Icons8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Currency_Icons16x16", new EmbeddedAssets.Currency_Icons16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("StatusIcons16x16", new EmbeddedAssets.StatusIcons16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("StatusIcons18x18", new EmbeddedAssets.StatusIcons18x18().bitmapData, 16, 16);
        // Environment
        AssetLibrary.addImageSet("cobj16x16", new EmbeddedAssets.customobjects16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Foundry_Environment8x8", new EmbeddedAssets.Foundry_Environment8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Foundry_Environment16x16", new EmbeddedAssets.Foundry_Environment16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Foundry_Environment32x32", new EmbeddedAssets.Foundry_Environment32x32().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Tavern_Environment8x8", new EmbeddedAssets.Tavern_Environment8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Vault_Environment8x8", new EmbeddedAssets.Vault_Environment8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_NotSpecific8x8", new EmbeddedAssets.Overworld_Environment_NotSpecific8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_FearedShallows8x8", new EmbeddedAssets.Overworld_Environment_FearedShallows8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_FearedShallows16x16", new EmbeddedAssets.Overworld_Environment_FearedShallows16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Overworld_Environment_FearedShallows32x32", new EmbeddedAssets.Overworld_Environment_FearedShallows16x16().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Overworld_Environment_GarnetWoods8x8", new EmbeddedAssets.Overworld_Environment_GarnetWoods8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_GarnetWoods8x16", new EmbeddedAssets.Overworld_Environment_GarnetWoods8x16().bitmapData, 8, 16);
        AssetLibrary.addImageSet("Overworld_Environment_GarnetWoods16x16", new EmbeddedAssets.Overworld_Environment_GarnetWoods16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Overworld_Environment_GarnetWoods32x32", new EmbeddedAssets.Overworld_Environment_GarnetWoods32x32().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Overworld_Environment_SandstoneValley8x8", new EmbeddedAssets.Overworld_Environment_SandstoneValley8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_SandstoneValley16x8", new EmbeddedAssets.Overworld_Environment_SandstoneValley16x8().bitmapData, 16, 8);
        AssetLibrary.addImageSet("Overworld_Environment_SandstoneValley16x16", new EmbeddedAssets.Overworld_Environment_SandstoneValley16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Overworld_Environment_SandstoneValley32x32", new EmbeddedAssets.Overworld_Environment_SandstoneValley32x32().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Overworld_Environment_Feltare8x8", new EmbeddedAssets.Overworld_Environment_Feltare8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_Feltare16x16", new EmbeddedAssets.Overworld_Environment_Feltare16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Overworld_Environment_Feltare32x32", new EmbeddedAssets.Overworld_Environment_Feltare32x32().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Overworld_Environment_AshenValley8x8", new EmbeddedAssets.Overworld_Environment_AshenValley8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_AshenValley16x16", new EmbeddedAssets.Overworld_Environment_AshenValley16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Overworld_Environment_DroughtsPath8x8", new EmbeddedAssets.Overworld_Environment_DroughtsPath8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_DroughtsPath16x16", new EmbeddedAssets.Overworld_Environment_DroughtsPath16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Overworld_Environment_Nidavellir8x8", new EmbeddedAssets.Overworld_Environment_Nidavellir8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Overworld_Environment_Nidavellir16x8", new EmbeddedAssets.Overworld_Environment_Nidavellir16x8().bitmapData, 8, 16);
        AssetLibrary.addImageSet("Overworld_Environment_Nidavellir16x16", new EmbeddedAssets.Overworld_Environment_Nidavellir16x16().bitmapData, 16, 16);
        // Equipment
        AssetLibrary.addImageSet("lofiGodSlayerAccessories", new EmbeddedAssets.GodSlayerAccessories().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodSlayerArmor", new EmbeddedAssets.GodSlayerArmor().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodSlayerAbilities", new EmbeddedAssets.GodSlayerAbilities().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodSlayerProjectiles", new EmbeddedAssets.GodSlayerProjectiles().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodSlayerWeapons", new EmbeddedAssets.GodSlayerWeapons().bitmapData, 8, 8);

        AssetLibrary.addImageSet("lofiGodlyAccessories", new EmbeddedAssets.GodlyAccessories().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodlyArmor", new EmbeddedAssets.GodlyArmor().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodlyAbilities", new EmbeddedAssets.GodlyAbilities().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodlyProjectiles", new EmbeddedAssets.GodlyProjectiles().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodlyWeapons", new EmbeddedAssets.GodlyWeapons().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiGodlyMiscellaneous", new EmbeddedAssets.GodlyMiscellaneous().bitmapData, 8, 8);

        AssetLibrary.addImageSet("lofiLegendaryAccessories", new EmbeddedAssets.LegendaryAccessories().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiLegendaryArmor", new EmbeddedAssets.LegendaryArmor().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiLegendaryAbilities", new EmbeddedAssets.LegendaryAbilities().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiLegendaryProjectiles", new EmbeddedAssets.LegendaryProjectiles().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiLegendaryWeapons", new EmbeddedAssets.LegendaryWeapons().bitmapData, 8, 8);

        AssetLibrary.addImageSet("lofiSacredAccessories", new EmbeddedAssets.SacredAccessories().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiSacredArmor", new EmbeddedAssets.SacredArmor().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiSacredAbilities", new EmbeddedAssets.SacredAbilities().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiSacredProjectiles", new EmbeddedAssets.SacredProjectiles().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiSacredWeapons", new EmbeddedAssets.SacredWeapons().bitmapData, 8, 8);

        AssetLibrary.addImageSet("StarterGear", new EmbeddedAssets.StarterGear().bitmapData, 8, 8);

        AssetLibrary.addImageSet("ArtifactAbilities", new EmbeddedAssets.ArtifactAbilities().bitmapData, 8, 8);

        AssetLibrary.addImageSet("ArtifactAbilityEntities", new EmbeddedAssets.ArtifactAbilityEntities().bitmapData, 16, 16);
        AssetLibrary.addImageSet("ArtifactAbilityEntities16x16", new EmbeddedAssets.ArtifactAbilityEntities16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("ArtifactAbilityProjectiles", new EmbeddedAssets.ArtifactAbilityProjectiles().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ArtifactAccessories", new EmbeddedAssets.ArtifactAccessories().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ArtifactArmor", new EmbeddedAssets.ArtifactArmor().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ArtifactWeapons", new EmbeddedAssets.ArtifactWeapons().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ArtifactWeaponsProjectiles", new EmbeddedAssets.ArtifactWeaponsProjectiles().bitmapData, 8, 8);

        AssetLibrary.addImageSet("ValiantAbilities", new EmbeddedAssets.ValiantAbilities().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ValiantAbilityEntities16x16", new EmbeddedAssets.ValiantAbilityEntities16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("ValiantAbilityProjectiles", new EmbeddedAssets.ValiantAbilityProjectiles().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ValiantAccessories", new EmbeddedAssets.ValiantAccessories().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ValiantArmor", new EmbeddedAssets.ValiantArmor().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ValiantWeapons", new EmbeddedAssets.ValiantWeapons().bitmapData, 8, 8);
        AssetLibrary.addImageSet("ValiantWeaponsProjectiles", new EmbeddedAssets.ValiantWeaponsProjectiles().bitmapData, 8, 8);
        // Crafting, Consumables, Ingredients
        AssetLibrary.addImageSet("Consumables_Maxing8x8", new EmbeddedAssets.Consumables_Maxing8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Consumables_Tokens8x8", new EmbeddedAssets.Consumables_Tokens8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Consumables_Upgrades8x8", new EmbeddedAssets.Consumables_Upgrades8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Utilities_Artifact8x8", new EmbeddedAssets.Utilities_Artifact8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Utilities_PetStones8x8", new EmbeddedAssets.Utilities_PetStones8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Utilities_Valiant8x8", new EmbeddedAssets.Utilities_Valiant8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Crafting_Capsules8x8", new EmbeddedAssets.Crafting_Capsules8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Crafting_Ingredients8x8", new EmbeddedAssets.Crafting_Ingredients8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Crafting_LuckyDips", new EmbeddedAssets.Crafting_LuckyDips().bitmapData, 8, 8);
        // Interactables
        AssetLibrary.addImageSet("DroppedContainers8x8", new EmbeddedAssets.DroppedContainers8x8().bitmapData, 8, 8);
        AssetLibrary.addImageSet("Foundry_Containers16x16", new EmbeddedAssets.Foundry_Containers16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Foundry_Portals16x16", new EmbeddedAssets.Foundry_Portals16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Foundry_Portals32x32", new EmbeddedAssets.Foundry_Portals32x32().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Foundry_Stations16x16", new EmbeddedAssets.Foundry_Stations16x16().bitmapData, 16, 16);
        AssetLibrary.addImageSet("Foundry_Stations32x32", new EmbeddedAssets.Foundry_Stations32x32().bitmapData, 32, 32);
        AssetLibrary.addImageSet("Marketplace_Stations16x16", new EmbeddedAssets.Marketplace_Stations16x16().bitmapData, 16, 16);
        // Textiles
        AssetLibrary.addImageSet("Textiles8x8", new EmbeddedAssets.Textiles8x8().bitmapData, 8, 8);
        // Old System
        AssetLibrary.addImageSet("lofiInterface", new EmbeddedAssets.lofiInterface().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiInterfaceBig", new EmbeddedAssets.lofiInterfaceBig().bitmapData, 16, 16);
        AssetLibrary.addImageSet("lofiInterface2", new EmbeddedAssets.lofiInterface2().bitmapData, 8, 8);
        AssetLibrary.addImageSet("lofiParts", new EmbeddedAssets.lofiParts().bitmapData, 8, 8);
        AssetLibrary.addImageSet("stars", new EmbeddedAssets.stars().bitmapData, 5, 5);
        AssetLibrary.addImageSet("textile4x4", new EmbeddedAssets.textile4x4().bitmapData, 4, 4);
        AssetLibrary.addImageSet("textile5x5", new EmbeddedAssets.textile5x5().bitmapData, 5, 5);
        AssetLibrary.addImageSet("textile9x9", new EmbeddedAssets.textile9x9().bitmapData, 9, 9);
        AssetLibrary.addImageSet("textile10x10", new EmbeddedAssets.textile10x10().bitmapData, 10, 10);
        AssetLibrary.addImageSet("inner_mask", new EmbeddedAssets.innerMask().bitmapData, 4, 4);
        AssetLibrary.addImageSet("sides_mask", new EmbeddedAssets.sidesMask().bitmapData, 4, 4);
        AssetLibrary.addImageSet("outer_mask", new EmbeddedAssets.outerMask().bitmapData, 4, 4);
        AssetLibrary.addImageSet("innerP1_mask", new EmbeddedAssets.innerP1Mask().bitmapData, 4, 4);
        AssetLibrary.addImageSet("innerP2_mask", new EmbeddedAssets.innerP2Mask().bitmapData, 4, 4);
        AssetLibrary.addImageSet("invisible", new BitmapData(8, 8, true, 0), 8, 8);
        AssetLibrary.addImageSet("cursorsEmbed", new EmbeddedAssets.cursors().bitmapData, 32, 32);
    }

    private function addAnimatedCharacters():void {
        AnimatedChars.add("players", new EmbeddedAssets.Players().bitmapData, new EmbeddedAssets.playersMask().bitmapData, 16, 16, 112, 48, AnimatedChar.RIGHT);
        AnimatedChars.add("playerskins", new EmbeddedAssets.playersSkins().bitmapData, new EmbeddedAssets.playersSkinsMask().bitmapData, 8, 8, 56, 24, AnimatedChar.RIGHT);
        AnimatedChars.add("Pets16x16", new EmbeddedAssets.Pets16x16().bitmapData, null, 16, 16, 112, 16, AnimatedChar.DOWN);
        AnimatedChars.add("ValiantAbilityCharacters", new EmbeddedAssets.ValiantAbilityCharacters().bitmapData, null, 8, 8, 56, 8, AnimatedChar.RIGHT);
        AnimatedChars.add("ArtifactAbilityCharacters8x8", new EmbeddedAssets.ArtifactAbilityCharacters8x8().bitmapData, null, 8, 8, 56, 8, AnimatedChar.RIGHT);
        AnimatedChars.add("ArtifactAbilityCharacters16x16", new EmbeddedAssets.ArtifactAbilityCharacters16x16().bitmapData, null, 16, 16, 112, 16, AnimatedChar.RIGHT);
    }

    private function addSoundEffects():void {
        SoundEffectLibrary.load("button_click");
        SoundEffectLibrary.load("enter_realm");
        SoundEffectLibrary.load("error");
        SoundEffectLibrary.load("inventory_move_item");
        SoundEffectLibrary.load("level_up");
        SoundEffectLibrary.load("loot_appears");
        SoundEffectLibrary.load("no_mana");
        SoundEffectLibrary.load("use_key");
        SoundEffectLibrary.load("use_potion");
    }

    private function parse3DModels():void {
        var name:* = null;
        var ba:ByteArray = null;
        var model:String = null;
        for (name in EmbeddedAssets.models_) {
            ba = EmbeddedAssets.models_[name];
            model = ba.readUTFBytes(ba.length);
            Model3D.parse3DOBJ(name, ba);
            Model3D.parseFromOBJ(name, model);
        }
    }

    private function parseParticleEffects():void {
        var xml:XML = XML(new EmbeddedAssets.particles());
        ParticleLibrary.parseFromXML(xml);
    }

    private function parseGroundFiles():void {
        var groundObj:* = undefined;
        for each(groundObj in EmbeddedData.groundFiles) {
            GroundLibrary.parseFromXML(XML(groundObj));
        }
    }

    private function parseObjectFiles():void {
        var objectObj:* = undefined;
        for each(objectObj in EmbeddedData.objectFiles) {
            ObjectLibrary.parseFromXML(XML(objectObj));
        }
    }

    private function parseRegionFiles():void {
        var regionXML:* = undefined;
        for each(regionXML in EmbeddedData.regionFiles) {
            RegionLibrary.parseFromXML(XML(regionXML));
        }
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/ClassDetailView.as">
package svera.untiered.classes.view {
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.util.HonorUtil;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.Sprite;
import flash.filters.DropShadowFilter;
import flash.text.TextFieldAutoSize;
import flash.text.TextFormat;
import flash.text.TextFormatAlign;

import svera.untiered.assets.model.Animation;
import svera.untiered.util.components.StarsView;

public class ClassDetailView extends Sprite {
    private static const RIGHT_JUSTIFICATION_STATS:int = 205;

    public static const WIDTH:int = 250;

    private static const TEXT_WIDTH:int = 188;


    private var classNameText:SimpleText;

    private var classDescriptionText:SimpleText;

    private var questCompletionText:SimpleText;

    private var levelTitleText:SimpleText;

    private var levelText:SimpleText;

    private var honorTitleText:SimpleText;

    private var honorText:SimpleText;

    private var honorIcon:Bitmap;

    private var nextGoalText:SimpleText;

    private var nextGoalDetailText:SimpleText;

    private var questCompletedStars:StarsView;

    private var animContainer:Sprite;

    private var animation:Animation;

    public var skinListView:CharacterSkinListView;


    public function ClassDetailView(playBtn:TitleMenuOption = null) {
        var dropShadowFilter:DropShadowFilter;
        super();
        dropShadowFilter = new DropShadowFilter(0, 0, 0, 1, 8, 8);
        this.animContainer = new Sprite();
        //addChild(this.animContainer);
        this.classNameText = new SimpleText(20, 16777215, false, TEXT_WIDTH, 0);
        this.classNameText.setBold(true);
        this.classNameText.filters = [dropShadowFilter];
        this.classNameText.width = TEXT_WIDTH;
        this.classNameText.autoSize = TextFieldAutoSize.CENTER;

        addChild(this.classNameText);
        this.classDescriptionText = new SimpleText(14, 16777215, false, TEXT_WIDTH, 0);
        this.classDescriptionText.filters = [dropShadowFilter];
        this.classDescriptionText.width = TEXT_WIDTH;
        this.classDescriptionText.wordWrap = true;
        var tf:TextFormat = this.classDescriptionText.getTextFormat();
        tf.align = TextFormatAlign.CENTER;
        this.classDescriptionText.defaultTextFormat = tf;
        this.classDescriptionText.setTextFormat(tf);
        addChild(this.classDescriptionText);
        this.questCompletionText = new SimpleText(14, 16777215, false, 0, 0);
        this.questCompletionText.filters = [dropShadowFilter];
        this.questCompletionText.text = "Class Quests Completed";
        this.questCompletionText.setBold(true);
        this.questCompletionText.updateMetrics();
        addChild(this.questCompletionText);
        this.levelTitleText = new SimpleText(14, 16777215, false, 0, 0);
        this.levelTitleText.filters = [dropShadowFilter];
        this.levelTitleText.text = "Highest Level Achieved";
        this.levelTitleText.setBold(true);
        this.levelTitleText.updateMetrics();
        addChild(this.levelTitleText);
        this.levelText = new SimpleText(16, 16777215, false, 0, 0);
        this.levelText.filters = [dropShadowFilter];
        this.levelText.setBold(true);
        addChild(this.levelText);
        this.honorTitleText = new SimpleText(14, 16777215, false, 0, 0);
        this.honorTitleText.filters = [dropShadowFilter];
        this.honorTitleText.text = "Most Honor Achieved";
        this.honorTitleText.setBold(true);
        this.honorTitleText.updateMetrics();
        addChild(this.honorTitleText);
        this.honorText = new SimpleText(16, 15387756, false, 0, 0);
        this.honorText.filters = [dropShadowFilter];
        this.honorText.setBold(true);
        addChild(this.honorText);
        this.honorIcon = new Bitmap(HonorUtil.getHonorIcon());
        this.honorIcon.filters = [dropShadowFilter];
        addChild(this.honorIcon);
        this.nextGoalText = new SimpleText(14, 16777215, false, 0, 0);
        this.nextGoalText.setBold(true);
        this.nextGoalText.filters = [dropShadowFilter];
        this.nextGoalText.text = "Next Goal:";
        this.nextGoalText.updateMetrics();
        this.nextGoalText.visible = false;
        addChild(this.nextGoalText);
        this.nextGoalDetailText = new SimpleText(14, 16777215, false, 0, 0);
        this.nextGoalDetailText.filters = [dropShadowFilter];
        this.nextGoalDetailText.visible = false;
        addChild(this.nextGoalDetailText);
        this.questCompletedStars = new StarsView();
        addChild(this.questCompletedStars);


        skinListView = new CharacterSkinListView(playBtn)
        addChild(skinListView);

    }

    public function setData(name:String, description:String, stars:int, highestLevel:int, highestHonor:int):void {
        this.classNameText.text = name;
        classNameText.updateMetrics();
        this.classDescriptionText.text = description;
        classDescriptionText.updateMetrics();
        this.levelText.text = String(highestLevel);
        this.levelText.updateMetrics();
        this.questCompletedStars.setStars(stars);
        this.honorText.text = String(highestHonor);
        this.honorText.updateMetrics();
        this.layout();
    }

    public function setNextGoal(name:String, nextGoal:int):void {
        this.nextGoalText.visible = nextGoal != -1;
        this.nextGoalDetailText.visible = nextGoal != -1;
        if (nextGoal != -1) {
            this.nextGoalDetailText.text = "Earn " + String(nextGoal) + " Honor with a " + String(name);
            this.nextGoalDetailText.updateMetrics();
            this.nextGoalDetailText.y = this.nextGoalText.y + this.nextGoalText.height;
            this.nextGoalDetailText.x = WIDTH / 2 - this.nextGoalDetailText.width / 2;
        }
    }

    public function setWalkingAnimation(value:Animation):void {
        this.animation && this.removeAnimation(this.animation);
        this.animation = value;
        this.animation && this.addAnimation(this.animation);
        this.layout();
    }

    private function removeAnimation(animation:Animation):void {
        animation.stop();
        this.animContainer.removeChild(animation);
    }

    private function addAnimation(animation:Animation):void {
        this.animContainer.addChild(animation);
        animation.start();
    }
    public function positionSkins():void {

    }

    private function layout():void {
        this.animContainer.x = WIDTH / 2 - this.animContainer.width / 2;
        this.animContainer.y = 110 - this.animContainer.height;

        this.classNameText.x = WIDTH / 2 - this.classNameText.width / 2;
        this.classNameText.y = 110;

        skinListView.x = 23 + (WIDTH) / 2; // 23 is really just a magic number atm, because idk how to fix slight missposition caused by skins texture i use to test this
        skinListView.y = classNameText.y - classNameText.height - skinListView.skinsContainer.height / 2; // ???

        this.classDescriptionText.y = this.classNameText.y + this.classNameText.textHeight + 5;
        this.classDescriptionText.x = WIDTH / 2 - this.classDescriptionText.width / 2;

        this.questCompletionText.y = this.classDescriptionText.y + this.classDescriptionText.textHeight + 20;
        this.questCompletionText.x = RIGHT_JUSTIFICATION_STATS - this.questCompletionText.width;

        this.questCompletedStars.y = this.questCompletionText.y;
        this.questCompletedStars.x = RIGHT_JUSTIFICATION_STATS + 18;

        this.levelTitleText.y = this.questCompletionText.y + this.questCompletionText.height + 5;
        this.levelTitleText.x = RIGHT_JUSTIFICATION_STATS - this.levelTitleText.width;

        this.levelText.y = this.levelTitleText.y;
        this.levelText.x = RIGHT_JUSTIFICATION_STATS + 18;

        this.honorTitleText.y = this.levelTitleText.y + this.levelTitleText.height + 5;
        this.honorTitleText.x = RIGHT_JUSTIFICATION_STATS - this.honorTitleText.width;

        this.honorText.y = this.honorTitleText.y;
        this.honorText.x = RIGHT_JUSTIFICATION_STATS + 18;

        this.honorIcon.y = this.honorTitleText.y - 7;
        this.honorIcon.x = this.honorText.x + this.honorText.textWidth - 3;

        this.nextGoalText.y = this.honorTitleText.y + this.honorTitleText.height + 17;
        this.nextGoalText.x = WIDTH / 2 - this.nextGoalText.width / 2;

        this.nextGoalDetailText.y = this.nextGoalText.y + this.nextGoalText.height;
        this.nextGoalDetailText.x = WIDTH / 2 - this.nextGoalDetailText.width / 2;
    }
}
}
</file>

<file path="src/svera/untiered/storage/GiftWindow.as">
package svera.untiered.storage {
import com.company.assembleegameclient.objects.GiftChest;
import com.company.assembleegameclient.objects.Player;

import flash.display.Sprite;
import flash.events.MouseEvent;

import svera.untiered.itemdata.NewItemData;


import svera.untiered.storage.components.StorageSortTab;

public class GiftWindow extends Sprite {

    private var owner_:GiftChest;

    private var contentView_:GiftContent;
    private var sortCategories_:Vector.<StorageSortTab>;

    public function GiftWindow(owner:GiftChest, player:Player) {
        this.owner_ = owner;

        this.sortCategories_ = StorageUtil.makeStorageSortCategories();

        for (var i:int = 0; i < this.sortCategories_.length; i++) {
            var sorter:StorageSortTab = this.sortCategories_[i];

            sorter.x = 5;
            sorter.y = StorageUtil.TOP_PAD + (StorageSortTab.SIZE + 5) * i;
            sorter.addEventListener(MouseEvent.CLICK, this.onSort);

            this.addChild(sorter);
        }

        this.contentView_ = new GiftContent(this.owner_, player);
        this.contentView_.x = StorageUtil.LEFT_PAD;
        this.contentView_.y = StorageUtil.TOP_PAD;
        this.addChild(this.contentView_);

        graphics.clear();
        graphics.beginFill(0x262626);
        graphics.drawRect(0, 0, StorageUtil.WINDOW_SIZE, StorageUtil.WINDOW_SIZE);
        graphics.endFill();
    }

    public function setContent(size:int, slots:Vector.<NewItemData>):void {
        this.owner_.setContainer(size, slots);
        this.contentView_.initialize(size, slots);
    }

    public function updateSlot(slot:int, inventory:NewItemData):void {
        this.owner_.equipment_[slot] = inventory;
        this.contentView_.updateSlot(slot, inventory);
    }

    private function onSort(e:MouseEvent):void {
        var caller:StorageSortTab = e.currentTarget as StorageSortTab;
        if (caller == null) {
            return;
        }

        caller.select();
        if (caller.isSelected()) {
            this.contentView_.sortBy(caller.filter_);
        }

        for each(var sorter:StorageSortTab in this.sortCategories_) {
            if (sorter.filter_ == caller.filter_) {
                continue;
            }
            sorter.unselect();
        }
    }

    public function dispose():void {

    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/CharacterSelectionAndNewsScreen.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.ui.Scrollbar;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.DisplayObject;
import flash.display.Shape;
import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.filters.DropShadowFilter;
import flash.geom.Rectangle;
import flash.text.TextFormatAlign;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.core.model.PlayerModel;
import svera.untiered.game.view.CurrencyDisplay;
import svera.untiered.ui.view.components.ScreenBase;

public class CharacterSelectionAndNewsScreen extends Sprite {
    private const SCROLLBAR_REQUIREMENT_HEIGHT:Number = 400;

    private const DROP_SHADOW:DropShadowFilter = new DropShadowFilter(0, 0, 0, 1, 8, 8);

    private var model:PlayerModel;

    private var isInitialized:Boolean;

    private var nameText:SimpleText;

    private var currencyDisplay:CurrencyDisplay;

    private var charactersText:SimpleText;

    private var newsText:SimpleText;

    private var newsList:NewsList;

    private var characterList:CharacterList;

    private var characterListHeight:Number;

    private var playButton:TitleMenuOption;

    private var backButton:TitleMenuOption;

    private var classesButton:TitleMenuOption;

    private var lines:Shape;

    private var scrollBar:Scrollbar;

    public var close:Signal;

    public var showClasses:Signal;

    public var newCharacter:Signal;

    public var playGame:Signal;

    [Embed(source="brickLeft.png")]
    public static var brickLeftSource:Class;
    public static var brickLeft:BitmapData = new brickLeftSource().bitmapData;
    [Embed(source="brickRight.png")]
    public static var brickRightSource:Class;
    public static var brickRight:BitmapData = new brickRightSource().bitmapData;
    public static var brickLeftContainer:Sprite = new Sprite();
    public static var brickRightContainer:Sprite = new Sprite();
    [Embed(source="nameTextSign.png")]
    private var nameTextSignSource:Class;
    private var nameTextSign:Bitmap = new Bitmap(new nameTextSignSource().bitmapData);

    public function CharacterSelectionAndNewsScreen() {
        this.playButton = new TitleMenuOption("play", 36, true);
        this.backButton = new TitleMenuOption("back", 22, false);
        this.classesButton = new TitleMenuOption("classes", 22, false);
        this.newCharacter = new Signal();
        this.playGame = new Signal();
        super();
        addChild(new ScreenBase(2));
        var h:Number = 0;
        var l:Bitmap;
        var r:Bitmap;
        while (h < GameClient.STAGE.fullScreenHeight) {
            l = new Bitmap(brickLeft);
            r = new Bitmap(brickRight);
            l.y = h;
            r.y = h;
            addChild(l);
            brickLeftContainer.addChild(l);
            brickRightContainer.addChild(r);
            h += l.height;
        }
        addChild(nameTextSign);
        addChild(brickLeftContainer);
        addChild(brickRightContainer);
        addChild(new AccountScreen());
        this.close = new NativeMappedSignal(this.backButton, MouseEvent.CLICK);
        this.showClasses = new NativeMappedSignal(this.classesButton, MouseEvent.CLICK);
    }

    public function initialize(model:PlayerModel):void {
        if (this.isInitialized) {
            return;
        }
        this.isInitialized = true;
        this.model = model;
        this.createDisplayAssets(model);
        stage.addEventListener(Event.RESIZE, positionButtons);
    }

    private function createDisplayAssets(model:PlayerModel):void {
        this.createNameText();
        this.createCurrencyDisplay();
        this.createCharactersText();
        this.createCharacterList();

        this.createButtons();
        this.positionButtons();

        if (this.characterListHeight > this.SCROLLBAR_REQUIREMENT_HEIGHT) {
            this.createScrollbar();
        }
    }

    private function createButtons():void {
        addChild(this.playButton);
        addChild(this.classesButton);
        addChild(this.backButton);
        this.playButton.addEventListener(MouseEvent.CLICK, this.onPlayClick);
    }

    private function positionButtons(e:Event = null):void {
        this.playButton.x = (GameClient.StageWidth - this.playButton.width) * 0.5;
        this.playButton.y = GameClient.StageHeight - (600 - 520);
        this.backButton.x = (GameClient.StageWidth - this.backButton.width) * 0.5 - 94;
        this.backButton.y = GameClient.StageHeight - (600 - 532);
        this.classesButton.x = (GameClient.StageWidth - this.classesButton.width) * 0.5 + 96;
        this.classesButton.y = backButton.y;
        nameTextSign.x = (GameClient.StageWidth - nameTextSign.width) * 0.5;
        brickRightContainer.x = GameClient.StageWidth - brickRightContainer.width;
        this.nameText.x = (GameClient.StageWidth - this.nameText.width) * 0.5;
    }

    private function createScrollbar():void {
        this.scrollBar = new Scrollbar(16, 399);
        this.scrollBar.x = 375;
        this.scrollBar.y = 113;
        this.scrollBar.setIndicatorSize(399, this.characterList.height);
        this.scrollBar.addEventListener(Event.CHANGE, this.onScrollBarChange);
        addChild(this.scrollBar);
    }

    private function createCharacterList():void {
        this.characterList = new CharacterList(this.model);
        this.characterList.x = 115;
        this.characterList.y = 153;
        this.characterListHeight = this.characterList.height;
        addChild(this.characterList);
    }

    private function createCharactersText():void {
        this.charactersText = new SimpleText(18, 11776947, false, 0, 0);
        this.charactersText.setBold(true);
        this.charactersText.text = "Characters";
        this.charactersText.updateMetrics();
        this.charactersText.filters = [this.DROP_SHADOW];
        this.charactersText.setAlignment(TextFormatAlign.LEFT);
        this.charactersText.x = (GameClient.StageWidth - charactersText.width) / 2;
        this.charactersText.y = nameText.y + nameText.height;
        addChild(this.charactersText);
    }

    private function createCurrencyDisplay():void {
        this.currencyDisplay = new CurrencyDisplay();
        this.currencyDisplay.draw(this.model.getTsavorite(), this.model.getMedallions(), this.model.getHonor(), false);
        this.currencyDisplay.x = GameClient.StageWidth;
        this.currencyDisplay.y = 20;
        addChild(this.currencyDisplay);
    }

    private function createNameText():void {
        this.nameText = new SimpleText(22, 11776947, false, 0, 0);
        this.nameText.setBold(true);
        this.nameText.text = this.model.getName() || "Undefined";
        this.nameText.updateMetrics();
        this.nameText.filters = [this.DROP_SHADOW];
        this.nameText.y = 24 + this.nameText.height;
        addChild(this.nameText);
    }

    private function onScrollBarChange(event:Event):void {
        this.characterList.setPos(-this.scrollBar.pos() * (this.characterListHeight - 400));
    }

    private function removeIfAble(object:DisplayObject):void {
        if (object && contains(object)) {
            removeChild(object);
        }
    }

    private function onPlayClick(event:Event):void {
        if (this.model.getCharacterCount() == 0) {
            this.newCharacter.dispatch();
        } else {
            this.playGame.dispatch();
        }
    }

    public function setName(name:String):void {
        this.nameText.text = name;
        this.nameText.updateMetrics();
        this.nameText.x = (GameClient.StageWidth - this.nameText.width) * 0.5;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/screens/NewCharacterScreen.as">
package com.company.assembleegameclient.screens {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.screens.charrects.CharacterRect;
import com.company.ui.SimpleText;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.utils.Dictionary;

import org.osflash.signals.Signal;

import svera.untiered.core.model.PlayerModel;
import svera.untiered.game.view.CurrencyDisplay;
import svera.untiered.ui.view.components.ScreenBase;

public class NewCharacterScreen extends Sprite {
    private var backButton_:TitleMenuOption;
    private var currencyDisplay_:CurrencyDisplay;
    public var tooltip:Signal;
    public var close:Signal;
    public var selected:Signal;
    private var isInitialized:Boolean = false;
    private var boxes_:Vector.<Dictionary>;
    private var tiny:SimpleText = new SimpleText(18, 0xFFFFFF, false);
    private var short:SimpleText = new SimpleText(18, 0xFFFFFF, false);
    private var medium:SimpleText = new SimpleText(18, 0xFFFFFF, false);
    private var long:SimpleText = new SimpleText(18, 0xFFFFFF, false);
    private var textList:Sprite = new Sprite();

    public function NewCharacterScreen() {
        this.boxes_ = new Vector.<Dictionary>(4, true);
        super();
        this.tooltip = new Signal(Sprite);
        this.selected = new Signal(int);
        this.close = new Signal();
        addChild(new ScreenBase(2));
        addChild(CharacterSelectionAndNewsScreen.brickLeftContainer);
        addChild(CharacterSelectionAndNewsScreen.brickRightContainer);
        addChild(new AccountScreen());
    }

    public function initialize(model:PlayerModel):void {
        var playerXML:XML = null;
        var objectType:int = 0;
        var characterType:String = null;
        var charBox:CharacterBox = null;
        if (this.isInitialized) {
            return;
        }
        addEventListener(Event.RESIZE, positionStuff);
        this.isInitialized = true;
        this.backButton_ = new TitleMenuOption("back", 36, false);
        this.backButton_.addEventListener(MouseEvent.CLICK, this.onBackClick);
        this.currencyDisplay_ = new CurrencyDisplay();
        this.currencyDisplay_.draw(model.getTsavorite(), model.getMedallions(), model.getHonor());
        addChild(this.currencyDisplay_);

        function strToRange(s:String):int {
            if (s == 'tiny')
                return 0;
            if (s == 'short')
                return 1;
            if (s == "medium")
                return 2;
            if (s == 'long')
                return 3;
        }

        tiny.text = "tiny";
        short.text = "short";
        medium.text = "medium";
        long.text = "long";
        tiny.updateMetrics();
        short.updateMetrics();
        medium.updateMetrics();
        long.updateMetrics();

        textList.addChild(tiny);
        textList.addChild(short);
        textList.addChild(medium);
        textList.addChild(long);
        addChild(textList);

        for (var i:int = 0; i < ObjectLibrary.playerChars_.length; i++) {
            playerXML = ObjectLibrary.playerChars_[i];
            objectType = int(playerXML.@type);
            characterType = playerXML.@id;
            if (playerXML.hasOwnProperty("SubClassOf")) {
                continue;
            }
            charBox = new CharacterBox(playerXML, model.getCharStats()[objectType], model);
            var range:int = strToRange(playerXML.Range);
            if (boxes_.length < range || boxes_[range] == null) {
                boxes_[range] = new Dictionary();
            }

            boxes_[range][objectType] = charBox;
            charBox.addEventListener(MouseEvent.ROLL_OVER, this.onCharBoxOver);
            charBox.addEventListener(MouseEvent.ROLL_OUT, this.onCharBoxOut);
            charBox.characterSelectClicked_.add(this.onCharBoxClick);
            addChild(charBox);
        }
        addChild(this.backButton_);

        positionStuff();
    }

    private function positionStuff(e:Event = null):void {
        this.backButton_.x = GameClient.HalfStageWidth - this.backButton_.width / 2;
        this.backButton_.y = GameClient.StageHeight - (600 - 524);
        this.currencyDisplay_.x = stage.stageWidth;
        this.currencyDisplay_.y = 20;

        var charBox:CharacterBox;
        var range:Dictionary;
        var stripLen:int = (GameClient.StageWidth - CharacterSelectionAndNewsScreen.brickRightContainer.width) / 140;

        var boxW:int = CharacterRect.WIDTH + 30;
        var rowHeight:int = CharacterRect.HEIGHT + 30;

        var totalWidth:int = boxW * 8;
        var offsetX:int = (GameClient.StageWidth - totalWidth) / 2;
        var position:Vector.<int> = new Vector.<int>(4, true);
        var j:int = 0;
        for each(range in boxes_) {
            var i:int = 0;
            for each(charBox in range) {
                charBox.x = offsetX + boxW * int(i % 2 + j) + boxW * j;
                charBox.y = 150 + rowHeight * int(i / 2);
                i++;
            }
            if (charBox != null) {
                var a:SimpleText = textList.getChildAt(j) as SimpleText;
                a.x = charBox.x - 15 - a.width / 2; //15 is half width of the space between boxes
            }
            j++;
        }
        textList.y = 150 - tiny.height * 1.5; // 18 is textSize
    }

    private function onBackClick(event:Event):void {
        this.close.dispatch();
    }

    private function onCharBoxOver(event:MouseEvent):void {
        var charBox:CharacterBox = event.currentTarget as CharacterBox;
        charBox.setOver(true);
        this.tooltip.dispatch(charBox.getTooltip());
    }

    private function onCharBoxOut(event:MouseEvent):void {
        var charBox:CharacterBox = event.currentTarget as CharacterBox;
        charBox.setOver(false);
        this.tooltip.dispatch(null);
    }

    private function onCharBoxClick(event:MouseEvent):void {
        this.tooltip.dispatch(null);
        var charBox:CharacterBox = event.currentTarget.parent as CharacterBox;
        var objectType:int = charBox.objectType();
        var displayId:String = ObjectLibrary.typeToDisplayId_[objectType];
        this.selected.dispatch(objectType);
    }

    public function updateCurrencies(tsavorite:int, medallions:int, honor:int):void {
        this.currencyDisplay_.draw(tsavorite, medallions, honor);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/InventoryTile.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.ui.SimpleText;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.filters.DropShadowFilter;

import svera.untiered.itemdata.NewItemData;

public class InventoryTile extends InteractiveItemTile {


    public var hotKey:String;

    private var hotKeyBMP:Bitmap;

    public function InventoryTile(id:int, parentGrid:ItemGrid, isInteractive:Boolean) {
        super(id, parentGrid, isInteractive);
    }

    public function addTileNumber(tileNumber:int):void {
        this.hotKey = String.fromCharCode(Parameters.data_["useEquipInvSlot" + String(tileNumber)]);
        this.buildHotKeyBMP();
    }

    public function buildHotKeyBMP():void {
        var tempText:SimpleText = new SimpleText(12, 0x5b4c96, false, 0, 0);
        tempText.text = hotKey;
        tempText.setBold(true);
        tempText.updateMetrics();
        var bmpData:BitmapData = new BitmapData(20, 20, true, 0);
        bmpData.draw(tempText);
        this.hotKeyBMP = new Bitmap(bmpData);
        this.hotKeyBMP.x = 0 - 2;
        this.hotKeyBMP.y = 0 - 3;
        hotKeyBMP.filters = [new DropShadowFilter(0, 0, 0, 1.0, 1.5, 1.5, 255)];
        addChild(hotKeyBMP);
    }

    override public function setItemSprite(newItemSprite:ItemTileSprite):void {
        super.setItemSprite(newItemSprite);
        newItemSprite.setDim(false);
    }

    override public function setItem(itemData:NewItemData):Boolean {
        return super.setItem(itemData);
    }

    override protected function beginDragCallback():void {
    }

    override protected function endDragCallback():void {
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/ItemTile.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.ui.SimpleText;
import com.company.util.GraphicsUtil;

import flash.display.GraphicsPath;
import flash.display.GraphicsSolidFill;
import flash.display.IGraphicsData;
import flash.display.Shape;
import flash.display.Sprite;

import svera.untiered.constants.ItemConstants;
import svera.untiered.itemdata.NewItemData;

public class ItemTile extends Sprite {

    public static const TILE_DOUBLE_CLICK:String = "TILE_DOUBLE_CLICK";

    public static const TILE_SINGLE_CLICK:String = "TILE_SINGLE_CLICK";

    public static const WIDTH:int = 40;

    public static const HEIGHT:int = 40;

    public static const BORDER:int = 4;


    private var fill_:GraphicsSolidFill = new GraphicsSolidFill(getBackgroundColor(), 1);

    private var path_:GraphicsPath = new GraphicsPath(new Vector.<int>(), new Vector.<Number>());

    private var graphicsData_:Vector.<IGraphicsData> = new <IGraphicsData>[fill_, path_, GraphicsUtil.END_FILL];

    private var restrictedUseIndicator:Shape;

    public var itemSprite:ItemTileSprite;

    public var tileId:int;

    public var ownerGrid:ItemGrid;

    public function ItemTile(id:int, parentGrid:ItemGrid) {
        super();
        this.tileId = id;
        this.ownerGrid = parentGrid;
        this.restrictedUseIndicator = new Shape();
        addChild(this.restrictedUseIndicator);
        this.setItemSprite(new ItemTileSprite());
    }

    public function drawBackground(cuts:Array):void {
        GraphicsUtil.clearPath(this.path_);
        GraphicsUtil.drawCutEdgeRect(0, 0, WIDTH, HEIGHT, 4, cuts, this.path_);
        graphics.clear();
        graphics.drawGraphicsData(this.graphicsData_);
        var fill:GraphicsSolidFill = new GraphicsSolidFill(0x5C1D1D, 1);
        GraphicsUtil.clearPath(this.path_);
        var graphicsData:Vector.<IGraphicsData> = new <IGraphicsData>[fill, this.path_, GraphicsUtil.END_FILL];
        GraphicsUtil.drawCutEdgeRect(0, 0, WIDTH, HEIGHT, 4, cuts, this.path_);
        this.restrictedUseIndicator.graphics.drawGraphicsData(graphicsData);
        this.restrictedUseIndicator.cacheAsBitmap = true;
        this.restrictedUseIndicator.visible = false;
    }

    public function setItem(itemData:NewItemData):Boolean {
        if (itemData == this.itemSprite.itemData) {
            return false;
        }
        this.itemSprite.setType(itemData);
        this.updateUseability(this.ownerGrid.curPlayer);
        return true;
    }

    public function setItemSprite(itemTileSprite:ItemTileSprite):void {
        this.itemSprite = itemTileSprite;
        this.itemSprite.x = WIDTH / 2;
        this.itemSprite.y = HEIGHT / 2;
        addChild(this.itemSprite);
    }

    public function updateUseability(player:Player):void {
        var itemData:NewItemData = itemSprite.itemData;
        if (itemData == null){
            this.restrictedUseIndicator.visible = false;
            return;
        }
        this.restrictedUseIndicator.visible = !ObjectLibrary.isUsableByPlayer(itemData.ObjectType, player);
    }

    public function canHoldItem(itemData:NewItemData):Boolean {
        return true;
    }

    public function resetItemPosition():void {
        this.setItemSprite(this.itemSprite);
    }

    public function getItemData():NewItemData {
        return itemSprite.itemData;
    }

    protected function getBackgroundColor():int {
        return 0x131126;
    }
}
}
</file>

<file path="src/GameClient.as">
package {
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.util.AssetLoader;
import com.company.assembleegameclient.util.StageProxy;

import flash.display.DisplayObjectContainer;
import flash.display.LoaderInfo;
import flash.display.Sprite;
import flash.display.Stage;
import flash.display.StageAlign;
import flash.display.StageScaleMode;
import flash.events.Event;
import flash.events.MouseEvent;

import svera.lib.framework.AppContext;
import svera.untiered.account.AccountModule;
import svera.untiered.appengine.AppEngineModule;
import svera.untiered.core.StaticInjectorContext;
import svera.untiered.assets.AssetsModule;
import svera.untiered.characters.CharactersModule;
import svera.untiered.classes.ClassesModule;
import svera.untiered.core.CoreModule;
import svera.untiered.death.DeathModule;
import svera.untiered.dialogs.DialogsModule;
import svera.untiered.game.GameModule;
import svera.untiered.honor.HonorModule;
import svera.untiered.hud.HUDModule;
import svera.untiered.legends.LegendsModule;
import svera.untiered.minimap.MiniMapModule;
import svera.lib.net.NetModule;
import svera.untiered.stage3D.Renderer;
import svera.untiered.stage3D.Stage3DModule;
import svera.untiered.startup.StartupModule;
import svera.untiered.startup.control.StartupSignal;
import svera.untiered.tooltips.TooltipsModule;
import svera.untiered.ui.UIModule;
import svera.untiered.ui.UIUtils;

[SWF(frameRate="60", backgroundColor="#0", width="800", height="600")]
public class GameClient extends Sprite {
    public static var STAGE:Stage;
    public static var StageWidth:int;
    public static var StageHeight:int;
    public static var HalfStageWidth:int;
    public static var HalfStageHeight:int;

    private var context:AppContext;

    public function GameClient() {
        super();
        if (stage) {
            this.setup();
        } else {
            addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        }
    }

    private function onAddedToStage(event:Event):void {
        removeEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        this.setup();
    }

    private function setup():void {
        STAGE = stage;
        STAGE.scaleMode = StageScaleMode.NO_SCALE;
        STAGE.align = StageAlign.TOP_LEFT;

        onResize(null);
        STAGE.addEventListener(MouseEvent.RIGHT_CLICK, onRightClick);
        STAGE.addEventListener(Event.RESIZE, onResize);
        STAGE.addEventListener(Event.ENTER_FRAME, onEnterFrame);

        new AssetLoader().load();

        this.hackParameters();
        this.createContext();

        var startup:StartupSignal = this.context.injector.getInstance(StartupSignal);
        startup.dispatch();

        UIUtils.toggleQuality(Parameters.data_.quality);
    }

    private function onEnterFrame(event:Event):void {
        SoundEffectLibrary.clear();
    }

    private function onResize(event:Event):void {
        StageWidth = stage.stageWidth;
        StageHeight = stage.stageHeight;
        HalfStageWidth = StageWidth * 0.5;
        HalfStageHeight = StageHeight * 0.5;

        if (Renderer.inGame) {
            scaleX = 1;
            scaleY = 1;
            // If you have these methods, uncomment:
            // Camera.adjustDimensions();
            // Stage3DModule.adjustDimensions();
        } else {
            scaleX = 1;
            scaleY = 1;
            x = 0;
            y = 0;
        }
    }

    private static function onRightClick(event:MouseEvent):void {
        // Suppress context menu
    }

    private function hackParameters():void {
        Parameters.root = stage.root;
    }

    private function createContext():void {
        trace("[GameClient] Creating context...");
        var stageProxy:StageProxy = new StageProxy(this);

        // Create new lightweight context
        this.context = new AppContext();

        // Initialize StaticInjectorContext for legacy code
        StaticInjectorContext.injector = this.context.injector;

        this.context.injector.map(DisplayObjectContainer).toValue(this);

        // Map other core dependencies
        this.context.injector.map(LoaderInfo).toValue(root.stage.root.loaderInfo);
        this.context.injector.map(StageProxy).toValue(stageProxy);

        trace("[GameClient] Installing modules...");

        // Install all modules (order matters for dependencies)
        this.context
                .install(new StartupModule())
                .install(new NetModule())
                .install(new AssetsModule())
                .install(new DialogsModule())
                .install(new AppEngineModule())
                .install(new AccountModule())
                .install(new CoreModule())
                .install(new DeathModule())
                .install(new CharactersModule())
                .install(new GameModule())
                .install(new UIModule())
                .install(new MiniMapModule())
                .install(new LegendsModule())
                .install(new HonorModule())
                .install(new TooltipsModule())
                .install(new ClassesModule())
                .install(new Stage3DModule())
                .install(new HUDModule());

        trace("[GameClient] Initializing context...");

        // Initialize the context
        this.context.initialize();

        trace("[GameClient] Context ready!");
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/game/MapUserInput.as">
package com.company.assembleegameclient.game {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.options.Options;
import com.company.util.KeyCodes;

import flash.display.Stage;
import flash.display.StageDisplayState;
import flash.events.Event;
import flash.events.KeyboardEvent;
import flash.events.MouseEvent;

import net.hires.debug.Stats;

import org.swiftsuspenders.Injector;

import svera.untiered.core.StaticInjectorContext;
import svera.untiered.core.view.Layers;
import svera.untiered.game.model.PotionInventoryModel;
import svera.untiered.game.model.UsePotionVO;
import svera.untiered.game.signals.AddTextLineSignal;
import svera.untiered.game.signals.SetTextBoxVisibilitySignal;
import svera.untiered.game.signals.UsePotionSignal;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.minimap.control.MiniMapZoomSignal;
import svera.untiered.ui.view.HUDView;

public class MapUserInput {
    private static var stats_:Stats = new Stats();

    public var gs_:GameSprite;
    private var moveLeft_:Boolean = false;
    private var moveRight_:Boolean = false;
    private var moveUp_:Boolean = false;
    private var moveDown_:Boolean = false;
    private var rotateLeft_:Boolean = false;
    private var rotateRight_:Boolean = false;
    private var mouseDown_:Boolean = false;
    private var autofire_:Boolean = false;
    private var specialKeyDown_:Boolean = false;
    private var enablePlayerInput_:Boolean = true;
    private var addTextLine:AddTextLineSignal;
    private var setTextBoxVisibility:SetTextBoxVisibilitySignal;
    private var miniMapZoom:MiniMapZoomSignal;
    private var usePotionSignal:UsePotionSignal;
    private var potionInventoryModel:PotionInventoryModel;
    private var hudView:HUDView;
    private var layers:Layers;
    private var nexusHeld:int = -1;

    public function MapUserInput(gs:GameSprite) {
        super();
        this.gs_ = gs;
        //this.mouseDownTimer = new Timer(MOUSE_DOWN_WAIT_PERIOD,1);
        //this.mouseDownTimer.addEventListener(TimerEvent.TIMER_COMPLETE,this.onMouseDownWaitPeriodOver);
        this.gs_.addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
        this.gs_.addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        var injector:Injector = StaticInjectorContext.getInjector();
        this.addTextLine = injector.getInstance(AddTextLineSignal);
        this.setTextBoxVisibility = injector.getInstance(SetTextBoxVisibilitySignal);
        this.miniMapZoom = injector.getInstance(MiniMapZoomSignal);
        this.usePotionSignal = injector.getInstance(UsePotionSignal);
        this.potionInventoryModel = injector.getInstance(PotionInventoryModel);
        this.layers = injector.getInstance(Layers);
        this.gs_.map.signalRenderSwitch.add(this.onRenderSwitch);
    }

    public function clearInput():void {
        this.moveLeft_ = false;
        this.moveRight_ = false;
        this.moveUp_ = false;
        this.moveDown_ = false;
        this.rotateLeft_ = false;
        this.rotateRight_ = false;
        this.mouseDown_ = false;
        this.autofire_ = false;
        this.setPlayerMovement();
    }

    public function onRenderSwitch(wasLastGpu:Boolean):void {
        if (wasLastGpu) {
            this.gs_.stage.removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.gs_.stage.removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
            this.gs_.map.addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.gs_.map.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        } else {
            this.gs_.map.removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.gs_.map.removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
            this.gs_.stage.addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.gs_.stage.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        }
    }

    public function setEnablePlayerInput(enable:Boolean):void {
        if (this.enablePlayerInput_ != enable) {
            this.enablePlayerInput_ = enable;
            this.clearInput();
        }
    }

    private function onAddedToStage(event:Event):void {
        var stage:Stage = this.gs_.stage;
        stage.addEventListener(Event.ACTIVATE, this.onActivate);
        stage.addEventListener(Event.DEACTIVATE, this.onDeactivate);
        stage.addEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
        stage.addEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
        stage.addEventListener(MouseEvent.MOUSE_WHEEL, this.onMouseWheel);
        if (Parameters.GPURenderFrame) {
            stage.addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            stage.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        } else {
            this.gs_.map.addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.gs_.map.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        }
        stage.addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        //stage.addEventListener(MouseEvent.RIGHT_CLICK,this.disableRightClick);
    }

    private function onRemovedFromStage(event:Event):void {
        var stage:Stage = this.gs_.stage;
        stage.removeEventListener(Event.ACTIVATE, this.onActivate);
        stage.removeEventListener(Event.DEACTIVATE, this.onDeactivate);
        stage.removeEventListener(KeyboardEvent.KEY_DOWN, this.onKeyDown);
        stage.removeEventListener(KeyboardEvent.KEY_UP, this.onKeyUp);
        stage.removeEventListener(MouseEvent.MOUSE_WHEEL, this.onMouseWheel);
        if (Parameters.GPURenderFrame) {
            stage.removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            stage.removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        } else {
            this.gs_.map.removeEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.gs_.map.removeEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
        }
        stage.removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
        //stage.removeEventListener(MouseEvent.RIGHT_CLICK,this.disableRightClick);
    }

    private function onActivate(event:Event):void {
    }

    private function onDeactivate(event:Event):void {
        this.clearInput();
    }

    private function onMouseDown(event:MouseEvent):void {
        var mouseX:Number = NaN;
        var mouseY:Number = NaN;
        var angle:Number = NaN;
        var itemType:int = 0;
        var objectXML:XML = null;
        var player:Player = this.gs_.map.player_;
        if (player == null) {
            return;
        }
        /*if(this.mouseDownTimer.running == false)
        {
           this.mouseDownCount = 1;
           this.mouseDownTimer.start();
        }
        else
        {
           this.mouseDownCount++;
        }*/
        if (!this.enablePlayerInput_) {
            return;
        }


        if (Parameters.GPURenderFrame) {
            if (event.currentTarget == event.target || event.target == this.gs_.map || event.target == this.gs_) {
                angle = Math.atan2(this.gs_.map.mouseY, this.gs_.map.mouseX);
            } else {
                return;
            }
        } else {
            angle = Math.atan2(this.gs_.map.mouseY, this.gs_.map.mouseX);
        }
        player.attemptAttackAngle(angle);
        this.mouseDown_ = true;
    }

    /*private function onMouseDownWaitPeriodOver(e:TimerEvent) : void
    {
       var pt:Point = null;
       if(this.mouseDownCount > 1)
       {
          pt = this.gs_.map.pSTopW(this.gs_.map.mouseX,this.gs_.map.mouseY);
          trace("World point: " + pt.x + ", " + pt.y);
       }
    }*/

    private function onMouseUp(event:MouseEvent):void {
        this.mouseDown_ = false;
    }

    private function onMouseWheel(event:MouseEvent):void {
        if (event.ctrlKey) {
            if (event.delta > 0) {
                Parameters.data_.mScale = Math.min(Parameters.data_.mScale + 0.05, 2);
            } else {
                Parameters.data_.mScale = Math.max(Parameters.data_.mScale - 0.05, 0.7);
            }
            if (event.delta != 0)
                Parameters.root.dispatchEvent(new Event(Event.RESIZE));
            return;
        }
        if (event.delta > 0) {
            this.miniMapZoom.dispatch(MiniMapZoomSignal.IN);
        } else {
            this.miniMapZoom.dispatch(MiniMapZoomSignal.OUT);
        }
    }

    private function onEnterFrame(event:Event):void {
        var angle:Number = NaN;
        var player:Player = null;
        if (this.enablePlayerInput_ && (this.mouseDown_ || this.autofire_)) {
            angle = Math.atan2(this.gs_.map.mouseY, this.gs_.map.mouseX);
            player = this.gs_.map.player_;
            if (player != null) {
                player.attemptAttackAngle(angle);
            }
        }
    }

    private function onKeyDown(event:KeyboardEvent):void {
        var stage:Stage = this.gs_.stage;
        switch (event.keyCode) {
            case KeyCodes.F1:
            case KeyCodes.F2:
            case KeyCodes.F3:
            case KeyCodes.F4:
            case KeyCodes.F5: //Reset mscale
                Parameters.data_.mScale = 1;
                break;
            case KeyCodes.F6:
            case KeyCodes.F7:
            case KeyCodes.F8:
            case KeyCodes.F9:
            case KeyCodes.F10:
            case KeyCodes.F11:
            case KeyCodes.F12:
            case KeyCodes.INSERT:
                break;
            default:
                if (stage.focus != null) {
                    return;
                }
                break;
        }
        var player:Player = this.gs_.map.player_;
        if (player == null) {
            return;
        }
        switch (event.keyCode) {
            case Parameters.data_.moveUp:
                this.moveUp_ = true;
                break;
            case Parameters.data_.moveDown:
                this.moveDown_ = true;
                break;
            case Parameters.data_.moveLeft:
                this.moveLeft_ = true;
                break;
            case Parameters.data_.moveRight:
                this.moveRight_ = true;
                break;
            case Parameters.data_.rotateLeft:
                if (!Parameters.data_.allowRotation) {
                    break;
                }
                this.rotateLeft_ = true;
                break;
            case Parameters.data_.rotateRight:
                if (!Parameters.data_.allowRotation) {
                    break;
                }
                this.rotateRight_ = true;
                break;
            case Parameters.data_.ability2:
                UseAbility(player, 1);
                break;
            case Parameters.data_.ability3:
                UseAbility(player, 2);
                break;
            case Parameters.data_.ability4:
                UseAbility(player, 3);
                break;
            case Parameters.data_.resetToDefaultCameraAngle:
                Parameters.data_.cameraAngle = Parameters.data_.defaultCameraAngle;
                Parameters.save();
                break;
            case Parameters.data_.autofireToggle:
                this.autofire_ = !this.autofire_;
                break;
            case Parameters.data_.inventoryToggle:
                HUDView.instance.ToggleInventory();
                break;
            case Parameters.data_.useEquipInvSlot1:
                this.useEquipItem(4);
                break;
            case Parameters.data_.useEquipInvSlot2:
                this.useEquipItem(5);
                break;
            case Parameters.data_.useEquipInvSlot3:
                this.useEquipItem(6);
                break;
            case Parameters.data_.useEquipInvSlot4:
                this.useEquipItem(7);
                break;
            case Parameters.data_.useEquipInvSlot5:
                this.useEquipItem(8);
                break;
            case Parameters.data_.useEquipInvSlot6:
                this.useEquipItem(9);
                break;
            case Parameters.data_.useEquipInvSlot7:
                this.useEquipItem(10);
                break;
            case Parameters.data_.useEquipInvSlot8:
                this.useEquipItem(11);
                break;
            case Parameters.data_.useHealthPotion:
                if (this.potionInventoryModel.getPotionModel(PotionInventoryModel.HEALTH_POTION_ID).available) {
                    this.usePotionSignal.dispatch(new UsePotionVO(PotionInventoryModel.HEALTH_POTION_ID, UsePotionVO.CONTEXTBUY));
                }
                break;
            case Parameters.data_.useMagicPotion:
                if (this.potionInventoryModel.getPotionModel(PotionInventoryModel.MAGIC_POTION_ID).available) {
                    this.usePotionSignal.dispatch(new UsePotionVO(PotionInventoryModel.MAGIC_POTION_ID, UsePotionVO.CONTEXTBUY));
                }
                break;
            case Parameters.data_.miniMapZoomOut:
                this.miniMapZoom.dispatch(MiniMapZoomSignal.OUT);
                break;
            case Parameters.data_.miniMapZoomIn:
                this.miniMapZoom.dispatch(MiniMapZoomSignal.IN);
                break;
            case Parameters.data_.togglePerformanceStats:
                this.togglePerformanceStats();
                break;
            case Parameters.data_.escapeToNexus:
            case Parameters.data_.escapeToNexus2: // Make this serverside communicated
                nexusHeld++;
                /*trace("Nexus being held: ", nexusHeld);
                var gif:GIF = new Recallingbase();
                var animationReplaying:Boolean = false;
                if(gs_.contains(gif))
                   gs_.removeChild(gif);
                gif.x = player.x_;
                gif.y = player.y_;
                gif.scaleX = 2;
                gif.scaleY = 2;
                gs_.addChild(gif);
                switch(nexusHeld)
                {
                   case 0:
                   case 15:
                   case 30:
                   case 45:
                      gif.stop();
                      gif.play();
                      break;
                }*/
                if (nexusHeld >= 60) {
                    this.gs_.gsc_.escape();
                    /*gif.stop();
                    nexusHeld = -1;
                    animationReplaying = false;*/
                }
                break;
            case Parameters.data_.options:
                this.clearInput();
                GameClient.STAGE.addChild(new Options(this.gs_));
                break;
            case Parameters.data_.toggleCentering:
                Parameters.data_.centerOnPlayer = !Parameters.data_.centerOnPlayer;
                Parameters.save();
                break;
            case Parameters.data_.toggleFullscreenMode:
                //doing it like this is better because then there's no additional memory allocated to the variable, and it works if say you go fullscreen, then press ESC, and go fullscreen again.
                //before if you did that, you'd need to press the key twice because the variable was not updated
                this.gs_.stage.displayState = this.gs_.stage.displayState == StageDisplayState.NORMAL ? StageDisplayState.FULL_SCREEN_INTERACTIVE : StageDisplayState.NORMAL;
                break;
        }
        this.setPlayerMovement();
    }

    private function onKeyUp(event:KeyboardEvent):void {
        var player:Player = this.gs_.map.player_;
        if (player == null)
            return;

        switch (event.keyCode) {
            case Parameters.data_.moveUp:
                this.moveUp_ = false;
                break;
            case Parameters.data_.moveDown:
                this.moveDown_ = false;
                break;
            case Parameters.data_.moveLeft:
                this.moveLeft_ = false;
                break;
            case Parameters.data_.moveRight:
                this.moveRight_ = false;
                break;
            case Parameters.data_.rotateLeft:
                this.rotateLeft_ = false;
                break;
            case Parameters.data_.rotateRight:
                this.rotateRight_ = false;
                break;
        }
        this.setPlayerMovement();
    }

    private function UseAbility(player:Player, slotId:int):void {
        var itemType:int = player.equipment_[slotId].ObjectType;
        if (itemType == 0) {
            return;
        }
        var objectXML:XML = ObjectLibrary.xmlLibrary_[itemType];
        if (objectXML == null || objectXML.hasOwnProperty("EndMpCost")) {
            return;
        }
        player.useAltWeapon(gs_.map.mouseX, gs_.map.mouseY, slotId);
    }

    private function setPlayerMovement():void {
        var player:Player = this.gs_.map.player_;
        if (player == null) {
            return;
        }
        if (this.enablePlayerInput_) {
            player.setRelativeMovement((this.rotateRight_ ? 1 : 0) - (this.rotateLeft_ ? 1 : 0), (this.moveRight_ ? 1 : 0) - (this.moveLeft_ ? 1 : 0), (this.moveDown_ ? 1 : 0) - (this.moveUp_ ? 1 : 0));
        } else {
            player.setRelativeMovement(0, 0, 0);
        }
    }

    private function useEquipItem(slotId:int):void {
        var slotIndex:int = ObjectLibrary.getMatchingSlotIndex(this.gs_.map.player_.equipment_[slotId], this.gs_.map.player_);
        if (slotIndex != -1) {
            GameServerConnection.instance.invSwap(
                    this.gs_.map.player_,
                    this.gs_.map.player_, slotId,
                    this.gs_.map.player_, slotIndex);
        } else {
            GameServerConnection.instance.useItem_new(this.gs_.map.player_, slotId);
        }
    }

    private function togglePerformanceStats():void {
        if (this.gs_.contains(stats_)) {
            this.gs_.removeChild(stats_);
            this.gs_.removeChild(this.gs_.gsc_.jitterWatcher_);
            this.gs_.gsc_.disableJitterWatcher();
        } else {
            this.gs_.addChild(stats_);
            this.gs_.gsc_.enableJitterWatcher();
            this.gs_.gsc_.jitterWatcher_.y = stats_.height;
            this.gs_.addChild(this.gs_.gsc_.jitterWatcher_);
        }
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/ContainerGrid.as">
package com.company.assembleegameclient.ui.panels.itemgrids {
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.InteractiveItemTile;

import svera.untiered.itemdata.NewItemData;

public class ContainerGrid extends ItemGrid {
    private var tiles:Vector.<InteractiveItemTile>;

    private var numSlots_:int;
    private var noCuts_:Boolean;

    public function ContainerGrid(gridOwner:GameObject, currentPlayer:Player, numSlots:int = 8, rowLength:int = 2, noCuts:Boolean = false) {
        super(gridOwner, currentPlayer, 0, ItemGrid.NO_CUT, rowLength);

        this.noCuts_ = noCuts;

        this.resizeContainer(numSlots);
    }

    public function resizeContainer(numSlots:int):void {
        var curSize:int = this.numSlots_;
        this.numSlots_ = numSlots;

        var newTiles:Vector.<InteractiveItemTile> = new Vector.<InteractiveItemTile>(this.numSlots_);

        var tile:InteractiveItemTile = null;

        for (var i:int = 0; i < this.numSlots_; i++) {

            if (i < curSize) {
                this.removeFromGrid(this.tiles[i]);
                tile = this.tiles[i];
            } else {
                tile = new InteractiveItemTile(i + this.indexOffset, this, this.interactive);
            }

            addToGrid(tile, 2, i);
            newTiles[i] = tile;
        }

        this.tiles = newTiles;
    }

    override public function setItems(items:Vector.<NewItemData>, itemIndexOffset:int = 0):void {
        var numItems:int = 0;
        var i:int = 0;
        var refresh:Boolean = false;
        if (items) {
            numItems = items.length;
            for (i = 0; i < this.numSlots_; i++) {
                if (i + indexOffset < numItems) {
                    if (this.tiles[i].setItem(items[i + indexOffset])) {
                        refresh = true;
                    }
                } else {
                    if (this.tiles[i].setItem(null)) { //TODO: not sure
                        refresh = true;
                    }
                }
            }
            if (refresh) {
                refreshTooltip();
            }
        }
    }

    public function setItem(slot:int, itemId:NewItemData):void {
        if (slot >= this.tiles.length || slot < 0) {
            return;
        }
        this.tiles[slot].setItem(itemId);
    }

    public function get items():Vector.<InteractiveItemTile> {
        return this.tiles;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/mediators/ItemGridMediator.as">
package com.company.assembleegameclient.ui.panels.mediators {
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.objects.Container;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.OneWayContainer;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.ContainerGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.InventoryGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.InteractiveItemTile;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.ItemTile;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.ItemTileEvent;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.assembleegameclient.util.DisplayHierarchy;

import svera.lib.framework.Mediator;

import svera.untiered.core.model.MapModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.core.signals.ShowTooltipSignal;
import svera.untiered.game.model.PotionInventoryModel;
import svera.untiered.itemdata.NewItemData;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.ui.model.HUDModel;

public class ItemGridMediator extends Mediator {


    [Inject]
    public var view:ItemGrid;

    [Inject]
    public var mapModel:MapModel;

    [Inject]
    public var playerModel:PlayerModel;

    [Inject]
    public var potionInventoryModel:PotionInventoryModel;

    [Inject]
    public var hudModel:HUDModel;

    [Inject]
    public var showToolTip:ShowTooltipSignal;

    public function ItemGridMediator() {
        super();
    }

    override public function initialize():void {
        this.view.addEventListener(ItemTileEvent.ITEM_MOVE, this.onTileMove);
        this.view.addEventListener(ItemTileEvent.ITEM_SHIFT_CLICK, this.onShiftClick);
        this.view.addEventListener(ItemTileEvent.ITEM_DOUBLE_CLICK, this.onDoubleClick);
        this.view.addToolTip.add(this.onAddToolTip);
    }

    private function onAddToolTip(tooltip:ToolTip):void {
        this.showToolTip.dispatch(tooltip);
    }

    override public function destroy():void {
        super.destroy();
    }

    private function onTileMove(e:ItemTileEvent):void {
        var targetTile:InteractiveItemTile = null;
        var inventoryGrid:InventoryGrid = null;
        var slot:int = 0;
        var sourceTile:InteractiveItemTile = e.tile;
        var target:* = DisplayHierarchy.getParentWithTypeArray(sourceTile.getDropTarget(), InventoryGrid, InteractiveItemTile, Map);
        if (target is InteractiveItemTile) {
            targetTile = target as InteractiveItemTile;
            if (this.canSwapItems(sourceTile, targetTile)) {
                this.swapItemTiles(sourceTile, targetTile);
            }
        } else if (target is Map || this.hudModel.gameSprite.map.mouseX < 300) {
            this.dropItem(sourceTile);
        } else if (target is InventoryGrid) {
            slot = sourceTile.ownerGrid.curPlayer.nextAvailableInventorySlot();
            if (slot != -1) {
                GameServerConnection.instance.invSwap(this.view.curPlayer, sourceTile.ownerGrid.owner, sourceTile.tileId, this.view.curPlayer, slot);
                sourceTile.setItem(null);
                sourceTile.updateUseability(this.view.curPlayer);
            }
        }
        sourceTile.resetItemPosition();
    }

    /*private function onPotionMove(e:ItemTileEvent) : void
    {
       var sourceTile:InteractiveItemTile = e.tile;
       var target:* = DisplayHierarchy.getParentWithTypeArray(sourceTile.getDropTarget(),TabStripView,Map);
       if(target is Map)
       {
          this.dropItem(sourceTile);
       }
       else if(target is TabStripView)
       {
          this.addToPotionStack(sourceTile);
       }
       sourceTile.resetItemPosition();
    }*/

    /*private function addToPotionStack(sourceTile:InteractiveItemTile) : void
    {
       if(!GameServerConnection.instance || !this.view.interactive || !sourceTile || this.potionInventoryModel.getPotionModel(sourceTile.getItemId()).maxPotionCount <= this.hudModel.gameSprite.map.player_.getPotionCount(sourceTile.getItemId()))
       {
          return;
       }
       GameServerConnection.instance.invSwapPotion(this.view.curPlayer,this.view.owner,sourceTile.tileId,sourceTile.itemSprite.itemId,this.view.curPlayer,PotionInventoryModel.getPotionSlot(sourceTile.getItemId()),ItemConstants.NO_ITEM);
       sourceTile.setItem(ItemConstants.NO_ITEM);
       sourceTile.updateUseability(this.view.curPlayer);
    }*/

    private function canSwapItems(sourceTile:InteractiveItemTile, targetTile:InteractiveItemTile):Boolean {
        if (!sourceTile.canHoldItem(targetTile.getItemData())) {
            return false;
        }
        if (!targetTile.canHoldItem(sourceTile.getItemData())) {
            return false;
        }
        if (ItemGrid(targetTile.parent).owner is OneWayContainer) {
            return false;
        }
        return true;
    }

    private function dropItem(itemTile:InteractiveItemTile):void {
        var groundContainer:Container = null;
        var equipment:Vector.<NewItemData> = null;
        var equipCount:int = 0;
        var openIndex:int = 0;
        var isSoulbound:Boolean = ObjectLibrary.isSoulbound(itemTile.itemSprite.itemData);
        var container:Container = this.view.owner as Container;
        if (this.view.owner == this.view.curPlayer || container && container.ownerId_ == this.view.curPlayer.accountId_ && !isSoulbound) {
            groundContainer = this.mapModel.currentInteractiveTarget as Container;
            if (groundContainer) {
                equipment = groundContainer.equipment_;
                equipCount = equipment.length;
                for (openIndex = 0; openIndex < equipCount; openIndex++) {
                    if (equipment[openIndex].ObjectType < 0) {
                        break;
                    }
                }
                if (openIndex < equipCount) {
                    this.dropWithoutDestTile(itemTile, groundContainer, openIndex);
                } else {
                    GameServerConnection.instance.invDrop(this.view.owner, itemTile.tileId);
                }
            } else {
                GameServerConnection.instance.invDrop(this.view.owner, itemTile.tileId);
            }
        }
        itemTile.setItem(null);
    }

    private function swapItemTiles(sourceTile:ItemTile, destTile:ItemTile):Boolean {
        if (!GameServerConnection.instance || !this.view.interactive || !sourceTile || !destTile) {
            return false;
        }
        GameServerConnection.instance.invSwap(this.view.curPlayer, this.view.owner, sourceTile.tileId, destTile.ownerGrid.owner, destTile.tileId);
        var tempItemId:NewItemData = sourceTile.getItemData();
        sourceTile.setItem(destTile.getItemData());
        destTile.setItem(tempItemId);
        sourceTile.updateUseability(this.view.curPlayer);
        destTile.updateUseability(this.view.curPlayer);
        return true;
    }

    private function dropWithoutDestTile(sourceTile:ItemTile, container:Container, containerIndex:int):void {
        if (!GameServerConnection.instance || !this.view.interactive || !sourceTile || !container) {
            return;
        }
        GameServerConnection.instance.invSwap(this.view.curPlayer, this.view.owner, sourceTile.tileId, container, containerIndex);
        sourceTile.setItem(null);
    }

    private function onShiftClick(e:ItemTileEvent):void {
        var tile:InteractiveItemTile = e.tile;
        if (tile.ownerGrid is InventoryGrid || tile.ownerGrid is ContainerGrid) {
            GameServerConnection.instance.useItem_new(tile.ownerGrid.owner, tile.tileId);
        }
    }

    private function onDoubleClick(e:ItemTileEvent):void {
        var tile:InteractiveItemTile = e.tile;
        if (tile.ownerGrid is ContainerGrid) {
            this.equipOrUseContainer(tile);
        } else {
            this.equipOrUseInventory(tile);
        }
        this.view.refreshTooltip();
    }

    /*private function isStackablePotion(tile:InteractiveItemTile) : Boolean
    {
       return tile.getItemId() == PotionInventoryModel.HEALTH_POTION_ID || tile.getItemId() == PotionInventoryModel.MAGIC_POTION_ID;
    }*/

    private function pickUpItem(tile:InteractiveItemTile):void {
        var nextAvailable:int = this.view.curPlayer.nextAvailableInventorySlot();
        if (nextAvailable != -1) {
            GameServerConnection.instance.invSwap(this.view.curPlayer, this.view.owner, tile.tileId, this.view.curPlayer, nextAvailable);
        }
    }

    private function equipOrUseContainer(tile:InteractiveItemTile):void {
        var tileOwner:GameObject = tile.ownerGrid.owner;
        var player:Player = this.view.curPlayer;
        var nextAvailableSlotIndex:int = this.view.curPlayer.nextAvailableInventorySlot();
        if (nextAvailableSlotIndex != -1) {
            GameServerConnection.instance.invSwap(player, this.view.owner, tile.tileId, this.view.curPlayer, nextAvailableSlotIndex);
        } else {
            GameServerConnection.instance.useItem_new(tileOwner, tile.tileId);
        }
    }

    private function equipOrUseInventory(tile:InteractiveItemTile):void {
        var tileOwner:GameObject = tile.ownerGrid.owner;
        var player:Player = this.view.curPlayer;
        var matchingSlotIndex:int = ObjectLibrary.getMatchingSlotIndex(tile.getItemData(), player);
        if (matchingSlotIndex != -1) {
            GameServerConnection.instance.invSwap(player, tileOwner, tile.tileId, player, matchingSlotIndex);
        } else {
            GameServerConnection.instance.useItem_new(tileOwner, tile.tileId);
        }
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinListItem.as">
package svera.untiered.classes.view {
import com.company.ui.SimpleText;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.Sprite;
import flash.events.MouseEvent;
import flash.filters.ColorMatrixFilter;
import flash.filters.DropShadowFilter;
import flash.geom.ColorTransform;

import org.osflash.signals.Signal;

import svera.untiered.assets.model.Animation;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;

public class CharacterSkinListItem extends Sprite {
    private const grayscaleMatrix:ColorMatrixFilter = new ColorMatrixFilter(MoreColorUtil.greyscaleFilterMatrix);
    private var nameText:SimpleText;
    private var lock:Bitmap;
    public var selected:Signal = new Signal();
    public var model:CharacterSkin;
    public var state:CharacterSkinState;
    private var isOver:Boolean;
    public var index:int = 0;
    public var initialAngle:Number = 0;
    public var angle:Number = 0;

    public function CharacterSkinListItem() {
        this.state = CharacterSkinState.NULL;
        nameText = makeNameText();
        lock = makeLock();
        super();
    }

    private function makeNameText():SimpleText {
        var text:SimpleText = new SimpleText(12, 16777215, false, 0, 0);
        text.setBold(true);
        text.filters = [new DropShadowFilter(0, 0, 0, 1, 8, 8)];
        text.updateMetrics();
        addChild(text);
        return text;
    }

    private function makeLock():Bitmap {
        var bitmap:Bitmap = new Bitmap();
        bitmap.scaleX = 2;
        bitmap.scaleY = 2;
        bitmap.y = height * 0.5 - 4;
        bitmap.visible = false;
        addChild(bitmap);
        return bitmap;
    }

    public function setLockIcon(data:BitmapData):void {
        this.lock.bitmapData = data;
        this.lock.x = -this.lock.width - 5;
    }

    public function setSkin(icon:Animation):void {
        addChild(icon)
        icon.start();
    }

    public function getModel():CharacterSkin {
        return this.model;
    }

    public function setModel(value:CharacterSkin):void {
        this.model && this.model.changed.remove(this.onModelChanged);
        this.model = value;
        this.model && this.model.changed.add(this.onModelChanged);

        this.onModelChanged(this.model);
        onOut(null);
        addEventListener(MouseEvent.MOUSE_OVER, this.onOver);
        addEventListener(MouseEvent.MOUSE_OUT, this.onOut);
    }

    private function onModelChanged(skin:CharacterSkin):void {
        this.state = Boolean(skin) ? skin.getState() : CharacterSkinState.NULL;
        this.updateName();
        this.updateState();
    }

    public function getState():CharacterSkinState {
        return this.state;
    }

    private var firstW:Number = 0;

    private function updateName():void {
        nameText.text = Boolean(this.model) ? this.model.name : "";
        nameText.updateMetrics();
        if (firstW == 0) {
            firstW = width;
        }
        nameText.x = (firstW - nameText.width) / 2;
        nameText.y = nameText.height;
    }

    private function updateState():void {
        updateGrayFilter();
    }

    private function onOver(e:MouseEvent):void {
        this.isOver = true;

        if (this.state.isDisabled()) {
            transform.colorTransform = new ColorTransform(0.5, 0.5, 0.5);
            return;
        }
        transform.colorTransform = new ColorTransform(1.2, 1.2, 1.2);
    }

    private function onOut(e:MouseEvent):void {
        this.isOver = false;
        if (this.state.isDisabled()) {
            transform.colorTransform = new ColorTransform(0.5, 0.5, 0.5);
            return;
        }
        transform.colorTransform = new ColorTransform(1, 1, 1);

    }

    private function updateGrayFilter():void {
        filters = this.state == CharacterSkinState.PURCHASING ? [grayscaleMatrix] : [];
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinView.as">
package svera.untiered.classes.view {
import com.company.assembleegameclient.screens.AccountScreen;
import com.company.assembleegameclient.screens.TitleMenuOption;

import flash.display.Shape;
import flash.display.Sprite;
import flash.events.MouseEvent;

import org.osflash.signals.Signal;
import org.osflash.signals.natives.NativeMappedSignal;

import svera.untiered.game.view.CurrencyDisplay;
import svera.untiered.ui.view.components.ScreenBase;

public class CharacterSkinView extends Sprite {
    public var playBtn:TitleMenuOption;
    public var play:NativeMappedSignal;
    public var back:Signal;
    public static var positionStuff:Signal;
    private var classDetailView:ClassDetailView;

    public function CharacterSkinView() {
        super();
        makeScreenBase()
        makeAccountScreen()
        makeLines();
        makeCurrencyDisplay();
        playBtn = makePlayButton();
        var backBtn:TitleMenuOption = makeBackButton();
        play = new NativeMappedSignal(playBtn, MouseEvent.CLICK);
        back = new NativeMappedSignal(backBtn, MouseEvent.CLICK);
        positionStuff = new Signal();
        makeClassDetailView();
    }

    private function makeScreenBase():ScreenBase {
        var base:ScreenBase = new ScreenBase(2);
        addChild(base);
        return base;
    }

    private function makeAccountScreen():AccountScreen {
        var screen:AccountScreen = new AccountScreen();
        addChild(screen);
        return screen;
    }

    private function makeCurrencyDisplay():CurrencyDisplay {
        var display:CurrencyDisplay = new CurrencyDisplay();
        display.x = GameClient.StageWidth;
        display.y = 20;
        addChild(display);
        return display;
    }

    private function makeLines():Shape {
        var shape:Shape = new Shape();
        shape.graphics.clear();
        shape.graphics.lineStyle(2, 5526612);
        shape.graphics.moveTo(0, 105);
        shape.graphics.lineTo(GameClient.StageWidth, 105);
        shape.graphics.moveTo(346, 105);
        shape.graphics.lineTo(346, GameClient.StageHeight - (600 - 526));
        //addChild(shape);
        return shape;
    }

    private function makePlayButton():TitleMenuOption {
        var option:TitleMenuOption;
        option = new TitleMenuOption("play", 36, false);
        option.x = GameClient.HalfStageWidth - option.width / 2;
        option.y = GameClient.StageHeight - (600 - 520);
        addChild(option);
        return option;
    }

    private function makeBackButton():TitleMenuOption {
        var option:TitleMenuOption = new TitleMenuOption("back", 22, false);
        option.x = 30;
        option.y = GameClient.StageHeight - (600 - 534);
        addChild(option);
        return option;
    }

    private function makeClassDetailView():ClassDetailView {
        classDetailView = new ClassDetailView(playBtn);

        addChild(classDetailView);

        positionStuff.add(positionThings);

        //Add left and right here because theyre out of class detail bounds
        addChild(classDetailView.skinListView.rightSkin);
        addChild(classDetailView.skinListView.leftSkin);

        return classDetailView;
    }

    private function positionThings():void {
        classDetailView.x = (width - ClassDetailView.WIDTH) / 2;
        classDetailView.y = (GameClient.StageHeight - classDetailView.height) / 2;

        trace("Position things dispatched");
        classDetailView.positionSkins();

        classDetailView.skinListView.rightSkin.x = classDetailView.x + ClassDetailView.WIDTH + classDetailView.skinListView.rightSkin.width;
        classDetailView.skinListView.rightSkin.y = classDetailView.y + classDetailView.height / 2;

        classDetailView.skinListView.leftSkin.x = classDetailView.x - classDetailView.skinListView.leftSkin.width;
        classDetailView.skinListView.leftSkin.y = classDetailView.skinListView.rightSkin.y;
    }

    public function setPlayButtonEnabled(activate:Boolean):void {
        if (!activate) {
            this.playBtn.deactivate();
        }
    }
}
}
</file>

<file path="src/svera/untiered/classes/view/CharacterSkinListView.as">
package svera.untiered.classes.view {
import com.company.assembleegameclient.screens.TitleMenuOption;
import com.company.assembleegameclient.util.Currency;
import com.company.ui.SimpleText;
import com.gskinner.motion.GTween;
import com.gskinner.motion.easing.Sine;

import flash.display.Sprite;
import flash.events.Event;
import flash.events.MouseEvent;
import flash.utils.getTimer;

import svera.untiered.classes.control.BuyCharacterSkinSignal;
import svera.untiered.classes.model.CharacterSkin;
import svera.untiered.classes.model.CharacterSkinState;
import svera.untiered.core.StaticInjectorContext;
import svera.untiered.util.components.LegacyBuyButton;
import svera.untiered.util.components.api.BuyButton;

public class CharacterSkinListView extends Sprite {
    [Inject]
    public var buyCharacterSkin:BuyCharacterSkinSignal;

    public static const PADDING:int = 5;
    public static const WIDTH:int = 442;
    public static const HEIGHT:int = 400;

    public var skinsContainer:Orbiter;
    public var buyButton:BuyButton;
    public var currentSkin:CharacterSkinListItem;
    private var purchasingText:SimpleText = new SimpleText(14, 16777215, false, 0, 0);
    public var playButton:TitleMenuOption;
    private var selectedSkin:int = 0;
    public var rightSkin:TitleMenuOption = new TitleMenuOption(">", 24, true, true);
    public var leftSkin:TitleMenuOption = new TitleMenuOption("<", 24, true, true);
    private const radius:Number = 100;
    public var lastTime:int = getTimer();
    // Degrees per second.
    public var speed:Number = 60;
    private var angle:Number = 0;
    private var tween:GTween;


    private var _accAngle:Number = -(Math.PI * 3) / 2;
    public var rotationDirection:Number = 0;

    public function get testAngle():Number {
        return rotationDirection;
    }

    public function set testAngle(a:Number):void {
        rotationDirection = a;
    }

    public function get accAngle():Number {
        return _accAngle;
    }

    public function set accAngle(a:Number):void {
        _accAngle = a;
    }

    public function CharacterSkinListView(playButton_:TitleMenuOption) {
        super();
        playButton = playButton_;
        buyCharacterSkin = StaticInjectorContext.getInjector().getInstance(BuyCharacterSkinSignal);
        setBuyButton();
        makeList();

        rightSkin.clicked.add(right);
        leftSkin.clicked.add(left);

        addEventListener(Event.RESIZE, function (e:Event):void {
        });

    }

    private function left():void {
        if (++selectedSkin >= skinsContainer.items.length) {
            selectedSkin = 0;
        }
        currentSkin && currentSkin.selected.dispatch(false);

        currentSkin = skinsContainer.items[selectedSkin];
        trace(currentSkin.model.name);
        currentSkin.selected.dispatch(true); // TODO: Fix this cause insane shit with position
        setButtonVisibilities();
        if(currentSkin.model.getState() == CharacterSkinState.PURCHASABLE){
            currentSkin.model.bought.addOnce(setButtonVisibilities);
        }

        tween = new GTween(this, 0.15, {testAngle: -1}, {ease: Sine.easeIn});
        tween.init();
        //tween.setValues({"testAngle": -1});
        tween.onChange = setPositions;
        tween.onComplete = resetAngle;

    }

    private function right():void {
        if (--selectedSkin < 0) {
            selectedSkin = skinsContainer.items.length - 1;
        }
        currentSkin && currentSkin.selected.dispatch(false);

        currentSkin = skinsContainer.items[selectedSkin];
        trace(currentSkin.model.name);
        currentSkin.selected.dispatch(true); // TODO: Fix this cause insane shit with position
        setButtonVisibilities();
        if(currentSkin.model.getState() == CharacterSkinState.PURCHASABLE){
            currentSkin.model.bought.addOnce(setButtonVisibilities);
        }
        //var targetVal:Number = _accAngle +
        tween = new GTween(this, 0.15, {testAngle: 1}, {ease: Sine.easeIn});
        tween.init();
        tween.onChange = setPositions;
        tween.onComplete = resetAngle;
    }

    private function resetAngle(change:GTween = null):void {
        _accAngle += angle * testAngle;
        testAngle = 0;
        tween = null;
    }

    private function setPositions(change:GTween = null):void {
        var radius:Number = 100;
        var localAcc:Number = _accAngle + angle * testAngle;
        for each(var item:CharacterSkinListItem in skinsContainer.items) {

            var x:Number = Math.cos(localAcc) * radius;
            var y:Number = Math.sin(localAcc) * radius * 0.38; // 0.38 for ellipse look

            item.scaleX = item.scaleY = Math.max((y / 19 + 2) / 2, 1); //min scale 1, max scale 2
            item.x = -item.width / 2;
            item.y = -item.height / 2;
            item.angle = localAcc;
            var container:Sprite = item.parent as Sprite; // Used only to make thing centered
            container.x = x;
            container.y = y;
            localAcc += angle;
        }
    }

    private function makeList():Sprite {
        skinsContainer = new Orbiter();
        return skinsContainer;
    }

    public function get getListHeight():Number {
        return skinsContainer.height
    }

    public function setItems(items_:Vector.<CharacterSkinListItem>):void {
        skinsContainer.items = items_;
        var counter:Number = 0;
        angle = (Math.PI * 2) / items_.length;
        skinsContainer.speed = angle / 60; // angle / fps

        var radius:Number = 100;
        _accAngle = -(Math.PI * 3) / 2;
        for each(var item:CharacterSkinListItem in items_) {


            var container:Sprite = new Sprite(); // Used only to make thing centered

            var x:Number = Math.cos(_accAngle) * radius;
            var y:Number = Math.sin(_accAngle) * radius * 0.38; // 0.38 for ellipse look

            item.scaleX = item.scaleY = Math.max((y / 19 + 2) / 2, 1); //min scale 1, max scale 2
            item.x = -item.width / 2;
            item.y = -item.height / 2;
            item.initialAngle = _accAngle;
            item.angle = _accAngle;
            counter++;
            container.addChild(item);
            container.x = x;
            container.y = y;
            skinsContainer.addChild(container);
            _accAngle += angle;
        }
        addChild(skinsContainer);
        CharacterSkinView.positionStuff.dispatch();
    }

    private function setButtonVisibilities(skin:CharacterSkin = null):void {
        var isOwned:Boolean = currentSkin.state == CharacterSkinState.OWNED;
        var isPurchasable:Boolean = currentSkin.state == CharacterSkinState.PURCHASABLE;
        var isPurchasing:Boolean = currentSkin.state == CharacterSkinState.PURCHASING;
        if (isOwned) {
            if(currentSkin.model == skin){
                currentSkin.setModel(skin);
            }
            playButton && playButton.activate();
        } else {
            playButton && playButton.deactivate();
        }
        if (isPurchasable) {
            setCost(currentSkin.model);
        }
        buyButton && (buyButton.visible = isPurchasable && !isOwned);

        this.purchasingText.visible = isPurchasing;
    }

    public function setBuyButton():void {
        buyButton = new LegacyBuyButton("", 16, 0, Currency.TSAVORITE);
        buyButton.setWidth(40);
        this.buyButton.x = (width - this.buyButton.width) / 2;
        this.buyButton.y = 300;
        this.buyButton.visible = false;
        buyButton.addEventListener(MouseEvent.CLICK, onBuy)
            addChild(buyButton);
    }

    private function onBuy(e:Event):void {
        buyCharacterSkin.dispatch(currentSkin.model);
    }

    private function updatePurchasingText():void {
        this.purchasingText.text = "Purchasing...";
        this.purchasingText.updateMetrics();
        this.purchasingText.x = width - this.purchasingText.width - 15;
        this.purchasingText.y = height / 2 - this.purchasingText.height / 2;
    }

    private function setCost(skin:CharacterSkin):void {
        if (!skin)
            return;

        var cost:int = Boolean(skin) ? skin.cost : 0;
        buyButton.setPrice(cost, Currency.TSAVORITE);
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/objects/ObjectLibrary.as">
package com.company.assembleegameclient.objects {
import com.company.assembleegameclient.objects.animation.AnimationsData;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.assembleegameclient.util.redrawers.GlowRedrawer;
import com.company.util.AssetLibrary;
import com.company.util.ConversionUtil;

import flash.display.BitmapData;
import flash.utils.Dictionary;
import flash.utils.getDefinitionByName;

import svera.untiered.itemdata.Item;

import svera.untiered.constants.GeneralConstants;
import svera.untiered.constants.ItemConstants;
import svera.untiered.itemdata.NewItemData;
import svera.untiered.messaging.impl.data.StatData;

public class ObjectLibrary {
    public static const baseItems:Dictionary = new Dictionary();

    public static var playerChars_:Vector.<XML> = new Vector.<XML>();
    public static var hexTransforms_:Vector.<XML> = new Vector.<XML>();
    public static var playerClassAbbr_:Dictionary = new Dictionary();
    public static const propsLibrary_:Dictionary = new Dictionary();
    public static const xmlLibrary_:Dictionary = new Dictionary();
    public static const idToType_:Dictionary = new Dictionary();
    public static const typeToDisplayId_:Dictionary = new Dictionary();
    public static const typeToTextureData_:Dictionary = new Dictionary();
    public static const typeToTopTextureData_:Dictionary = new Dictionary();
    public static const typeToAnimationsData_:Dictionary = new Dictionary();
    public static const defaultProps_:ObjectProperties = new ObjectProperties(null);

    public static const TYPE_MAP:Object = {
        "CaveWall": CaveWall,
        "Character": Character,
        "CharacterChanger": CharacterChanger,
        "ClosedVaultChest": ClosedVaultChest,
        "ClosedGiftChest": ClosedGiftChest,
        "ConnectedWall": ConnectedWall,
        "Container": Container,
        "GameObject": GameObject,
        "GuildBoard": GuildBoard,
        "GuildChronicle": GuildChronicle,
        "GuildHallPortal": GuildHallPortal,
        "GuildMerchant": GuildMerchant,
        "GuildRegister": GuildRegister,
        "Merchant": Merchant,
        "ReskinVendor": ReskinVendor,
        "OneWayContainer": OneWayContainer,
        "Player": Player,
        "Portal": Portal,
        "Projectile": Projectile,
        "Sign": Sign,
        "SpiderWeb": SpiderWeb,
        "Stalagmite": Stalagmite,
        "Wall": Wall,
        "Traits": Traits,
        "Vault": VaultChest,
        "MarketObject":MarketObject,
        "Gift": GiftChest
    };


    public function ObjectLibrary() {
        super();
    }

    public static function parseFromXML(xml:XML):void {
        var objectXML:XML = null;
        var id:String = null;
        var displayId:String = null;
        var objectType:int = 0;
        var found:Boolean = false;
        var i:int = 0;
        for each(objectXML in xml.Object) {
            id = String(objectXML.@id);
            displayId = id;
            if (objectXML.hasOwnProperty("DisplayId")) {
                displayId = objectXML.DisplayId;
            }
            if (objectXML.hasOwnProperty("Group")) {
                if (objectXML.Group == "Hexable") {
                    hexTransforms_.push(objectXML);
                }
            }
            objectType = int(objectXML.@type);
            propsLibrary_[objectType] = new ObjectProperties(objectXML);
            xmlLibrary_[objectType] = objectXML;
            idToType_[id] = objectType;
            typeToDisplayId_[objectType] = displayId;

            if (String(objectXML.Class) == "Equipment" || objectXML.hasOwnProperty("Item"))
            {
                baseItems[objectType] = Item.parseFromXml(objectXML);
            }
            else if (String(objectXML.Class) == "Player") {
                playerClassAbbr_[objectType] = String(objectXML.@id).substr(0, 2);
                found = false;
                for (i = 0; i < playerChars_.length; i++) {
                    if (int(playerChars_[i].@type) == objectType) {
                        playerChars_[i] = objectXML;
                        found = true;
                    }
                }
                if (!found) {
                    playerChars_.push(objectXML);
                }
            }
            typeToTextureData_[objectType] = new TextureData(objectXML);
            if (objectXML.hasOwnProperty("Top")) {
                typeToTopTextureData_[objectType] = new TextureData(XML(objectXML.Top));
            }
            if (objectXML.hasOwnProperty("Animation")) {
                typeToAnimationsData_[objectType] = new AnimationsData(objectXML);
            }
        }
    }

    public static function getIdFromType(type:int):String {
        var objectXML:XML = xmlLibrary_[type];
        if (objectXML == null) {
            return null;
        }
        return String(objectXML.@id);
    }

    public static function getPropsFromId(id:String):ObjectProperties {
        var objectType:int = idToType_[id];
        return propsLibrary_[objectType];
    }

    public static function getXMLfromId(id:String):XML {
        var objectType:int = idToType_[id];
        return xmlLibrary_[objectType];
    }

    public static function getObjectFromType(objectType:int):GameObject {
        var objectXML:XML = xmlLibrary_[objectType];
        var typeReference:String = objectXML.Class;
        var typeClass:Class = TYPE_MAP[typeReference] || makeClass(typeReference);
        return new typeClass(objectXML);
    }

    private static function makeClass(typeReference:String):Class {
        var typeName:String = "com.company.assembleegameclient.objects." + typeReference;
        return getDefinitionByName(typeName) as Class;
    }

    public static function getTextureFromType(objectType:int):BitmapData {
        var textureData:TextureData = typeToTextureData_[objectType];
        if (textureData == null) {
            return null;
        }
        return textureData.getTexture();
    }
    public static function isMarketBanned(_arg1:int):Boolean {
        var xml:XML = xmlLibrary_[_arg1];
        return !(xml == null) && (xml.TierType == "Stat" || xml.TierType == "Common" ||  xml.hasOwnProperty("Soulbound"));
    }
    public static function getRedrawnTextureFromType(objectType:int, size:int, includeBottom:Boolean, useCaching:Boolean = true, scaleValue:int = 5):BitmapData {
        var textureData:TextureData = typeToTextureData_[objectType];
        var texture:BitmapData = Boolean(textureData) ? textureData.getTexture() : null;
        if (texture == null) {
            texture = AssetLibrary.getImageFromSet("Overworld_Environment_NotSpecific8x8", 1);
        }
        var mask:BitmapData = Boolean(textureData) ? textureData.mask_ : null;
        if (mask == null) {
            return TextureRedrawer.redraw(texture, size, includeBottom, 0, useCaching, scaleValue);
        }
        var objectXML:XML = xmlLibrary_[objectType];
        var tex1:int = Boolean(objectXML.hasOwnProperty("Tex1")) ? int(int(objectXML.Tex1)) : int(0);
        var tex2:int = Boolean(objectXML.hasOwnProperty("Tex2")) ? int(int(objectXML.Tex2)) : int(0);
        texture = TextureRedrawer.resize(texture, mask, size, includeBottom, tex1, tex2);
        texture = GlowRedrawer.outlineGlow(texture, 0);
        return texture;
    }

    public static function getSizeFromType(objectType:int):int {
        var objectXML:XML = xmlLibrary_[objectType];
        if (!objectXML.hasOwnProperty("Size")) {
            return 100;
        }
        return int(objectXML.Size);
    }

    public static function getSlotTypeFromType(objectType:int):int {
        var objectXML:XML = xmlLibrary_[objectType];
        if (objectXML == null || !objectXML.hasOwnProperty("SlotType")) {
            return -1;
        }
        return int(objectXML.SlotType);
    }

    public static function getSlotTypeFromItemData(itemData:NewItemData):int {
        if (itemData == null)
            return -1;

        return itemData.SlotType;
    }

    public static function isEquippableByPlayer(objectType:int, player:Player):Boolean {
        if (objectType == ItemConstants.NO_ITEM) {
            return false;
        }
        var objectXML:XML = xmlLibrary_[objectType];
        var slotType:int = int(objectXML.SlotType.toString());
        for (var i:uint = 0; i < GeneralConstants.NUM_EQUIPMENT_SLOTS; i++) {
            if (player.slotTypes_[i] == slotType) {
                return true;
            }
        }
        return false;
    }

    public static function getMatchingSlotIndex(itemData:NewItemData, player:Player):int {
        if (itemData == null)
            return -1;

        var slotType:int = itemData.SlotType;
        for (var i:int = 0; i < GeneralConstants.NUM_EQUIPMENT_SLOTS; i++) {
            if (player.slotTypes_[i] == slotType) {
                return i;
            }
        }

        return -1;
    }

    public static function isUsableByPlayer(objectType:int, player:Player):Boolean {
        if (player == null) {
            return true;
        }
        var objectXML:XML = xmlLibrary_[objectType];
        if (objectXML == null || !objectXML.hasOwnProperty("SlotType")) {
            return false;
        }
        var slotType:int = objectXML.SlotType;
        if (slotType == ItemConstants.POTION_TYPE) {
            return true;
        }
        for (var i:int = 0; i < player.slotTypes_.length; i++) {
            if (player.slotTypes_[i] == slotType) {
                return true;
            }
        }
        return false;
    }

    public static function isSoulbound(itemData:NewItemData):Boolean {
        if (itemData == null)
            return false;

        return itemData.Soulbound;
    }

    public static function usableBy(objectType:int):Vector.<String> {
        var playerXML:XML = null;
        var slotTypes:Vector.<int> = null;
        var i:int = 0;
        var objectXML:XML = xmlLibrary_[objectType];
        if (objectXML == null || !objectXML.hasOwnProperty("SlotType")) {
            return null;
        }
        var slotType:int = objectXML.SlotType;
        if (slotType == ItemConstants.POTION_TYPE || slotType == ItemConstants.RING_TYPE) {
            return null;
        }
        var usable:Vector.<String> = new Vector.<String>();
        for each(playerXML in playerChars_) {
            slotTypes = ConversionUtil.toIntVector(playerXML.SlotTypes);
            for (i = 0; i < slotTypes.length; i++) {
                if (slotTypes[i] == slotType) {
                    usable.push(typeToDisplayId_[int(playerXML.@type)]);
                    break;
                }
            }
        }
        return usable;
    }

    public static function playerMeetsRequirements(objectType:int, player:Player):Boolean {
        var reqXML:XML = null;
        if (player == null) {
            return true;
        }
        var objectXML:XML = xmlLibrary_[objectType];
        for each(reqXML in objectXML.EquipRequirement) {
            if (!playerMeetsRequirement(reqXML, player)) {
                return false;
            }
        }
        return true;
    }

    public static function playerMeetsRequirement(reqXML:XML, p:Player):Boolean {
        var val:int = 0;
        if (reqXML.toString() == "Stat") {
            val = int(reqXML.@value);
            switch (int(reqXML.@stat)) {
                case StatData.MAXHP:
                    return p.maxHP_ >= val;
                case StatData.MAXSP:
                    return p.maxSP_ >= val;
                case StatData.MAXRP:
                    return p.maxRP_ >= val;
                case StatData.LEVEL:
                    return p.level_ >= val;
                case StatData.AWAKENING:
                    return p.awakening_ >= val;
                case StatData.RELIC:
                    return p.relic_ >= val;
                case StatData.BACKGROUND:
                    return p.background_ >= val;
                case StatData.ATTACK:
                    return p.attack_ >= val;
                case StatData.ARMOR:
                    return p.armor_ >= val;
                case StatData.SPEED:
                    return p.speed_ >= val;
                case StatData.VIGOR:
                    return p.vigor_ >= val;
                case StatData.INTELLECT:
                    return p.intellect >= val;
                case StatData.DEXTERITY:
                    return p.dexterity_ >= val;
            }
        }
        return false;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/ItemGrid.as">
package com.company.assembleegameclient.ui.panels.itemgrids {
import com.company.assembleegameclient.constants.InventoryOwnerTypes;
import com.company.assembleegameclient.objects.Container;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.objects.VaultChest;
import com.company.assembleegameclient.ui.panels.Panel;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.EquipmentTile;
import com.company.assembleegameclient.ui.panels.itemgrids.itemtiles.ItemTile;
import com.company.assembleegameclient.ui.tooltip.EquipmentToolTip;
import com.company.assembleegameclient.ui.tooltip.TextToolTip;
import com.company.assembleegameclient.ui.tooltip.ToolTip;
import com.company.util.SpriteUtil;

import flash.events.MouseEvent;

import org.osflash.signals.Signal;

import svera.untiered.constants.ItemConstants;
import svera.untiered.itemdata.NewItemData;

public class ItemGrid extends Panel {

    public static const NO_CUT:Array = [0, 0, 0, 0];
    public static const ALL_CUT:Array = [1, 1, 1, 1];

    public static const CutsByNum:Object = {
        1: [ALL_CUT, ALL_CUT, ALL_CUT, ALL_CUT, ALL_CUT],
        2: [[1, 0, 0, 0], NO_CUT, NO_CUT, [0, 1, 0, 0], [0, 0, 0, 1], NO_CUT, NO_CUT, [0, 0, 1, 0]],
        3: [[1, 0, 0, 0], NO_CUT, NO_CUT, [0, 1, 0, 0], [0, 0, 0, 1], NO_CUT, NO_CUT, [0, 0, 1, 0]],
        6: [[1, 0, 0, 0], NO_CUT, NO_CUT, [0, 1, 0, 0], NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, NO_CUT, [0, 0, 0, 1], NO_CUT, NO_CUT, [0, 0, 1, 0]]
    };


    protected var padding:uint = 4;
    public const addToolTip:Signal = new Signal(ToolTip);

    public var owner:GameObject;

    private var tooltip:ToolTip;
    private var tooltipFocusTile:ItemTile;

    public var curPlayer:Player;

    protected var indexOffset:int;

    public var interactive:Boolean;

    private var overrideCut_:Array;
    private var rowLength:uint;

    public function ItemGrid(gridOwner:GameObject, currentPlayer:Player, itemIndexOffset:int, overrideCut:Array = null, rowLength:int = 4) {
        super(null);
        this.overrideCut_ = overrideCut;
        this.rowLength = rowLength;
        this.owner = gridOwner;
        this.curPlayer = currentPlayer;
        this.indexOffset = itemIndexOffset;
        var isContainer:Boolean = gridOwner is Container || gridOwner is VaultChest;
        if (gridOwner == currentPlayer || isContainer) {
            this.interactive = true;
        }
    }

    public function hideTooltip():void {
        if (this.tooltip) {
            this.tooltip.detachFromTarget();
            this.tooltip = null;
            this.tooltipFocusTile = null;
        }
    }

    public function refreshTooltip():void {
        if (!stage || !this.tooltip || !this.tooltip.stage) {
            return;
        }
        if (this.tooltipFocusTile) {
            this.tooltip.detachFromTarget();
            this.tooltip = null;
            this.addToolTipToTile(this.tooltipFocusTile);
        }
    }

    public function onTileHover(e:MouseEvent):void {
        if (!stage) {
            return;
        }
        var tile:ItemTile = e.currentTarget as ItemTile;
        this.addToolTipToTile(tile);
        this.tooltipFocusTile = tile;
    }

    private function addToolTipToTile(tile:ItemTile):void {
        var itemName:String = null;
        if (tile.itemSprite.itemData != null) {
            this.tooltip = new EquipmentToolTip(tile.itemSprite.itemData, this.curPlayer, Boolean(this.owner) ? int(this.owner.objectType_) : int(-1), this.getCharacterType(), tile.tileId);
        } else {
            if (tile is EquipmentTile) {
                itemName = ItemConstants.itemTypeToName((tile as EquipmentTile).itemType);
            } else {
                itemName = "item";
            }
            this.tooltip = new TextToolTip(3552822, 10197915, null, "Empty " + itemName + " Slot", 200);
        }
        this.tooltip.attachToTarget(tile);
        this.addToolTip.dispatch(this.tooltip);
    }

    private function getCharacterType():String {
        if (this.owner == this.curPlayer) {
            return InventoryOwnerTypes.CURRENT_PLAYER;
        }
        if (this.owner is Player) {
            return InventoryOwnerTypes.OTHER_PLAYER;
        }
        return InventoryOwnerTypes.NPC;
    }

    public function addToGrid(tile:ItemTile, numRows:uint, tileIndex:uint):void {
        tile.drawBackground(this.overrideCut_ == null ? CutsByNum[numRows][tileIndex] : this.overrideCut_);
        tile.addEventListener(MouseEvent.ROLL_OVER, this.onTileHover);
        tile.x = int(tileIndex % this.rowLength) * (ItemTile.WIDTH + this.padding);
        tile.y = int(tileIndex / this.rowLength) * (ItemTile.HEIGHT + this.padding);
        addChild(tile);
    }

    public function removeFromGrid(tile:ItemTile):void {
        SpriteUtil.safeRemoveChild(this, tile);
    }

    public function setItems(items:Vector.<NewItemData>, itemIndexOffset:int = 0):void {

    }

    public function enableInteraction(enabled:Boolean):void {
        mouseEnabled = enabled;
    }

    override public function draw():void {
        this.setItems(this.owner.equipment_, this.indexOffset);
    }
}
}
</file>

<file path="src/svera/untiered/stage3D/Renderer.as">
package svera.untiered.stage3D {
import com.adobe.utils.AGALMiniAssembler;
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.parameters.Parameters;

import flash.display.GraphicsBitmapFill;
import flash.display.GraphicsGradientFill;
import flash.display.IGraphicsData;
import flash.display.Stage3D;
import flash.display.StageScaleMode;
import flash.display3D.Context3D;
import flash.display3D.Context3DProgramType;
import flash.display3D.Context3DTextureFormat;
import flash.display3D.Context3DTriangleFace;
import flash.display3D.Context3DVertexBufferFormat;
import flash.display3D.IndexBuffer3D;
import flash.display3D.Program3D;
import flash.display3D.VertexBuffer3D;
import flash.display3D.textures.Texture;
import flash.geom.Matrix3D;
import flash.geom.Vector3D;
import flash.utils.ByteArray;

import org.swiftsuspenders.Injector;

import svera.untiered.stage3D.Object3D.Object3DStage3D;
import svera.untiered.stage3D.Object3D.Util;
import svera.untiered.stage3D.graphic3D.Graphic3D;
import svera.untiered.stage3D.graphic3D.TextureFactory;
import svera.untiered.stage3D.proxies.Context3DProxy;

public class Renderer {
    public static const STAGE3D_FILTER_PAUSE:uint = 1;

    public static const STAGE3D_FILTER_BLIND:uint = 2;

    public static const STAGE3D_FILTER_DRUNK:uint = 3;

    public static var inGame:Boolean;

    private static const POST_FILTER_VERTEX_CONSTANTS:Vector.<Number> = new <Number>[1, 2, 0, 0];

    private static const GRAYSCALE_FRAGMENT_CONSTANTS:Vector.<Number> = new <Number>[0.3, 0.59, 0.11, 0];

    private static const BLIND_FRAGMENT_CONSTANTS:Vector.<Number> = new <Number>[0.05, 0.05, 0.05, 0];

    private static const POST_FILTER_POSITIONS:Vector.<Number> = new <Number>[-1, 1, 0, 0, 1, 1, 1, 0, 1, -1, 1, 1, -1, -1, 0, 1];

    private static const POST_FILTER_TRIS:Vector.<uint> = new <uint>[0, 2, 3, 0, 1, 2];


    [Inject]
    public var context3D:Context3DProxy;

    [Inject]
    public var textureFactory:TextureFactory;

    [Inject]
    public var injector:Injector;

    public static var tX:Number;

    public static var tY:Number;

    public var program2:Program3D;

    private var postProcessingProgram_:Program3D;

    private var blurPostProcessing_:Program3D;

    private var shadowProgram_:Program3D;

    private var graphic3D_:Graphic3D;

    protected var _projection:Matrix3D;

    protected var cameraMatrix_:Matrix3D;

    private var p_:Vector3D;

    private var f_:Vector3D;

    private var u_:Vector3D;

    private var r_:Vector3D;

    private var rd_:Vector.<Number>;

    protected var widthOffset_:Number;

    protected var heightOffset_:Number;

    private var stageWidth:Number = 600;

    private var stageHeight:Number = 600;

    private var sceneTexture_:Texture;

    private var blurFactor:Number = 0.01;

    private var postFilterVertexBuffer_:VertexBuffer3D;

    private var postFilterIndexBuffer_:IndexBuffer3D;

    protected var _vertexShader:String;

    protected var _fragmentShader:String;

    protected var blurFragmentConstants_:Vector.<Number>;

    public function Renderer(render3D:Render3D) {
        this.cameraMatrix_ = new Matrix3D();
        this.p_ = new Vector3D();
        this.f_ = new Vector3D();
        this.u_ = new Vector3D();
        this.r_ = new Vector3D();
        this.rd_ = new Vector.<Number>(16, true);
        this._vertexShader = ["m44 op, va0, vc0", "m44 v0, va0, vc8", "m44 v1, va1, vc8", "mov v2, va2"].join("\n");
        this._fragmentShader = ["tex oc, v2, fs0 <2d,clamp>"].join("\n");
        this.blurFragmentConstants_ = Vector.<Number>([0.4, 0.6, 0.4, 1.5]);
        super();
        Renderer.inGame = false;
        this.setTranslationToTitle();
        render3D.add(this.onRender);
    }

    public function init(context3D:Context3D):void {
        this._projection = Util.perspectiveProjection(56, 1, 0.1, 2048);
        var vsAssembler:AGALMiniAssembler = new AGALMiniAssembler();
        vsAssembler.assemble(Context3DProgramType.VERTEX, this._vertexShader);
        var fsAssembler:AGALMiniAssembler = new AGALMiniAssembler();
        fsAssembler.assemble(Context3DProgramType.FRAGMENT, this._fragmentShader);
        this.program2 = context3D.createProgram();
        this.program2.upload(vsAssembler.agalcode, fsAssembler.agalcode);
        var fragSource:String = "tex ft0, v0, fs0 <2d,clamp,linear>\n" + "dp3 ft0.x, ft0, fc0\n" + "mov ft0.y, ft0.x\n" + "mov ft0.z, ft0.x\n" + "mov oc, ft0\n";
        var vertSource:String = "mov op, va0\n" + "add vt0, vc0.xxxx, va0\n" + "div vt0, vt0, vc0.yyyy\n" + "sub vt0.y, vc0.x, vt0.y\n" + "mov v0, vt0\n";
        var assembler:AGALMiniAssembler = new AGALMiniAssembler();
        assembler.assemble(Context3DProgramType.VERTEX, vertSource);
        var vertexShaderAGAL:ByteArray = assembler.agalcode;
        assembler.assemble(Context3DProgramType.FRAGMENT, fragSource);
        var fragmentShaderAGAL:ByteArray = assembler.agalcode;
        this.postProcessingProgram_ = context3D.createProgram();
        this.postProcessingProgram_.upload(vertexShaderAGAL, fragmentShaderAGAL);
        var blurFS:String = "sub ft0, v0, fc0\n" + "sub ft0.zw, ft0.zw, ft0.zw\n" + "dp3 ft1, ft0, ft0\n" + "sqt ft1, ft1\n" + "div ft1.xy, ft1.xy, fc0.zz\n" + "pow ft1.x, ft1.x, fc0.w\n" + "mul ft0.xy, ft0.xy, ft1.xx\n" + "div ft0.xy, ft0.xy, ft1.yy\n" + "add ft0.xy, ft0.xy, fc0.xy\n" + "tex oc, ft0, fs0<2d,clamp>\n";
        var blurVS:String = "m44 op, va0, vc0\n" + "mov v0, va1\n";
        assembler.assemble(Context3DProgramType.VERTEX, blurVS);
        var blurVSAGAL:ByteArray = assembler.agalcode;
        assembler.assemble(Context3DProgramType.FRAGMENT, blurFS);
        var blurFSAGAL:ByteArray = assembler.agalcode;
        this.blurPostProcessing_ = context3D.createProgram();
        this.blurPostProcessing_.upload(blurVSAGAL, blurFSAGAL);
        var shadowVS:String = "m44 op, va0, vc0\n" + "mov v0, va1\n" + "mov v1, va2\n";
        assembler.assemble(Context3DProgramType.VERTEX, shadowVS);
        var shadowVSAGAL:ByteArray = assembler.agalcode;
        var shadowFS:String = "sub ft0.xy, v1.xy, fc4.xx\n" + "mul ft0.xy, ft0.xy, ft0.xy\n" + "add ft0.x, ft0.x, ft0.y\n" + "slt ft0.y, ft0.x, fc4.y\n" + "mul oc, v0, ft0.yyyy\n";
        assembler.assemble(Context3DProgramType.FRAGMENT, shadowFS);
        var shadowFSAGAL:ByteArray = assembler.agalcode;
        this.shadowProgram_ = context3D.createProgram();
        this.shadowProgram_.upload(shadowVSAGAL, shadowFSAGAL);
        this.sceneTexture_ = context3D.createTexture(1024, 1024, Context3DTextureFormat.BGRA, true);
        this.postFilterVertexBuffer_ = context3D.createVertexBuffer(4, 4);
        this.postFilterVertexBuffer_.uploadFromVector(POST_FILTER_POSITIONS, 0, 4);
        this.postFilterIndexBuffer_ = context3D.createIndexBuffer(6);
        this.postFilterIndexBuffer_.uploadFromVector(POST_FILTER_TRIS, 0, 6);
        this.graphic3D_ = this.injector.getInstance(Graphic3D);
    }

    private function UpdateCameraMatrix(camera:Camera):void {
        var angleRad:Number = -camera.angleRad_;
        this.f_.x = 0;
        this.f_.y = 0;
        this.f_.z = -1;
        this.p_.x = -(camera.x_ + this.widthOffset_);
        this.p_.y = camera.y_ - this.heightOffset_;
        this.p_.z = -camera.z_;
        this.r_.x = Math.cos(angleRad);
        this.r_.y = Math.sin(angleRad);
        this.r_.z = 0;
        this.u_.x = Math.cos(angleRad + Math.PI / 2);
        this.u_.y = Math.sin(angleRad + Math.PI / 2);
        this.u_.z = 0;
        this.rd_[0] = this.r_.x;
        this.rd_[1] = this.u_.x;
        this.rd_[2] = this.f_.x;
        this.rd_[3] = 0;
        this.rd_[4] = this.r_.y;
        this.rd_[5] = this.u_.y;
        this.rd_[6] = this.f_.y;
        this.rd_[7] = 0;
        this.rd_[8] = this.r_.z;
        this.rd_[9] = 1;
        this.rd_[10] = -this.f_.z;
        this.rd_[11] = 0;
        this.rd_[12] = this.p_.dotProduct(this.r_);
        this.rd_[13] = this.p_.dotProduct(this.u_);
        this.rd_[14] = -this.p_.dotProduct(this.f_);
        this.rd_[15] = 1;
        var temp:Matrix3D = new Matrix3D();
        temp.rawData = this.rd_;
        this.cameraMatrix_.identity();
        this.cameraMatrix_.append(temp);
    }

    private function onRender(graphicsDatas:Vector.<IGraphicsData>, grahpicsData3d:Vector.<Object3DStage3D>, mapWidth:Number, mapHeight:Number, camera:Camera, filterIndex:uint):void {
        GameClient.STAGE.scaleMode = StageScaleMode.NO_SCALE;
        if (GameClient.STAGE.stageWidth != this.stageWidth || GameClient.STAGE.stageHeight != this.stageHeight) {
            this.resizeStage3DBackBuffer();
        }
        if (Renderer.inGame) {
            this.setTranslationToGame();
        } else {
            this.setTranslationToTitle();
        }
        if (filterIndex > 0) {
            this.renderWithPostEffect(graphicsDatas, grahpicsData3d, mapWidth, mapHeight, camera, filterIndex);
        } else {
            this.renderScene(graphicsDatas, grahpicsData3d, mapWidth, mapHeight, camera);
        }
        this.context3D.present();
    }

    private function resizeStage3DBackBuffer():void {
        if (GameClient.STAGE.stageWidth < 1 || GameClient.STAGE.stageHeight < 1) {
            return;
        }
        var stage3d:Stage3D = GameClient.STAGE.stage3Ds[0];
        this.stageWidth = GameClient.StageWidth;
        this.stageHeight = GameClient.StageHeight;
        stage3d.context3D.configureBackBuffer(GameClient.StageWidth, GameClient.StageHeight, 2, true);
    }

    private function renderWithPostEffect(graphicsDatum:Vector.<IGraphicsData>, graphicsDatum3D:Vector.<Object3DStage3D>, mapWidth:Number, mapHeight:Number, camera:Camera, filterIndex:uint):void {
        this.context3D.GetContext3D().setRenderToTexture(this.sceneTexture_, true);
        this.renderScene(graphicsDatum, graphicsDatum3D, mapWidth, mapHeight, camera);
        this.context3D.GetContext3D().setRenderToBackBuffer();
        switch (filterIndex) {
            case STAGE3D_FILTER_PAUSE:
            case STAGE3D_FILTER_BLIND:
                this.context3D.GetContext3D().setProgram(this.postProcessingProgram_);
                this.context3D.GetContext3D().setTextureAt(0, this.sceneTexture_);
                this.context3D.GetContext3D().clear(0.5, 0.5, 0.5);
                this.context3D.GetContext3D().setVertexBufferAt(0, this.postFilterVertexBuffer_, 0, Context3DVertexBufferFormat.FLOAT_2);
                this.context3D.GetContext3D().setVertexBufferAt(1, null);
                break;
            case STAGE3D_FILTER_DRUNK:
                this.context3D.GetContext3D().setProgram(this.blurPostProcessing_);
                this.context3D.GetContext3D().setTextureAt(0, this.sceneTexture_);
                this.context3D.GetContext3D().clear(0.5, 0.5, 0.5);
                this.context3D.GetContext3D().setVertexBufferAt(0, this.postFilterVertexBuffer_, 0, Context3DVertexBufferFormat.FLOAT_2);
                this.context3D.GetContext3D().setVertexBufferAt(1, this.postFilterVertexBuffer_, 2, Context3DVertexBufferFormat.FLOAT_2);
        }
        this.context3D.GetContext3D().setVertexBufferAt(2, null);
        switch (filterIndex) {
            case STAGE3D_FILTER_PAUSE:
                this.context3D.setProgramConstantsFromVector(Context3DProgramType.VERTEX, 0, POST_FILTER_VERTEX_CONSTANTS);
                this.context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0, GRAYSCALE_FRAGMENT_CONSTANTS);
                break;
            case STAGE3D_FILTER_BLIND:
                this.context3D.setProgramConstantsFromVector(Context3DProgramType.VERTEX, 0, POST_FILTER_VERTEX_CONSTANTS);
                this.context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0, BLIND_FRAGMENT_CONSTANTS);
                break;
            case STAGE3D_FILTER_DRUNK:
                if (this.blurFragmentConstants_[3] <= 0.2 || this.blurFragmentConstants_[3] >= 1.8) {
                    this.blurFactor = this.blurFactor * -1;
                }
                this.blurFragmentConstants_[3] = this.blurFragmentConstants_[3] + this.blurFactor;
                this.context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, new Matrix3D());
                this.context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0, this.blurFragmentConstants_, this.blurFragmentConstants_.length / 4);
        }
        this.context3D.GetContext3D().clear(0, 0, 0, 1);
        this.context3D.GetContext3D().drawTriangles(this.postFilterIndexBuffer_);
    }

    private function renderScene(graphicsDatum:Vector.<IGraphicsData>, graphicsDatum3d:Vector.<Object3DStage3D>, mapWidth:Number, mapHeight:Number, camera:Camera):void {
        var test:GraphicsBitmapFill;
        var graphicsData:IGraphicsData = null;
        this.context3D.clear();
        var finalTransform:Matrix3D = new Matrix3D();
        var index3d:uint = 0;
        this.widthOffset_ = -mapWidth / 2;
        this.heightOffset_ = mapHeight / 2;
        this.UpdateCameraMatrix(camera);
        for each(graphicsData in graphicsDatum) {
            this.context3D.GetContext3D().setCulling(Context3DTriangleFace.NONE);
            if (graphicsData is GraphicsBitmapFill && !GraphicsFillExtra.isSoftwareDraw(GraphicsBitmapFill(graphicsData))) {
                try {
                    test = GraphicsBitmapFill(graphicsData);
                    var a:int = test.bitmapData.width;
                } catch (e:Error) {
                    trace("ERROR CAUGHT -- Invalid Bitmap Data");
                    continue;
                }
                this.graphic3D_.setGraphic(test, this.context3D);
                finalTransform.identity();
                finalTransform.append(this.graphic3D_.getMatrix3D());
                finalTransform.appendScale(1 / Stage3DModule.HALF_WIDTH, 1 / Stage3DModule.HALF_HEIGHT, 1);
                finalTransform.appendTranslation(Renderer.tX / Stage3DModule.WIDTH, Renderer.tY / Stage3DModule.HEIGHT, 0);
                this.context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, finalTransform, true);
                this.graphic3D_.render(this.context3D);
            }
            if (graphicsData is GraphicsGradientFill) {
                this.context3D.GetContext3D().setProgram(this.shadowProgram_);
                this.graphic3D_.setGradientFill(GraphicsGradientFill(graphicsData), this.context3D, Stage3DModule.HALF_WIDTH, Stage3DModule.HALF_HEIGHT);
                finalTransform.identity();
                finalTransform.append(this.graphic3D_.getMatrix3D());
                finalTransform.appendTranslation(Renderer.tX / Stage3DModule.WIDTH, Renderer.tY / Stage3DModule.HEIGHT, 0);
                this.context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, finalTransform, true);
                this.context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 4, Vector.<Number>([0.5, 0.25, 0, 0]));
                this.graphic3D_.renderShadow(this.context3D);
            }
            if (graphicsData == null && graphicsDatum3d.length != 0) {
                try {
                    this.context3D.GetContext3D().setProgram(this.program2);
                    this.context3D.GetContext3D().setCulling(Context3DTriangleFace.BACK);
                    graphicsDatum3d[index3d].UpdateModelMatrix(this.widthOffset_, this.heightOffset_);
                    finalTransform.identity();
                    finalTransform.append(graphicsDatum3d[index3d].GetModelMatrix());
                    finalTransform.append(this.cameraMatrix_);
                    finalTransform.append(this._projection);
                    finalTransform.appendTranslation(Renderer.tX / Stage3DModule.WIDTH, Renderer.tY / Stage3DModule.HEIGHT * 11.5, 0);
                    this.context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 0, finalTransform, true);
                    this.context3D.setProgramConstantsFromMatrix(Context3DProgramType.VERTEX, 8, graphicsDatum3d[index3d].GetModelMatrix(), true);
                    graphicsDatum3d[index3d].draw(this.context3D.GetContext3D());
                    index3d++;
                } catch (e:Error) {
                    trace("ERROR CAUGHT -- Invalid Bitmap Data");
                }
            }
        }
    }

    private function setTranslationToGame():void {
        tX = 0; //-200.0 / Parameters.data_.mScale * (GameClient.StageHeight / 600.0)
        tY = !Parameters.data_.centerOnPlayer ? (Camera.OFFSET_SCREEN_RECT.y + Camera.CENTER_SCREEN_RECT.height * 0.5) * 2 : -50.0 / Parameters.data_.mScale * (GameClient.StageHeight / 600.0);
    }

    private function setTranslationToTitle():void {
        Renderer.tX = Renderer.tY = 0;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/ui/tooltip/EquipmentToolTip.as">
package com.company.assembleegameclient.ui.tooltip {
import com.company.assembleegameclient.constants.InventoryOwnerTypes;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.LineBreakDesign;
import com.company.ui.SimpleText;
import com.company.util.BitmapUtil;
import com.company.util.KeyCodes;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.filters.DropShadowFilter;
import flash.text.StyleSheet;
import flash.utils.Dictionary;

import svera.untiered.itemdata.LinkUtils;
import svera.untiered.itemdata.ProjectileData;

import svera.untiered.constants.ActivationType;
import svera.untiered.itemdata.NewItemData;
import svera.untiered.messaging.impl.data.StatData;

public class EquipmentToolTip extends ToolTip {
    private static const MAX_WIDTH:int = 230;
    private static const CSS_TEXT:String = ".in { margin-left:10px; text-indent: -10px; }";

    private var icon_:Bitmap;
    private var titleText_:SimpleText;
    private var tierText:SimpleText;
    private var descText_:SimpleText;
    private var line1_:LineBreakDesign;
    private var effectsText_:SimpleText;
    private var line2_:LineBreakDesign;
    private var restrictionsText_:SimpleText;
    private var player_:Player;
    private var item:NewItemData;
    private var isEquippable_:Boolean = false;
    private var objectXML_:XML = null;
    private var playerCanUse:Boolean;
    private var restrictions:Vector.<Restriction>;
    private var effects:Vector.<Effect>;
    private var itemSlotTypeId:int;
    private var invType:int;
    private var inventoryOwnerType:String;
    private var inventorySlotID:uint;
    private var isInventoryFull:Boolean;
    private var yOffset:int;
    private var currItem:NewItemData;

    private var uuidText:SimpleText;
    private var dateText:SimpleText;


    public function EquipmentToolTip(itemData:NewItemData, player:Player, invType:int, inventoryOwnerType:String, inventorySlotID:uint = 1.0) {
        this.player_ = player;
        this.item = itemData;
        this.inventoryOwnerType = inventoryOwnerType;
        this.inventorySlotID = inventorySlotID;
        this.isInventoryFull = Boolean(player) ? Boolean(player.isInventoryFull()) : Boolean(false);
        this.playerCanUse = player != null ? Boolean(ObjectLibrary.isUsableByPlayer(itemData.ObjectType, player)) : Boolean(false);
        var backgroundColor:uint = this.playerCanUse || this.player_ == null ? 0x363636 : 6036765;
        var outlineColor:uint = this.playerCanUse || player == null ? 0x9B9B9B : 10965039;
        super(backgroundColor, 1, outlineColor, 1, true);
        this.objectXML_ = ObjectLibrary.xmlLibrary_[itemData.ObjectType];
        var equipSlotIndex:int = Boolean(this.player_) ? int(ObjectLibrary.getMatchingSlotIndex(this.item, this.player_)) : int(-1);
        this.isEquippable_ = equipSlotIndex != -1;
        this.effects = new Vector.<Effect>();
        this.invType = invType;
        this.itemSlotTypeId = item.SlotType;
        var slot:int = player ? ObjectLibrary.getMatchingSlotIndex(item, player) : -1;
        if (player_ == null) {
            this.currItem = item;
        } else if (slot != -1 && player_.equipment_[slot] != null) {
            this.currItem = player_.equipment_[slot];
        }

        this.addIcon();
        this.addTitle();
        this.addTierText();
        this.addDescriptionText();
        //this.addNumProjectilesTagsToEffectsList();
        //this.addProjectileTagsToEffectsList();
        //this.addActivateTagsToEffectsList();
        //this.addActivateOnEquipTagsToEffectsList();
        //this.addCooldownTagToEffectsList();
        //this.addDoseTagsToEffectsList();
        //this.addMpCostTagToEffectsList();
        //this.addHonorBonusTagToEffectsList();
        //this.makeEffectsList();
        this.makeRestrictionList();
        this.makeRestrictionText();
        this.addTestItemDataText();
    }

    private function addTestItemDataText():void {
        this.uuidText = new SimpleText(14, 11776947, false, MAX_WIDTH, 0);
        this.uuidText.wordWrap = true;
        this.uuidText.text = this.item.Uuid;
        this.uuidText.updateMetrics();
        this.uuidText.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.uuidText.x = 4;
        this.uuidText.y = this.yOffset;
        this.yOffset = this.uuidText.y + this.uuidText.height + 8;
        addChild(this.uuidText);

        /*this.dateText = new SimpleText(14, 11776947, false, MAX_WIDTH, 0);
        this.dateText.wordWrap = true;
        this.dateText.text = this.item.CreationTime.toLocaleString();
        this.dateText.updateMetrics();
        this.dateText.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.dateText.x = 4;
        this.dateText.y = this.yOffset;
        this.yOffset = this.dateText.y + this.dateText.height + 8;
        addChild(this.dateText);*/
    }


    private static function BuildRestrictionsHTML(restrictions:Vector.<Restriction>):String {
        var restriction:Restriction = null;
        var line:String = null;
        var html:String = "";
        var first:Boolean = true;
        for each(restriction in restrictions) {
            if (!first) {
                html = html + "\n";
            } else {
                first = false;
            }
            line = "<font color=\"#" + restriction.color_.toString(16) + "\">" + restriction.text_ + "</font>";
            if (restriction.bold_) {
                line = "<b>" + line + "</b>";
            }
            html = html + line;
        }
        return html;
    }

    private function addIcon():void {
        var scaleValue:int = item.Scale;
        var texture:BitmapData = ObjectLibrary.getRedrawnTextureFromType(this.item.ObjectType, 60, true, true, scaleValue);
        texture = BitmapUtil.cropToBitmapData(texture, 4, 4, texture.width - 8, texture.height - 8);
        this.icon_ = new Bitmap(texture);
        addChild(this.icon_);
    }

    private function addTierText():void {
        this.tierText = new SimpleText(16, 16777215, false, 30, 0);
        this.tierText.setBold(true);
        this.tierText.y = this.icon_.height / 2 - this.titleText_.actualHeight_ / 2;
        this.tierText.x = MAX_WIDTH - 30;
        if (!this.objectXML_.hasOwnProperty("Consumable") && !this.isPet()) {
            if (this.objectXML_.hasOwnProperty("Tier")) {
                this.tierText.text = "T" + this.objectXML_.Tier;

            }
            else if (objectXML_.hasOwnProperty("TierType")) {
                switch (objectXML_.TierType) {
                    case "Celestial":
                        tierText.setColor(TooltipHelper.CELESTIAL_COLOR);
                        tierText.text = "CL";
                        break;
                    case "Exiled":
                        tierText.setColor(TooltipHelper.EXILED_COLOR);
                        tierText.text = "EX";
                        break;
                    case "Relic":
                        tierText.setColor(TooltipHelper.RELIC_COLOR);
                        tierText.text = "R";
                        break;
                    case "Valiant":
                        tierText.setColor(TooltipHelper.VALIANT_COLOR);
                        tierText.text = "VL";
                        break;
                    case "Ancestral":
                        tierText.setColor(TooltipHelper.ANCESTRAL_COLOR);
                        tierText.text = "AN";
                        break;
                    case "Artifact":
                        tierText.setColor(TooltipHelper.ARTIFACT_COLOR);
                        tierText.text = "A";
                        break;
                    case "Tarnished":
                        tierText.setColor(TooltipHelper.TARNISHED_COLOR);
                        tierText.text = "T";
                        break;
                    case "Uncommon":
                        tierText.setColor(TooltipHelper.UNCOMMON_COLOR);
                        tierText.text = "UC";
                        break;
                    case "Stat":
                        tierText.setColor(16777215);
                        tierText.text = "S";
                        break;
                    case "Common":
                        tierText.setColor(TooltipHelper.COMMON_COLOR);
                        tierText.text = "C";
                        break;
                }
            }
            else {
                this.tierText.setColor(9055202);
                this.tierText.text = "UT";
            }
            this.tierText.updateMetrics();
            addChild(this.tierText);
        }
    }

    private function isPet():Boolean {
        var activateTags:XMLList = null;
        activateTags = this.objectXML_.Activate.(text() == "PermaPet");
        return activateTags.length() >= 1;
    }

    private function addTitle():void {
        //var prefix:String = ItemData.getPrefix(this.itemData_);
        var color:int = this.playerCanUse || this.player_ == null ? int(16777215) : int(16549442);

        this.titleText_ = new SimpleText(16, color, false, MAX_WIDTH - this.icon_.width - 4 - 30, 0);
        this.titleText_.setBold(true);
        this.titleText_.wordWrap = true;
        this.titleText_.text = ObjectLibrary.typeToDisplayId_[this.item.ObjectType];
        this.titleText_.updateMetrics();
        this.titleText_.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.titleText_.x = this.icon_.width + 4;
        this.titleText_.y = this.icon_.height / 2 - this.titleText_.actualHeight_ / 2;

        addChild(this.titleText_);
    }

    private function buildUniqueTooltipData():String {
        var effectDataList:XMLList = null;
        var uniqueEffectList:Vector.<Effect> = null;
        var effectDataXML:XML = null;
        if (this.objectXML_.hasOwnProperty("ExtraTooltipData")) {
            effectDataList = this.objectXML_.ExtraTooltipData.EffectInfo;
            uniqueEffectList = new Vector.<Effect>();
            for each(effectDataXML in effectDataList) {
                uniqueEffectList.push(new Effect(effectDataXML.attribute("name"), effectDataXML.attribute("description")));
            }
            return this.BuildEffectsHTML(uniqueEffectList) + "\n";
        }
        return "";
    }

    private function makeEffectsList():void {
        this.yOffset = this.descText_.y + this.descText_.height + 8;
        if (this.effects.length != 0 || this.objectXML_.hasOwnProperty("ExtraTooltipData")) {
            this.line1_ = new LineBreakDesign(MAX_WIDTH - 12, 0);
            this.line1_.x = 8;
            this.line1_.y = this.yOffset;
            addChild(this.line1_);
            this.effectsText_ = new SimpleText(14, 11776947, false, MAX_WIDTH - this.icon_.width - 4, 0);
            this.effectsText_.wordWrap = true;
            this.effectsText_.htmlText = this.buildUniqueTooltipData() + this.BuildEffectsHTML(this.effects);
            this.effectsText_.useTextDimensions();
            this.effectsText_.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
            this.effectsText_.x = 4;
            this.effectsText_.y = this.line1_.y + 8;
            addChild(this.effectsText_);
            this.yOffset = this.effectsText_.y + this.effectsText_.height + 8;
        }
    }

    private function addNumProjectilesTagsToEffectsList():void {
        if (item.NumProjectiles) {
            this.effects.push(new Effect("Shots", item.NumProjectiles.toString()));
        }
        if (item.NumProjectiles1) {
            this.effects.push(new Effect("Shots", item.NumProjectiles1.toString()));
        }
        if (item.NumProjectiles2) {
            this.effects.push(new Effect("Shots", item.NumProjectiles2.toString()));
        }
    }

    private function addHonorBonusTagToEffectsList():void {
        if (this.item.HonorBonus == 0) return;

        var color:uint = this.playerCanUse ? TooltipHelper.BETTER_COLOR : TooltipHelper.NO_DIFF_COLOR;
        if (this.currItem != null && this.currItem.HonorBonus != 0) {
            color = TooltipHelper.getTextColor(item.HonorBonus - currItem.HonorBonus);
        }
        this.effects.push(new Effect("Honor Bonus",  this.item.HonorBonus + "%"));

    }

    private function addMpCostTagToEffectsList():void {
        if (this.objectXML_.hasOwnProperty("MpCost")) {
            this.effects.push(new Effect("MP Cost", this.objectXML_.MpCost));
        }
    }

    private function addCooldownTagToEffectsList():void {
        if (this.item.Cooldown != 500) {
            this.effects.push(new Effect("Cooldown: {cd}", this.item.Cooldown / 1000 + " seconds"));
        }
    }

    private function addDoseTagsToEffectsList():void {
        if (item.Doses) {
            this.effects.push(new Effect("Doses", item.Doses.toString()));
        }
    }

    private function addProjectileTagsToEffectsList():void {
        var projXML:XML = null;
        var range:Number = NaN;
        var condEffectXML:XML = null;
        if (this.objectXML_.hasOwnProperty("Projectile")) {
            var proj:ProjectileData = this.item.Projectiles[0];
            var minDmg:int = proj.MinDamage;
            var maxDmg:int = proj.MaxDamage;
            var dmg:int = proj.Damage;
            var dmgString:String = dmg > 0 ? dmg.toString() : minDmg == maxDmg ? minDmg.toString() : minDmg + " - " + maxDmg;
            this.effects.push(new Effect("Damage", dmgString));

            range = Number(projXML.Speed) * Number(projXML.LifetimeMS) / 10000;
            this.effects.push(new Effect("Range", TooltipHelper.getFormattedString(range)));
            if (this.objectXML_.Projectile.hasOwnProperty("MultiHit")) {
                this.effects.push(new Effect("", "Shots hit multiple targets"));
            }
            if (this.objectXML_.Projectile.hasOwnProperty("PassesCover")) {
                this.effects.push(new Effect("", "Shots pass through obstacles"));
            }

            if (this.item.RateOfFire != 1.0) {
                this.effects.push(new Effect("Rate of Fire", Math.round(this.item.RateOfFire * 100) + "%"));
            }

            for each(condEffectXML in projXML.ConditionEffect) {
                this.effects.push(new Effect("Shot Effect", this.objectXML_.Projectile.ConditionEffect + " for " + this.objectXML_.Projectile.ConditionEffect.@duration + " secs"));
            }
        }
    }

    private function addActivateTagsToEffectsList():void {
        var activateXML:XML = null;
        var val:String = null;
        var stat:int = 0;
        var amt:int = 0;
        var activationType:String = null;
        for each(activateXML in this.objectXML_.Activate) {
            activationType = activateXML.toString();
            switch (activationType) {
                case ActivationType.DYE:
                    this.effects.push(new Effect("", "Changes texture of your character"));
                    continue;
                case ActivationType.COND_EFFECT_AURA:
                    this.effects.push(new Effect("Party Effect", "Within " + activateXML.@range + " sqrs"));
                    this.effects.push(new Effect("", activateXML.@effect + " for " + activateXML.@duration + " secs"));
                    continue;
                case ActivationType.COND_EFFECT_SELF:
                    this.effects.push(new Effect("Effect on Self", ""));
                    this.effects.push(new Effect("", activateXML.@effect + " for " + activateXML.@duration + " secs"));
                    continue;
                case ActivationType.HEAL:
                    this.effects.push(new Effect("", "+" + activateXML.@amount + " HP"));
                    continue;
                case ActivationType.HEAL_NOVA:
                    this.effects.push(new Effect("Party Heal", activateXML.@amount + " HP at " + activateXML.@range + " sqrs"));
                    continue;
                case ActivationType.MAGIC:
                    this.effects.push(new Effect("", "+" + activateXML.@amount + " RP"));
                    continue;
                case ActivationType.MAGIC_NOVA:
                    this.effects.push(new Effect("Fill Party Magic", activateXML.@amount + " RP at " + activateXML.@range + " sqrs"));
                    continue;
                case ActivationType.TELEPORT:
                    this.effects.push(new Effect("", "Teleport to Target"));
                    continue;
                case ActivationType.VAMPIRE_BLAST:
                    this.effects.push(new Effect("Steal", activateXML.@totalDamage + " HP within " + activateXML.@radius + " sqrs"));
                    continue;
                case ActivationType.TRAP:
                    this.effects.push(new Effect("Trap", activateXML.@totalDamage + " HP within " + activateXML.@radius + " sqrs"));
                    this.effects.push(new Effect("", activateXML.@effect + " for " + activateXML.@duration + " secs"));
                    continue;
                case ActivationType.STASIS_BLAST:
                    this.effects.push(new Effect("Stasis on Group", activateXML.@duration + " secs"));
                    continue;
                case ActivationType.DECOY:
                    this.effects.push(new Effect("Decoy", activateXML.@duration + " secs"));
                    continue;
                case ActivationType.LIGHTNING:
                    this.effects.push(new Effect("Lightning", ""));
                    this.effects.push(new Effect("", activateXML.@totalDamage + " to " + activateXML.@maxTargets + " targets"));
                    continue;
                case ActivationType.POISON_GRENADE:
                    this.effects.push(new Effect("Poison Grenade", ""));
                    this.effects.push(new Effect("", activateXML.@totalDamage + " HP over " + activateXML.@duration + " secs within " + activateXML.@radius + " sqrs"));
                    continue;
                case ActivationType.REMOVE_NEG_COND:
                    this.effects.push(new Effect("", "Removes negative conditions"));
                    continue;
                case ActivationType.REMOVE_NEG_COND_SELF:
                    this.effects.push(new Effect("", "Removes negative conditions"));
                    continue;
                case ActivationType.BULLET_NOVA:
                    this.effects.push(new Effect("Shots", "20"));
                    continue;
                case ActivationType.SHURIKEN:
                    this.effects.push(new Effect("Shots", activateXML.@amount));
                    this.effects.push(new Effect("", "Stars seek nearby enemies"));
                    this.effects.push(new Effect("", "Dazes nearby enemies"));
                    continue;
                case ActivationType.INCREMENT_STAT:
                    stat = int(activateXML.@stat);
                    amt = int(activateXML.@amount);
                    if (stat != 0 && stat != 1) {
                        val = "Permanently increases " + LinkUtils.statIndexToName(stat);
                    } else {
                        val = "+" + amt + " " + LinkUtils.statIndexToName(stat);
                    }
                    this.effects.push(new Effect("", val));
            }
        }
    }

    private function formatStringForPluralValue(amount:uint, string:String):String {
        if (amount > 1) {
            string = string + "s";
        }
        return string;
    }

    private function addActivateOnEquipTagsToEffectsList():void {
        var activateXML:XML = null;
        var stats:Dictionary = new Dictionary();
        var datas:Dictionary = new Dictionary();
        for each(activateXML in this.objectXML_.ActivateOnEquip) {
            var stat:int = int(activateXML.@stat);
            var amount:int = int(activateXML.@amount);

            if (stats[stat] == null) {
                stats[stat] = 0;
            }
            stats[stat] = stats[stat] + amount;
        }

        if (this.item) {

        }

        var isEmpty:Boolean = true;
        var s:Object;
        for each (s in stats) {
            if (s != null) {
                isEmpty = false;
                break;
            }
        }

        if (!isEmpty) {
            this.effects.push(new Effect("On Equip", ""));

            for (s in stats) {
                var key:int = int(s);
                var value:int = stats[s];
                var data:int = datas[key] == null ? 0 : datas[key];

                this.effects.push(new Effect("", this.addIncrementStatTag(key, value, data)));
            }
        }
    }

    private function addIncrementStatTag(stat:int, amount:int, data:int):String {
        var amountString:String = null;
        var dataString:String = null;
        var textColor:String = TooltipHelper.DEFAULT_COLOR;
        if (amount > -1) {
            amountString = String("+" + amount);
        } else {
            amountString = String(amount);
            textColor = "#ff0000";
        }

        if (data > 0) {
            dataString = " (+" + data + ")";
        } else {
            dataString = "";
        }

        return TooltipHelper.wrapInFontTag(amountString + dataString + " " + LinkUtils.statIndexToName(stat), textColor);
    }

    private function addEquipmentItemRestrictions():void {
        this.restrictions.push(new Restriction("Must be equipped to use", 11776947, false));
        if (this.isInventoryFull || this.inventoryOwnerType == InventoryOwnerTypes.CURRENT_PLAYER) {
            this.restrictions.push(new Restriction("Double-Click to equip", 11776947, false));
        } else {
            this.restrictions.push(new Restriction("Double-Click to take", 11776947, false));
        }
    }

    private function addAbilityItemRestrictions():void {
        this.restrictions.push(new Restriction("Press [" + KeyCodes.CharCodeStrings[Parameters.data_.ability1] + "] in world to use", 16777215, false));
        this.restrictions.push(new Restriction("Press [" + KeyCodes.CharCodeStrings[Parameters.data_.ability2] + "] in world to use", 16777215, false));
        this.restrictions.push(new Restriction("Press [" + KeyCodes.CharCodeStrings[Parameters.data_.ability3] + "] in world to use", 16777215, false));
    }

    private function addConsumableItemRestrictions():void {
        this.restrictions.push(new Restriction("Consumed with use", 11776947, false));
        if (this.isInventoryFull || this.inventoryOwnerType == InventoryOwnerTypes.CURRENT_PLAYER) {
            this.restrictions.push(new Restriction("Double-Click or Shift-Click on item to use", 16777215, false));
        } else {
            this.restrictions.push(new Restriction("Double-Click to take & Shift-Click to use", 16777215, false));
        }
    }

    private function addReusableItemRestrictions():void {
        this.restrictions.push(new Restriction("Can be used multiple times", 11776947, false));
        this.restrictions.push(new Restriction("Double-Click or Shift-Click on item to use", 16777215, false));
    }

    private function makeRestrictionList():void {
        var reqXML:XML = null;
        var reqMet:Boolean = false;
        var stat:int = 0;
        var value:int = 0;
        this.restrictions = new Vector.<Restriction>();
        if (this.item.Soulbound) {
            this.restrictions.push(new Restriction("Soulbound", 9055202, false));
        }
        if (this.playerCanUse) {
            if (this.item.Usable) {
                this.addAbilityItemRestrictions();
                this.addEquipmentItemRestrictions();
            } else if (this.item.Consumable) {
                this.addConsumableItemRestrictions();
            } else if (this.item.InvUse) {
                this.addReusableItemRestrictions();
            } else {
                this.addEquipmentItemRestrictions();
            }
        } else if (this.player_ != null) {
            this.restrictions.push(new Restriction("Not usable by " + ObjectLibrary.typeToDisplayId_[this.player_.objectType_], 16549442, true));
        }
        var usable:Vector.<String> = ObjectLibrary.usableBy(this.item.ObjectType);
        if (usable != null) {
            this.restrictions.push(new Restriction("Usable by: " + usable.join(", "), 11776947, false));
        }
        for each(reqXML in this.objectXML_.EquipRequirement) {
            reqMet = ObjectLibrary.playerMeetsRequirement(reqXML, this.player_);
            if (reqXML.toString() == "Stat") {
                stat = int(reqXML.@stat);
                value = int(reqXML.@value);
                this.restrictions.push(new Restriction("Requires " + LinkUtils.statIndexToName(stat) + " of " + value, reqMet ? 11776947 : 16549442, reqMet ? Boolean(false) : Boolean(true)));
            }
        }
    }

    private function makeRestrictionText():void {
        var sheet:StyleSheet = null;
        if (this.restrictions.length != 0) {
            this.line2_ = new LineBreakDesign(MAX_WIDTH - 12, 0);
            this.line2_.x = 8;
            this.line2_.y = this.yOffset;
            addChild(this.line2_);
            sheet = new StyleSheet();
            sheet.parseCSS(CSS_TEXT);
            this.restrictionsText_ = new SimpleText(14, 11776947, false, MAX_WIDTH - 4, 0);
            this.restrictionsText_.styleSheet = sheet;
            this.restrictionsText_.wordWrap = true;
            this.restrictionsText_.htmlText = "<span class=\'in\'>" + BuildRestrictionsHTML(this.restrictions) + "</span>";
            this.restrictionsText_.useTextDimensions();
            this.restrictionsText_.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
            this.restrictionsText_.x = 4;
            this.restrictionsText_.y = this.line2_.y + 8;
            addChild(this.restrictionsText_);
        }
    }

    private function addDescriptionText():void {
        this.descText_ = new SimpleText(14, 11776947, false, MAX_WIDTH, 0);
        this.descText_.wordWrap = true;
        this.descText_.text = this.item.Description;
        this.descText_.updateMetrics();
        this.descText_.filters = [new DropShadowFilter(0, 0, 0, 0.5, 12, 12)];
        this.descText_.x = 4;
        this.descText_.y = this.icon_.height + 2;
        this.yOffset = this.descText_.y + this.descText_.height + 8;
        addChild(this.descText_);
    }

    private function BuildEffectsHTML(effects:Vector.<Effect>):String {
        var effect:Effect = null;
        var textColor:String = null;
        var html:String = "";
        var first:Boolean = true;
        for each(effect in effects) {
            textColor = "#FFFF8F";
            if (!first) {
                html = html + "\n";
            } else {
                first = false;
            }
            if (effect.name_ != "") {
                html = html + (effect.name_ + ": ");
            }
            html = html + ("<font color=\"" + textColor + "\">" + effect.value_ + "</font>");
        }
        return html;
    }
}
}

class Effect {


    public var name_:String;

    public var value_:String;

    function Effect(name:String, value:String) {
        super();
        this.name_ = name;
        this.value_ = value;
    }

}

class Restriction {


    public var text_:String;

    public var color_:uint;

    public var bold_:Boolean;

    function Restriction(text:String, color:uint, bold:Boolean) {
        super();
        this.text_ = text;
        this.color_ = color;
        this.bold_ = bold;
    }
}
</file>

<file path="src/com/company/assembleegameclient/ui/panels/itemgrids/itemtiles/EquipmentTile.as">
package com.company.assembleegameclient.ui.panels.itemgrids.itemtiles {
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.panels.itemgrids.ItemGrid;
import com.company.util.AssetLibrary;
import com.company.util.MoreColorUtil;

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.filters.ColorMatrixFilter;

import svera.untiered.itemdata.Item;

import svera.untiered.constants.ItemConstants;
import svera.untiered.itemdata.NewItemData;

public class EquipmentTile extends InteractiveItemTile {

    private static const greyColorFilter:ColorMatrixFilter = new ColorMatrixFilter(MoreColorUtil.singleColorFilterMatrix(0x2d234a));


    public var backgroundDetail:Bitmap;

    public var itemType:int;

    private var minResourceUsage:int;

    public function EquipmentTile(id:int, parentGrid:ItemGrid, isInteractive:Boolean) {
        super(id, parentGrid, isInteractive);
    }

    override public function canHoldItem(itemData:NewItemData):Boolean {
        return itemData == null || this.itemType == ObjectLibrary.getSlotTypeFromItemData(itemData);
    }

    public function setType(itemType_:int):void {
        var bd:BitmapData = null;
        var dx:int = 0;
        var dy:int = 0;
        switch (itemType_) {
            case ItemConstants.ALL_TYPE:
                break;
            case ItemConstants.SWORD_AXE_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x42);
                break;
            case ItemConstants.DAGGER_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x04);
                break;
            case ItemConstants.BOW_CROSSBOW_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x91);
                break;
            case ItemConstants.MACE_LANCE_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x05);
                break;
            case ItemConstants.SHIELD_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x19);
                break;
            case ItemConstants.LEATHER_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0xae);
                break;
            case ItemConstants.PLATE_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0xaf);
                break;
            case ItemConstants.STAFF_WAND_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x61);
                break;
            case ItemConstants.RING_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x9f);
                break;
            case ItemConstants.SPELL_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x28);
                break;
            case ItemConstants.SEAL_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x1b);
                break;
            case ItemConstants.CLOAK_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x0a);
                break;
            case ItemConstants.ROBE_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0xad);
                break;
            case ItemConstants.GUN_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x90);
                break;
            case ItemConstants.HELM_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x18);
                break;
            case ItemConstants.CLAWS_GAUNTLET_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0);
                break;
            case ItemConstants.POISON_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x0c);
                break;
            case ItemConstants.SKULL_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x2a);
                break;
            case ItemConstants.TRAP_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x39);
                break;
            case ItemConstants.DUAL_WIELD_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 2);
                break;
            case ItemConstants.PRISM_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x0b);
                break;
            case ItemConstants.SCEPTER_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x3c);
                break;
            case ItemConstants.KATANA_SCYTHE_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x06);
                break;
            case ItemConstants.CHAKRAM_TYPE:
                bd = AssetLibrary.getImageFromSet("StarterGear", 0x1d);
                break;
        }
        if (bd != null) {
            this.backgroundDetail = new Bitmap(bd);
            this.backgroundDetail.x = BORDER;
            this.backgroundDetail.y = BORDER;
            this.backgroundDetail.scaleX = 4;
            this.backgroundDetail.scaleY = 4;
            this.backgroundDetail.filters = [greyColorFilter];
            addChildAt(this.backgroundDetail, 0);
        }
        this.itemType = itemType_;
    }

    override public function setItem(itemId:NewItemData):Boolean {
        var itemChanged:Boolean = super.setItem(itemId);
        if (itemChanged) {
            backgroundDetail && (backgroundDetail.visible = itemSprite.itemData == null);
            this.updateMinMana();
        }
        return itemChanged;
    }

    private function updateMinMana():void {
        if (itemSprite.itemData == null) {
            minResourceUsage = 0;
            return;
        }

        var item:NewItemData = itemSprite.itemData;
        if (item.Usable && !item.MultiPhase)
            minResourceUsage = item.MpCost;
        else if (item.Usable && item.MultiPhase)
            minResourceUsage = -1;//TODO[ITEMDATA]: phase cost
        else
            minResourceUsage = 0;
    }

    public function updateDim(player:Player):void {
        itemSprite.setDim(player && player.rp_ < this.minResourceUsage);
    }

    override protected function beginDragCallback():void {
        this.backgroundDetail.visible = true;
    }

    override protected function endDragCallback():void {
        this.backgroundDetail.visible = itemSprite.itemData == null;
    }

    override protected function getBackgroundColor():int {
        return 0x131126;
    }
}
}
</file>

<file path="src/com/company/assembleegameclient/game/GameSprite.as">
package com.company.assembleegameclient.game {
import com.company.assembleegameclient.map.Camera;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.IInteractiveObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.ui.GuildText;
import com.company.assembleegameclient.ui.RankText;
import com.company.assembleegameclient.ui.TextBox;
import com.company.assembleegameclient.util.TextureRedrawer;
import com.company.util.CachingColorTransformer;
import com.company.util.PointUtil;

import flash.display.Sprite;
import flash.events.Event;
import flash.external.ExternalInterface;
import flash.utils.getTimer;

import org.osflash.signals.Signal;

import svera.lib.loopedprocs.LoopedCallback;
import svera.lib.loopedprocs.LoopedProcess;
import svera.untiered.constants.GeneralConstants;
import svera.untiered.core.model.MapModel;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.game.view.CurrencyDisplay;
import svera.untiered.messaging.impl.GameServerConnection;
import svera.untiered.messaging.impl.incoming.MapInfo;
import svera.untiered.stage3D.Renderer;
import svera.untiered.ui.UIUtils;
import svera.untiered.ui.view.HUDView;

public class GameSprite extends Sprite {
    public const closed:Signal = new Signal();
    public const modelInitialized:Signal = new Signal();
    public const drawCharacterWindow:Signal = new Signal(Player);
    public var map:Map;
    public var camera_:Camera;
    public var gsc_:GameServerConnection;
    public var mui_:MapUserInput;
    public var textBox_:TextBox;
    public var isNexus_:Boolean = false;
    public var hudView:HUDView;
    public var rankText_:RankText;
    public var guildText_:GuildText;
    public var currencyDisplay_:CurrencyDisplay;
    public var isEditor:Boolean;
    public var lastUpdate_:int = 0;
    public var firstUpdate:Boolean = true;
    public var mapModel:MapModel;
    public var model:PlayerModel;
    private var focus:GameObject;
    private var isGameStarted:Boolean;
    private var displaysPosY:uint = 4;



    public function GameSprite(gameId:int, createCharacter:Boolean, charId:int, model:PlayerModel, mapJSON:String, traits:Array) {
        this.camera_ = new Camera();
        super();
        this.model = model;
        this.map = new Map(this);
        addChild(this.map);
        this.gsc_ = new GameServerConnection(this, gameId, createCharacter, charId, mapJSON, traits);
        this.mui_ = new MapUserInput(this);
        this.textBox_ = new TextBox(this, 600, 600);
        addChild(this.textBox_);
    }

    public function setFocus(focus:GameObject):void {
        this.focus = focus || this.map.player_;
    }

    public function applyMapInfo(mapInfo:MapInfo):void {
        this.map.setProps(mapInfo.width_, mapInfo.height_, mapInfo.name_, mapInfo.background_, mapInfo.allowPlayerTeleport_, mapInfo.showDisplays_);
    }

    public function hudModelInitialized():void {
        this.hudView = new HUDView();
        addChild(this.hudView);
    }

    public function initialize():void {
        this.map.initialize();
        this.currencyDisplay_ = new CurrencyDisplay(this);
        this.currencyDisplay_.x = 0;
        this.currencyDisplay_.y = 50;
        addChild(this.currencyDisplay_);
        this.modelInitialized.dispatch();

        if (this.map.showDisplays_) {
            this.showSafeAreaDisplays();
        }
        GameClient.STAGE.dispatchEvent(new Event(Event.RESIZE));
        if (this.map.name_ == "Nexus") {
            isNexus_ = true;
        }
    }

    public function onScreenResize(_arg_1:Event):void {
        var uiscale:Boolean = true;//Parameters.data_.uiscale;
        var sWidth:Number = 1;
        var sHeight:Number = 1;
        var result:Number = sWidth / sHeight;
        if (this.map != null && !Parameters.data_.GPURender) {
/*            this.map.scaleX = sWidth * Parameters.data_.mScale;
            this.map.scaleY = sHeight * Parameters.data_.mScale;*/
        }
        /*         if (this.scaledLayer != null) {
                    if (uiscale) {
                       this.scaledLayer.scaleX = result;
                       this.scaledLayer.scaleY = 1;
                    } else {
                       this.scaledLayer.scaleX = sWidth;
                       this.scaledLayer.scaleY = sHeight;
                    }
                    this.scaledLayer.x = 400 - ((800 * this.scaledLayer.scaleX) / 2);
                    this.scaledLayer.y = 300 - ((600 * this.scaledLayer.scaleY) / 2);
                 }
                 if (this.forceScaledLayer != null) {
                    this.forceScaledLayer.scaleX = result;
                    this.forceScaledLayer.scaleY = 1;
                 }
                 if (this.bossHealthBar != null)
                 {
                    if (uiscale)
                    {
                       this.bossHealthBar.scaleX = result;
                       this.bossHealthBar.scaleY = 1;
                    }
                    else
                    {
                       this.bossHealthBar.scaleX = sWidth;
                       this.bossHealthBar.scaleY = sHeight;
                    }
                 }*/
        if (this.hudView != null) {
            /*            if (!Parameters.data_.hudscale) {
                           this.hudView.scaleX = result;
                           this.hudView.scaleY = 1;
                           this.hudView.y = 0;
                        } else {*/
            this.hudView.scaleX = sWidth;
            this.hudView.scaleY = sHeight;
            //this.hudView.y = (300 * (1 - sHeight));
            //}
            //this.hudView.x = (800 - (200 * this.hudView.scaleX));
            if (this.currencyDisplay_ != null) {
                this.currencyDisplay_.x = currencyDisplay_.width + 8;
                currencyDisplay_.y = 25;
            }
        }
        if (this.textBox_ != null) {
            if (uiscale) {
                this.textBox_.scaleX = result;
                this.textBox_.scaleY = 1;
                this.textBox_.y = 0;
            } else {
                this.textBox_.scaleX = sWidth;
                this.textBox_.scaleY = sHeight;
                this.textBox_.y = 600 * (1 - sHeight);
            }
            //trace("resize",chatBox_.y,chatBox_.list.y)
        }
        if (this.rankText_ != null) {
            if (uiscale) {
                this.rankText_.scaleX = result;
                this.rankText_.scaleY = 1;
            } else {
                this.rankText_.scaleX = sWidth;
                this.rankText_.scaleY = sHeight;
            }
            this.rankText_.x = 8 * this.rankText_.scaleX;
            this.rankText_.y = 2 * this.rankText_.scaleY;
        }
        if (this.guildText_ != null) {
            if (uiscale) {
                this.guildText_.scaleX = result;
                this.guildText_.scaleY = 1;
            } else {
                this.guildText_.scaleX = sWidth;
                this.guildText_.scaleY = sHeight;
            }
            this.guildText_.x = 64 * this.guildText_.scaleX;
            this.guildText_.y = 2 * this.guildText_.scaleY;
        }
        if (this.currencyDisplay_ != null) {
            if (uiscale) {
                this.currencyDisplay_.scaleX = result;
                this.currencyDisplay_.scaleY = 1;
            } else {
                this.currencyDisplay_.scaleX = sWidth;
                this.currencyDisplay_.scaleY = sHeight;
            }
        }
    }

    private function showSafeAreaDisplays():void {
        this.showRankText();
        this.showGuildText();
    }

    private function showGuildText():void {
        this.guildText_ = new GuildText("", -1);
        this.guildText_.x = 64;
        this.guildText_.y = 6;
        addChild(this.guildText_);
    }

    private function showRankText():void {
        this.rankText_ = new RankText(-1, true, false);
        this.rankText_.x = 8;
        this.rankText_.y = this.displaysPosY;
        this.displaysPosY = this.displaysPosY + UIUtils.NOTIFICATION_SPACE;
        addChild(this.rankText_);
    }

    private function callTracking(functionName:String):void {
        if (ExternalInterface.available == false) {
            return;
        }
        try {
            ExternalInterface.call(functionName);
        } catch (err:Error) {
        }
    }

    private function updateNearestInteractive():void {
        var dist:Number = NaN;
        var go:GameObject = null;
        var iObj:IInteractiveObject = null;
        if (!this.map || !this.map.player_) {
            return;
        }
        var player:Player = this.map.player_;
        var minDist:Number = GeneralConstants.MAXIMUM_INTERACTION_DISTANCE;
        var closestInteractive:IInteractiveObject = null;
        var playerX:Number = player.x_;
        var playerY:Number = player.y_;
        for each(go in this.map.goDict_) {
            iObj = go as IInteractiveObject;
            if (iObj) {
                if (Math.abs(playerX - go.x_) < GeneralConstants.MAXIMUM_INTERACTION_DISTANCE || Math.abs(playerY - go.y_) < GeneralConstants.MAXIMUM_INTERACTION_DISTANCE) {
                    dist = PointUtil.distanceXY(go.x_, go.y_, playerX, playerY);
                    if (dist < GeneralConstants.MAXIMUM_INTERACTION_DISTANCE && dist < minDist) {
                        minDist = dist;
                        closestInteractive = iObj;
                    }
                }
            }
        }
        this.mapModel.currentInteractiveTarget = closestInteractive;
    }

    public function connect():void {
        if (!this.isGameStarted) {
            this.isGameStarted = true;
            Renderer.inGame = true;
            this.gsc_.connect();
            this.lastUpdate_ = getTimer();
            stage.addEventListener(Event.ENTER_FRAME, this.onEnterFrame);
            GameClient.STAGE.addEventListener(Event.RESIZE, onScreenResize);
            LoopedProcess.addProcess(new LoopedCallback(100, this.updateNearestInteractive));
        }
    }

    public function disconnect():void {
        if (this.isGameStarted) {
            this.isGameStarted = false;
            Renderer.inGame = false;
            this.gsc_.serverConnection.disconnect();
            stage.removeEventListener(Event.ENTER_FRAME, this.onEnterFrame);
            GameClient.STAGE.removeEventListener(Event.RESIZE, onScreenResize);
            LoopedProcess.destroyAll();
            contains(this.map) && removeChild(this.map);
            this.map.dispose();
            CachingColorTransformer.clear();
            TextureRedrawer.clearCache();
            this.gsc_.disconnect();
        }
    }

    private function onEnterFrame(event:Event):void {
        var time:int = getTimer();
        var player:Player = this.map.player_;
        if (player != null) {
            var dt:int = time - this.lastUpdate_;
            LoopedProcess.runProcesses(time);
            this.map.update(time, dt);
            this.camera_.update(dt);

            if (this.focus) {
                this.camera_.configureCamera(this.focus, player.isHallucinating());
                this.map.draw(this.camera_, time);
            }

            this.currencyDisplay_.draw(model.getTsavorite(), model.getMedallions(), model.getHonor());
            this.drawCharacterWindow.dispatch(player);
            if (this.map.showDisplays_) {
                this.rankText_.draw(player.numStars_);
                this.guildText_.draw(player.guildName_, player.guildRank_);
            }
        }
        this.lastUpdate_ = time;
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/data/StatData.as">
package svera.untiered.messaging.impl.data {
import flash.utils.ByteArray;
import flash.utils.IDataInput;
import flash.utils.IDataOutput;

public class StatData {
    public static const SIZE:int = 0;
    public static const MAXHP:int = 1;
    public static const HP:int = 2;
    public static const MAXSP:int = 3;
    public static const SP:int = 4;
    public static const MAXRP:int = 5;
    public static const RP:int = 6;
    public static const NEXTLEVELEXP:int = 7;
    public static const EXP:int = 8;
    public static const LEVEL:int = 9;
    public static const AWAKENING:int = 10;
    public static const RELIC:int = 11;
    public static const BACKGROUND:int = 12;
    public static const STATPOINTS:int = 13;
    public static const ASCENSIONPOINTS:int = 14;
    public static const INVENTORY:int = 15;
    public static const ATTACK:int = 16;
    public static const ARMOR:int = 17;
    public static const SPEED:int = 18;
    public static const VIGOR:int = 19;
    public static const INTELLECT:int = 20;
    public static const DEXTERITY:int = 21;
    public static const OVERSHIELDMAX:int = 22;
    public static const OVERSHIELDDELAY:int = 23;
    public static const OVERSHIELDRECHARGERATE:int = 24;
    public static const MAXSTAMINA:int = 25;
    public static const MAXRAGE:int = 26;
    public static const MAXFURY:int = 27;
    public static const RESILIENCE:int = 28;
    public static const PHYSICALRESIST:int = 29;
    public static const MAGICRESIST:int = 30;
    public static const ELEMENTALRESIST:int = 31;
    public static const FIRERESIST:int = 32;
    public static const WATERRESIST:int = 33;
    public static const WINDRESIST:int = 34;
    public static const ELECTRICRESIST:int = 35;
    public static const EARTHRESIST:int = 36;
    public static const ICERESIST:int = 37;
    public static const VOIDRESIST:int = 38;
    public static const LIGHTRESIST:int = 39;
    public static const BLASTRESIST:int = 40;
    public static const STRENGTH:int = 41;
    public static const PHYSICALDMG:int = 42;
    public static const MAGICALDMG:int = 43;
    public static const FIREDMG:int = 44;
    public static const WATERDMG:int = 45;
    public static const WINDDMG:int = 46;
    public static const ELECTRICDMG:int = 47;
    public static const EARTHDMG:int = 48;
    public static const ICEDMG:int = 49;
    public static const VOIDDMG:int = 50;
    public static const LIGHTDMG:int = 51;
    public static const BLASTDMG:int = 52;
    public static const ABILITYPWR:int = 53;
    public static const CRITICALCHANCE:int = 54;
    public static const CRITICALDAMAGE:int = 55;
    public static const ABILITYCRITCHANCE:int = 56;
    public static const ABILITYCRITDAMAGE:int = 57;
    public static const TENACITY:int = 58;
    public static const ABILITYCOOLDOWN:int = 59;
    public static const DOWNDURATION:int = 60;
    public static const POWER:int = 61;
    public static const DASHCOOLDOWN:int = 62;
    public static const DASHWINDOW:int = 63;
    public static const CONDITION:int = 64;
    public static const NUMSTARS:int = 65;
    public static const NAME:int = 66;
    public static const TEX1:int = 67;
    public static const TEX2:int = 68;
    public static const MERCHANDISETYPE:int = 69;
    public static const MERCHANDISEPRICE:int = 70;
    public static const TSAVORITE:int = 71;
    public static const MEDALLIONS:int = 72;
    public static const HONOR:int = 73;
    public static const ACTIVE:int = 74;
    public static const ACCOUNTID:int = 75;
    public static const MERCHANDISECURRENCY:int = 76;
    public static const CONNECT:int = 77;
    public static const MERCHANDISECOUNT:int = 78;
    public static const MERCHANDISEMINSLEFT:int = 79;
    public static const MERCHANDISEDISCOUNT:int = 80;
    public static const MERCHANDISERANKREQ:int = 81;
    public static const MAXHPBOOST:int = 82;
    public static const MAXSPBOOST:int = 83;
    public static const MAXRPBOOST:int = 84;
    public static const ATTACKBOOST:int = 85;
    public static const ARMORBOOST:int = 86;
    public static const SPEEDBOOST:int = 87;
    public static const VIGORBOOST:int = 88;
    public static const INTELLECTBOOST:int = 89;
    public static const DEXTERITYBOOST:int = 90;
    public static const CHARHONOR:int = 91;
    public static const NEXTCLASSQUESTHONOR:int = 92;
    public static const LEGENDARYRANK:int = 93;
    public static const SINKLEVEL:int = 94;
    public static const ALTTEXTURE:int = 95;
    public static const GUILDNAME:int = 96;
    public static const GUILDRANK:int = 97;
    public static const BREATH:int = 98;
    public static const HEALTHPOTIONSTACK:int = 99;
    public static const MAGICPOTIONSTACK:int = 100;
    public static const TEXTURE:int = 101;
    public static const OWNERACCOUNTID:int = 102;
    public static const PETID:int = 103;
    public static const PETSKIN:int = 104;
    public static const PETTYPE:int = 105;
    public static const PETRARITY:int = 106;
    public static const PETMAXLEVEL:int = 107;
    public static const PETUNK1:int = 108;
    public static const PETABILITYPOWER1:int = 109;
    public static const PETABILITYPOWER2:int = 110;
    public static const PETABILITYPOWER3:int = 111;
    public static const PETABILITYLEVEL1:int = 112;
    public static const PETABILITYLEVEL2:int = 113;
    public static const PETABILITYLEVEL3:int = 114;
    public static const PETABILITYTYPE1:int = 115;
    public static const PETABILITYTYPE2:int = 116;
    public static const PETABILITYTYPE3:int = 117;
    public static const EFFECTS2:int = 118;
    public static const TOKENS:int = 119;
    public static const DAMAGEMIN:int = 120;
    public static const DAMAGEMAX:int = 121;
    public static const DAMAGEMINBONUS:int = 122;
    public static const DAMAGEMAXBONUS:int = 123;
    public static const FORTUNEBONUS:int = 124;
    public static const RANK:int = 125;
    public static const ADMIN:int = 126;
    public static const FORTUNE:int = 127;
    public static const RAIDTOKEN:int = 128;
    public static const SURGE:int = 129;
    public static const EVASION:int = 130;
    public static const MIGHT:int = 131;
    public static const MIGHTBONUS:int = 132;
    public static const LUCK:int = 133;
    public static const LUCKBONUS:int = 134;
    public static const RESTORATION:int = 135;
    public static const PROTECTION:int = 136;
    public static const RESTORATIONBONUS:int = 137;
    public static const PROTECTIONBONUS:int = 138;
    public static const PROTECTIONPOINTS:int = 139;
    public static const PROTECTIONPOINTSMAX:int = 140;
    public static const EFFECT:int = 141;
    public static const MARKSENABLED:int = 142;
    public static const MARK:int = 143;
    public static const NODE1:int = 144;
    public static const NODE2:int = 145;
    public static const NODE3:int = 146;
    public static const NODE4:int = 147;
    public static const ASCENSIONENABLED:int = 148;
    public static const RAGEBAR:int = 149;
    public static const RESTORALESSENCEFRAGMENTS:int = 150;
    public static const CHANCEDENOM:int = 151;
    public static const SEASONALEXPERIENCEGOAL:int = 152;
    public static const SEASONALEXPERIENCE:int = 153;
    public static const SEASONALTIER:int = 154;
    public static const SEASONALPREMIUM:int = 155;
    public static const PARTYID:int = 156;
    public static const PARTYRANK:int = 157;
    public static const PARTYSUMMONER:int = 158;
    public static const COSMETICPETTYPE:int = 159;
    public static const HASCOSMETICPET:int = 160;
    public static const FIREFRAGMENTS:int = 161;
    public static const WATERFRAGMENTS:int = 162;
    public static const AIRFRAGMENTS:int = 163;
    public static const ELECTRICFRAGMENTS:int = 164;
    public static const EARTHFRAGMENTS:int = 165;
    public static const ICEFRAGMENTS:int = 166;
    public static const VOIDFRAGMENTS:int = 167;
    public static const LIGHTFRAGMENTS:int = 168;
    public static const APOTIONS:int = 169;
    public static const DPOTIONS:int = 170;
    public static const SPOTIONS:int = 171;
    public static const DEPOTIONS:int = 172;
    public static const VPOTIONS:int = 173;
    public static const WPOTIONS:int = 174;
    public static const LPOTIONS:int = 175;
    public static const MPOTIONS:int = 176;
    public static const RPOTIONS:int = 177;
    public static const LUPOTIONS:int = 178;
    public static const MIPOTIONS:int = 179;
    public static const PPOTIONS:int = 180;
    public static const FIREASPECT:int = 181;
    public static const WATERASPECT:int = 182;
    public static const AIRASPECT:int = 183;
    public static const ELECTRICASPECT:int = 184;
    public static const EARTHASPECT:int = 185;
    public static const ICEASPECT:int = 186;
    public static const VOIDASPECT:int = 187;
    public static const LIGHTASPECT:int = 188;
    public static const EVASIONBONUS:int = 189;
    public static const LEGENDARYLOOTBOX:int = 190;
    public static const EVENTLOOTBOX:int = 191;
    public static const GOLDLOOTBOX:int = 192;
    public static const ELITELOOTBOX:int = 193;
    public static const PREMIUMLOOTBOX:int = 194;
    public static const EFFECTS3:int = 195;
    public static const MININGTIER:int = 196;
    public static const LUMBERTIER:int = 197;
    public static const FORAGETIER:int = 198;
    public static const GLOW:int = 199;


    public var statType_:uint = 0;

    public var statValue_:int;

    public var slotValue:int;

    public var strStatValue_:String;

    public var uintStatValue:uint;
    public var statByteArray:ByteArray;


    public function StatData() {
        super();
    }

    public static function statToName(stat:int):String {
        switch (stat) {
            case 0:
                return "Maximum HP";
            case 1:
                return "Maximum SP";
            case 2:
                return "Maximum RP";
            case 3:
                return "Attack";
            case 4:
                return "Armor";
            case 5:
                return "Speed";
            case 6:
                return "Dexterity";
            case 7:
                return "Vigor";
            case 8:
                return "Intelligence";
            default:
                return "Unknown Stat";
        }
    }

    public function isStringStat():Boolean {
        switch (this.statType_) {
            case NAME:
            case GUILDNAME:
            case EFFECT:
                return true;
            default:
                return false;
        }
    }

    public function parseFromInput(data:IDataInput):void {
        this.statType_ = data.readUnsignedByte();

        switch (statType_) {
            case NAME:
            case GUILDNAME:
            case EFFECT:
                this.strStatValue_ = data.readUTF();
                break;
            case INVENTORY:
                this.slotValue = data.readInt();
                statByteArray = new ByteArray();

                var len:int = data.readInt();
                statByteArray.length = len;
                data.readBytes(statByteArray, 0, len);
                statByteArray.endian = "littleEndian";
                statByteArray.position = 0;
                break;
            default:
                this.statValue_ = data.readInt();
                break;
        }
    }

    public function toString():String {
        if (this.isStringStat()) {
            return "[" + this.statType_ + ": \"" + this.strStatValue_ + "\"]";
        }
        return "[" + this.statType_ + ": " + this.statValue_ + "]";
    }
}
}
</file>

<file path="src/svera/untiered/ui/view/HUDView.as">
package svera.untiered.ui.view {
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.ui.TradePanel;
import com.company.assembleegameclient.ui.panels.InteractPanel;
import com.company.assembleegameclient.ui.panels.itemgrids.BindGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.EquippedGrid;
import com.company.assembleegameclient.ui.panels.itemgrids.InventoryGrid;
import com.company.util.SpriteUtil;

import flash.display.Sprite;
import flash.events.Event;
import flash.geom.Point;

import svera.untiered.game.view.LootboxModalButton;
import svera.untiered.game.view.RaidLauncherButton;
import svera.untiered.game.view.components.StatsView;
import svera.untiered.hud.HUD_Overlay;
import svera.untiered.messaging.impl.incoming.TradeAccepted;
import svera.untiered.messaging.impl.incoming.TradeChanged;
import svera.untiered.messaging.impl.incoming.TradeStart;
import svera.untiered.minimap.view.MiniMap;
import svera.untiered.ui.UIUtils;

public class HUDView extends Sprite {
    private const MAP_POSITION:Point = new Point(204, 4);

    private const INTERACT_PANEL_POSITION:Point = new Point(0, 500);

    private var hudOverlay:HUD_Overlay;

    private var miniMap:MiniMap;

    public var bindGrid:BindGrid;

    public var equippedGrid:EquippedGrid;

    public var inventoryGrid:InventoryGrid;

    private var statMeters:StatMetersView;

    public var statsView:StatsView;

    private var characterDetails:CharacterDetailsView;

    public var interactPanel:InteractPanel;

    public var tradePanel:TradePanel;

    public static var instance:HUDView;
    public var raidLauncherButton:RaidLauncherButton;
    private var displaysPosY:uint = 4;

    public var lootBoxButton:LootboxModalButton;

    public function HUDView() {
        super();
        instance = this;
        this.createAssets();
        this.addAssets();
        GameClient.STAGE.addEventListener(Event.RESIZE, positionAssets);
        this.positionAssets();
    }

    private function createAssets():void {
        this.hudOverlay = new HUD_Overlay();
        this.miniMap = new MiniMap(192, 192);
        this.characterDetails = new CharacterDetailsView();
        this.statMeters = new StatMetersView();
    }

    private function addAssets():void {
        addChild(this.hudOverlay);
        addChild(this.miniMap);
        addChild(this.characterDetails);
        addChild(this.statMeters);
    }

    private function positionAssets(e:Event = null):void {
        hudOverlay.parent.mouseEnabled = false;
        this.hudOverlay.x = GameClient.HalfStageWidth - this.hudOverlay.width * 0.5;
        this.hudOverlay.y = GameClient.StageHeight - hudOverlay.height;
        this.miniMap.x = GameClient.StageWidth - miniMap._width - 2;
        this.miniMap.y = this.MAP_POSITION.y;
        this.characterDetails.x = hudOverlay.x + 26;
        this.characterDetails.y = hudOverlay.y;
        this.statMeters.x = hudOverlay.x + 100;
        this.statMeters.y = hudOverlay.y + 45;

        if (inventoryGrid && equippedGrid && statsView && interactPanel) {
            equippedGrid.x = hudOverlay.x + 131;
            equippedGrid.y = hudOverlay.y + 2;

            bindGrid.x = hudOverlay.x + 347;
            bindGrid.y = hudOverlay.y + 3;

            inventoryGrid.x = bindGrid.x;
            inventoryGrid.y = GameClient.StageHeight - inventoryGrid.height;

            statsView.x = inventoryGrid.x - this.statsView.width * 2;
            statsView.y = inventoryGrid.y;

            interactPanel.x = GameClient.HalfStageWidth - interactPanel.width * 0.5;
            interactPanel.y = hudOverlay.y - interactPanel.height - 30;
        }
    }

    public function setPlayerDependentAssets(gs:GameSprite):void {
        var player:Player = gs.map.player_;
        this.inventoryGrid = new InventoryGrid(player, player, 5);
        this.equippedGrid = new EquippedGrid(player, player.slotTypes_, player);
        bindGrid = new BindGrid(player, player, inventoryGrid);
        this.statsView = new StatsView(50, 200);
        this.interactPanel = new InteractPanel(gs, player, 200, 100);

        this.inventoryGrid.x = GameClient.HalfStageWidth + 70;
        this.inventoryGrid.y = GameClient.StageHeight - inventoryGrid.height;

        equippedGrid.x = hudOverlay.x + 131;
        equippedGrid.y = hudOverlay.y + 2;
        bindGrid.x = hudOverlay.x + 347;
        bindGrid.y = hudOverlay.y + 3;

        this.statsView.x = inventoryGrid.x - this.statsView.width;
        this.statsView.y = inventoryGrid.y;

        this.interactPanel.x = 0;
        this.interactPanel.y = GameClient.StageHeight - interactPanel.height;

        this.inventoryGrid.visible = false;
        this.statsView.visible = false;

        showRaidLauncher();
        showLootboxButton();

        addChild(this.inventoryGrid);
        addChild(this.equippedGrid);
        addChild(this.bindGrid);
        addChild(this.statsView);
        addChild(this.interactPanel);
    }

    public function draw():void {
        positionAssets();
        if(bindGrid){
            bindGrid.draw();
        }
        if (this.equippedGrid) {
            this.equippedGrid.draw();
        }
        if (this.interactPanel) {
            this.interactPanel.draw();
        }
    }

    public function startTrade(gs:GameSprite, tradeStart:TradeStart):void {
        if (this.tradePanel != null) {
            return;
        }
        this.tradePanel = new TradePanel(gs, tradeStart);
        this.tradePanel.y = GameClient.StageHeight - (600 - 200);
        this.tradePanel.addEventListener(Event.CANCEL, this.onTradeCancel);
        addChild(this.tradePanel);
        this.characterDetails.visible = false;
        this.statMeters.visible = false;
        this.interactPanel.visible = false;
    }

    public function tradeChanged(tradeChanged:TradeChanged):void {
        if (this.tradePanel == null) {
            return;
        }
        this.tradePanel.setYourOffer(tradeChanged.offer_);
    }

    public function tradeAccepted(tradeAccepted:TradeAccepted):void {
        if (this.tradePanel == null) {
            return;
        }
        this.tradePanel.youAccepted(tradeAccepted.myOffer_, tradeAccepted.yourOffer_);
    }

    private function onTradeCancel(event:Event):void {
        this.removeTradePanel();
    }

    public function tradeDone():void {
        this.removeTradePanel();
    }

    private function removeTradePanel():void {
        if (this.tradePanel != null) {
            this.tradePanel.removeEventListener(Event.CANCEL, this.onTradeCancel);
            SpriteUtil.safeRemoveChild(this, this.tradePanel);
            this.tradePanel = null;
            this.characterDetails.visible = true;
            this.statMeters.visible = true;
            this.interactPanel.visible = true;
        }
    }

    private function OpenInventory():void {
        this.statsView.visible = true;
        this.inventoryGrid.visible = true;
    }

    private function CloseInventory():void {
        this.statsView.visible = false;
        this.inventoryGrid.visible = false;
    }

    public function ToggleInventory():void {
        if (this.inventoryGrid.visible) {
            this.CloseInventory();
        } else this.OpenInventory();
    }
    private function showRaidLauncher():void {
        this.raidLauncherButton = new RaidLauncherButton();
        this.raidLauncherButton.x = 50;
        this.raidLauncherButton.y = this.displaysPosY;
        this.displaysPosY = this.displaysPosY + UIUtils.NOTIFICATION_SPACE;
        addChild(this.raidLauncherButton);
    }


    private function showLootboxButton():void {
        this.lootBoxButton = new LootboxModalButton();
        this.lootBoxButton.x = this.raidLauncherButton.x + 32;
        this.lootBoxButton.y = this.raidLauncherButton.y;
        addChild(this.lootBoxButton);
    }
    public function setMiniMapFocus(object:GameObject) : void {
        this.miniMap.setFocus(object);
    }
}
}
</file>

<file path="src/svera/untiered/messaging/impl/GameServerConnection.as">
package svera.untiered.messaging.impl {
import com.company.assembleegameclient.account.ui.unboxing.UnboxResultBox;
import com.company.assembleegameclient.game.GameSprite;
import com.company.assembleegameclient.game.events.GuildResultEvent;
import com.company.assembleegameclient.game.events.ReconnectEvent;
import com.company.assembleegameclient.map.GroundLibrary;
import com.company.assembleegameclient.map.Map;
import com.company.assembleegameclient.map.mapoverlay.CharacterStatusText;
import com.company.assembleegameclient.objects.Character;
import com.company.assembleegameclient.objects.Container;
import com.company.assembleegameclient.objects.FlashDescription;
import com.company.assembleegameclient.objects.GameObject;
import com.company.assembleegameclient.objects.Merchant;
import com.company.assembleegameclient.objects.ObjectLibrary;
import com.company.assembleegameclient.objects.Player;
import com.company.assembleegameclient.objects.Portal;
import com.company.assembleegameclient.objects.Projectile;
import com.company.assembleegameclient.objects.SellableObject;
import com.company.assembleegameclient.objects.particles.AOEEffect;
import com.company.assembleegameclient.objects.particles.BurstEffect;
import com.company.assembleegameclient.objects.particles.CollapseEffect;
import com.company.assembleegameclient.objects.particles.ConeBlastEffect;
import com.company.assembleegameclient.objects.particles.FlowEffect;
import com.company.assembleegameclient.objects.particles.HealEffect;
import com.company.assembleegameclient.objects.particles.LightningEffect;
import com.company.assembleegameclient.objects.particles.LineEffect;
import com.company.assembleegameclient.objects.particles.NovaEffect;
import com.company.assembleegameclient.objects.particles.ParticleEffect;
import com.company.assembleegameclient.objects.particles.PoisonEffect;
import com.company.assembleegameclient.objects.particles.RingEffect;
import com.company.assembleegameclient.objects.particles.StreamEffect;
import com.company.assembleegameclient.objects.particles.TeleportEffect;
import com.company.assembleegameclient.objects.particles.ThrowEffect;
import com.company.assembleegameclient.objects.thrown.ThrowProjectileEffect;
import com.company.assembleegameclient.parameters.Parameters;
import com.company.assembleegameclient.sound.Music;
import com.company.assembleegameclient.sound.SoundEffectLibrary;
import com.company.assembleegameclient.ui.dialogs.Dialog;
import com.company.assembleegameclient.ui.panels.GuildInvitePanel;
import com.company.assembleegameclient.ui.panels.TradeRequestPanel;
import com.company.assembleegameclient.util.ConditionEffect;
import com.company.assembleegameclient.util.Currency;
import com.company.assembleegameclient.util.FreeList;
import com.company.util.Random;
import com.company.util.Trig;

import flash.display.BitmapData;
import flash.events.Event;
import flash.geom.Point;
import flash.utils.Dictionary;
import flash.utils.getTimer;

import org.osflash.signals.Signal;
import org.swiftsuspenders.Injector;

import svera.lib.net.api.MessageMap;
import svera.lib.net.api.MessageProvider;
import svera.lib.net.impl.Message;
import svera.lib.net.impl.MessageCenter;
import svera.lib.net.impl.SocketServer;
import svera.lib.util.GIF;
import svera.untiered.account.core.Account;
import svera.untiered.characters.reskin.control.ReskinHandler;
import svera.untiered.classes.model.CharacterClass;
import svera.untiered.classes.model.ClassesModel;
import svera.untiered.core.StaticInjectorContext;
import svera.untiered.core.model.PlayerModel;
import svera.untiered.death.control.HandleDeathSignal;
import svera.untiered.dialogs.control.OpenDialogSignal;
import svera.untiered.game.focus.control.SetGameFocusSignal;
import svera.untiered.game.model.AddSpeechBalloonVO;
import svera.untiered.game.model.AddTextLineVO;
import svera.untiered.game.model.GameModel;
import svera.untiered.game.signals.AddSpeechBalloonSignal;
import svera.untiered.game.signals.AddTextLineSignal;
import svera.untiered.itemdata.NewItemData;
import svera.untiered.memMarket.signals.MemMarketAddSignal;
import svera.untiered.memMarket.signals.MemMarketBuySignal;
import svera.untiered.memMarket.signals.MemMarketMyOffersSignal;
import svera.untiered.memMarket.signals.MemMarketRemoveSignal;
import svera.untiered.memMarket.signals.MemMarketSearchSignal;
import svera.untiered.messaging.impl.data.GroundTileData;
import svera.untiered.messaging.impl.data.ObjectData;
import svera.untiered.messaging.impl.data.ObjectDropData;
import svera.untiered.messaging.impl.data.ObjectStatusData;
import svera.untiered.messaging.impl.data.StatData;
import svera.untiered.messaging.impl.incoming.AccountList;
import svera.untiered.messaging.impl.incoming.AllyShoot;
import svera.untiered.messaging.impl.incoming.Aoe;
import svera.untiered.messaging.impl.incoming.BuyResult;
import svera.untiered.messaging.impl.incoming.CreateSuccess;
import svera.untiered.messaging.impl.incoming.Damage;
import svera.untiered.messaging.impl.incoming.Death;
import svera.untiered.messaging.impl.incoming.EnemyShoot;
import svera.untiered.messaging.impl.incoming.Failure;
import svera.untiered.messaging.impl.incoming.GlobalNotification;
import svera.untiered.messaging.impl.incoming.Goto;
import svera.untiered.messaging.impl.incoming.GuildResult;
import svera.untiered.messaging.impl.incoming.InvResult;
import svera.untiered.messaging.impl.incoming.InvitedToGuild;
import svera.untiered.messaging.impl.incoming.MapInfo;
import svera.untiered.messaging.impl.incoming.NewTick;
import svera.untiered.messaging.impl.incoming.Notification;
import svera.untiered.messaging.impl.incoming.PlaySound;
import svera.untiered.messaging.impl.incoming.QuestObjId;
import svera.untiered.messaging.impl.incoming.Reconnect;
import svera.untiered.messaging.impl.incoming.ServerPlayerShoot;
import svera.untiered.messaging.impl.incoming.SetFocus;
import svera.untiered.messaging.impl.incoming.ShowEffect;
import svera.untiered.messaging.impl.incoming.StorageSlotUpdate;
import svera.untiered.messaging.impl.incoming.StorageUpdate;
import svera.untiered.messaging.impl.incoming.SwitchMusic;
import svera.untiered.messaging.impl.incoming.Text;
import svera.untiered.messaging.impl.incoming.TradeAccepted;
import svera.untiered.messaging.impl.incoming.TradeChanged;
import svera.untiered.messaging.impl.incoming.TradeDone;
import svera.untiered.messaging.impl.incoming.TradeRequested;
import svera.untiered.messaging.impl.incoming.TradeStart;
import svera.untiered.messaging.impl.incoming.UnboxResultPacket;
import svera.untiered.messaging.impl.incoming.Update;
import svera.untiered.messaging.impl.incoming.market.MarketAddResult;
import svera.untiered.messaging.impl.incoming.market.MarketBuyResult;
import svera.untiered.messaging.impl.incoming.market.MarketMyOffersResult;
import svera.untiered.messaging.impl.incoming.market.MarketRemoveResult;
import svera.untiered.messaging.impl.incoming.market.MarketSearchResult;
import svera.untiered.messaging.impl.outgoing.AcceptTrade;
import svera.untiered.messaging.impl.outgoing.AoeAck;
import svera.untiered.messaging.impl.outgoing.Buy;
import svera.untiered.messaging.impl.outgoing.CancelTrade;
import svera.untiered.messaging.impl.outgoing.ChangeGuildRank;
import svera.untiered.messaging.impl.outgoing.ChangeTrade;
import svera.untiered.messaging.impl.outgoing.Create;
import svera.untiered.messaging.impl.outgoing.CreateGuild;
import svera.untiered.messaging.impl.outgoing.EditAccountList;
import svera.untiered.messaging.impl.outgoing.EnemyHit;
import svera.untiered.messaging.impl.outgoing.Escape;
import svera.untiered.messaging.impl.outgoing.GotoAck;
import svera.untiered.messaging.impl.outgoing.GuildInvite;
import svera.untiered.messaging.impl.outgoing.GuildRemove;
import svera.untiered.messaging.impl.outgoing.Hello;
import svera.untiered.messaging.impl.outgoing.InvDrop;
import svera.untiered.messaging.impl.outgoing.InvSwap;
import svera.untiered.messaging.impl.outgoing.JoinGuild;
import svera.untiered.messaging.impl.outgoing.LaunchRaid;
import svera.untiered.messaging.impl.outgoing.Load;
import svera.untiered.messaging.impl.outgoing.Move;
import svera.untiered.messaging.impl.outgoing.PlayerHit;
import svera.untiered.messaging.impl.outgoing.PlayerShoot;
import svera.untiered.messaging.impl.outgoing.PlayerText;
import svera.untiered.messaging.impl.outgoing.Reskin;
import svera.untiered.messaging.impl.outgoing.ShootAck;
import svera.untiered.messaging.impl.outgoing.SquareHit;
import svera.untiered.messaging.impl.outgoing.StorageRequest;
import svera.untiered.messaging.impl.outgoing.StorageUpgrade;
import svera.untiered.messaging.impl.outgoing.Teleport;
import svera.untiered.messaging.impl.outgoing.TradeRequest;
import svera.untiered.messaging.impl.outgoing.UnboxRequest;
import svera.untiered.messaging.impl.outgoing.UseItem;
import svera.untiered.messaging.impl.outgoing.UsePortal;
import svera.untiered.messaging.impl.outgoing.market.MarketAdd;
import svera.untiered.messaging.impl.outgoing.market.MarketAll;
import svera.untiered.messaging.impl.outgoing.market.MarketBuy;
import svera.untiered.messaging.impl.outgoing.market.MarketMyOffers;
import svera.untiered.messaging.impl.outgoing.market.MarketRemove;
import svera.untiered.messaging.impl.outgoing.market.MarketSearch;
import svera.untiered.minimap.control.UpdateGameObjectTileSignal;
import svera.untiered.minimap.control.UpdateGroundTileSignal;
import svera.untiered.minimap.model.UpdateGroundTileVO;
import svera.untiered.storage.StorageUtil;
import svera.untiered.storage.signals.GiftSlotUpdateSignal;
import svera.untiered.storage.signals.GiftUpdateSignal;
import svera.untiered.storage.signals.VaultSlotUpdateSignal;
import svera.untiered.storage.signals.VaultUpdateSignal;
import svera.untiered.ui.model.UpdateGameObjectTileVO;
import svera.untiered.ui.view.MessageCloseDialog;
import svera.untiered.ui.view.tiernotifications.CelestialPopup;
import svera.untiered.ui.view.tiernotifications.ExiledPopup;
import svera.untiered.ui.view.tiernotifications.RelicPopup;
import svera.untiered.ui.view.tiernotifications.TarnishedPopup;
import svera.untiered.ui.view.tiernotifications.UncommonPopup;
import svera.untiered.ui.view.tiernotifications.ValiantPopup;

public class GameServerConnection {
    public static const FAILURE:int = 0;
    public static const CREATE_SUCCESS:int = 1;
    public static const CREATE:int = 2;
    public static const PLAYERSHOOT:int = 3;
    public static const MOVE:int = 4;
    public static const PLAYERTEXT:int = 5;
    public static const TEXT:int = 6;
    public static const SERVERPLAYERSHOOT:int = 7;
    public static const DAMAGE:int = 8;
    public static const UPDATE:int = 9;
    public static const NOTIFICATION:int = 10;
    public static const NEWTICK:int = 11;
    public static const INVSWAP:int = 12;
    public static const USEITEM:int = 13;
    public static const SHOWEFFECT:int = 14;
    public static const HELLO:int = 15;
    public static const GOTO:int = 16;
    public static const INVDROP:int = 17;
    public static const INVRESULT:int = 18;
    public static const RECONNECT:int = 19;
    public static const MAPINFO:int = 20;
    public static const LOAD:int = 21;
    public static const TELEPORT:int = 22;
    public static const USEPORTAL:int = 23;
    public static const DEATH:int = 24;
    public static const BUY:int = 25;
    public static const BUYRESULT:int = 26;
    public static const AOE:int = 27;
    public static const PLAYERHIT:int = 28;
    public static const ENEMYHIT:int = 29;
    public static const AOEACK:int = 30;
    public static const SHOOTACK:int = 31;
    public static const SQUAREHIT:int = 32;
    public static const EDITACCOUNTLIST:int = 33;
    public static const ACCOUNTLIST:int = 34;
    public static const QUESTOBJID:int = 35;
    public static const CREATEGUILD:int = 36;
    public static const GUILDRESULT:int = 37;
    public static const GUILDREMOVE:int = 38;
    public static const GUILDINVITE:int = 39;
    public static const ALLYSHOOT:int = 40;
    public static const ENEMYSHOOT:int = 41;
    public static const ESCAPE:int = 42;
    public static const INVITEDTOGUILD:int = 43;
    public static const JOINGUILD:int = 44;
    public static const CHANGEGUILDRANK:int = 45;
    public static const PLAYSOUND:int = 46;
    public static const RESKIN:int = 47;
    public static const GOTOACK:int = 48;
    public static const TRADEREQUEST:int = 49;
    public static const TRADEREQUESTED:int = 50;
    public static const TRADESTART:int = 51;
    public static const CHANGETRADE:int = 52;
    public static const TRADECHANGED:int = 53;
    public static const CANCELTRADE:int = 54;
    public static const TRADEDONE:int = 55;
    public static const ACCEPTTRADE:int = 56;
    public static const TRADEACCEPTED:int = 57;
    public static const SWITCHMUSIC:int = 58;
    public static const VAULTUPDATE:int = 59;
    public static const VAULTSLOTUPDATE:int = 60;
    public static const VAULTREQUEST:int = 61;
    public static const VAULTUPGRADE:int = 62;
    public static const GLOBAL_NOTIFICATION:int = 69;

    public static const LAUNCH_RAID:int = 88;
    public static const UNBOXREQUEST:int = 92;
    public static const UNBOXRESULT:int = 93;// add 94

    public static const MARKET_SEARCH:int = 94;
    public static const MARKET_SEARCH_RESULT:int = 95;
    public static const MARKET_BUY:int = 96;
    public static const MARKET_BUY_RESULT:int = 97;
    public static const MARKET_ADD:int = 98;
    public static const MARKET_ADD_RESULT:int = 99;
    public static const MARKET_REMOVE:int = 100;
    public static const MARKET_REMOVE_RESULT:int = 101;
    public static const MARKET_MY_OFFERS:int = 102;
    public static const MARKET_MY_OFFERS_RESULT:int = 103;
    public static const MARKET_ALL:int = 104;
    public static const SET_FOCUS:int = 105;

    public static var instance:GameServerConnection;

    private static const NORMAL_SPEECH_COLORS:Vector.<uint> = new <uint>[14802908, 16777215, 5526612];
    private static const ENEMY_SPEECH_COLORS:Vector.<uint> = new <uint>[5644060, 16549442, 13484223];
    private static const TELL_SPEECH_COLORS:Vector.<uint> = new <uint>[2493110, 61695, 13880567];
    private static const GUILD_SPEECH_COLORS:Vector.<uint> = new <uint>[4098560, 10944349, 13891532];

    public var gs_:GameSprite;
    public var gameId_:int;
    public var createCharacter_:Boolean;
    public var charId_:int;
    public var mapJSON_:String;
    public var traits_:Array;
    public var jitterWatcher_:JitterWatcher = null;
    public var serverConnection:SocketServer;
    private var messages:MessageProvider;
    private var playerId_:int = -1;
    private var player:Player;
    public var outstandingBuy_:OutstandingBuy = null;
    private var rand_:Random = null;
    private var death:Death;
    private var addTextLine:AddTextLineSignal;
    private var addSpeechBalloon:AddSpeechBalloonSignal;
    private var updateGroundTileSignal:UpdateGroundTileSignal;
    private var updateGameObjectTileSignal:UpdateGameObjectTileSignal;
    private var handleDeath:HandleDeathSignal;
    private var setGameFocus:SetGameFocusSignal;
    private var classesModel:ClassesModel;
    private var playerModel:PlayerModel;
    private var injector:Injector;
    private var model:GameModel;

    public function GameServerConnection(gs:GameSprite, gameId:int, createCharacter:Boolean, charId:int, mapJSON:String, traits:Array) {
        super();
        this.injector = StaticInjectorContext.getInjector();
        this.addTextLine = this.injector.getInstance(AddTextLineSignal);
        this.addSpeechBalloon = this.injector.getInstance(AddSpeechBalloonSignal);
        this.updateGroundTileSignal = this.injector.getInstance(UpdateGroundTileSignal);
        this.updateGameObjectTileSignal = this.injector.getInstance(UpdateGameObjectTileSignal);
        this.handleDeath = this.injector.getInstance(HandleDeathSignal);
        this.setGameFocus = this.injector.getInstance(SetGameFocusSignal);
        this.classesModel = this.injector.getInstance(ClassesModel);
        this.serverConnection = this.injector.getInstance(SocketServer);
        this.messages = this.injector.getInstance(MessageProvider);
        this.model = this.injector.getInstance(GameModel);
        this.playerModel = this.injector.getInstance(PlayerModel);
        instance = this;
        this.gs_ = gs;
        this.gameId_ = gameId;
        this.createCharacter_ = createCharacter;
        this.charId_ = charId;
        this.mapJSON_ = mapJSON;
        this.traits_ = traits;
    }

    public function disconnect():void {
        this.removeServerConnectionListeners();
        this.unmapMessages();
        this.serverConnection.disconnect();
    }

    private function removeServerConnectionListeners():void {
        this.serverConnection.connected.remove(this.onConnected);
        this.serverConnection.closed.remove(this.onClosed);
        this.serverConnection.error.remove(this.onError);
    }

    public function connect():void {
        this.addServerConnectionListeners();
        this.mapMessages();
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.CLIENT_CHAT_NAME, "Connecting..."));
        this.serverConnection.connect(Parameters.SERVER_ADDRESS, Parameters.GAME_PORT);
    }

    private function addServerConnectionListeners():void {
        this.serverConnection.connected.add(this.onConnected);
        this.serverConnection.closed.add(this.onClosed);
        this.serverConnection.error.add(this.onError);
    }

    private function mapMessages():void {
        var messages:MessageMap = this.injector.getInstance(MessageMap);
        messages.map(CREATE).toMessage(Create);
        messages.map(PLAYERSHOOT).toMessage(PlayerShoot);
        messages.map(MOVE).toMessage(Move);
        messages.map(PLAYERTEXT).toMessage(PlayerText);
        messages.map(INVSWAP).toMessage(InvSwap);
        messages.map(USEITEM).toMessage(UseItem);
        messages.map(HELLO).toMessage(Hello);
        messages.map(INVDROP).toMessage(InvDrop);
        messages.map(LOAD).toMessage(Load);
        messages.map(TELEPORT).toMessage(Teleport);
        messages.map(USEPORTAL).toMessage(UsePortal);
        messages.map(BUY).toMessage(Buy);
        messages.map(PLAYERHIT).toMessage(PlayerHit);
        messages.map(ENEMYHIT).toMessage(EnemyHit);
        messages.map(AOEACK).toMessage(AoeAck);
        messages.map(SHOOTACK).toMessage(ShootAck);
        messages.map(SQUAREHIT).toMessage(SquareHit);
        messages.map(CREATEGUILD).toMessage(CreateGuild);
        messages.map(GUILDREMOVE).toMessage(GuildRemove);
        messages.map(GUILDINVITE).toMessage(GuildInvite);
        messages.map(ESCAPE).toMessage(Escape);
        messages.map(JOINGUILD).toMessage(JoinGuild);
        messages.map(CHANGEGUILDRANK).toMessage(ChangeGuildRank);
        messages.map(EDITACCOUNTLIST).toMessage(EditAccountList);
        messages.map(TRADEREQUEST).toMessage(TradeRequest);
        messages.map(CHANGETRADE).toMessage(ChangeTrade);
        messages.map(CANCELTRADE).toMessage(CancelTrade);
        messages.map(ACCEPTTRADE).toMessage(AcceptTrade);
        messages.map(FAILURE).toMessage(Failure).toMethod(this.onFailure);
        messages.map(CREATE_SUCCESS).toMessage(CreateSuccess).toMethod(this.onCreateSuccess);
        messages.map(TEXT).toMessage(Text).toMethod(this.onText);
        messages.map(SERVERPLAYERSHOOT).toMessage(ServerPlayerShoot).toMethod(this.onServerPlayerShoot);
        messages.map(DAMAGE).toMessage(Damage).toMethod(this.onDamage);
        messages.map(UPDATE).toMessage(Update).toMethod(this.onUpdate);
        messages.map(NOTIFICATION).toMessage(Notification).toMethod(this.onNotification);
        messages.map(GLOBAL_NOTIFICATION).toMessage(GlobalNotification).toMethod(this.onGlobalNotification);

        messages.map(NEWTICK).toMessage(NewTick).toMethod(this.onNewTick);
        messages.map(SHOWEFFECT).toMessage(ShowEffect).toMethod(this.onShowEffect);
        messages.map(GOTO).toMessage(Goto).toMethod(this.onGoto);
        messages.map(GOTOACK).toMessage(GotoAck);
        messages.map(INVRESULT).toMessage(InvResult).toMethod(this.onInvResult);
        messages.map(RECONNECT).toMessage(Reconnect).toMethod(this.onReconnect);
        messages.map(MAPINFO).toMessage(MapInfo).toMethod(this.onMapInfo);
        messages.map(DEATH).toMessage(Death).toMethod(this.onDeath);
        messages.map(BUYRESULT).toMessage(BuyResult).toMethod(this.onBuyResult);
        messages.map(AOE).toMessage(Aoe).toMethod(this.onAoe);
        messages.map(ACCOUNTLIST).toMessage(AccountList).toMethod(this.onAccountList);
        messages.map(QUESTOBJID).toMessage(QuestObjId).toMethod(this.onQuestObjId);
        messages.map(GUILDRESULT).toMessage(GuildResult).toMethod(this.onGuildResult);
        messages.map(ALLYSHOOT).toMessage(AllyShoot).toMethod(this.onAllyShoot);
        messages.map(ENEMYSHOOT).toMessage(EnemyShoot).toMethod(this.onEnemyShoot);
        messages.map(INVITEDTOGUILD).toMessage(InvitedToGuild).toMethod(this.onInvitedToGuild);
        messages.map(PLAYSOUND).toMessage(PlaySound).toMethod(this.onPlaySound);
        messages.map(TRADEREQUESTED).toMessage(TradeRequested).toMethod(this.onTradeRequested);
        messages.map(TRADESTART).toMessage(TradeStart).toMethod(this.onTradeStart);
        messages.map(TRADECHANGED).toMessage(TradeChanged).toMethod(this.onTradeChanged);
        messages.map(TRADEDONE).toMessage(TradeDone).toMethod(this.onTradeDone);
        messages.map(TRADEACCEPTED).toMessage(TradeAccepted).toMethod(this.onTradeAccepted);
        messages.map(SWITCHMUSIC).toMessage(SwitchMusic).toMethod(this.onSwitchMusic);
        messages.map(VAULTUPDATE).toMessage(StorageUpdate).toMethod(this.storageUpdate);
        messages.map(VAULTSLOTUPDATE).toMessage(StorageSlotUpdate).toMethod(this.storageSlotUpdate);
        messages.map(VAULTREQUEST).toMessage(StorageRequest);
        messages.map(VAULTUPGRADE).toMessage(StorageUpgrade);
        messages.map(UNBOXREQUEST).toMessage(UnboxRequest);
        messages.map(UNBOXRESULT).toMessage(UnboxResultPacket).toMethod(unboxResult);
        messages.map(MARKET_SEARCH).toMessage(MarketSearch);
        messages.map(MARKET_SEARCH_RESULT).toMessage(MarketSearchResult).toMethod(this.onMarketSearchResult);
        messages.map(MARKET_BUY).toMessage(MarketBuy);
        messages.map(MARKET_BUY_RESULT).toMessage(MarketBuyResult).toMethod(this.onMarketBuyResult);
        messages.map(MARKET_ADD).toMessage(MarketAdd);
        messages.map(MARKET_ADD_RESULT).toMessage(MarketAddResult).toMethod(this.onMarketAddResult);
        messages.map(MARKET_REMOVE).toMessage(MarketRemove);
        messages.map(MARKET_REMOVE_RESULT).toMessage(MarketRemoveResult).toMethod(this.onMarketRemoveResult);
        messages.map(MARKET_MY_OFFERS).toMessage(MarketMyOffers);
        messages.map(MARKET_MY_OFFERS_RESULT).toMessage(MarketMyOffersResult).toMethod(this.onMarketMyOffersResult);
        messages.map(LAUNCH_RAID).toMessage(LaunchRaid);
        messages.map(RESKIN).toMessage(Reskin).toHandler(ReskinHandler);

        messages.map(SET_FOCUS).toMessage(SetFocus).toMethod(setFocus);
    }

    private function unmapMessages():void {
        var messages:MessageMap = this.injector.getInstance(MessageMap);
        (messages as MessageCenter).unmapAll();
    }

    public function getNextDamage(minDamage:uint, maxDamage:uint):uint {
        return this.rand_.nextIntRange(minDamage, maxDamage);
    }

    public function enableJitterWatcher():void {
        if (this.jitterWatcher_ == null) {
            this.jitterWatcher_ = new JitterWatcher();
        }
    }

    public function disableJitterWatcher():void {
        if (this.jitterWatcher_ != null) {
            this.jitterWatcher_ = null;
        }
    }

    private function create():void {
        var charClass:CharacterClass = this.classesModel.getSelected();
        var create:Create = this.messages.require(CREATE) as Create;
        create.classType = charClass.id;
        create.skinType = charClass.skins.getSelectedSkin().id;
        create.traitOne = this.traits_[0];
        create.traitTwo = this.traits_[1];
        create.traitThree = this.traits_[2];
        this.serverConnection.sendMessage(create);
    }

    private function load():void {
        var load:Load = this.messages.require(LOAD) as Load;
        load.charId_ = this.charId_;
        this.serverConnection.sendMessage(load);
    }
    private function unboxResult(_arg1:UnboxResultPacket):void {
        StaticInjectorContext.getInjector().getInstance(OpenDialogSignal).dispatch(new UnboxResultBox(this.gs_, _arg1.items_));
    }
    public function vaultUpgrade(objectId:int):void {
        var upgrade:StorageUpgrade = this.messages.require(VAULTUPGRADE) as StorageUpgrade;
        upgrade.objectId_ = objectId;
        this.serverConnection.sendMessage(upgrade);
    }

    public function storageRequest(objectId:int):void {
        var request:StorageRequest = this.messages.require(VAULTREQUEST) as StorageRequest;
        request.objectId_ = objectId;
        this.serverConnection.sendMessage(request);
    }

    private function storageUpdate(update:StorageUpdate):void {
        var updateSignal:Signal = this.injector.getInstance(update.type_ == StorageUtil.VAULT ? VaultUpdateSignal : GiftUpdateSignal);
        updateSignal.dispatch(update.size_, update.items_);
    }

    private function storageSlotUpdate(update:StorageSlotUpdate):void {
        var updateSignal:Signal = this.injector.getInstance(update.type_ == StorageUtil.VAULT ? VaultSlotUpdateSignal : GiftSlotUpdateSignal);
        updateSignal.dispatch(update.slot_, update.inventory_, update.itemData_);
    }

    public function playerShoot(time:int, startX:Number, startY:Number, angle:Number, ability:Boolean, numShots:int):void {
        var playerShoot:PlayerShoot = this.messages.require(PLAYERSHOOT) as PlayerShoot;
        playerShoot.time_ = time;
        playerShoot.startingPos_.x_ = startX;
        playerShoot.startingPos_.y_ = startY;
        playerShoot.angle_ = angle;
        playerShoot.ability_ = ability;
        playerShoot.numShots_ = numShots;
        this.serverConnection.sendMessage(playerShoot);
    }

    private function onGoto(gotoPkt:Goto):void {
        if (gotoPkt.objectId_ == playerId_) {
            this.gs_.map.gotoRequested_++;
        }
        var go:GameObject = this.gs_.map.goDict_[gotoPkt.objectId_];
        if (go == null) {
            return;
        }
        go.onGoto(gotoPkt.pos_.x_, gotoPkt.pos_.y_, this.gs_.lastUpdate_);
    }

    public function playerHit(bulletId:int):void {
        var playerHit:PlayerHit = this.messages.require(PLAYERHIT) as PlayerHit;
        playerHit.bulletId_ = bulletId;
        this.serverConnection.sendMessage(playerHit);
    }

    public function enemyHit(time:int, bulletId:int, targetId:int):void {
        var enemyHit:EnemyHit = this.messages.require(ENEMYHIT) as EnemyHit;
        enemyHit.time_ = time;
        enemyHit.bulletId_ = bulletId;
        enemyHit.targetId_ = targetId;
        this.serverConnection.sendMessage(enemyHit);
    }

    public function squareHit(time:int, bulletId:int):void {
        var squareHit:SquareHit = this.messages.require(SQUAREHIT) as SquareHit;
        squareHit.time_ = time;
        squareHit.bulletId_ = bulletId;
        this.serverConnection.sendMessage(squareHit);
    }

    public function aoeAck(time:int, x:Number, y:Number):void {
        var aoeAck:AoeAck = this.messages.require(AOEACK) as AoeAck;
        aoeAck.time_ = time;
        aoeAck.position_.x_ = x;
        aoeAck.position_.y_ = y;
        this.serverConnection.sendMessage(aoeAck);
    }

    public function shootAck(time:int):void {
        var shootAck:ShootAck = this.messages.require(SHOOTACK) as ShootAck;
        shootAck.time_ = time;
        this.serverConnection.sendMessage(shootAck);
    }

    public function playerText(textStr:String):void {
        var playerTextMessage:PlayerText = this.messages.require(PLAYERTEXT) as PlayerText;
        playerTextMessage.text_ = textStr;
        this.serverConnection.sendMessage(playerTextMessage);
    }

    public function tradeRequest(name:String):void {
        var requestTrade:TradeRequest = this.messages.require(TRADEREQUEST) as TradeRequest;
        requestTrade.name = name;
        this.serverConnection.sendMessage(requestTrade);
    }

    public function changeTrade(offer:Vector.<Boolean>):void {
        var changeTrade:ChangeTrade = this.messages.require(CHANGETRADE) as ChangeTrade;
        changeTrade.offer_ = offer;
        this.serverConnection.sendMessage(changeTrade);
    }

    public function cancelTrade():void {
        this.serverConnection.sendMessage(this.messages.require(CANCELTRADE));
    }

    public function acceptTrade(myOffer:Vector.<Boolean>, yourOffer:Vector.<Boolean>):void {
        var acceptTrade:AcceptTrade = this.messages.require(ACCEPTTRADE) as AcceptTrade;
        acceptTrade.myOffer_ = myOffer;
        acceptTrade.yourOffer_ = yourOffer;
        this.serverConnection.sendMessage(acceptTrade);
    }

    public function invSwap(player:Player, sourceObj:GameObject, slotId1:int, targetObj:GameObject, slotId2:int):Boolean {
        if (!this.gs_ || this.gs_.hudView.tradePanel != null) {
            return false;
        }
        var invSwap:InvSwap = this.messages.require(INVSWAP) as InvSwap;
        invSwap.slotObject1_.objectId_ = sourceObj.objectId_;
        invSwap.slotObject1_.slotId_ = slotId1;
        invSwap.slotObject2_.objectId_ = targetObj.objectId_;
        invSwap.slotObject2_.slotId_ = slotId2;
        this.serverConnection.sendMessage(invSwap);

        var tempItem:NewItemData = sourceObj.equipment_[slotId1];
        sourceObj.equipment_[slotId1] = targetObj.equipment_[slotId2];
        targetObj.equipment_[slotId2] = tempItem;

        SoundEffectLibrary.play("inventory_move_item");
        return true;
    }

    /*public function invSwapPotion(player:Player, sourceObj:GameObject, slotId1:int, itemId:int, targetObj:GameObject, slotId2:int, objectType2:int) : Boolean
    {
       if(!this.gs_)
       {
          return false;
       }
       var invSwap:InvSwap = this.messages.require(INVSWAP) as InvSwap;
       invSwap.time_ = this.gs_.lastUpdate_;
       invSwap.position_.x_ = player.x_;
       invSwap.position_.y_ = player.y_;
       invSwap.slotObject1_.objectId_ = sourceObj.objectId_;
       invSwap.slotObject1_.slotId_ = slotId1;
       invSwap.slotObject1_.objectType_ = itemId;
       invSwap.slotObject2_.objectId_ = targetObj.objectId_;
       invSwap.slotObject2_.slotId_ = slotId2;
       invSwap.slotObject2_.objectType_ = objectType2;
       sourceObj.equipment_[slotId1] = ItemConstants.NO_ITEM;
       if(itemId == PotionInventoryModel.HEALTH_POTION_ID)
       {
          player.healthPotionCount_++;
       }
       else if(itemId == PotionInventoryModel.MAGIC_POTION_ID)
       {
          player.magicPotionCount_++;
       }
       this.serverConnection.sendMessage(invSwap);
       SoundEffectLibrary.play("inventory_move_item");
       return true;
    }*/

    public function invDrop(object:GameObject, slotId:int):void {
        var invDrop:InvDrop = this.messages.require(INVDROP) as InvDrop;
        invDrop.slotId_ = slotId;
        this.serverConnection.sendMessage(invDrop);
        object.equipment_[slotId] = null;
    }

    public function useItem(time:int, objectId:int, slotId:int, posX:Number, posY:Number):void {
        var useItemMess:UseItem = this.messages.require(USEITEM) as UseItem;
        useItemMess.time_ = time;
        useItemMess.slotObject_.objectId_ = objectId;
        useItemMess.slotObject_.slotId_ = slotId;
        useItemMess.itemUsePos_.x_ = posX;
        useItemMess.itemUsePos_.y_ = posY;
        this.serverConnection.sendMessage(useItemMess);
    }

    public function useItem_new(itemOwner:GameObject, slotId:int):Boolean {
        var itemId:NewItemData = itemOwner.equipment_[slotId];
        var objectXML:XML = ObjectLibrary.xmlLibrary_[itemId];
        if (objectXML && (objectXML.hasOwnProperty("Consumable") || objectXML.hasOwnProperty("InvUse"))) {
            this.applyUseItem(itemOwner, slotId, itemId.ObjectType, objectXML);
            SoundEffectLibrary.play("use_potion");
            return true;
        }
        SoundEffectLibrary.play("error");
        return false;
    }

    private function applyUseItem(owner:GameObject, slotId:int, objectType:int, itemData:XML):void {
        var useItem:UseItem = this.messages.require(USEITEM) as UseItem;
        useItem.time_ = gs_.lastUpdate_;
        useItem.slotObject_.objectId_ = owner.objectId_;
        useItem.slotObject_.slotId_ = slotId;
        useItem.itemUsePos_.x_ = 0;
        useItem.itemUsePos_.y_ = 0;
        this.serverConnection.sendMessage(useItem);
        if (itemData.hasOwnProperty("Consumable")) {
            owner.equipment_[slotId] = null;
        }
    }

    public function move(player:Player, time:int):void {
        var move:Move = this.messages.require(MOVE) as Move;
        move.time_ = time;
        move.newPosition_.x_ = player.x_;
        move.newPosition_.y_ = player.y_;
        this.serverConnection.sendMessage(move);
    }

    public function teleport(time:int, objectId:int):void {
        var teleport:Teleport = this.messages.require(TELEPORT) as Teleport;
        teleport.time_ = time;
        teleport.objectId_ = objectId;
        this.serverConnection.sendMessage(teleport);
    }

    public function usePortal(objectId:int):void {
        var usePortal:UsePortal = this.messages.require(USEPORTAL) as UsePortal;
        usePortal.objectId_ = objectId;
        this.serverConnection.sendMessage(usePortal);
    }

    public function buy(sellableObjectId:int, currencyType:int):void {
        if (this.outstandingBuy_) {
            return;
        }
        var sObj:SellableObject = this.gs_.map.goDict_[sellableObjectId];
        if (sObj == null) {
            return;
        }
        this.outstandingBuy_ = new OutstandingBuy(sObj.soldObjectInternalName(), sObj.price_, sObj.currency_);
        var buyMesssage:Buy = this.messages.require(BUY) as Buy;
        buyMesssage.objectId_ = sellableObjectId;
        this.serverConnection.sendMessage(buyMesssage);
    }

    public function gotoAck(time:int):void {
        var gotoAck:GotoAck = this.messages.require(GOTOACK) as GotoAck;
        gotoAck.time_ = time;
        this.serverConnection.sendMessage(gotoAck);
    }

    public function editAccountList(accountListId:int, add:Boolean, objectId:int):void {
        var eal:EditAccountList = this.messages.require(EDITACCOUNTLIST) as EditAccountList;
        eal.accountListId_ = accountListId;
        eal.add_ = add;
        eal.objectId_ = objectId;
        this.serverConnection.sendMessage(eal);
    }

    public function createGuild(name:String):void {
        var createGuild:CreateGuild = this.messages.require(CREATEGUILD) as CreateGuild;
        createGuild.name_ = name;
        this.serverConnection.sendMessage(createGuild);
    }

    public function guildRemove(name:String):void {
        var guildRemove:GuildRemove = this.messages.require(GUILDREMOVE) as GuildRemove;
        guildRemove.name_ = name;
        this.serverConnection.sendMessage(guildRemove);
    }

    public function guildInvite(name:String):void {
        var guildInvite:GuildInvite = this.messages.require(GUILDINVITE) as GuildInvite;
        guildInvite.name_ = name;
        this.serverConnection.sendMessage(guildInvite);
    }

    public function escape():void {
        if (this.playerId_ == -1 || this.gs_.map.name_ == "Nexus") {
            return;
        }
        this.serverConnection.sendMessage(this.messages.require(ESCAPE));
    }

    public function joinGuild(guildName:String):void {
        var joinGuild:JoinGuild = this.messages.require(JOINGUILD) as JoinGuild;
        joinGuild.guildName_ = guildName;
        this.serverConnection.sendMessage(joinGuild);
    }

    public function changeGuildRank(name:String, rank:int):void {
        var changeGuildRank:ChangeGuildRank = this.messages.require(CHANGEGUILDRANK) as ChangeGuildRank;
        changeGuildRank.name_ = name;
        changeGuildRank.guildRank_ = rank;
        this.serverConnection.sendMessage(changeGuildRank);
    }

    private function onConnected():void {
        var account:Account = StaticInjectorContext.getInjector().getInstance(Account);
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.CLIENT_CHAT_NAME, "Connected!"));
        var hello:Hello = this.messages.require(HELLO) as Hello;
        hello.buildVersion_ = Parameters.BUILD_VERSION;
        hello.gameId_ = this.gameId_;
        hello.username_ = account.getUsername();
        hello.password_ = account.getPassword();
        hello.mapJSON_ = this.mapJSON_ == null ? "" : this.mapJSON_;
        this.serverConnection.sendMessage(hello);
    }

    private function onCreateSuccess(createSuccess:CreateSuccess):void {
        this.playerId_ = createSuccess.objectId_;
        this.charId_ = createSuccess.charId_;
        this.gs_.initialize();
        this.createCharacter_ = false;
    }

    private function onDamage(damage:Damage):void {
        var map:Map = this.gs_.map;
        var target:GameObject = map.goDict_[damage.targetId_];
        if (target != null) {
            target.damage(damage.damageAmount_, damage.effects_, null);
        }
    }
    /* Market */
    public function onMarketSearchResult(searchResult:MarketSearchResult) : void
    {
        MemMarketSearchSignal.instance.dispatch(searchResult);
    }

    /* Market */
    public function onMarketBuyResult(buyResult:MarketBuyResult) : void
    {
        MemMarketBuySignal.instance.dispatch(buyResult);
    }

    /* Market */
    public function onMarketAddResult(addResult:MarketAddResult) : void
    {
        MemMarketAddSignal.instance.dispatch(addResult);
    }

    /* Market */
    public function onMarketRemoveResult(removeResult:MarketRemoveResult) : void
    {
        MemMarketRemoveSignal.instance.dispatch(removeResult);
    }

    /* Market */
    public function onMarketMyOffersResult(myOffersResult:MarketMyOffersResult) : void
    {
        MemMarketMyOffersSignal.instance.dispatch(myOffersResult);
    }
    public function marketSearch(itemType:int) : void
    {
        var search:MarketSearch = this.messages.require(MARKET_SEARCH) as MarketSearch;
        search.itemType_ = itemType;
        this.serverConnection.sendMessage(search);
    }

    /* Market */
    public function marketRemove(id:int) : void
    {
        var remove:MarketRemove = this.messages.require(MARKET_REMOVE) as MarketRemove;
        remove.id_ = id;
        this.serverConnection.sendMessage(remove);
    }

    /* Market */
    public function marketMyOffers() : void
    {
        var myOffers:MarketMyOffers = this.messages.require(MARKET_MY_OFFERS) as MarketMyOffers;
        this.serverConnection.sendMessage(myOffers);
    }

    /* Market */
    public function marketBuy(id:int) : void
    {
        var buy:MarketBuy = this.messages.require(MARKET_BUY) as MarketBuy;
        buy.id_ = id;
        this.serverConnection.sendMessage(buy);
    }

    /* Market */
    public function marketAdd(items:Vector.<int>, price:int, currency:int, hours:int) : void
    {
        var add:MarketAdd = this.messages.require(MARKET_ADD)  as MarketAdd;
        add.slots_= items;
        add.price_ = price;
        add.currency_ = currency;
        add.hours_ = hours;
        this.serverConnection.sendMessage(add);
    }
    public function marketAll() : void
    {
        var all:MarketAll = this.messages.require(MARKET_ALL) as MarketAll;
        this.serverConnection.sendMessage(all);
    }

    private function onServerPlayerShoot(serverPlayerShoot:ServerPlayerShoot):void {
        //var owner:GameObject = this.gs_.map.goDict_[serverPlayerShoot.ownerId_];
        for (var i:int = 0; i < serverPlayerShoot.damageList_.length; i++) {
            var proj:Projectile = FreeList.newObject(Projectile) as Projectile;
            var bulletId:int = serverPlayerShoot.ownerId_ == this.playerId_ ? serverPlayerShoot.bulletId_ + i : 0;
            proj.reset(serverPlayerShoot.containerType_, 0, serverPlayerShoot.ownerId_, bulletId, serverPlayerShoot.angle_ + serverPlayerShoot.angleInc_ * i, this.gs_.lastUpdate_);
            proj.setDamage(serverPlayerShoot.damageList_[i]);
            this.gs_.map.addObj(proj, serverPlayerShoot.startingPos_.x_, serverPlayerShoot.startingPos_.y_);
        }
        if (serverPlayerShoot.ownerId_ == this.playerId_) {
            this.shootAck(this.gs_.lastUpdate_);
        }
    }

    private function onAllyShoot(allyShoot:AllyShoot):void {
        var i:int;
        var owner:GameObject = this.gs_.map.goDict_[allyShoot.ownerId_];
        var weaponXML:XML = ObjectLibrary.xmlLibrary_[allyShoot.containerType_];
        var arcGap:Number = (Boolean(weaponXML.hasOwnProperty("ArcGap")) ? Number(weaponXML.ArcGap) : 11.25) * Trig.toRadians;
        var numShots:int = Boolean(weaponXML.hasOwnProperty("NumProjectiles")) ? int(int(weaponXML.NumProjectiles)) : int(1);
        var totalArc:Number = arcGap * (numShots - 1);
        var angle:Number = allyShoot.angle_ - totalArc / 2;
        var startId:int = Projectile.nextFakeBulletId_;
        Projectile.nextFakeBulletId_ += numShots;
        for (i = 0; i < numShots; i++) {
            var proj:Projectile = FreeList.newObject(Projectile) as Projectile;
            proj.reset(allyShoot.containerType_, 0, allyShoot.ownerId_, startId + i, angle, this.gs_.lastUpdate_);
            this.gs_.map.addObj(proj, owner.x_, owner.y_);
            angle = angle + arcGap;
        }
        owner.setAttack(allyShoot.containerType_, allyShoot.angle_);
    }

    private function onEnemyShoot(enemyShoot:EnemyShoot):void {
        var proj:Projectile = null;
        var angle:Number = NaN;
        var owner:GameObject = this.gs_.map.goDict_[enemyShoot.ownerId_];

        for (var i:int = 0; i < enemyShoot.numShots_; i++) {
            proj = FreeList.newObject(Projectile) as Projectile;
            angle = enemyShoot.angle_ + enemyShoot.angleInc_ * i;
            proj.reset(owner.objectType_, enemyShoot.bulletType_, enemyShoot.ownerId_, enemyShoot.bulletId_ + i, angle, this.gs_.lastUpdate_);
            proj.setDamage(enemyShoot.damage_);
            this.gs_.map.addObj(proj, enemyShoot.startingPos_.x_, enemyShoot.startingPos_.y_);
        }

        this.shootAck(this.gs_.lastUpdate_);
        owner.setAttack(owner.objectType_, enemyShoot.angle_ + enemyShoot.angleInc_ * ((enemyShoot.numShots_ - 1) / 2));
    }

    private function dropObject(obj:ObjectDropData):void {
        var go:GameObject = this.gs_.map.goDict_[obj.objectId_];
        if (obj.explode_ && go is Character) {
            (go as Character).explode();
        }
        this.gs_.map.removeObj(obj.objectId_);
    }

    private function addObject(obj:ObjectData):void {
        var map:Map = this.gs_.map;
        var go:GameObject = ObjectLibrary.getObjectFromType(obj.objectType_);
        if (go == null) {
            trace("unhandled object type: " + obj.objectType_);
            return;
        }
        var status:ObjectStatusData = obj.status_;
        go.setObjectId(status.objectId_);
        map.addObj(go, status.pos_.x_, status.pos_.y_);
        if (go is Player) {
            this.handleNewPlayer(go as Player, map);
        }
        this.processObjectStatus(status);
        if (go.props_.static_ && go.props_.occupySquare_ && !go.props_.noMiniMap_) {
            this.updateGameObjectTileSignal.dispatch(new UpdateGameObjectTileVO(go.x_, go.y_, go));
        }
    }

    private function handleNewPlayer(player:Player, map:Map):void {
        this.setPlayerSkinTemplate(player, 0);
        if (player.objectId_ == this.playerId_) {
            this.player = player;
            this.model.player = player;
            map.player_ = player;
            this.gs_.setFocus(player);
            this.setGameFocus.dispatch(this.playerId_.toString());
        }
    }

    private function onUpdate(update:Update):void {
        var i:int;
        var tile:GroundTileData = null;
        for (i = 0; i < update.tiles_.length; i++) {
            tile = update.tiles_[i];
            this.gs_.map.setGroundTile(tile.x_, tile.y_, tile.type_);
            this.updateGroundTileSignal.dispatch(new UpdateGroundTileVO(tile.x_, tile.y_, tile.type_));
        }
        for (i = 0; i < update.newObjs_.length; i++) {
            this.addObject(update.newObjs_[i]);
        }
        for (i = 0; i < update.drops_.length; i++) {
            this.dropObject(update.drops_[i]);
        }
    }

    private function onNotification(notification:Notification):void {
        // used to be queued
        var text:CharacterStatusText = null;
        var go:GameObject = this.gs_.map.goDict_[notification.objectId_];

        if (go != null) {
            text = new CharacterStatusText(go, notification.text_, notification.color_, 2000);
            this.gs_.map.mapOverlay_.addStatusText(text);
            if (go == this.player && notification.text_ == "Quest Complete!") {
                this.gs_.map.quest_.completed();
            }
        }
    }

    private function onNewTick(newTick:NewTick):void {
        var objectStatus:ObjectStatusData = null;
        if (this.jitterWatcher_ != null) {
            this.jitterWatcher_.record();
        }
        for each(objectStatus in newTick.statuses_) {
            this.processObjectStatus(objectStatus);
        }
        if (newTick.playerStats_.length > 0) {
            this.updateGameObject(gs_.map.player_, newTick.playerStats_, true);
        }
        this.player.map_.movesRequested_++;
    }

    private function onShowEffect(showEffect:ShowEffect):void {
        var go:GameObject = null;
        var e:ParticleEffect = null;
        var start:Point = null;
        var map:Map = this.gs_.map;
        switch (showEffect.effectType_) {
            case ShowEffect.HEAL_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                map.addObj(new HealEffect(go, showEffect.color_), go.x_, go.y_);
                break;
            case ShowEffect.TELEPORT_EFFECT_TYPE:
                map.addObj(new TeleportEffect(), showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.STREAM_EFFECT_TYPE:
                e = new StreamEffect(showEffect.pos1_, showEffect.pos2_, showEffect.color_);
                map.addObj(e, showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.THROW_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                start = go != null ? new Point(go.x_, go.y_) : showEffect.pos2_.toPoint();
                e = new ThrowEffect(start, showEffect.pos1_.toPoint(), showEffect.color_);
                map.addObj(e, start.x, start.y);
                break;
            case ShowEffect.NOVA_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new NovaEffect(go, showEffect.pos1_.x_, showEffect.color_);
                map.addObj(e, go.x_, go.y_);
                break;
            case ShowEffect.POISON_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new PoisonEffect(go, showEffect.color_);
                map.addObj(e, go.x_, go.y_);
                break;
            case ShowEffect.LINE_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new LineEffect(go, showEffect.pos1_, showEffect.color_);
                map.addObj(e, showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.BURST_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new BurstEffect(go, showEffect.pos1_, showEffect.pos2_, showEffect.color_);
                map.addObj(e, showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.FLOW_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new FlowEffect(showEffect.pos1_, go, showEffect.color_);
                map.addObj(e, showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.RING_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new RingEffect(go, showEffect.pos1_.x_, showEffect.color_);
                map.addObj(e, go.x_, go.y_);
                break;
            case ShowEffect.LIGHTNING_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new LightningEffect(go, showEffect.pos1_, showEffect.color_, showEffect.pos2_.x_);
                map.addObj(e, go.x_, go.y_);
                break;
            case ShowEffect.COLLAPSE_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new CollapseEffect(go, showEffect.pos1_, showEffect.pos2_, showEffect.color_);
                map.addObj(e, showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.CONEBLAST_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                e = new ConeBlastEffect(go, showEffect.pos1_, showEffect.pos2_.x_, showEffect.color_);
                map.addObj(e, go.x_, go.y_);
                break;
            case ShowEffect.JITTER_EFFECT_TYPE:
                this.gs_.camera_.startJitter();
                break;
            case ShowEffect.FLASH_EFFECT_TYPE:
                go = map.goDict_[showEffect.targetObjectId_];
                if (go == null) {
                    break;
                }
                go.flash_ = new FlashDescription(getTimer(), showEffect.color_, showEffect.pos1_.x_, showEffect.pos1_.y_);
                break;
            case ShowEffect.THROW_PROJECTILE_EFFECT_TYPE:
                start = showEffect.pos1_.toPoint();
                e = new ThrowProjectileEffect(showEffect.color_, showEffect.pos2_.toPoint(), showEffect.pos1_.toPoint());
                map.addObj(e, start.x, start.y);
                break;
            default:
                trace("ERROR: Unknown Effect type: " + showEffect.effectType_);
        }
    }

    private function updateGameObject(go:GameObject, stats:Vector.<StatData>, isMyObject:Boolean):void {
        var stat:StatData = null;
        var value:int = 0;
        var player:Player = go as Player;
        var merchant:Merchant = go as Merchant;
        for each(stat in stats) {
            value = stat.statValue_;
            switch (stat.statType_) {
                case StatData.SIZE:
                    go.size_ = value;
                    continue;
                case StatData.GLOW:
                    go.glowColor = value;
                    continue;
                case StatData.MAXHP:
                    go.maxHP_ = value;
                    continue;
                case StatData.HP:
                    go.hp_ = value;
                    continue;
                case StatData.MAXSP:
                    player.maxSP_ = value;
                    continue;
                case StatData.SP:
                    player.sp_ = value;
                    continue;
                case StatData.MAXRP:
                    player.maxRP_ = value;
                    continue;
                case StatData.RP:
                    player.rp_ = value;
                    continue;
                case StatData.NEXTLEVELEXP:
                    player.nextLevelExp_ = value;
                    continue;
                case StatData.EXP:
                    player.exp_ = value;
                    continue;
                case StatData.LEVEL:
                    go.level_ = value;
                    continue;
                case StatData.AWAKENING:
                    player.awakening_ = value;
                    continue;
                case StatData.RELIC:
                    player.relic_ = value;
                    continue;
                case StatData.BACKGROUND:
                    player.background_ = value;
                    continue;
                case StatData.STATPOINTS:
                    player.statPoints_ = value;
                    continue;
                case StatData.ASCENSIONPOINTS:
                    player.ascensionPoints_ = value;
                    continue;
                case StatData.ATTACK:
                    player.attack_ = value;
                    continue;
                case StatData.ARMOR:
                    go.armor_ = value;
                    continue;
                case StatData.SPEED:
                    player.speed_ = value;
                    continue;
                case StatData.DEXTERITY:
                    player.dexterity_ = value;
                    continue;
                case StatData.VIGOR:
                    player.vigor_ = value;
                    continue;
                case StatData.INTELLECT:
                    player.intellect = value;
                    continue;

                    //NEW STATS

                    // Resistance Related

                case StatData.RESILIENCE:
                    player.Resilience = value;
                    continue;
                case StatData.PHYSICALRESIST:
                    player.PhysicalResist = value;
                    continue;
                case StatData.MAGICRESIST:
                    player.MagicResist = value;
                    continue;
                case StatData.ELEMENTALRESIST:
                    player.ElementalResist = value;
                    continue;
                case StatData.FIRERESIST:
                    player.FireResist = value;
                    continue;
                case StatData.WATERRESIST:
                    player.WaterResist = value;
                    continue;
                case StatData.WINDRESIST:
                    player.WindResist = value;
                    continue;
                case StatData.ELECTRICRESIST:
                    player.ElectricResist = value;
                    continue;
                case StatData.EARTHRESIST:
                    player.EarthResist = value;
                    continue;
                case StatData.ICERESIST:
                    player.IceResist = value;
                    continue;
                case StatData.VOIDRESIST:
                    player.VoidResist = value;
                    continue;
                case StatData.LIGHTRESIST:
                    player.LightResist = value;
                    continue;
                case StatData.BLASTRESIST:
                    player.BlastResist = value;
                    continue;

                    // Damage related

                case StatData.STRENGTH:
                    player.Strength = value;
                    continue;
                case StatData.PHYSICALDMG:
                    player.PhysicalDMG = value;
                    continue;
                case StatData.MAGICALDMG:
                    player.MagicalDMG = value;
                    continue;
                case StatData.FIREDMG:
                    player.FireDMG = value;
                    continue;
                case StatData.WATERDMG:
                    player.WaterDMG = value;
                    continue;
                case StatData.WINDDMG:
                    player.WindDMG = value;
                    continue;
                case StatData.ELECTRICDMG:
                    player.ElectricDMG = value;
                    continue;
                case StatData.EARTHDMG:
                    player.EarthDMG = value;
                    continue;
                case StatData.ICEDMG:
                    player.IceDMG = value;
                    continue;
                case StatData.VOIDDMG:
                    player.VoidDMG = value;
                    continue;
                case StatData.LIGHTDMG:
                    player.LightDMG = value;
                    continue;
                case StatData.BLASTDMG:
                    player.BlastDMG = value;
                    continue;
                case StatData.ABILITYPWR:
                    player.AbilityPWR = value;
                    continue;
                case StatData.CRITICALCHANCE:
                    player.CriticalChance = value;
                    continue;
                case StatData.CRITICALDAMAGE:
                    player.CriticalDamage = value;
                    continue;
                case StatData.ABILITYCRITCHANCE:
                    player.AbilityCritChance = value;
                    continue;
                case StatData.ABILITYCRITDAMAGE:
                    player.AbilityCritDamage = value;
                    continue;

                case StatData.EVASION:
                    player.Evasion = value;
                    continue;
                case StatData.LUCK:
                    player.Luck = value;
                    continue;
                case StatData.TENACITY:
                    player.Tenacity = value;
                    continue;
                case StatData.ABILITYCOOLDOWN:
                    player.AbilityCooldown = value;
                    continue;
                case StatData.DOWNDURATION:
                    player.DownDuration = value;
                    continue;
                case StatData.POWER:
                    player.Power = value;
                    continue;

                case StatData.DASHCOOLDOWN:
                    player.DashCooldown = value;
                    continue;
                case StatData.DASHWINDOW:
                    player.DashWindow = value;
                    continue;

                case StatData.EFFECT:
                    player.setEffect(stat.strStatValue_);
                    continue;
                case StatData.CONDITION:
                    go.condition_[ConditionEffect.CE_FIRST_BATCH] = value;
                    break;
                case StatData.EFFECTS2:
                    go.condition_[ConditionEffect.CE_SECOND_BATCH] = value;
                    break;
                case StatData.EFFECTS3:
                    go.condition_[ConditionEffect.CE_THIRD_BATCH] = value;
                    break;
                case StatData.INVENTORY:
                    go.equipment_[stat.slotValue] = NewItemData.FromByteArray(stat.statByteArray);
                    continue;
                case StatData.NUMSTARS:
                    player.numStars_ = value;
                    continue;
                case StatData.NAME:
                    if (go.name_ != stat.strStatValue_) {
                        go.name_ = stat.strStatValue_;
                        go.nameBitmapData_ = null;
                    }
                    continue;
                case StatData.TEX1:
                    go.setTex1(value);
                    continue;
                case StatData.TEX2:
                    go.setTex2(value);
                    continue;
                case StatData.MERCHANDISETYPE:
                    //merchant.setMerchandiseType(ItemData.loadFromData(stat.statByteArray[0])); //TODO: will need fix
                    continue;
                case StatData.TSAVORITE:
                    player.setTsavorite(value);
                    continue;
                case StatData.MEDALLIONS:
                    player.setMedallions(value);
                    continue;
                case StatData.HONOR:
                    player.setHonor(value);
                    continue;
                case StatData.MERCHANDISEPRICE:
                    (go as SellableObject).setPrice(value);
                    continue;
                case StatData.ACTIVE:
                    (go as Portal).active_ = value != 0;
                    continue;
                case StatData.ACCOUNTID:
                    player.accountId_ = value;
                    continue;
                case StatData.MERCHANDISECURRENCY:
                    (go as SellableObject).setCurrency(value);
                    continue;
                case StatData.CONNECT:
                    go.connectType_ = value;
                    continue;
                case StatData.MERCHANDISECOUNT:
                    merchant.count_ = value;
                    merchant.untilNextMessage_ = 0;
                    continue;
                case StatData.MERCHANDISEMINSLEFT:
                    merchant.minsLeft_ = value;
                    merchant.untilNextMessage_ = 0;
                    continue;
                case StatData.MERCHANDISEDISCOUNT:
                    merchant.discount_ = value;
                    merchant.untilNextMessage_ = 0;
                    continue;
                case StatData.MERCHANDISERANKREQ:
                    (go as SellableObject).setRankReq(value);
                    continue;
                case StatData.MAXHPBOOST:
                    player.maxHPBoost_ = value;
                    continue;
                case StatData.MAXSPBOOST:
                    player.maxSPBoost_ = value;
                    continue;
                case StatData.MAXRPBOOST:
                    player.maxRPBoost_ = value;
                    continue;
                case StatData.ATTACKBOOST:
                    player.attackBoost_ = value;
                    continue;
                case StatData.ARMORBOOST:
                    player.armorBoost_ = value;
                    continue;
                case StatData.SPEEDBOOST:
                    player.speedBoost_ = value;
                    continue;
                case StatData.VIGORBOOST:
                    player.vigorBoost_ = value;
                    continue;
                case StatData.INTELLECTBOOST:
                    player.intelligenceBoost_ = value;
                    continue;
                case StatData.DEXTERITYBOOST:
                    player.dexterityBoost_ = value;
                    continue;
                case StatData.OWNERACCOUNTID:
                    if (go is Container) {
                        (go as Container).setOwnerId(value);
                    }
                    continue;
                case StatData.CHARHONOR:
                    player.charHonor = value;
                    continue;
                case StatData.NEXTCLASSQUESTHONOR:
                    player.nextClassQuestHonor = value;
                    continue;
                case StatData.LEGENDARYRANK:
                    player.legendaryRank_ = value;
                    continue;
                case StatData.SINKLEVEL:
                    if (!isMyObject) {
                        player.sinkLevel_ = value;
                    }
                    continue;
                case StatData.ALTTEXTURE:
                    go.setAltTexture(value);
                    continue;
                case StatData.GUILDNAME:
                    player.setGuildName(stat.strStatValue_);
                    continue;
                case StatData.GUILDRANK:
                    player.guildRank_ = value;
                    continue;
                case StatData.BREATH:
                    player.breath_ = value;
                    continue;

                case StatData.HEALTHPOTIONSTACK:
                    player.healthPotionCount_ = value;
                    continue;
                case StatData.MAGICPOTIONSTACK:
                    player.magicPotionCount_ = value;
                    continue;
                case StatData.TEXTURE:
                    player.skinId != value && this.setPlayerSkinTemplate(player, value);
                    continue;
                default:
                    trace("unhandled stat: " + stat.statType_);
            }
        }
    }

    private function setPlayerSkinTemplate(player:Player, skinId:int):void {
        var message:Reskin = this.messages.require(RESKIN) as Reskin;
        message.skinID = skinId;
        message.player = player;
        message.consume();
    }
    private function setFocus(pkt:SetFocus):void {
        var goDict:Dictionary = this.gs_.map.goDict_;
        if (goDict) {
            var go:GameObject = goDict[pkt.objectId_];
            gs_.setFocus(go);
            gs_.hudView.setMiniMapFocus(go);
        }
    }
    private function processObjectStatus(objectStatus:ObjectStatusData):void {
        var pLevel:int = -1;
        var pExp:int = -1;
        var pHonor:int = -1;
        var map:Map = this.gs_.map;
        var go:GameObject = map.goDict_[objectStatus.objectId_];
        if (go == null) {
            trace("missing object: " + objectStatus.objectId_);
            return;
        }
        var isMyObject:Boolean = objectStatus.objectId_ == this.playerId_;
        if (!isMyObject) {
            go.onTickPos(objectStatus.pos_.x_, objectStatus.pos_.y_);
        }
        var player:Player = go as Player;
        if (player != null) {
            pLevel = player.level_;
            pExp = player.exp_;
            pHonor = player.charHonor;
        }
        this.updateGameObject(go, objectStatus.stats_, isMyObject);
        if (player != null && pLevel != -1) {
            if (player.level_ > pLevel) {
                if (isMyObject) {
                    player.handleLevelUp();
                } else {
                    player.levelUpEffect("Level Up!");
                }
            } else if (player.exp_ > pExp) {
                player.handleExpUp(player.exp_ - pExp);
                if (player.charHonor > pHonor) {
                    player.handleHonorUp(player.charHonor - pHonor)
                }
            }
        }
    }

    private function onText(text:Text):void {
        var go:GameObject = null;
        var colors:Vector.<uint> = null;
        var speechBalloonvo:AddSpeechBalloonVO = null;
        var textString:String = text.text_;
        if (text.objectId_ >= 0) {
            go = this.gs_.map.goDict_[text.objectId_];
            if (go != null) {
                colors = NORMAL_SPEECH_COLORS;
                if (go.props_.isEnemy_) {
                    colors = ENEMY_SPEECH_COLORS;
                } else if (text.recipient_ == Parameters.GUILD_CHAT_NAME) {
                    colors = GUILD_SPEECH_COLORS;
                } else if (text.recipient_ != "") {
                    colors = TELL_SPEECH_COLORS;
                }
                speechBalloonvo = new AddSpeechBalloonVO(go, textString, colors[0], 1, colors[1], 1, colors[2], text.bubbleTime_, false, true);
                this.addSpeechBalloon.dispatch(speechBalloonvo);
            }
        }
        this.addTextLine.dispatch(new AddTextLineVO(text.name_, textString, text.objectId_, text.numStars_, text.recipient_));
    }

    private function onInvResult(invResult:InvResult):void {
        if (invResult.result_ != 0) {
            this.handleInvFailure();
        }
    }

    private function handleInvFailure():void {
        SoundEffectLibrary.play("error");
        this.gs_.hudView.interactPanel.redraw();
    }

    private function onReconnect(reconnect:Reconnect):void {
        var gameID:int = reconnect.gameId_;
        var createChar:Boolean = this.createCharacter_;
        var charId:int = this.charId_;
        var reconnectEvent:ReconnectEvent = new ReconnectEvent(gameID, createChar, charId);
        this.gs_.dispatchEvent(reconnectEvent);
    }

    private function parseXML(xmlString:String):void {
        var extraXML:XML = XML(xmlString);
        GroundLibrary.parseFromXML(extraXML);
        ObjectLibrary.parseFromXML(extraXML);
        ObjectLibrary.parseFromXML(extraXML);
    }

    private function onMapInfo(mapInfo:MapInfo):void {
        this.gs_.applyMapInfo(mapInfo);
        this.rand_ = new Random(mapInfo.fp_);
        Music.load(mapInfo.music_);
        if (this.createCharacter_) {
            this.create();
        } else {
            this.load();
        }
    }

    private function onDeath(death:Death):void {
        // keep for now, seems to fix the death issue
        //disconnect();

        this.death = death;
        var data:BitmapData = new BitmapData(this.gs_.stage.stageWidth, this.gs_.stage.stageHeight);
        data.draw(this.gs_);
        death.background = data;
        if (!this.gs_.isEditor) {
            this.handleDeath.dispatch(death);
        }
    }

    private function onBuyResult(buyResult:BuyResult):void {
        if (buyResult.result_ == BuyResult.SUCCESS_BRID) {
            if (this.outstandingBuy_) {
                switch (this.outstandingBuy_.currency_) {
                    case Currency.TSAVORITE:
                        this.playerModel.changeTsavorite(-this.outstandingBuy_.price_);
                        break;
                    case Currency.MEDALLIONS:
                        this.playerModel.changeMedallions(-this.outstandingBuy_.price_);
                        break;
                    case Currency.HONOR:
                        this.playerModel.changeHonor(-this.outstandingBuy_.price_);
                        break;
                }
            }
        }
        this.outstandingBuy_ = null;
        switch (buyResult.result_) {
            case BuyResult.DIALOG_BRID:
                StaticInjectorContext.getInjector().getInstance(OpenDialogSignal).dispatch(new MessageCloseDialog("Purchase Error", buyResult.resultString_));
                break;
            default:
                this.addTextLine.dispatch(new AddTextLineVO(buyResult.result_ == BuyResult.SUCCESS_BRID ? Parameters.SERVER_CHAT_NAME : Parameters.ERROR_CHAT_NAME, buyResult.resultString_));
        }
    }

    private function onAccountList(accountList:AccountList):void {
        if (accountList.accountListId_ == 0) {
            this.gs_.map.party_.setStars(accountList);
        }
        if (accountList.accountListId_ == 1) {
            this.gs_.map.party_.setIgnores(accountList);
        }
    }

    private function onQuestObjId(questObjId:QuestObjId):void {
        this.gs_.map.quest_.setObject(questObjId.objectId_);
    }

    private function onAoe(aoe:Aoe):void {
        var d:int = 0;
        var effects:Vector.<uint> = null;
        var e:AOEEffect = new AOEEffect(aoe.pos_.toPoint(), aoe.radius_, aoe.color_);
        this.gs_.map.addObj(e, aoe.pos_.x_, aoe.pos_.y_);
        if (this.player.isImmortal()) {
            this.aoeAck(this.gs_.lastUpdate_, this.player.x_, this.player.y_);
            return;
        }
        var hit:Boolean = this.player.distTo(aoe.pos_) < aoe.radius_;
        if (hit) {
            d = GameObject.damageWithDefense(aoe.damage_, this.player.armor_, false, this.player.condition_);
            effects = null;
            if (aoe.effect_ != 0) {
                effects = new Vector.<uint>();
                effects.push(aoe.effect_);
            }
            this.player.damage(d, effects, null);
        }
        this.aoeAck(this.gs_.lastUpdate_, this.player.x_, this.player.y_);
    }

    private function onGuildResult(guildResult:GuildResult):void {
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, guildResult.errorText_));
        this.gs_.dispatchEvent(new GuildResultEvent(guildResult.success_, guildResult.errorText_));
    }

    private function onInvitedToGuild(invitedToGuild:InvitedToGuild):void {
        if (Parameters.data_.showGuildInvitePopup) {
            this.gs_.hudView.interactPanel.setOverride(new GuildInvitePanel(this.gs_, invitedToGuild.name_, invitedToGuild.guildName_));
        }
        this.addTextLine.dispatch(new AddTextLineVO("", "You have been invited by " + invitedToGuild.name_ + " to join the guild " + invitedToGuild.guildName_ + ".\n  If you wish to join type \"/join " + invitedToGuild.guildName_ + "\""));
    }

    private function onPlaySound(playSound:PlaySound):void {
        SoundEffectLibrary.play(playSound.sound_);
    }

    private function onClosed():void {
        this.gs_.closed.dispatch();
    }

    private function onError(error:String):void {
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, error));
    }
    private function onGlobalNotification(globalNotification:GlobalNotification):void {
        switch (globalNotification.text) {
            case "beginnersPackage":
                return;
            case "Uncommon":
                Popup(UncommonPopup);
                return;
            case "Tarnished":
                Popup(TarnishedPopup);
                return;
                //case "Artifact":
                //    Popup(ArtifactPopup, artifactPopup);
                //    return;
                //case "Ancestral":
                //    Popup(AncestralPopup, ancestralPopup);
                //    return;
            case "Valiant":
                Popup(ValiantPopup);
                return;
            case "Relic":
                Popup(RelicPopup);
                return;
            case "Exiled":
                Popup(ExiledPopup);
                return;
            case "Celestial":
                Popup(CelestialPopup);
                return;
        }
    }

    private function Popup(_arg1:Class):void
    {
        var gif:GIF = new _arg1();
        if(gs_.contains(gif))
            gs_.removeChild(gif);
        gif.x = gif.y = + 6;
        gif.scaleX = 2;
        gif.scaleY = 2;
        gif.play();
        gs_.addChild(gif);
    }
    private function onFailure(event:Failure):void {
        switch (event.errorId_) {
            case Failure.INCORRECT_VERSION:
                this.handleIncorrectVersionFailure(event);
                break;
            case Failure.FORCE_CLOSE_GAME:
                this.handleForceCloseGameFailure(event);
                break;
            case Failure.INVALID_TELEPORT_TARGET:
                this.handleInvalidTeleportTarget(event);
                break;
            default:
                this.handleDefaultFailure(event);
        }
    }

    private function handleInvalidTeleportTarget(event:Failure):void {
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, event.errorDescription_));
        this.player.nextTeleportAt_ = 0;
    }

    private function handleForceCloseGameFailure(event:Failure):void {
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, event.errorDescription_));
        this.gs_.closed.dispatch();
    }

    private function handleIncorrectVersionFailure(event:Failure):void {
        var dialog:Dialog = new Dialog("Client version: " + Parameters.BUILD_VERSION + "\nServer version: " + event.errorDescription_, "Client Update Needed", "Ok", null);
        dialog.addEventListener(Dialog.LEFT_BUTTON, this.onDoClientUpdate);
        this.gs_.stage.addChild(dialog);
    }

    private function handleDefaultFailure(event:Failure):void {
        this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, event.errorDescription_));
    }

    private function onDoClientUpdate(event:Event):void {
        var dialog:Dialog = event.currentTarget as Dialog;
        dialog.parent.removeChild(dialog);
        this.gs_.closed.dispatch();
    }

    private function onTradeRequested(tradeRequested:TradeRequested):void {
        if (Parameters.data_.showTradePopup) {
            this.gs_.hudView.interactPanel.setOverride(new TradeRequestPanel(this.gs_, tradeRequested.name));
        }
        this.addTextLine.dispatch(new AddTextLineVO("", tradeRequested.name + " wants to " + "trade with you.  Type \"/trade " + tradeRequested.name + "\" to trade."));
    }

    private function onTradeStart(tradeStart:TradeStart):void {
        if (Parameters.data_.showTradePopup)
            this.gs_.hudView.interactPanel.removeOverride();
        this.gs_.hudView.startTrade(this.gs_, tradeStart);
    }

    private function onTradeChanged(tradeChanged:TradeChanged):void {
        this.gs_.hudView.tradeChanged(tradeChanged);
    }

    private function onTradeDone(tradeDone:TradeDone):void {
        this.gs_.hudView.tradeDone();
        switch (tradeDone.code_) {
            case TradeDone.TRADE_SUCCESSFUL:
            case TradeDone.PLAYER_CANCELED:
                this.addTextLine.dispatch(new AddTextLineVO("", tradeDone.description_));
                break;
            case TradeDone.TRADE_ERROR:
                this.addTextLine.dispatch(new AddTextLineVO(Parameters.ERROR_CHAT_NAME, tradeDone.description_));
                break;
        }
    }

    private function onTradeAccepted(tradeAccepted:TradeAccepted):void {
        this.gs_.hudView.tradeAccepted(tradeAccepted);
    }

    private function onSwitchMusic(switchMusic:SwitchMusic):void {
        Music.load(switchMusic.music_);
    }
}
}
</file>

</files>
